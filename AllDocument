day01-html
今日任务
网站信息页面案例
网站图片信息页面案例
网站友情链接页面案例
网站首页案例
网站注册页面案例
网站后台页面案例
教学导航
教学目标	了解什么是标记语言
了解HTML主要特性,主要变化及发展趋势
了解HTML的结构标签
掌握HTML的主要标签(字体,图片,列表,链接,表单等标签)
教学方法	案例驱动法
网站信息页面显示案例：
需求分析：
在网页中显示一个文字信息页面，显示效果如下：

分析：
技术分析
【HTML的概述】
什么是HTML
HTML：Hyper Text Markup Language 超文本标记语言
超文本：比文本功能更加强大
标记语言：通过一组标签对内容进行描述的一门语言
为什么学习HTML
HTML是设计页面基础
在哪些地方可以使用HTML
设计页面的时候都可以使用HTML
如何使用HTML
HTML的语法和规范
HTML文件的扩展名是.html或者是.htm
HTML文件是由头和体组成
HTML这组标签是不区分大小写
HTML的标记通常是由开始标签和结束标签组成：<b>内容</b>  <br/>
【HTML的字体标签】
<font>标签
<font 属性名=”属性值”>文字</font>
size:控制字体大小.最小1 最大7
color：控制字体颜色. 使用英文设置 ，使用16进制数设置
face：控制字体.
【HTML的排版标签】
<hn>标题标签
<h1>b标题</h1>
<p>段落标签
<p>一段文字</p>
<br/>换行标签
<br/>代表换行
<hr/>水平线标签
<hr/>水平线标签
<b>字体加粗
<b>文字</b>
<i>斜体标签
<i>斜体</i>
步骤分析
步骤一：创建一个html文件
步骤二：创建标题标签
步骤三：标题下面会有一个水平线
步骤四：创建段落标签创建四个段落
步骤五：将某些文字设置为红色
代码实现
<html>
	<head>
		<meta charset="utf-8">
		<title>页面标题</title>
	</head>
	<body>
		<!-- 创建标题标签 -->
		<h2>公司简介</h2>
		<!--
        	作者：offline
        	时间：2016-01-21
        	描述：水平线
        -->
        <hr />
        <!--
        	作者：offline
        	时间：2016-01-21
        	描述：创建段落标签
        -->
		<p>
			<font color="#FF0000"><b>“中关村黑马程序员训练营”</b></font>是由<b>传智播客</b>联合中关村软件园、CSDN，并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展，而企业招不到优秀人才的困扰。 目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地，并被评为中关村软件园重点扶持人才企业。
		</p>
		
		<p>
			黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”，必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确保学员质量，并降低企业的用人风险。
		</p>
		
		<p>
			中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新，不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。
		</p>
		
		<p>
			一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。
		</p>
	</body>
</html>
网站的图片页面显示
需求分析：
在网页中显示带有图片的页面效果如下：

分析：
技术分析：
【HTML的图片标记】
<img />
src：图片的路径
width：图片宽度
height：图片的高度
alt：图片提示
图片路径：
分成相对路径和绝对路径
相对路径:
./	:代表当前路径
../ :代表上一级路径
步骤分析：
创建一个img标签引入logo图片
创建一个img标签引入header图片
代码实现
<html>
	<head>
		<meta charset="utf-8">
		<title>网站图片页面</title>
	</head>
	<body>
		<img src="../img/logo2.png"/><img src="../img/header.png" />
	</body>
</html>
网站的列表显示页面
需求分析：
在页面中列表显示友情链接：
分析：
技术分析
【HTML的列表标签】
无序列表
	<ul>
		<li>内容1</li>
<li>内容2</li>
	</ul>
有序列表
	<ol>
		<li>内容1</li>
<li>内容2</li>
	</ol>
步骤实现
创建一个无序列表显示友情链接
代码实现
		<ul>
			<li>百度</li>
			<li>传智播客</li>
			<li>百合网</li>
			<li>世纪佳缘</li>
		</ul>
总结：
【超链接标签】
<a>超链接</a>
href：超链接跳转的路径
target：打开方式
_self：在自身页面打开
_blank：打开一个新窗口
网站的首页显示
需求分析：
在浏览器中显示网站的首页效果如下：

分析：
技术分析
【HTML的表格标签】
表格标签：
	<table>
		<tr>
			<td></td>
<td></td>
		</tr>
<tr>
			<td></td>
<td></td>
		</tr>
	
	</table>

表格的属性：
border	：表格边框
width	：表格宽度
height	：表格高度
align	：水平方向对齐方式 left center right
bgcolor	：背景色
步骤分析：
步骤一：创建8行表格
步骤二：实现第一行，嵌套一个一行三列表格。
步骤三：实现第二行，实现导航，设置背景色。
步骤四：放置一张图片
步骤五：显示热门商品，创建一个三行七列的表格。对表格进行跨行，跨列的操作。
步骤六：引入一张广告图片。
步骤七：显示最新商品，创建一个三行七列的表格。对表格进行跨行，跨列的操作。
步骤八：广告信息
步骤九：链接版权信息。
代码实现
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>网站首页</title>
	</head>
	<body>
		<table width="1400" border="0" align="center">
			<tr>
				<td>
					<!-- LOGO部分 -->
					<table width="100%">
						<tr height="40">
							<td>
								<img src="../img/logo2.png"/>
							</td>
							<td>
								<img src="../img/header.png"/>
							</td>
							<td>
								<a href="#">登录</a>
								<a href="../案例五：网站注册页面显示/网站的注册页面.html">注册</a>
								<a href="#">购物车</a>
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr height="30" bgcolor="black">
				<td>
					<!--导航部分-->
					
					<a href="#"><font color="white">首页</font></a>&nbsp;&nbsp;&nbsp;  
					<a href="#"><font color="white">手机数码</font></a>&nbsp;&nbsp;&nbsp;  
					<a href="#"><font color="white">电脑办公</font></a>&nbsp;&nbsp;&nbsp;        
					<a href="#"><font color="white">鞋靴箱包</font></a>&nbsp;&nbsp;&nbsp; 
					<a href="#"><font color="white">鞋靴箱包</font></a>&nbsp;&nbsp;&nbsp; 
					
				</td>
			</tr>
			<tr>
				<td>
					<img src="../img/1.jpg" width="100%" />
				</td>
			</tr>
			<tr>
				<td>
					<table width="100%" border="0">
						<tr>
							<td colspan="7"><font size="5"><b>最新商品</b></font><img src="../img/title2.jpg"></td>
						</tr>
						<tr>
							<td rowspan="2"  width="200" height="500">
								<img src="../products/hao/big01.jpg" width="100%" height="100%"/>
							</td>
							<td colspan="3" width="600" height="250">
								<img src="../products/hao/middle01.jpg" width="100%" height="250"/>
							</td>
							
							<td width="200" align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td width="200"  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td width="200"  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
						</tr>
						<tr>
							
							<td  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<!--广告-->
					<a href="#"><img src="../products/hao/ad.jpg" width="100%"></a>
				</td>
			</tr>
			<tr>
				<td>
					<table width="100%" border="0">
						<tr>
							<td colspan="7"><font size="5"><b>最新商品</b></font><img src="../img/title2.jpg"></td>
						</tr>
						<tr>
							<td rowspan="2"  width="200" height="500">
								<img src="../products/hao/big01.jpg" width="100%" height="100%"/>
							</td>
							<td colspan="3" width="600" height="250">
								<img src="../products/hao/middle01.jpg" width="100%" height="250"/>
							</td>
							
							<td width="200" align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td width="200"  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td width="200"  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
						</tr>
						<tr>
							
							<td  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td  align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
							<td align="center">
								<img src="../products/hao/small03.jpg"/><br/>
								<p><font color="gray">电磁锅</font></p>
								<p><font color="red">$499</font></p>
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<img src="../img/footer.jpg" width="100%"/>
				</td>
			</tr>
			<tr>
				<td align="center">
				    <a href="../案例一：网站信息页面显示/网站信息页面显示.html">关于我们</a>
				    <a href="">联系我们</a>
				    <a href="">招贤纳士</a>
				    <a href="">法律声明</a>
				    <a href="../案例三：网站列表页面显示/网站列表页面显示.html">友情链接</a>
				    <a href="">支付方式</a>
				    <a href="">配送方式</a>
				    <a href="">服务声明</a>
				    <a href="">广告声明</a>
					<br/>
					Copyright © 2005-2016 传智商城 版权所有 
				</td>
			</tr>
		</table>
	</body>
</html>

网站的注册页面案例：
需求分析：
在浏览器中显示如下的效果：

分析：
技术分析：
【HTML的表单标签】
表单标签：
需要提交的表单需要使用<form></form>括起来
action：提交路径
method：提交方式
文本框:
<input type=”text”/>
name
value
size
maxlength
readonly
密码框：
<input type=”password”/>
单选按钮：
<input type=”radio”/>
Checked：默认选中
复选框
<input type=”checkbox”/>
Checked：默认选中
下拉列表框
<select><option></option></select>
Selected：默认选中
Multiple：全部显示
文件上传项
<input type=”file” name=”file”/>
文本区
<textarea name=”” cols=”” rows=””></textarea>
提交按钮
<input type=”submit” value=”注册”>
重置按钮
<input type=”reset” value=”重置”>
普通按钮
<input type=”button” value=”普通按钮”>
隐藏字段
<input type=”hidden” name=”id”/>

提交方式：
GET	：默认值
提交的数据都会在地址栏中进行显示
提交的数据的时候是有大小的限制
POST	：
提交的数据不会再地址栏中进行显示
提交的数据没有大小限制
步骤分析：
步骤一：创建一个5行表格
步骤二：完成每行显示
步骤三：中间行设置一个背景图片，嵌套一个表格居中显示。在表格中显示表单的内容
代码实现：
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<table border="1" width="100%">
			<tr>
				<td>
					<!-- LOGO部分 -->
					<table width="100%">
						<tr height="40">
							<td>
								<img src="../img/logo2.png"/>
							</td>
							<td>
								<img src="../img/header.png"/>
							</td>
							<td>
								<a href="#">登录</a>
								<a href="#">注册</a>
								<a href="#">购物车</a>
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr bgcolor="black" height="30">
				<td>
					<a href="#"><font color="white">首页</font></a>&nbsp;&nbsp;&nbsp;  
					<a href="#"><font color="white">手机数码</font></a>&nbsp;&nbsp;&nbsp;  
					<a href="#"><font color="white">电脑办公</font></a>&nbsp;&nbsp;&nbsp;        
					<a href="#"><font color="white">鞋靴箱包</font></a>&nbsp;&nbsp;&nbsp; 
					<a href="#"><font color="white">鞋靴箱包</font></a>&nbsp;&nbsp;&nbsp;
				</td>
			</tr>
			<tr height="600">
				<td>
					<table width="100%" height="100%" background="../img/regist_bg.jpg">
						<tr>
							<td align="center">
								<table width="60%" height="80%" border="1" bgcolor="white">
									<tr>
										<td>
											<form>
											<table width="100%" height="100%" border="0" align="center" cellspacing="10">
												<tr>
													<td>用户名</td>
													<td><input type="text" name="username"/></td>
												</tr>
												<tr>
													<td>密码</td>
													<td><input type="password" name="password"/></td>
												</tr>
												<tr>
													<td>确认密码</td>
													<td><input type="password" name="repassword"/></td>
												</tr>
												<tr>
													<td>性别</td>
													<td><input type="radio" name="sex" value="男" checked="checked"/>男<input type="radio" name="sex" value="女"/>女</td>
												</tr>
												<tr>
													<td>Email</td>
													<td><input type="text" name="email"/></td>
												</tr>
												<tr>
													<td>姓名</td>
													<td><input type="text" name="name"/></td>
												</tr>
												<tr>
													<td>生日</td>
													<td><input type="text" name="birthday"/></td>
												</tr>
												<tr>
													<td>验证码</td>
													<td><input type="text" name="checkcode" size="10"/></td>
												</tr>
												<tr>
													<td colspan="2"><input type="submit" value="注册"/></td>
												</tr>
											</table>
											</form>
										</td>
									</tr>
								</table>
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<img src="../img/footer.jpg" width="100%"/>
				</td>
			</tr>
			<tr>
				<td align="center">
				    <a href="../案例一：网站信息页面显示/网站信息页面显示.html">关于我们</a>
				    <a href="">联系我们</a>
				    <a href="">招贤纳士</a>
				    <a href="">法律声明</a>
				    <a href="../案例三：网站列表页面显示/网站列表页面显示.html">友情链接</a>
				    <a href="">支付方式</a>
				    <a href="">配送方式</a>
				    <a href="">服务声明</a>
				    <a href="">广告声明</a>
					<br/>
					Copyright © 2005-2016 传智商城 版权所有 
				</td>
			</tr>
		</table>
	</body>
</html>
网站后台页面显示
需求分析：
在浏览器中显示网站的后台页面，效果如下图：

分析：
技术分析：
【HTML的框架标记】
<frameset>
</frameset>
* 使用了frameset标签，不需要使用body.
* 属性：
* rows：横向切分页面
* cols：纵向切分页面
<frame>标签代表切分每个部分的页面
* src：引入页面的路径
步骤分析：
步骤一：先将页面切分成上下两个部分。
步骤二：将下部分切分成左右两个部分。
步骤三：分别引入不同的页面。
代码实现：
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	
	<frameset rows="15%,*">
		<frame src="top.html" />
		<frameset cols="15%,*">
			<frame src="left.html" />
			<frame src="right.html" />
		</frameset>
	</frameset>
</html>
扩展需求：
点击分类管理，将数据放入到表格中显示到右侧区域中！
在frame上添加一个属性name，在超链接的target属性上设置这个名称。点击超链接的时候，跳转到指定的位置。
	<h3><a href="data.html" target="right">分类管理</a></h3>

第2章WEB02-CSS&JS篇
今日任务
使用CSS完成网站首页的美化
使用CSS完成网站注册页面的美化
使用JS完成简单的数据校验
使用JS完成图片轮播效果
教学导航
教学目标	了解CSS的概念
了解CSS的引入方式
了解CSS的基本语法和常用的选择器
了解CSS的盒子模型,悬浮和定位.
了解JS的概念
掌握JS的基本语法,数据类型,能够使用JS完成简单的页面交互.
教学方法	案例驱动法

使用CSS对首页进行重新布局：
需求分析：
在上次的HTML课程中已经使用表格标签对页面进行布局显示了，但是表格标签有一定的缺陷。实际开发中都会采用DIV+CSS的方式进行布局。使用DIV+CSS重新布局网站的首页：

分析：
技术分析
【HTML的DIV标签】
HTML中有两个块标记：
<div></div>
<span></span>
【CSS的概述】
什么是CSS：
Cascading Style Sheets 层叠样式表.
CSS的作用：
CSS主要用来修饰HTML的显示.代码复用.将页面元素与样式进行分离. 
CSS的使用：
语法：
	选择器{属性1:属性值;属性2:属性值;..}
		<style>
			h2{
				color:red;
				font-size:100px;
			}
		</style>
【CSS的引入方式】
行内样式：
直接在html的元素上使用style的属性编写CSS：
<span style="color:#00FF00 ;font-size: 100px;">黑马训练营</span>
内部样式：
在html的<head>标签中使用<style>标签来定义CSS
		<style>
			span{
				color:blue;
				font-size: 200px;
			}
		</style>
外部样式：
将CSS定义成一个.css的文件，在html中将该文件引入到html中
<link href="style.css" rel="stylesheet" type="text/css"/>
【CSS的基本选择器】
CSS的选择器为了更能精确的找个某个元素来设计的
元素选择器：
			div{
				color: red;
			}
id选择器：
		<style>
			#d1{
				color: red;
			}
		</style>

<div id="d1">王凤</div>
***** id通常都是唯一的.
类选择器：
HTML:
<div class="d1">王守义</div>
		<div>王凤</div>
		<div class="d1">王如花</div>

CSS:
		<style>
			.d1{
				color: green;
			}
		</style>
【CSS的悬浮】
CSS的float属性：
float属性中常用取值:
Left	:悬浮到左边
Right	:悬浮到右边
使用clear属性清除浮动：
Left		：清除左侧浮动
Right		：清除右侧浮动
Both		：清除两侧的浮动
步骤分析：
创建一个外层的div元素
在div中创建代表每块区域div
在每块div引入需要的元素的内容
代码实现：
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>网站的首页</title>
		<link href="../css/main.css" rel="stylesheet" type="text/css" />
		<style>
			
			.product{
				border:1px solid gray;
				width:16%;
				height:250px;
				float:left;
			}
		</style>
	</head>
	<body>
		<!-- 整体的DIV -->
		<div>
			<!-- LOGO部分的DIV -->
			<div>
				<!--分成三个小的DIV-->
				<div class="top">
					<img src="../img/logo2.png" height="48"/>
				</div>
				<div class="top">
					<img src="../img/header.png" height="48" />
				</div>
				<div class="top" style="padding-top: 10px;height: 40px;">
					<a href="#">登录</a>
					<a href="#">注册</a>
					<a href="#">购物车</a>
				</div>
			</div>
			
			<!--清除浮动-->
			<div class="clear"></div>
			<!-- 菜单部分的DIV-->
			<div class="menu">
				<ul>
					<li style="display: inline;">首页</li>
					<li style="display: inline;">电脑办公</li>
					<li style="display: inline;">手机数码</li>
					<li style="display: inline;">鞋靴箱包</li>
				</ul>
			</div>
			<!-- 图片轮播的DIV -->
			<div style="width: 99%;">
				<img src="../img/1.jpg" width="100%">
			</div>
			<!-- 商品展示的DIV -->
			<div style="border:1px solid green;width: 99%;">
				<!--标题的DIV-->
				<div><h2>最新商品<img src="../img/title2.jpg"></h2></div>
				<!-- 左侧的广告位的DIV -->
				<div style="width:15%;height:500px;border: 1px solid red;float:left;">
					<img src="../products/hao/big01.jpg" width="100%" height="100%"/>
				</div>
				<!-- 右侧的商品显示的DIV -->
				<div style="border:1px solid blue;width:84%;float: left;">
					<div>
						<!-- 横向广告部分 -->
						<div style="border:1px solid blue;width:50%;height: 250px;float:left;">
							<img src="../products/hao/middle01.jpg" width="100%" height="100%"/>
						</div>
						<!--商品的DIV-->
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div><div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						
						
					</div>
				</div>
			</div>
			<div style="width:99%;">
				<img src="../products/hao/ad.jpg" width="100%"/>
			</div>
			<div style="border:1px solid green;width: 99%;">
				<!--标题的DIV-->
				<div><h2>最新商品<img src="../img/title2.jpg"></h2></div>
				<!-- 左侧的广告位的DIV -->
				<div style="width:15%;height:500px;border: 1px solid red;float:left;">
					<img src="../products/hao/big01.jpg" width="100%" height="100%"/>
				</div>
				<!-- 右侧的商品显示的DIV -->
				<div style="border:1px solid blue;width:84%;float: left;">
					<div>
						<!-- 横向广告部分 -->
						<div style="border:1px solid blue;width:50%;height: 250px;float:left;">
							<img src="../products/hao/middle01.jpg" width="100%" height="100%"/>
						</div>
						<!--商品的DIV-->
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						<div class="product">
							<img src="../products/hao/small04.jpg"/>
							<p>电饭煲</p>
							<p style="color:red;">￥299</p>
						</div>
						
						
						
					</div>
				</div>
			</div>
			<div>
				<img src="../img/footer.jpg" />
			</div>
			<div align="center">
				<a href="../案例一：网站信息页面显示/网站信息页面显示.html">关于我们</a>
				    <a href="">联系我们</a>
				    <a href="">招贤纳士</a>
				    <a href="">法律声明</a>
				    <a href="link.html">友情链接</a>
				    <a href="">支付方式</a>
				    <a href="">配送方式</a>
				    <a href="">服务声明</a>
				    <a href="">广告声明</a>
					<br/>
					Copyright © 2005-2016 传智商城 版权所有 
			</div>
		</div>
	</body>
</html>

扩展：
CSS的其他的选择器：
【CSS的其他选择器】
属性选择器
选中带有某个属性的元素：
		<style>
			input[type="text"]{
				background-color: yellow;
			}
			
			input[type="password"]{
				background-color: green;
			}
		</style>
层次选择器：
父选择器 子孙选择器 {  }
		<style>
			#d1 div{
				color: red;
			}
		</style>
伪类选择器：
主要用来描述超链接
<style>
			a:link{
				color:blue;
				font-size: 40px;
			}
			a:visited{
				color: red;
				font-size: 40px;
			}
			a:hover{
				color: green;
				font-size: 100px;
			}
			a:active{
				color: brown;
				font-size: 200px;
			}
		</style>
使用DIV+CSS对注册页面进行布局：
需求分析：
使用DIV+CSS对注册页面进行布局。更加灵活！

分析：
技术分析：
【CSS的盒子模型】

设置盒子的外边距：margin
Margin-top
Margin-right
Margin-bottom
Margin-left
设置盒子的内边距：padding
Padding-top
Padding-right
Padding-bottom
Padding-left
步骤分析：
创建一个整体div元素
在里面创建5个分别代表某个部分的DIV
在每个部分中完成单独内容的显示
代码实现：
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<link href="../css/main.css" rel="stylesheet" type="text/css" />
		<style>
			.content{
				border:1px solid blue;
				height: 600px;
				background: url(../img/regist_bg.jpg);
				margin: 10px 0px;
			}
		</style>
	</head>
	<body>
		<!-- 创建一个整体的DIV -->
		<div>
			<div>
				<div class="top">
					<img src="../img/logo2.png" height="48"/>
				</div>
				<div class="top">
					<img src="../img/header.png"  height="48"/>
				</div>
				<div class="top" style="padding-top: 10px;height: 40px;">
					<a href="#">登录</a>
					<a href="#">注册</a>
					<a href="#">购物车</a>
				</div>
			</div>
			<!--清除浮动-->
			<div class="clear"></div>
			<!-- 菜单部分的DIV-->
			<div class="menu">
				<ul>
					<li style="display: inline;">首页</li>
					<li style="display: inline;">电脑办公</li>
					<li style="display: inline;">手机数码</li>
					<li style="display: inline;">鞋靴箱包</li>
				</ul>
			</div>
			
			<div class="content">
				<div style="position: absolute;left:400px;top:150px;background-color: white;border:5px solid gray;width: 700px;height: 500px;">
					<h3>用户注册</h3>
					<form>
											<table width="100%" height="100%" border="0" align="center" cellspacing="10">
												<tr>
													<td>用户名</td>
													<td><input type="text" name="username" placeholder="请输入用户名"/></td>
												</tr>
												<tr>
													<td>密码</td>
													<td><input type="password" name="password"/></td>
												</tr>
												<tr>
													<td>确认密码</td>
													<td><input type="password" name="repassword"/></td>
												</tr>
												<tr>
													<td>性别</td>
													<td><input type="radio" name="sex" value="男" checked="checked"/>男<input type="radio" name="sex" value="女"/>女</td>
												</tr>
												<tr>
													<td>Email</td>
													<td><input type="text" name="email"/></td>
												</tr>
												<tr>
													<td>姓名</td>
													<td><input type="text" name="name"/></td>
												</tr>
												<tr>
													<td>生日</td>
													<td><input type="text" name="birthday"/></td>
												</tr>
												<tr>
													<td>验证码</td>
													<td><input type="text" name="checkcode" size="10"/></td>
												</tr>
												<tr>
													<td colspan="2"><input type="submit" value="注册" style="background: url(../img/register.gif);"/></td>
												</tr>
											</table>
											</form>
				</div>
			</div >
			
			<div>
				<img src="../img/footer.jpg" />
			</div>
			<div align="center">
				<a href="../案例一：网站信息页面显示/网站信息页面显示.html">关于我们</a>
				    <a href="">联系我们</a>
				    <a href="">招贤纳士</a>
				    <a href="">法律声明</a>
				    <a href="link.html">友情链接</a>
				    <a href="">支付方式</a>
				    <a href="">配送方式</a>
				    <a href="">服务声明</a>
				    <a href="">广告声明</a>
					<br/>
					Copyright © 2005-2016 传智商城 版权所有 
			</div>
		</div>
	</body>
</html>
扩展：
扩展属性：
【列表属性】
ul li{
	list-style-image: url(../img/reg4.gif);
}
【颜色取值】
英文取值：
color：red
十六进制数：
color：#ff0000
Rgb方式：
color：rgb(255,0,0)
使用JS完成简单的数据的校验
需求分析：
使用JS完成对注册页面进行简单的数据的非空校验。在提交表单的时候，不可以出现用户名，密码是空的情况。
分析：
技术分析：
HTML骨架，CSS美化，JS可以使页面动起来。
【JavaScript的概述】
什么是JavaScript：
运行在浏览器端的脚本语言.

JS的组成：

ECMAScript：语法，语句.
BOM:浏览器对象
DOM:Document Object Model.操作文档中的元素和内容.
在哪些地方使用JS
JS增加用户和网站交互
如何使用JS
语法：
区分大小写
语法要求不是特别严格
变量是弱变量类型
var i = 3;
var s = “aa”;
JS代码需要写在<script></script>
【JS的数据类型】
原始类型：
string
number
boolean
undefined
null
引用类型：
基于对象而不是面向对象.内置对象.对象类型的默认值是null.
【JS的运算符和语句】
运算符与Java中一致.
全等于 === ：类型和值都一致返回true
语句与Java一致：
【JS的输出】
alert()
向页面中弹出一个提示框！！
innerHTML:
向页面的某个元素中写一段内容，将原有的东西覆盖
document.write();
向页面中写内容
步骤分析：
JS都是由事件触发的，第一步确定事件。
on…
JS的事件都会触发一个函数，编写一个函数。
JS获得操作的对象的元素。
document.getElementById(“”);
JS修改这个元素的属性或值。
代码实现：
		<script>
			// 第一步确定事件：onsubmit
			// 第二步编写触发函数：
			function checkForm(){
				// 第三步：通过ID获得元素
				var uValue = document.getElementById("username").value;
				// alert(uValue);
				if(uValue == ""){
					alert("用户名不能为空！");
					return false;
				}
				
				// 校验密码
				var pValue = document.getElementById("password").value;
				if(pValue == ""){
					alert("密码不能为空！");
					return false;
				}
				
				// 校验确认密码
				var rpValue = document.getElementById("repassword").value;
				if(rpValue != pValue){
					alert("两次密码输入不一致！");
					return false;
				}
				
				// 校验邮箱：使用正则表达式：
				var eValue = document.getElementById("email").value;
				if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/.test(eValue)){
					alert("邮箱格式不正确！");
					return false;
				}
			}
		</script>

使用JS完成首页上轮播图片效果：
需求分析：
在网站的首页上图片的轮播，现在页面中图片是静止的。让图片隔5秒自动切换。

分析：
技术分析：
【修改图片的路径】
获得图片，修改图片的src的属性。
document.getElementById("img1").src="2.jpg";
【JS中定时操作】
查看BOM中的window对象：

setInterval()	:隔多少毫秒之后，执行一段代码。重复执行。
setTimeout()		:隔多少毫秒之后，执行一段代码。

清除定时：
clearInterval()		:清除setInterval的定时操作。
clearTimeout()		: 清除setTimeout的定时操作。

示例代码：
			function init(){
				// window.setTimeout("alert('aaa')",5000);
				window.setInterval("alert('bbb')",5000);
			}
步骤分析：
步骤一：使用页面加载的事件触发一个函数
步骤二：在函数中设置定时：setInterval设置定时，5秒之后（切换图片-定义一个函数）
步骤三：编写切换图片的函数
步骤四：在函数中获得图片的元素
步骤五：修改图片的src的属性
代码实现：
<script>
			function init(){
				// 设置定时
				setInterval("changeImg()",5000);
			}
			
			// 定义一个全局变量
			var i = 1;
			
			function changeImg(){
				// 获得图片的元素：
				var img1 = document.getElementById("img1");
				
				if(i == 3){
					i =1;
				}else{
					i++;
				}
				
				// 修改图片的src的属性
				img1.src = "../img/"+i+".jpg";
			}
		</script>
第3章WEB03- JS篇
今日任务
使用JS完成页面定时弹出广告
使用JS完成表单的校验
使用JS完成表格的隔行换色
使用JS完成复选框的全选效果
使用JS完成省市联动效果
教学导航
教学目标	掌握JS中的BOM对象
掌握JS中的常用的事件
掌握JS中的常用DOM操作
了解JS中的内置对象
教学方法	案例驱动法

使用JS定时弹出广告
需求分析：
在浏览网站的时候，通常会5秒左右在顶部显示一个广告。过了5秒钟将这个广告隐藏。在网站的首页上显示这个广告。
分析：
技术分析：
【JS的定时操作】
setInterval();
setTimeout();

clearInterval();
clearTimeout();
【CSS控制显示和隐藏的属性】
display:
block	:显示的
none		:隐藏的
步骤分析：
步骤一：确定事件：onload.
步骤二：在函数中设置定时的操作.5秒显示这个div.
步骤三：清除原来的定时，重新设置一个定时操作.5秒以后隐藏掉.
步骤四：设置5秒后隐藏的定时，可以清除.
代码实现：
		<script>
			var time;
			function init(){
				// 设置定时操作：
				time = setInterval("showAd()",5000);
			}
			
			function showAd(){
				// 获得div元素
				var divAd = document.getElementById("divAd");
				divAd.style.display = "block";
				// 清除之前的定时操作：
				clearInterval(time);
				// 重新设置一个定时：5秒钟隐藏：
				time = setInterval("hideAd()",5000);
			}
			
			function hideAd(){
				// 获得div元素
				var divAd = document.getElementById("divAd");
				divAd.style.display="none";
				clearInterval(time);
			}
		</script>
总结：
扩展内容
【JS的引入的方式】
内部的JS
使用<script>标签
外部的JS
创建一个.js的文件
使用<script src="ad.js"></script>
【BOM中的对象】

Window对象：浏览器最顶层的对象.

Navigator：

Screen

History

Location

使用JS完成表单的校验
需求分析：
之前已经完成了一个表单校验，弹出提示框的形式。用户的体验不是特别的好。现在当鼠标点到文本框的时候，在文本框的后面给我们一段提示.当光标离开的时候完成校验.将信息写到文本框的后面的位置而不是提示框的形式。
分析：
技术分析：
【JS中的事件】
之前使用的事件：
onclick：
onsubmit：
onload：

使用：
onfocus	：获得焦点
onblur	：失去焦点
【JS控制向HTML的某个元素中写入内容】
document.getElementById(“”).innerHTML = “”;
步骤分析
确定事件：获得焦点和失去焦点
定义函数，在函数中进行校验
将校验的内容写入到文本框后面的<span>元素
代码实现：
		<script>
			function showTips(uid,info){
				// 控制后面的span元素：
				document.getElementById(uid+"span").innerHTML = "<font color='gray'>"+info+"</font>";
			}
			
			function checkUsername(uid,info){
				// 判断用户名是否为""
				var uValue = document.getElementById(uid).value;
				if(uValue == ""){
					document.getElementById(uid+"span").innerHTML = "<font color='red'>"+info+"</font>";
				}else{
					document.getElementById(uid+"span").innerHTML = "";
				}
			}
		</script>
总结：
JS的事件的总结：
onchange	：下拉列表上
ondblclick	：双击
onkeydown	：键盘按下
onkeyup		：键盘抬起
onmouseover	：鼠标在上面
onmouseout	：鼠标离开
onmousemove	：鼠标移动

需求：表格鼠标放上显示一个颜色，鼠标离开样式没有了！
<script>
			function changeColor(tid,flag){
				if(flag == 'over'){
					var tid = document.getElementById(tid);
					tid.style.backgroundColor="gold";
				}else if(flag == 'out'){
					var tid = document.getElementById(tid);
					tid.style.backgroundColor="white";
				}
			}
		</script>
使用JS控制表格的各行换色
需求
在网站的后台的表格页面中让表格显示出隔行换色的效果：
分析：
技术分析
【使用JS控制表格】
var tab1 = Document.getElementById(“tab1”);
var rows = tab1.rows.length;
for(){
	if(i % 2 == 0){

}
}
步骤分析：
步骤一：确定事件：onload事件
步骤二：获得表格元素
步骤三：获得表格的所有行的长度
步骤四：遍历表格的所有行
步骤五：使用下标对2取余
步骤六：设置奇数行和偶数行的颜色。
代码实现：
<script>
			window.onload = function(){
				// 获得表格元素：
				var tab1 = document.getElementById("tab1");
				// 获得表格的所有的行数：
				var len = tab1.rows.length;
				// 遍历所有的长度
				for(var i=0;i<len;i++){
					// 判断是奇数行还是偶数行：
					if(i % 2 == 0){
						tab1.rows[i].style.backgroundColor = "#33FF22";
					}else{
						tab1.rows[i].style.backgroundColor = "#883311";
					}
				}
			}
		</script>
总结：
表格隔行换色的时候，将最上一行也换掉了。第一行往往不需要进行换色的。
<table>
	<thead>
		<tr>
			<th></th>
		<tr>
	</thead>
	<tbody>
		<tr>
			<td></td>
		<tr>
	</tbody>
</table>

代码实现：
			window.onload = function(){
				// 获得表格元素：
				var tab1 = document.getElementById("tab1");
				// 查找表格中tbody中的所有的行数。
				var len = tab1.tBodies[0].rows.length;
				for(var i = 0 ;i<len ;i++){
					if(i % 2 == 0){
						tab1.tBodies[0].rows[i].style.backgroundColor="green";
					}else{
						tab1.tBodies[0].rows[i].style.backgroundColor="gold";
					}
				}
			}
使用JS控制复选框的全选和全不选的效果
需求的分析：
在后台管理页面中，往往会有批量删除数据的效果，就需要有复选框全选和全部选的效果。

分析：
步骤分析：
步骤一：确定事件：单击事件
步骤二：获得下面的所有的复选框
步骤三：如果上面的复选框被选中，将下面的所有的复选框选中状态变为checked=true.
步骤四：如果上面的复选框没被选中，将下面的所有的复选框选中状态变为checked=false.
代码实现：
function selectAll(){
				// alert("aaa");
				// 获得上面的复选框：
				var sAll = document.getElementById("selectAll");
				
				if(sAll.checked == true){
					// 上面的复选框被选中
					// 将下面的所有的复选框都被选中。
					var selectOnes = document.getElementsByName("selectOne");
					// 遍历数组中的每个元素，让每个元素都被选中：
					for(var i = 0;i<selectOnes.length;i++){
						selectOnes[i].checked = true;
					}
				}else{
					// 上面的复选框被选中
					// 将下面的所有的复选框都被选中。
					var selectOnes = document.getElementsByName("selectOne");
					// 遍历数组中的每个元素，让每个元素都被选中：
					for(var i = 0;i<selectOnes.length;i++){
						selectOnes[i].checked = false;
					}
				}
			}
总结：
DOM的操作：
DOM：Document Object Model 文档对象模型.
将HTML文档装载到内存,将HTML文档形成一个DOM的树形结构.


Document:文档对象.代表的是加载到内存中的整个的文档.
方法：
document.getElementById(“”);
document.getElementsByName(“”);
document.getElementsByTagName(“”);
document.createElement(“”);
Element:元素对象.代表文档中的每个元素（标签）
	<ul>
		<li>北京</li>
		<li>上海</li>
		<li>深圳</li>
	</ul>

	属性：
firstChild：获得其第一个孩子节点
lastChild：获得其最后一个子节点
方法：
appendChild();将节点添加到当前节点的最后.
insertBefore();将节点添加到某个元素之前.
Attribute:属性对象.代表元素上的属性.

Document,Element,Attribute统称为Node（节点）
JS控制二级联动：
需求：
在注册页面上有一个下拉列表,下拉列表显示省份信息,有另一个下列列表.选择某个省份，将这个省份下的城市列出.
分析：
技术分析：
【DOM创建元素】
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script>
			function addEl(){
				// 创建元素：
				var liEl = document.createElement("li");// <li></li>
				// 创建文本节点:
				var textEl = document.createTextNode("广州");// 广州
				// 将文本放入到li元素:
				liEl.appendChild(textEl);// <li>广州</li>
				// 获得ul元素:
				var ulEl = document.getElementById("ul1");
				// 将li放入到ul
				ulEl.appendChild(liEl);
			}
		</script>
	</head>
	<body>
		<ul id="ul1">
			<li>北京</li>
			<li>上海</li>
			<li>深圳</li>
		</ul>
		
		<input type="button" value="点击" onclick="addEl()"/>
	</body>
</html>
【数组对象的使用】
创建数组：

数组的属性：

数组的方法：

步骤分析：
步骤一：确定事件：onchange.
步骤二：获得改变的省份值 .
步骤三：比较省份的值 与 数组中定义的值是否相等，如果相等获得这个省份对应的所有的市的数组.
步骤四：创建option元素，将数组中的值添加到option元素中。
步骤五：将option添加到第二个下拉列表中.
代码实现：


			// 定义二维数组:
			var cities = new Array(4);
			cities[0] = new Array("长春市","吉林市","松原市","延边市");
			cities[1] = new Array("济南市","青岛市","烟台市","潍坊市","淄博市");
			cities[2] = new Array("石家庄市","唐山市","邯郸市","廊坊市");
			cities[3] = new Array("南京市","苏州市","扬州市","无锡市");
			
			function selectCity(val){
				// alert(val);
				var citySel = document.getElementById("city");
				// 清除原有的option:
				citySel.options.length = 0;
				
				// 遍历数组：
				for(var i=0;i<cities.length;i++){
					if(val == i){
						// 遍历数组：
						for(var j = 0 ;j<cities[i].length;j++){
							// alert(cities[i][j]);
							// 创建option元素：
							var opEl = document.createElement("option");
							// 创建文本元素：
							var textNo = document.createTextNode(cities[i][j]);
							// 将文本添加到option中．
							opEl.appendChild(textNo);
							// 将option添加到第二个下拉列表中
							citySel.appendChild(opEl);
						}
					}
				}
			}
总结：

查看文档了解方法：

全局函数：

parseInt();		将字符串转出整型
parseFloat();	将字符串转成小数

encodeURI()
decodeURI()
encodeURIComponent()
decodeURIComponent()

eval()			:将一段字符串当成一个JS的代码来运行.
JS控制下拉列表左右选择：
需求：
有两个列表，需要将左侧列表中的数据添加到右侧的列表中：

分析：
步骤分析：
单击事件：
编写函数：获得左侧的下拉列表.
遍历左侧列表中的所有的option元素.判断是否被选中。
如果被选中添加到右侧.

单击事件：
编写函数：获得左侧的下拉列表.
遍历左侧的列表中的所有的option.
全部添加到右侧.
JQuery
今日任务
使用JQuery完成页面定时弹出广告
使用JQuery完成表格的隔行换色
使用JQuery完成复选框的全选效果
使用JQuery完成省市联动效果
使用JQuery完成下列列表左右选择

教学导航
教学目标	掌握JQuery的基本使用
掌握JQuery的基本选择器,层次选择器
会使用JQuery完成DOM的基本操作.
教学方法	案例驱动法

使用JQuery完成页面的弹出广告的效果：
需求：
在网站的首页上定时弹出一个广告，过几秒之后，广告会自动消失。

分析：
技术分析：
【JQuery的概述】
什么JQuery：

JQuery的版本：
JQuery1.x   JQuery2.x(不支持IE6,7,8)
JQuery的作用：
大大简化的JS的代码编写.
将页面与JS分离
常见的JS的库：
JQuery,prototype,dwr,ExtJS...
【JQuery的入门】
		<script src="../../js/jquery-1.8.3.js"></script>
		<script>
			// 页面加载完毕
			window.onload = function(){
				alert("Hello 王守义");
			}
			
			window.onload = function(){
				alert("Hello 老王");
			}
			
			// DOM树绘制完毕以后就会执行
			jQuery(document).ready(function(){
				alert("Hello 王如花");
			});
			
			// JQ的简写   jQuery = $   
			/*jQuery(document).ready(function(){
				alert("Hello 王凤");
			});*/
			$(function(){
				alert("Hello 王凤");
			});
			
		</script>
【JQ和DOM对象的转换】
使用JS写的代码只能调用JS中的属性和方法.
使用JQ写的代码只能调用JQ中的属性和方法．
		<script src="../../js/jquery-1.8.3.js"></script>
		<script>
			// JS
			function writeIn(){
				// document.getElementById("s1").innerHTML = "Hello 王超杰";
				var s1 = document.getElementById("s1");
				// 将JS对象转成JQuery的对象
				$(s1).html("Hello 王超杰");
			}
			
			// JQ
			$(function(){
				$("#bt2").click(function(){
					// $("#s1").html("Hello 王守义");
					// 将JQ的对象转成JS的对象。
					// $("#s1")[0].innerHTML="Hello 王守义";
					// $("#s1").get(0).innerHTML = "Hello 王守义";
				});
			});
		</script>
【JQ的获得元素】
$(“#id”)
【JQ的效果】
* show(); --显示某个元素
* hide(); --隐藏某个元素
* slideDown();	--向下滑动
* slideUp();	--向上滑动
* fadeOut();	--淡出
* fadeIn();		--淡入
* animate();	--自定义动画
* toggle();		--单击事件的切换
步骤分析：
步骤一：页面加载后，设置一个定时操作.5秒执行一个函数.
步骤二：在函数中获得广告的div.显示div.
步骤三：清空原来的定时,设置一个定时.5秒后执行一个函数.
步骤四：在函数中获得广告的div.隐藏div.
代码实现：
		<script type="text/javascript" src="../js/jquery-1.8.3.js" ></script>
		<script>
			var time;
			$(function(){
				// 设置定时 5秒后执行一个显示广告的函数
				time = setInterval("showAd()",5000);
			});
			
			// 显示广告的函数
			function showAd(){
				// 获得广告的div，显示
				// $("#divAd").show(1000);
				// $("#divAd").slideDown(3000);
				$("#divAd").fadeIn(3000);
				// 清空定时：
				clearInterval(time);
				// 重新设置定时:
				time = setInterval("hideAd()",5000);
			}
			
			// 隐藏广告的函数:
			function hideAd(){
				// 获得广告的div，隐藏
				// $("#divAd").hide(3000);
				// $("#divAd").slideUp(3000);
				$("#divAd").fadeOut(3000);
				// 清空定时：
				clearInterval(time);
			}
		</script>
总结：
JQuery的选择器：
【基本选择器】
ID选择器：
$(“#id”)
类选择器：
$(“.class”)
元素选择器：
$(“元素”)
通配符选择器：
$(“*”)
选择器,选择器:
$(“#id,.class”)
【基本选择器的案例】
	<script type="text/javascript" src="../../js/jquery-1.8.3.js" ></script>
		<script>
			$(function(){
				$("#btn1").click(function(){
					$("#one").css("background","#bbffaa");`
				});
				
				$("#btn2").click(function(){
					$(".mini").css("backgroundColor","#bbffaa");
				});
				
				$("#btn3").click(function(){
					$("div").css("backgroundColor","#bbffaa");
				});
				
				$("#btn4").click(function(){
					$("*").css("backgroundColor","#bbffaa");
				});
				
				$("#btn5").click(function(){
					$("#two,.mini").css("backgroundColor","#bbffaa");
				});
			});
		</script>
	</head>
	<body>
		<input type="button" id="btn1" value="选择为one的元素"/>
		<input type="button" id="btn2" value="选择样式为mini的元素"/>
		<input type="button" id="btn3" value="选择所有的div元素"/>
		<input type="button" id="btn4" value="选择所有元素"/>
		<input type="button" id="btn5" value="选择id为two并且样式为mini的元素"/>
		<hr/>
		<div id="one">
			<div class="mini">
				111
			</div>
		</div>
		
		<div id="two">
			<div class="mini">
				222
			</div>
			<div class="mini">
				333
			</div>
		</div>
		
		<div id="three">
			<div class="mini">
				444
			</div>
			<div class="mini">
				555
			</div>
			<div class="mini">
				666
			</div>
		</div>
		
		<span id="four">
			
		</span>
	</body>
【JQ的层级选择器】
Ancestor  descendant2

Parent >child

Prev+next

Prev~sibling

【JQ层级选择器的代码】
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<link rel="stylesheet" href="../../css/style.css" type="text/css"/>
		<script type="text/javascript" src="../../js/jquery-1.8.3.js" ></script>
		<script>
			$(function(){
				$("#btn1").click(function(){
					$("body div").css("background","#bbffaa");
				});
				
				$("#btn2").click(function(){
					$("body>div").css("backgroundColor","#bbffaa");
				});
				
				$("#btn3").click(function(){
					$("#two+div").css("backgroundColor","#bbffaa");
				});
				
				$("#btn4").click(function(){
					$("#one~div").css("backgroundColor","#bbffaa");
				});
				
				
			});
		</script>
	</head>
	<body>
		<input type="button" id="btn1" value="选择body中的所有的div元素"/>
		<input type="button" id="btn2" value="选择body中的第一级的孩子"/>
		<input type="button" id="btn3" value="选择id为two的元素的下一个元素"/>
		<input type="button" id="btn4" value="选择id为one的所有的兄弟元素"/>
		
		<hr/>
		<div id="one">
			<div class="mini">
				111
			</div>
		</div>
		
		<div id="two">
			<div class="mini">
				222
			</div>
			<div class="mini">
				333
			</div>
		</div>
		
		<div id="three">
			<div class="mini">
				444
			</div>
			<div class="mini">
				555
			</div>
			<div class="mini">
				666
			</div>
		</div>
		
		<span id="four">
			
		</span>
	</body>
</html>
【JQ的基本过滤选择器】


$(function(){
				$("#btn1").click(function(){
					$("body div:first").css("background","#bbffaa");
				});
				
				$("#btn2").click(function(){
					$("body div:last").css("backgroundColor","#bbffaa");
				});
				
				$("#btn3").click(function(){
					$("body div:odd").css("backgroundColor","#bbffaa");
				});
				
				$("#btn4").click(function(){
					$("body div:even").css("backgroundColor","#bbffaa");
				});
				
				
			});
【JQ的属性选择器】
		<script>
			$(function(){
				$("#btn1").click(function(){
					$("div[title]").css("background","#bbffaa");
				});
				
				$("#btn2").click(function(){
					$("div[title='aaa']").css("backgroundColor","#bbffaa");
				});
				
			});
		</script>
【JQ的表单选择器】
			$(function(){
				$("#btn1").click(function(){
					$(":input").css("background","#bbffaa");
				});
				
				$("#btn2").click(function(){
					$(":text").css("background","#bbffaa");
				});
			});
使用JQuery完成表格的隔行换色
需求：
制作一个表格，隔行换色.第一行标题的行，不需要进行换色，其他的行需要变换颜色．

分析：
技术分析：
【JQuery的CSS类】
使用addClass(),removeClass(); 添加或移除样式
步骤分析：
步骤一：在页面中引入一个jquery的js
步骤二：写页面加载的函数.
步骤三：使用选择器基本过滤找到奇数行和偶数行
步骤四：分别给不同的行添加样式（样式已经由美工制作好的）
代码实现：
		<script>
			$(function(){
				// 找奇数行：
				//$("tr:odd").addClass("odd");
				// 偶数行:
				//$("tr:even").addClass("even");
				$("tbody>tr:odd").addClass("odd");
				$("tbody>tr:even").addClass("even");
			});
		</script>
使用JQuery完成复选框的全选和全不选
需求：
有如下的表格的数据，批量的进行删除.将上面的复选框选中，下面其他的复选框都被选中。如果上面的复选框没有被选中，那么将下面的所有的复选框全不选.

分析：
技术分析：
【JQuery操作某个元素的属性】
<script>
			$(function(){
				$("#bt1").click(function(){
					// 获得属性的值
					// alert($("#img1").attr("src"));
					// 修改属性的值:
					$("#img1").attr("src","../../img/f001a62f-a49d-4a4d-b56f-2b6908a0002c_g.jpg");
				});
			});
		</script>
步骤分析：
步骤一：引入jquery的js
步骤二：编写加载的方法.
步骤三：上面的复选框绑定一个单击事件
步骤四：如果上面的被选中，修改下面的所有的复选框的checked属性变为true否则将复选框的checked属性变为false.
代码实现：
		$(function(){
				// 步骤一：为上面的复选框绑定单击事件:
				$("#selectAll").click(function(){
					
					/*if(this.checked == true){
						// 如果上面的复选框被选中：
						$("input[name='ids']").attr("checked",true);
					}else{
						// 上面的复选框没有被选中
						$("input[name='ids']").attr("checked",false);
					}*/
					// $("input[name='ids']").attr("checked",this.checked);
					$("input[name='ids']").prop("checked",this.checked);// this JS的对象  
				});
			});
总结：
低版本可以使用attr方法设置属性的值.高版本中建议使用prop的方法设置属性的值.
使用JQuery完成省市联动
需求：
在注册的页面上有省市联动.

分析：
技术分析:
【JQuery的遍历】
each的方法进行遍历.
一种用法：
* JQ的对象.each(function(i,n){

});

二种用法
* $.each(数组,function(i,n){

});
【JQuery的DOM的操作】
JS中添加元素：appendChild();
JQ中添加元素：
append();
appendTo();
步骤分析：
步骤一：引入jquery.js
步骤二：加载的方法.
步骤三：定义二维数组
步骤四：在第一个省份的下拉列表中绑定一个事件change
步骤五：在绑定的事件的函数中，获得选中的省份的值.
步骤六：遍历数组，省份的值与数组中的值比较.
步骤七：获得数组的值.遍历获得的值.
步骤八：获得每个值.创建元素，创建文本节点.
步骤九：将文本添加到option元素中.将option添加到第二个下拉列表中 .
代码实现：
	// 定义二维数组：
			var cities = [
				["长春市","吉林市","延边市","白山市","松原市"],
				["济南市","青岛市","临沂市","烟台市"],
				["石家庄","唐山","保定","承德","秦皇岛"],
				["南京","苏州","扬州","无锡"]
			];
			$(function(){
				// 获得省份的下拉列表，绑定事件
				$("#province").change(function(){
					// 获得下拉列表的值:
					// alert(this.value);
					var val = this.value;
					
					var $city = $("#city");
					
					$city[0].options.length = 0;
					
					$(cities).each(function(i,n){
						// alert(i+"  "+n);
						if( val == i){
							$(n).each(function(j,m){
								// alert(m);
								// 创建option元素
								var opEL = document.createElement("option");
								// 创建文本节点
								var textNode = document.createTextNode(m);
								// 将文本添加到option中
								// opEL.appendChild(textNode);
								$(opEL).append(textNode);
								// 将option添加到第二个列表中
								$city.append(opEL);								
							});
						}
					});
				});
			});
总结
【JQuery的文档操作】
$(“a”).append(“b”); // 将b添加到a元素中.
$(“a”).appendTo(“b”); // 将a添加到b元素中.

$(“a”).insertBefore(“b”); // 将a元素插入到b元素之前
$(“a”).insertAfter(“b”); // 将a元素插入到b元素之后

$(“a”).remove();	// 将a元素移除
使用JQuery完成下拉列表的左右选择：
需求：
在数据的编辑的页面中，有已选的商品和未有的商品两个下拉列表，可以左右进行选择

分析：
技术分析：
JQuery的选择器和文档操作.
步骤分析：
步骤一：引入jquery的文件
步骤二：页面加载的函数
步骤三：在链接上添加一个事件.
步骤四：使用选择器找到左侧的列表中被选中的元素，添加到右侧.
代码实现：
		<script>
			$(function(){
				// 将左侧选中的option添加到右侧
				$("#add").click(function(){
					$("#selectLeft option:selected").appendTo("#selectRight");
				});
				
				// 将左侧所有的option添加到右侧
				$("#addAll").click(function(){
					$("#selectLeft option").appendTo("#selectRight");
				});
				
				// 双击事件
				$("#selectLeft").dblclick(function(){
					$("option:selected",this).appendTo("#selectRight");
				});
			});
		</script>
总结：
JQuery中常用的事件：




 BootStrap
今日任务
使用BootStrap制作一个响应式页面
使用BootStrap制作网站首页

教学导航
教学目标	掌握什么是响应式及响应式原理
掌握BootStrap的栅格系统
了解BootStrap的其他组件及JS控件
教学方法	案例驱动法
JQuery使用validate插件完成校验
在学习JavaScript时，我们手动的完成过表单数据的校验，此功能在开发中非常常见，属于通用功能范畴，实际开发一般使用都是第三方工具。本案例我们将使用jQuery插件validate进行表单的校验。
下载
官网地址：http://jqueryvalidation.org/files/jquery-validation-1.15.0.zip
帮助文档位置：http://jqueryvalidation.org/documentation/
目录结构：

导入
validate是jQuery插件，及必须在jQuery的基础上进行运行。我们将导入jQuery库、validate库、和国际化资源库（可选）
<!--依赖的jQuery库-->
<script src="../js/jquery-1.11.0.js" type="text/javascript" charset="utf-8" />
<!--validate校验库-->
<script src="../js/jquery.validate.js" type="text/javascript" charset="utf-8" />
<!--国际化库，中文提示（可选）-->
<script src="../js/messages_zh.js" type="text/javascript" charset="utf-8" />

使用前提
validate需要手动的声明，对那个表单进行校验，手动方式可以使用以下4种检验方式。
<script type="text/javascript">
	$().ready(function () {
		$("#formId").validate();
	});
</script>


检验器查询表
校验类型	取值	描述
required	true|false	必填字段
email	“@”或者”email”	邮件地址
url		路径
date	数字	日期
dateISO	字符串	日期（YYYY-MM-dd）
number		数字（负数，小数）
digits		整数
minlength	数字	最小长度
maxlength	数字	最大长度
rangelength	[minL,maxL]	长度范围
min		最小值
max		最大值
range	[min,max]	值范围
equalTo	jQuery表达式	两个值相同
remote	url路径	ajax校验

检验方式：js 代码
语法：
$(…).validate({
	rules:{},
	messages:{}
});

rules 规则语法：
	rules:{
		字段名:”校验器”,
		字段名:”校验器”
	}
	
校验器语法：
	语法1："校验器"
	语法2：{校验器:"取值",校验器:"取值",...}
	
message 提示语法：
	message:{
		字段名:{校验器:"提示",校验器:"提示",...}
	}

$("#formId").validate({
	rules:{
		username:"required",
		password:{
			required:true,
			rangelength:[2,5]
		},
		repassword:{
			equalTo:"[name='password']"
		}
	},
	messages:{
		username:{
			required:"不能为空"
		},
		password:{
			rangelength:"长度{0}-{1}之间"
		}
	}
});


案例实现
js代码
<script src="../js/jquery-1.11.0.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/jquery.validate.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/messages_zh.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript">
	$().ready(function () {
		$("#formId").validate({
			rules:{
				loginname:{
					required:true,
					minlength:2,
					maxlength:5
				},
				loginpwd:{
					required:true,
					number:true
				},
				reloginpwd:{
					equalTo:"[name='loginpwd']"
				},
				email:"email",
				username:{
					required:true,
					rangelength:[2,5]
				},
				gender:{
					required:true
				},
				birthday:"dateISO"
				/*,
				verifyCode:{
					remote:"t.html"
				},*/
			},
			messages:{
				gender:{
					required:"性别必须勾选"
				}
			}
		});
	});
</script>
补充说明

单选框:需提供一个label标签
<input type="radio" name="gender" value="男" />男
<input type="radio" name="gender" value="女" />女
<!--在指定位置显示错误信息
	* class 必须是error
	* for 必须设置错误对象
	
-->
<label for="gender" class="error"></label>

复选框:需提供一个value=””的选项

使用BootStrap开发一个响应式的页面：
需求：
开发一套页面，可以适用在PC端，Pad端，和手机端。不影响你的浏览的效果.
分析:
技术分析：
【BootStrap的概述】
BootStrap的概念

什么是响应式:
响应式页面设计：一套页面可以适配不同的设备.(PC,PAD,手机).
BootStrap的中文网：
http://www.bootcss.com/
下载BootStrap

BootStrap的结构：
* 全局CSS
    * BootStrap定义了一套CSS的样式表.
* 组件
    * BootStrap定义的一套按钮，导航条...
* JS插件
    * BootStrap定义的一套JS的插件.
BootStrap的入门开发：
		<meta charset="UTF-8">
		<!--BootStrap设计的页面支持响应式的 -->
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title></title>
		<!--引入BootStrap的CSS-->
		<link rel="stylesheet" href="../../css/bootstrap.css" type="text/css"/>
		<!--引入JQuery的JS文件：JQuery的JS文件要在BootStrap的js的文件的前面引入-->
		<script type="text/javascript" src="../../js/jquery-1.11.3.min.js" ></script>
		<!--引入BootStrap的JS的文件-->
		<script type="text/javascript" src="../../js/bootstrap.js" ></script>

补充说明:
  meta:
         width:可视区域的宽度，值可为数字或关键词device-width
         height:同width
         intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放
         maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，
              maximum-scale用户可将页面放大的程序，1.0将禁止用户放大到实际尺寸之上。
         user-scalable:是否可对页面进行缩放，no 禁止缩放
【BootStrap布局容器】

【BootStrap的栅格系统】
响应式的设计：
    * CSS3的样式：媒体查询
栅格样式：
    * 设备的分辨率大于 1200 使用lg样式
    * 设备的分辨率大于 992 < 1200 使用md样式
    * 设备的分辨率大于768 < 992 使用sm样式
    * 设备的分辨率小于 768 使用xs样式
将一行分成12列.定义div元素 样式的和 加一起等于12 即可.
【BootStrap的全局CSS】
定义了一套CSS
  * 对页面中的元素进行定义:
  * 列表元素，表单，按钮，图片...
代码实现：
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<!--BootStrap设计的页面支持响应式的 -->
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title></title>
		<!--引入BootStrap的CSS-->
		<link rel="stylesheet" href="../css/bootstrap.css" type="text/css"/>
		<!--引入JQuery的JS文件：JQuery的JS文件要在BootStrap的js的文件的前面引入-->
		<script type="text/javascript" src="../js/jquery-1.11.3.min.js" ></script>
		<!--引入BootStrap的JS的文件-->
		<script type="text/javascript" src="../js/bootstrap.js" ></script>
	</head>
	<body>
		<!--整体div-->
		<div class="container">
			<!--导航栏-->
			<div>
			
			<nav class="navbar navbar-inverse">
			  <div class="container-fluid">
			    <!-- Brand and toggle get grouped for better mobile display -->
			    <div class="navbar-header">
			      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
			        <span class="sr-only">Toggle navigation</span>
			        <span class="icon-bar"></span>
			        <span class="icon-bar"></span>
			        <span class="icon-bar"></span>
			      </button>
			      <a class="navbar-brand" href="#"><img src="../img/logo2.png" height="100%"></a>
			    </div>
			
			    <!-- Collect the nav links, forms, and other content for toggling -->
			    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			      <ul class="nav navbar-nav">
			        <li class="active"><a href="#">Java学院 <span class="sr-only">(current)</span></a></li>
			        <li><a href="#">IOS学院</a></li>
			        <li><a href="#">C++学院</a></li>
			        <li><a href="#">UI设计学院</a></li>
			        <li class="dropdown">
			          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">全部学院 <span class="caret"></span></a>
			          <ul class="dropdown-menu">
			            <li><a href="#">Java学院</a></li>
			            <li><a href="#">IOS学院</a></li>
			            <li><a href="#">C++学院</a></li>
			            <li role="separator" class="divider"></li>
			            <li><a href="#">UI设计学院</a></li>
			            <li role="separator" class="divider"></li>
			            <li><a href="#">网络营销学院</a></li>
			          </ul>
			        </li>
			      </ul>
			      <form class="navbar-form navbar-right" role="search">
			        <div class="form-group">
			          <input type="text" class="form-control" placeholder="Search">
			        </div>
			        <button type="submit" class="btn btn-default">Submit</button>
			      </form>
			    </div><!-- /.navbar-collapse -->
			  </div><!-- /.container-fluid -->
			</nav>
			</div>
			<!--图片轮播-->
			<div>
				<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
				  <!-- Indicators -->
				  <ol class="carousel-indicators">
				    <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
				    <li data-target="#carousel-example-generic" data-slide-to="1"></li>
				    <li data-target="#carousel-example-generic" data-slide-to="2"></li>
				    <li data-target="#carousel-example-generic" data-slide-to="3"></li>
				  </ol>
				
				  <!-- Wrapper for slides -->
				  <div class="carousel-inner" role="listbox">
				    <div class="item active">
				      <img src="../img/okwu.jpg" alt="">
				      <div class="carousel-caption">
				        <p>aaaa</p>
				      </div>
				    </div>
				    <div class="item">
				      <img src="../img/okwu-athletics.jpg" alt="">
				      <div class="carousel-caption">
				        
				      </div>
				    </div>
				    <div class="item">
				      <img src="../img/bartlesvillecf.jpg" alt="">
				      <div class="carousel-caption">
				        
				      </div>
				    </div>
				    <div class="item">
				      <img src="../img/emancipation.jpg" alt="">
				      <div class="carousel-caption">
				        
				      </div>
				    </div>
				  </div>
				 
				 <!--显示上一个和下一个的图标-->
				  <!-- Controls -->
				  <a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev">
				    <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
				    <span class="sr-only">Previous</span>
				  </a>
				  <a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next">
				    <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
				    <span class="sr-only">Next</span>
				  </a>
				</div>
			</div>
			
			<!--信息展示-->
			<div>
				<div class="col-md-4 col-sm-6 col-xs-12">
					<h2>WelCome</h2>
					<p>WelCome to HeiMa!WelCome to HeiMa!WelCome to HeiMa!</p>
					<p><a href="#" class="btn btn-primary pull-right">See More</a></p>
				</div>
				<div class="col-md-4 col-sm-6 col-xs-12">
					<h2>Our Team</h2>
					<p>Our Team,Our Team,Our Team,Our Team,Our Team,Our Team</p>
					<p><a href="#" class="btn btn-primary pull-right">See More</a></p>
				</div>
				<div class="col-md-4 col-sm-12 col-xs-12">
					<h2>About Us</h2>
					<p>About Us,About Us,About Us,About Us,About Us,About Us</p>
					<p><a href="#" class="btn btn-primary pull-right">See More</a></p>
				</div>
			</div>
		</div>
	</body>
</html>
使用BootStrap布局网站的首页：
需求：
使用BootStrap布局网站的首页.

分析：
步骤分析：
步骤一：新建一个html页面.引入bootStrap的相应js和css
步骤二：定义一个整体的div，将整体的div分成8个部分.
步骤三：完成每个部分的显示.
代码实现:
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<!--BootStrap设计的页面支持响应式的 -->
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title></title>
		<!--引入BootStrap的CSS-->
		<link rel="stylesheet" href="../css/bootstrap.css" type="text/css"/>
		<!--引入JQuery的JS文件：JQuery的JS文件要在BootStrap的js的文件的前面引入-->
		<script type="text/javascript" src="../js/jquery-1.11.3.min.js" ></script>
		<!--引入BootStrap的JS的文件-->
		<script type="text/javascript" src="../js/bootstrap.js" ></script>
	</head>
	<body>
		<!--整体div-->
		<div class="container">
			<!--Logo部分-->
			<div class="row">
				<div class="col-md-4 col-sm-6">
					<img src="../img/logo2.png" />
				</div>
				<div class="col-md-4 col-sm-6">
					<img src="../img/header.png" />
				</div>
				<div class="col-md-4 col-sm-12">
					<ul class="list-inline" style="padding-top: 15px;">
						<li><a href="#">登录</a></li>
						<li><a href="#">注册</a></li>
						<li><a href="#">购物车</a></li>
					</ul>
				</div>
			</div>
			<!--导航栏部分-->
			<div>
				<nav class="navbar navbar-inverse">
				  <div class="container-fluid">
				    <!-- Brand and toggle get grouped for better mobile display -->
				    <div class="navbar-header">
				      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
				        <span class="sr-only">Toggle navigation</span>
				        <span class="icon-bar"></span>
				        <span class="icon-bar"></span>
				        <span class="icon-bar"></span>
				      </button>
				      <a class="navbar-brand" href="#">首页</a>
				    </div>
				
				    <!-- Collect the nav links, forms, and other content for toggling -->
				    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
				      <ul class="nav navbar-nav">
				        <li class="active"><a href="#">手机数码 <span class="sr-only">(current)</span></a></li>
				        <li><a href="#">电脑办公</a></li>
				        <li><a href="#">电脑办公</a></li>
				        <li><a href="#">电脑办公</a></li>
				        <li><a href="#">电脑办公</a></li>
				        <li class="dropdown">
				          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a>
				          <ul class="dropdown-menu">
				            <li><a href="#">Action</a></li>
				            <li><a href="#">Another action</a></li>
				            <li><a href="#">Something else here</a></li>
				            <li role="separator" class="divider"></li>
				            <li><a href="#">Separated link</a></li>
				            <li role="separator" class="divider"></li>
				            <li><a href="#">One more separated link</a></li>
				          </ul>
				        </li>
				      </ul>
				      <form class="navbar-form navbar-right" role="search">
				        <div class="form-group">
				          <input type="text" class="form-control" placeholder="Search">
				        </div>
				        <button type="submit" class="btn btn-default">Submit</button>
				      </form>
				      
				    </div><!-- /.navbar-collapse -->
				  </div><!-- /.container-fluid -->
				</nav>
			</div>
			<!--图片轮播部分-->
			<div>
				<div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
				  <!-- Indicators -->
				  <ol class="carousel-indicators">
				    <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
				    <li data-target="#carousel-example-generic" data-slide-to="1"></li>
				    <li data-target="#carousel-example-generic" data-slide-to="2"></li>
				  </ol>
				
				  <!-- Wrapper for slides -->
				  <div class="carousel-inner" role="listbox">
				    <div class="item active">
				      <img src="../img/1.jpg" alt="">
				      <div class="carousel-caption">
				        
				      </div>
				    </div>
				    <div class="item">
				      <img src="../img/2.jpg" alt="">
				      <div class="carousel-caption">
				        
				      </div>
				    </div>
				    <div class="item">
				      <img src="../img/3.jpg" alt="">
				      <div class="carousel-caption">
				        
				      </div>
				    </div>
				  </div>
				
				  <!-- Controls -->
				  <a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev">
				    <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
				    <span class="sr-only">Previous</span>
				  </a>
				  <a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next">
				    <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
				    <span class="sr-only">Next</span>
				  </a>
				</div>
			</div>
			<!--最新商品显示部分-->
			<div>
				<div class="row">
					<h2>最新商品<img src="../img/title2.jpg"></h2>
				</div>
				<div class="row">
					<!--左侧广告部分-->
					<div class="col-md-2 hidden-sm hidden-xs" style="height: 400px;">
						<img src="../products/hao/big01.jpg" width="100%" height="100%"/>
					</div>
					<div class="col-md-10">
						<div class="row">
							<div class="col-md-6  hidden-sm hidden-xs" style="height: 200px;">
								<img src="../products/hao/middle01.jpg" width="100%" height="100%"/>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small03.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small04.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small05.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
						</div>
						<div class="row">
							<div class="col-md-2  col-sm-4">
								<img src="../products/hao/small03.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2  col-sm-4">
								<img src="../products/hao/small04.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small05.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small03.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small04.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small05.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
						</div>
					</div>
				</div>
			</div>
			<!--广告部分-->
			<div>
				<img src="../products/hao/ad.jpg" width="100%"/>
			</div>
			<!--热门商品显示部分-->
			<div>
				<div class="row">
					<h2>热门商品<img src="../img/title2.jpg"></h2>
				</div>
				<div class="row">
					<!--左侧广告部分-->
					<div class="col-md-2 hidden-sm hidden-xs" style="height: 400px;">
						<img src="../products/hao/big01.jpg" width="100%" height="100%"/>
					</div>
					<div class="col-md-10">
						<div class="row">
							<div class="col-md-6 hidden-sm hidden-xs" style="height: 200px;">
								<img src="../products/hao/middle01.jpg" width="100%" height="100%"/>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small03.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small04.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small05.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
						</div>
						<div class="row">
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small03.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small04.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small05.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small03.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small04.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
							<div class="col-md-2 col-sm-4">
								<img src="../products/hao/small05.jpg" />
								<p>电饭煲</p>
								<p>电饭煲</p>
							</div>
						</div>
					</div>
				</div>				
			</div>
			<!--广告部分-->
			<div>
				<img src="../img/footer.jpg" width="100%"/>
			</div>
			<!--页面底部友情链接-->
			<div align="center">
				<a href="../案例一：网站信息页面显示/网站信息页面显示.html">关于我们</a>
				    <a href="">联系我们</a>
				    <a href="">招贤纳士</a>
				    <a href="">法律声明</a>
				    <a href="../案例三：网站列表页面显示/网站列表页面显示.html">友情链接</a>
				    <a href="">支付方式</a>
				    <a href="">配送方式</a>
				    <a href="">服务声明</a>
				    <a href="">广告声明</a>
					<br/>
					Copyright © 2005-2016 传智商城 版权所有 
			</div>
		</div>
	</body>
</html>


MySQL
今日任务
完成对MYSQL数据库中的数据库,表及数据的CRUD的操作
给定一套系统模型可以分析其中表关系并完成建表操作
完成对MYSQL数据库的多表查询及建表操作.

教学导航
教学目标	掌握MYSQL的基本数据库,表及表中记录的操作
掌握MYSQL中的多表创建及多表查询
掌握MYSQL中的表关系分析并能正确建表
了解MYSQL可视化界面的使用
教学方法	案例驱动法

 完成对分类表的CRUD的操作
需求：
使用cmd的方式创建一个数据库，创建数据库表，完成对数据库表中的记录的CRUD的操作.
分析：
技术分析：
【MYSQL的概述】
什么是数据库：
数据库就是一个文件系统，需要通过标准SQL语句才能访问.
常见的数据库：
MYSQL	：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费.

Oracle	：收费的大型数据库.Oracle公司的产品.Oracle收购SUN公司，收购MYSQL.

DB2		：IBM公司的数据库产品,收费的.银行系统中.

SQLServer：MS公司.收费的中型的数据库.

SyBase	：已经淡出历史舞台.提供了一个非常专业数据建模的工具PowerDesigner.

SQLite	: 嵌入式的小型数据库,应用在手机端.

Java相关的数据库：MYSQL，Oracle．
关系型数据库：
数据库中存的实体和实体之间的关系.
MYSQL数据库服务器

【MYSQL的安装和卸载】
安装和卸载的过程记录下服务器安装的路径和数据文件存放的路径.卸载的时候将这个两个路径下的文件一并都删除掉.
【MYSQL的SQL语句】
什么是SQL
SQL：结构化查询语言.
SQL的分类：
DDL:数据定义语言.
    create,alter,drop...
DML:数据操纵语言
    insert,delete,update
DCL:数据控制语言
    if,grant
DQL:数据查询语言.
    Select
SQL的实现
使用SQL完成对数据库的CRUD的操作：
【创建数据库】
语法:
    * create database 数据库名;
    * create database 数据库名 character set 字符集;
    * create database 数据库名 character set 字符集 collate 校对规则;

【查看数据库】
* 查看数据库服务器中的所有的数据库:show databases;
* 查看某个数据库的定义的信息:show create database 数据库名;
【删除数据库】
* drop database 数据库名称;
【修改数据库】
* alter database 数据库名 character set 字符集 collate 校对规则;
【其他的数据库操作命令】
* 切换数据库：use 数据库名;
* 查看正在使用的数据库:select database();
使用SQL完成对数据库中表的CRUD的操作:
【创建表】
create table 表名(
   字段名 类型(长度) 约束,
   字段名 类型(长度) 约束
);

Java				MYSQL
int					int
float				float
double				double
char/String			char/varchar(char固定长度字符串，varchar可变长度的字符串)
Date				date,time,datetime,timestamp
文件类型				BLOB、TEXT   TEXT指的是文本文件  BLOB二进制文件
     * Oracle的文件类型：BLOB  CLOB

约束：
单表约束：
    * 主键约束：primary key
    * 唯一约束：unique
    * 非空约束：not null

创建一个分类表：
    分类ID int类型主键 自动增长
    分类名称 字符串类型 长度20

create table category(
	cid int primary key auto_increment,
	cname varchar(20)
);

***** 注意：建表之前一定先选择数据库.
【查看表】
查看数据库中的所有表：show tables;
查看表结构：desc 表名;
【删除表】
drop table 表名;
【修改表】
alter table 表名 add 列名 类型(长度) 约束; 		--修改表添加列. 
alter table 表名 modify 列名 类型(长度) 约束;	--修改表修改列的类型长度及约束.
alter table 表名 change 旧列名 新列名 类型(长度) 约束;	--修改表修改列名.
alter table 表名 drop 列名;					--修改表删除列.
rename table 表名 to 新表名;					--修改表名
alter table 表名 character set 字符集;		--修改表的字符集
使用SQL完成对表中记录的CRUD的操作：
【插入记录】
语法：
* insert into 表 (列名1,列名2,列名3..) values  (值1,值2,值3..); -- 向表中插入某些列
* insert into 表 values (值1,值2,值3..); --向表中插入所有列

注意：
* 1.列名数与values后面的值的个数相等
* 2.列的顺序与插入的值得顺序一致
* 3.列名的类型与插入的值要一致.
* 4.插入值得时候不能超过最大长度.
* 5.值如果是字符串或者日期需要加’’.

cmd下插入中文的乱码的解决：
* 修改mysql.ini文件.
    * 将[mysql]下面的字符集改为gbk
    * 重启mysql服务.services.msc
【修改记录】
语法：
* update 表名 set 字段名=值,字段名=值 [where 条件];

注意：
* 1.列名的类型与修改的值要一致.
* 2.修改值得时候不能超过最大长度.
* 3.值如果是字符串或者日期需要加’’.

【删除记录】
语法：
* delete from 表名 [where 条件];

面试：
删除表中所有记录使用delete from 表名; 还是用truncate table 表名;
* 删除方式：delete 一条一条删除. 而truncate 直接将表删除，重新建表.
* 事务控制DML,而delete属于DML.如果在一个事务中，delete数据，这些数据可以找回.truncate删除的数据找不回来.
【查询记录】
语法：
* select [distinct]*[列名,列名] from 表 [where 条件].

创建商品表：
创建商品表：
create table products(
	pid int primary key auto_increment,
	pname varchar(20),
	price double,
     pnum int,
     cno int,
	pdate timestamp
);

insert into products values (null,'泰国大榴莲',98,12,1,null);
insert into products values (null,'新疆大枣',38,123,1,null);
insert into products values (null,'新疆切糕',68,50,2,null);
insert into products values (null,'十三香',10,200,3,null);
insert into products values (null,'老干妈',20,180,3,null);
insert into products values (null,'豌豆黄',20,120,2,null);

简单查询:
     练习:
1.查询所有的商品
2.查询商品名和商品价格.	
3.查询所有商品都有那些价格.
4.将所有商品的价格+10元进行显示.(别名)


条件查询:
练习:
1.查询商品名称为十三香的商品所有信息：
2.查询商品价格>60元的所有的商品信息:
3.查询商品名称中包含”新”的商品
4.查询价格为38,68,98的商品

where后的条件写法：
    * > ,<,=,>=,<=,<>
    * like 使用占位符 _ 和 %  _代表一个字符 %代表任意个字符. 
        * select * from product where pname like '%新%';
    * in在某个范围中获得值.
        * select * from product where pid in (2,5,8);

排序查询:
1.查询所有的商品，按价格进行排序.(asc-升序,desc-降序)
2.查询名称有新的商品的信息并且按价格降序排序.


聚合函数:
* sum(),avg(),max(),min(),count();
1.获得所有商品的价格的总和：
2.获得商品表中价格的平均数：
3.获得商品表中有多少条记录：

分组：使用group by
1.根据cno字段分组，分组后统计商品的个数.
2.根据cno分组，分组统计每组商品的总数量，并且总数量> 200;
select cno,sum(pnum) t from products group by cno having t>200;   
SQL会创建多表及多表的关系:
需求:
分类表和商品表之间是不是有关系?如果有关系，在数据库中如何表示这种关系.
分析：
技术分析
【外键约束】
多个表之间是有关系的，那么关系靠谁来维护?
多表约束：外键约束.
alter table product add foreign key (cno) references category(cid);
【多表的关系】
一对多关系：
客户和订单，分类和商品，部门和员工.
一对多建表原则：在多的一方创建一个字段，字段作为外键指向一的一方的主键.
多对多关系：
学生和课程:
多对多关系建表原则：需要创建第三张表,中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键.
一对一关系：
在实际的开发中应用不多.因为一对一可以创建成一张表.
两种建表原则：
唯一外键对应：假设一对一是一个一对多的关系，在多的一方创建一个外键指向一的一方的主键，将外键设置为unique.
主键对应：让一对一的双方的主键进行建立关系.

网上商城案例实体抽取和表关系建立：


一对多的实现

###创建分类表（已存在）
create table category(
  cid varchar(32) PRIMARY KEY ,
  cname varchar(100)		#分类名称
);

# 商品表（已存在，删除，重新创建）
CREATE TABLE `products` (
  `pid` varchar(32) PRIMARY KEY  ,
  `name` VARCHAR(40) ,
  `price` DOUBLE 
);

#添加外键字段
alter table products add column category_id varchar(32);

#添加约束
alter table products add constraint product_fk foreign key (category_id) references category (cid);



多对多的实现
### 订单表
create table `orders`(
  `oid` varchar(32) PRIMARY KEY ,
  `totalprice` double 	#总计
);

### 订单项表
create table orderitem(
  oid varchar(50),-- 订单id
  pid varchar(50)-- 商品id
);
### 联合主键（可省略）
alter table `orderitem` add primary key (oid,pid);

###---- 订单表和订单项表的主外键关系
alter table `orderitem` add constraint orderitem_orders_fk foreign key (oid) references orders(oid);

###---- 商品表和订单项表的主外键关系
alter table `orderitem` add constraint orderitem_product_fk foreign key (pid) references products(pid);


初始化数据
-- 给商品表初始化数据
insert into products(pid,name,price,category_id) values('p001','联想',5000,'c001');
insert into products(pid,name,price,category_id) values('p002','海尔',3000,'c001');
insert into products(pid,name,price,category_id) values('p003','雷神',5000,'c001');
insert into products(pid,name,price,category_id) values('p004','JACK JONES',800,'c002');
insert into products(pid,name,price,category_id) values('p005','真维斯',200,'c002');
insert into products(pid,name,price,category_id) values('p006','花花公子',440,'c002');
insert into products(pid,name,price,category_id) values('p007','劲霸',2000,'c002');
insert into products(pid,name,price,category_id) values('p008','香奈儿',800,'c003');
insert into products(pid,name,price,category_id) values('p009','相宜本草',200,'c003');
insert into products(pid,name,price,category_id) values('p010','梅明子',200,null);


-- 给分类表初始化数据
insert into category values('c001','电器');
insert into category values('c002','服饰');
insert into category values('c003','化妆品');
insert into category values('c004','书籍');

使用商城表关系完成多表的查询（*****）
需求：
在商城的案例中很多涉及多表查询的功能，[我的订单]...
分析：
技术分析：
【多表查询】
交叉连接查询(基本不会使用-得到的是两个表的乘积)
语法：
* select * from A,B;
内连接查询(使用的关键字 inner join  -- inner可以省略)
* 隐式内连接：
    * select * from A,B where 条件;
* 显示内连接：
    * select * from A inner join B on 条件;
外连接查询(使用的关键字 outer join -- outer可以省略)
* 左外连接：left outer join
    * select * from A left outer join B on 条件;
* 右外连接：right outer join
    * select * from A right outer join B on 条件;

练习:
#1.查询哪些分类的商品已经上架
select cname from category c,products p where c.cid = p.category_id;
#隐式内连接
select distinct cname from category c,products p where c.cid = p.category_id;
#内连接
select distinct cname from category c
 inner join products p on c.cid = p.category_id;

#2.查询所有分类上架商品的个数
#左外连接
select cname,count(category_id) from category c
 left outer join products p on c.cid = p.category_id group by cname;

【子查询】
子查询, 查询“化妆品”分类上架商品详情
#隐式内连接
select p.* from products p, category c where p.category_id = c.cid and c.cname = '化妆品';
#子查询
select * from products where category_id = (select cid from category where cname = '化妆品');

【分页查询】
分页查询每个数据库的语句是不通用的.
MYSQL:使用limit的关键字.
* select * from product limit a,b;  --a:从哪开始,b:查询多少条.
Oracle:使用SQL语句嵌套.
SQLServer:使用top的关键字.


JDBC
今日任务
使用JDBC完成对分类表的CRUD的操作(JDBC的回顾)
使用DBCP,C3P0连接池完成基本数据库的操作(抽取工具类)
能够使用DBUtils完成CRUD的操作

教学导航
教学目标	掌握DBCP和C3P0连接池的使用并掌握连接池的原理.
能够使用DBUtils完成基本的CRUD的操作
教学方法	案例驱动法
使用JDBC完成对于分类的CRUD的操作-回顾JDBC
需求：
网上商城中对分类添加，修改，删除，查询的操作.使用JDBC完成对分类的CRUD的操作.
分析：
技术分析
【JDBC的回顾】
JDBC的概念：
JDBC：Java Data Base Connectivity.
驱动：

JDBC的开发步骤：
步骤一：注册驱动.
步骤二：获得连接.
	步骤三：创建执行SQL语句对象.
步骤四：释放资源.
JDBC的API的详解：
DriverManager：
    * 注册驱动：
    * 获得连接：
Connection：
    * 获得执行SQL语句对象.
        * Statement createStatement();
        * PreparedStatement prepareStatement(String sql);
        * CallableStatement prepareCall(String sql);
    * 进行事务管理:
        * setAutoCommit(boolean flag);
        * commit();
        * rollback();
Statement:
    * 执行SQL语句:
        * int executeUpate(String sql); --执行insert update delete语句.
        * ResultSet executeQuery(String sql); --执行select语句.
        * boolean execute(String sql); --执行select返回true 执行其他的语句返回false.
  
ResultSet:
    * 遍历结果集：next();
    * 获得结果集中的数据.getXXX(int c); getXXX(String name);
步骤分析
步骤一：创建Java项目，引入mysql的驱动包.
步骤二：编写程序
步骤三：注册驱动
步骤四：获得连接
步骤五：执行SQL
步骤六：释放资源
代码实现:
抽取工具类：
package com.itheima.jdbc.utils;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/**
 * JDBC的工具类
 * @author apple
 *
 */
public class JDBCUtils {
	public static final String DRIVERCLASS;
	public static final String URL;
	public static final String USERNAME;
	public static final String PASSWORD;
	
	static{
		// 获得属性文件中的数据.
		Properties properties = new Properties();
		try {
			properties.load(new FileInputStream("src/db.properties"));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		DRIVERCLASS = properties.getProperty("jdbc.driverClass");
		URL = properties.getProperty("jdbc.url");
		USERNAME = properties.getProperty("jdbc.username");
		PASSWORD = properties.getProperty("jdbc.password");
	}
	
	// 加载驱动：
	public static void loadDriver(){
		try {
			Class.forName(DRIVERCLASS);
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	// 获得连接:
	public static Connection getConnection(){
		loadDriver();
		Connection conn = null;
		try {
			conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return conn;
	}
	
	// 释放资源：
	public static void release(Statement stmt,Connection conn){
		if(stmt != null){
			try {
				stmt.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			stmt = null;
		}
		
		if(conn != null){
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			conn = null;
		}
	}
	
	public static void release(ResultSet rs,Statement stmt,Connection conn){
		if(rs!= null){
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			rs = null;
		}
		if(stmt != null){
			try {
				stmt.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			stmt = null;
		}
		
		if(conn != null){
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			conn = null;
		}
	}
}

分类的CRUD的操作详见JDBCDemo1.java
使用连接池改造JDBC的程序:
需求:
提升程序运行的效率,采用连接池对JDBC的部分的效率进行提升.
分析：
技术分析：
【连接池的概述】
为什么使用连接池
Connection对象在JDBC使用的时候.使用的时候就会去创建一个对象,使用结束以后就会将这个对象给销毁了.每次创建和销毁对象都是耗时操作.需要使用连接池对其进行优化.程序初始化的时候，初始化多个连接,将多个连接放入到池中(内存中).每次获取的时候,都可以直接从连接池中进行获取.使用结束以后,将连接归还到池中.
常见连接池:
DBCP	:Apache.
C3P0	:
【连接池的原理】
在javax.sql.DataSource接口--连接池的接口
* 功能：初始化多个连接.把多个连接放入到内存中.
* 归还：将连接对象放回到内存中.
【自定义连接池--了解】
public class MyDataSource implements DataSource{

	// 创建一个集合List集合.
	List<Connection> list = new ArrayList<Connection>();
	
	// 初始化连接池的时候，初始化5个连接.
	public  MyDataSource() {
		for (int i = 1; i <= 5; i++) {
			Connection conn = JDBCUtils.getConnection();
			list.add(conn);
		}
	}
	
	@Override
	// 从连接池中获得连接
	public Connection getConnection() throws SQLException {
		if(list.size()==0){
			for (int i = 1; i <= 3; i++) {
				Connection conn = JDBCUtils.getConnection();
				list.add(conn);
			}
		}
		Connection conn = list.remove(0);
		return conn;
	}
	
	// 归还连接：
	public void addBack(Connection conn){
		list.add(conn);
	}
...
}

【自定义连接池中问题】
1.创建连接池的时候能不能面向接口编程.
2.额外增加连接池的方法,那么程序员需要记住这些方法.能不能不额外去提供一些方法.
***** 解决：就是要去增强Connection的close方法.
       1.继承的方法:
            * 继承的使用条件：能够控制这个类的构造.
       2.装饰者模式:(*****)
            * 装饰者模式的使用条件：
                * 2.1增强的类和被增强的类实现相同的接口.
                * 2.2在增强的类中能够获得被增强的类的引用.
            * 接口中方法过多,只增强其中的一个方法.其他方法都需要原样调用原有方法.
       3.动态代理:(*****)
            * JDK的动态代理使用条件：
                 * 被代理的对象必须实现接口.
【使用开源连接池优化程序】
DBCP连接池：

核心API：


	@Test
	/**
	 * DBCP的一个入门：手动设置参数
	 */
	public void demo1(){
		Connection conn = null;
		PreparedStatement pstmt = null;
		
		// 创建连接池：
		BasicDataSource dataSource = new BasicDataSource();
		dataSource.setDriverClassName("com.mysql.jdbc.Driver");
		dataSource.setUrl("jdbc:mysql:///web07");
		dataSource.setUsername("root");
		dataSource.setPassword("1234");
		try{
			// 获得连接:
			conn = dataSource.getConnection();
			// 编写SQL语句.
			String sql = "insert into category values (null,?)";
			// 预编译SQL:
			pstmt = conn.prepareStatement(sql);
			// 设置参数:
			pstmt.setString(1, "鞋靴箱包");
			//执行SQL 
			pstmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			JDBCUtils.release(pstmt, conn);
		}
	}

	@Test
	/**
	 * DBCP的带有配置文件的方式
	 */
	public void demo2(){
		Connection conn = null;
		PreparedStatement pstmt = null;
		
		// 创建连接池：
		try{
			Properties properties = new Properties();
			properties.load(new FileInputStream("src/dbcp.properties"));
			DataSource dataSource = BasicDataSourceFactory.createDataSource(properties);
			// 获得连接:
			conn = dataSource.getConnection();
			// 编写SQL语句.
			String sql = "insert into category values (null,?)";
			// 预编译SQL:
			pstmt = conn.prepareStatement(sql);
			// 设置参数:
			pstmt.setString(1, "生活用品");
			//执行SQL 
			pstmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			JDBCUtils.release(pstmt, conn);
		}
	}

DBCP的参数的设置：
#连接设置
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/jdbc
username=root
password=1234

#<!-- 初始化连接 -->
initialSize=10

#最大连接数量
maxActive=50

#<!-- 最大空闲连接 -->
maxIdle=20

#<!-- 最小空闲连接 -->
minIdle=5

#<!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 -->
maxWait=60000
C3P0连接池的使用：


代码实现：
	@Test
	/**
	 * 手动设置参数的方式：
	 */
	public void demo1(){
		Connection conn = null;
		PreparedStatement stmt = null;
		// System.err.println("");
		try{
			// 创建连接池：
			ComboPooledDataSource dataSource = new ComboPooledDataSource();
			// 设置参数：
			dataSource.setDriverClass("com.mysql.jdbc.Driver");
			dataSource.setJdbcUrl("jdbc:mysql:///web07");
			dataSource.setUser("root");
			dataSource.setPassword("1234");
			
			conn = dataSource.getConnection();
//			编写SQL
			String sql = "insert into category values (null,?)";
			// 预编译SQL:
			stmt = conn.prepareStatement(sql);
			// 设置参数：
			stmt.setString(1, "食品饮料");
			stmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			JDBCUtils.release(stmt, conn);
		}
	}

	@Test
	/**
	 * 配置文件的方式：
	 */
	public void demo2(){
		Connection conn = null;
		PreparedStatement stmt = null;
		// System.err.println("");
		try{
			// 创建连接池：
			ComboPooledDataSource dataSource = new ComboPooledDataSource("mysql11111");
			
			conn = dataSource.getConnection();
//			编写SQL
			String sql = "insert into category values (null,?)";
			// 预编译SQL:
			stmt = conn.prepareStatement(sql);
			// 设置参数：
			stmt.setString(1, "食品饮料222");
			stmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			JDBCUtils.release(stmt, conn);
		}
	}
【使用C3P0改写了工具类】
public class JDBCUtils2 {
	
	private static final ComboPooledDataSource DATASOURCE =new ComboPooledDataSource();
	
	public Connection getConnection(){
		Connection conn = null;
		try {
			conn = DATASOURCE.getConnection();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return conn;
	}
     ...
}
DBUtils完成CRUD的操作
需求：
简化DAO的开发.
分析:
技术分析：
DBUtils
【概述】
DBUtils是java编程中的数据库操作实用工具，小巧简单实用。
DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。
Dbutils三个核心功能介绍
QueryRunner中提供对sql语句操作的API.
ResultSetHandler接口，用于定义select操作后，怎样封装结果集.
DbUtils类，它就是一个工具类,定义了关闭资源与事务处理的方法

【QueryRunner核心类】
QueryRunner(DataSource ds) ,提供数据源（连接池），DBUtils底层自动维护连接connection
update(String sql, Object... params) ，执行更新数据
query(String sql, ResultSetHandler<T> rsh, Object... params) ，执行查询

【ResultSetHandler结果集处理类】
ArrayHandler	将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值
ArrayListHandler	将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。
BeanHandler	将结果集中第一条记录封装到一个指定的javaBean中。
BeanListHandler	将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中
ColumnListHandler	将结果集中指定的列的字段值，封装到一个List集合中
KeyedHandler	将结果集中每一条记录封装到Map<String,Object>,在将这个map集合做为另一个Map的value,另一个Map集合的key是指定的字段的值。
MapHandler	将结果集中第一条记录封装到了Map<String,Object>集合中，key就是字段名称，value就是字段值

MapListHandler	将结果集中每一条记录封装到了Map<String,Object>集合中，key就是字段名称，value就是字段值，在将这些Map封装到List集合中。
ScalarHandler	它是用于单数据。例如select count(*) from 表操作。

【DbUtils】
closeQuietly(Connection conn) 关闭连接，如果有异常try后不抛。
commitAndCloseQuietly(Connection conn) 提交并关闭连接
rollbackAndCloseQuietly(Connection conn) 回滚并关闭连接






自定义DBUtils
案例相关知识
我们已经学习了DBUtils的使用，部分基础比较好的同学，在使用时就非常好奇，DBUtils的实现原理时什么，该文档作为扩展部分，带领大家动手编写一个属于自己的工具 - -自定义DBUtils。

JavaBean组件
JavaBean就是一个类，在开发中常用语封装数据。具有如下特性
1.需要实现接口：java.io.Serializable ，通常偷懒省略了。
2.提供私有字段：private 类型 字段名;
3.提供getter/setter方法：
4.提供无参构造

public class Category {
	
	private String cid;
	private String cname;
	
	public Category() {
		super();
	}
	public String getCid() {
		return cid;
	}
	public void setCid(String cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
    …toString….
}

BeanUtils工具
BeanUtils工具，准备对JavaBean进行处理
导入jar包：

简单操作
public class TestBean {
	
	@Test
	public void demo01(){
		//手动封装数据
		Category category = new Category();
		category.setCid("c001");
		category.setCname("测试");
		
		System.out.println(category);
	}
	
	@Test
	public void demo02() throws Exception{
		//beanUtils工具封装数据
		Category category = new Category();
		
		/* setProperty() ，相当于手动调用setter方法
		 * * 参数1：javabean实例对象
		 * * 参数2：javabean的属性，这是一个特殊概念，属性由setter或getter方法推断而得。
		 * 		例如：setUserName() ,去掉前缀--> UserName, 首字母小写 --> userName
		 * 		默认情况下，javabean的字段名和javabean的属性是一直
		 * * 参数3：具体值
		 */
		BeanUtils.setProperty(category, "cid", "c001");
		BeanUtils.setProperty(category, "cname", "测试2");
		
		System.out.println(category);
	}

}


添加功能
实现类
public class MyBeanUtils {

	private DataSource dataSource;

	public MyBeanUtils(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	public int update(String sql, Object... params) throws SQLException {
		Connection conn = null;
		PreparedStatement psmt = null;
		ResultSet rs = null;
		try {
			//1 获得连接
			conn = JdbcUtils.getConnection();
			
			//2获得预处理对象
			psmt = conn.prepareStatement(sql);
			//3设置实际参数
			if(params != null){
				for (int i = 0; i < params.length; i++) {
					psmt.setObject(i + 1, params[i]);
				}
			}
			//4 执行
			return psmt.executeUpdate();
			
		} catch (Exception e) {
			throw new RuntimeException(e);
		} finally{
			//释放资源
			JdbcUtils.release(conn, psmt, rs);
		}
	}

}

测试
@Test
public void demo01() throws SQLException{
	MyBeanUtils myBeanUtils = new MyBeanUtils(C3P0Utils.getDataSource());
	String sql = "insert into category(cid,cname) values(?,?)";
	Object[] params = {"x001","测试数据"};
	myBeanUtils.update(sql,params);
}


查询功能
query方法
工具类提供query()方法，方法的第二个参数必须是接口，在使用时，我们可以设置不同实现类，从而确定ResultSet采用什么样的封装类型。
public Object query(String sql, MyResultSetHandler rsHandler, Object... params) {
	Connection conn = null;
	PreparedStatement psmt = null;
	ResultSet rs = null;
	try {
		//1 获得连接
		conn = JdbcUtils.getConnection();
		
		//2 获得语句执行者
		psmt = conn.prepareStatement(sql);
		
		//3设置实际参数
		if(params != null){
			for (int i = 0; i < params.length; i++) {
				psmt.setObject(i + 1, params[i]);
			}
		}
		
		//4 执行语句，获得结果集对象
		rs = psmt.executeQuery();
		
		//5输出结果
		return  rsHandler.handler(rs);
		
	} catch (Exception e) {
		throw new RuntimeException(e);
	} finally{
		//释放资源
		JdbcUtils.release(conn, psmt, rs);
	}
}

定义接口
/**
 * 查询结果ResultSet封装数据的定义接口
 *
 */
public interface MyResultSetHandler {
	
	public Object handler(ResultSet rs);

}

编写封装实现类
通过构造方法获得JavaBean类型，并使用反射创建javabean实例
使用ResultSet 提供getMetaData()可以获得结果集对象的元数据
元数据：用于描述数据库数据的数据
通过getColumnCount() 可以获得查询结果的列数。
遍历列数，获得当前的列名 getColumnName() 
最后使用BeanUtils封装数据
public class MyBeanListHandler implements MyResultSetHandler {

	private Class beanClass;

	public MyBeanListHandler(Class beanClass) {
		this.beanClass = beanClass;
	}

	@Override
	public Object handler(ResultSet rs) {
		try {
			//1 创建javabean
			Object bean = beanClass.newInstance();
			
			ResultSetMetaData rsMeatData = rs.getMetaData();
			
			int columnCount = rsMeatData.getColumnCount();
			
			//2 BeanList 表示查询所有
			while(rs.next()){
				for (int i = 0; i < columnCount; i++) {
					//获得列名
					String columnName = rsMeatData.getColumnName(i + 1);
					// 获得对应的值
					Object columnValue = rs.getObject(columnCount);
					// 如果不为空封装数据
					if(columnValue != null){
						BeanUtils.setProperty(bean, columnName, columnValue);
					}
				}
			}
			
			return bean;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

}


测试
@Test
public void demo02() throws SQLException{
	MyBeanUtils myBeanUtils = new MyBeanUtils(C3P0Utils.getDataSource());
	String sql = "select * from category where cid = ? ";
	Object[] params = {"x001"};
	Category category = (Category) myBeanUtils.query(sql, new MyBeanListHandler(Category.class),params);
	System.out.println(category);
}










自定义连接池

案例分析
根据我们对连接池简单的理解，如果我们要编写自定义连接池，需要完成以下步骤
1.创建连接池实现（数据源），并实现接口 javax.sql.DataSource 。因为我们只使用该接口中getConnection()方法，简化本案例，我们将自己提供方法，而没有实现接口
2.提供一个集合，用于存放连接，因为移除/添加操作过多，所以选择LinkedList
3.本案例在静态代码块中，为连接池初始化3个连接。
4.之后程序如果需要连接，调用实现类的getConnection()，本方法将从连接池（容器List）获得连接。为了保证当前连接只能提供给一个线程使用，所以我们需要将连接先从连接池中移除。
5.当用户使用完连接，释放资源时，不执行close()方法，而是将连接添加到连接池中。

案例实现

提供容器及初始化
//#1 创建容器，用于存放连接Connection
private static LinkedList<Connection> pool = new LinkedList<Connection>();

//#1.1初始化连接池中的连接
static{
	try {
		//1 注册驱动
		Class.forName("com.mysql.jdbc.Driver");
		for (int i = 0; i < 3; i++) {
			//2 获得连接
			Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/day07_db", "root", "1234");
			//3 将连接添加到连接池中
			pool.add(conn);
		}
	} catch (Exception e) {
		throw new RuntimeException(e);
	}
}

获得连接
/**
 * #2 获得连接，从连接池中获得连接
 * @return
 */
public static Connection getConnection(){
	try {
		//1 如果池中有连接
		if(! pool.isEmpty()){
			//2 每一个连接Connection，只能提供给当前一个线程使用，必须进行移除操作
			Connection conn = pool.removeFirst();
			//3 返回刚刚获得连接
			return conn;
		}
		// 4 如果没有连接，等待100毫秒，然后继续
		Thread.sleep(100);
		return getConnection();
	} catch (Exception e) {
		throw new RuntimeException(e);
	}
}

归还连接
/**
 * #3 释放资源，当链接connection close时，归还给连接池
 * @param conn
 * @param st
 * @param rs
 */
public static void release(Connection conn){
	try {
		if (conn != null) {
//				conn.close();	//不是真的关闭
			pool.add(conn);	//将从连接池获得连接，归还给连接池
		}
	} catch (Exception e) {
	}
	
}

测试使用
为了体现连接池优势，我们将采用多线程并发访问，使同一个连接在不同的时段，被不同的线程使用。
public class TestCustomPool {
	
	public static void main(String[] args) {
		//10个线程，依次从连接池中获得连接
		for (int i = 0; i < 10; i++) {
			new MyThread().start();
		}
	}

}

class MyThread extends Thread {
	public void run() {
		try {
			//1 获得连接
			Connection conn = JdbcUtils.getConnection();
			
			
			System.out.println("使用：" + conn + " , " + Thread.currentThread());
			
			//2释放资源
			JdbcUtils.release(conn);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	};
}

自定义连接池：方法增强
需求
自定义连接池中存在严重问题，用户调用getConnection()获得连接后，必须使用release()方法进行连接的归还，如果用户调用 conn.close() 将连接真正的释放，连接池中将出现无连接可用。
此时我们希望，即使用户调用了close()方法，连接仍归还给连接池。close()方法原有功能时释放资源，期望功能：将当前连接归还连接池。说明close()方法没有我们希望的功能，我们将对close()方法进行增强，从而实现将连接归还给连接池的功能。

方法增强总结
1.继承，子类继承父类，将父类的方法进行复写，从而进行增强。
使用前提：必须有父类，且存在继承关系。
2.装饰者设计模式，此设计模式专门用于增强方法。【】
使用前提：必须有接口
缺点：需要将接口的所有方法都实现
3.动态代理：在运行时动态的创建代理类，完成增强操作。与装饰者相似
使用前提：必须有接口
难点：需要反射技术
4.字节码增强，运行时创建目标类子类，从而进行增强
常见第三方框架：cglib、javassist 等

装饰者设计模式
设计模式：专门为解决某一类问题，而编写的固定格式的代码。
装饰者固定结构：接口A，已知实现类C，需要装饰者创建代理类B
1.创建类B，并实现接口A
2.提供类B的构造方法，参数类型为A，用于接收A接口的其他实现类（C）
3.给类B添加类型为A成员变量，用于存放A接口的其他实现类
4.增强需要的方法
5.实现不需要增强的方法，方法体重调用成员变量存放的其他实现类对应的方法
A a = …C;
B b = new B(a);
class B implements A{
  private A a;
  public B(A a){
     this.a = a;
}
//增强的方法
public void close(){
}
  //不需要增强的方法
  public void commit(){
    this.a.commit();
}
}

实现
装饰类


public class MyConnection implements Connection {
	private Connection conn;
	private List<Connection> pool;
	
	public MyConnection(Connection conn){
		this.conn = conn;
	}
	
	/* 因为与自定义连接池有关系，所以需要另外添加一个构造方法 */
	public MyConnection(Connection conn,List<Connection> pool){
		this.conn = conn;
		this.pool = pool;
	}
	
	/* 以下是增强的方法 */
	
	@Override
	public void close() throws SQLException {
		//将调用当前close的链接Connection对象添加到链接池中
//		System.out.println("连接归还：" + this);
		this.pool.add(this);
	}
	/* 以下是不需要增强的方法  */
	
	@Override
	public void commit() throws SQLException {
		this.conn.commit();
	}
	....
}

使用装饰类（包装类）
将由DriverManager创建的连接，使用装饰类包装一下，然后添加到连接池中，构造方法中将容器pool传递进去，方便连接的归还。


使用连接










XML&Tomcat
今日内容介绍
编写服务器软件，访问指定配置内容
访问tomcat下已经发布的web项目

今日内容学习目标
可以编写xml存放任意内容
通过DTD约束编写指定格式的XML
通过Schema约束编写指定格式的XML
看得懂WEB项目的目录结构
使用Tomcat发布web项目，并成功访问
在STS下发布web项目





案例1-编写服务器软件，访问指定配置内容
案例介绍
第三阶段开始，我们将进行WEB编程阶段。在WEB编程中，我们可以通过浏览器访问WEB服务器上的资源。WEB服务器就是另一台计算机，这样学生就可以访问老师的资源了。
	
	浏览器的入口不同（访问路径），访问的资源也不同。
	

相关技术
为了灵活实现的不同路径（/hello）执行不同的资源（HelloMyServlet）我们需要使用XML进行配置；为了限定XML内容，我们需要使用xml约束（DTD或schema）；为了获得xml的内容，我们需要使用dom4j进行解析。
XML
什么是XML
XML全称为Extensible Markup Language，意思是可扩展的标记语言。XML语法上和HTML比较相似，但HTML中的元素是固定的，而XML的标签是可以由用户自定义的。
	W3C在1998年2月发布1.0版本，2004年2月又发布1.1版本，但因为1.1版本不能向下兼容1.0版本，所以1.1没有人用。同时，在2004年2月W3C又发布了1.0版本的第三版。我们要学习的还是1.0版本！！！
应用常见
配置文件
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5">
	<servlet>
		<servlet-name>HelloMyServlet</servlet-name>
		<servlet-class>cn.itcast.HelloMyServlet</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>HelloMyServlet</servlet-name>
		<url-pattern>/hello</url-pattern>
	</servlet-mapping>
</web-app>
存放数据
<?xml version="1.0" encoding="UTF-8"?>
<persons>
	<person id="p001">
		<name>张三</name>
	</person>
	<person id="p002">
		<name>李四</name>
	</person>
</persons>

XML 语法
XML文档声明
<?xml version="1.0" encoding="UTF-8"?>
1.文档声明必须为<?xml开头，以?>结束；
2.文档声明必须从文档的0行0列位置开始；
3.文档声明只有三个属性：
a)versioin：指定XML文档版本。必须属性，因为我们不会选择1.1，只会选择1.0；
b)encoding：指定当前文档的编码。可选属性，默认值是utf-8；
c)standalone：指定文档独立性。可选属性，默认值为yes，表示当前文档是独立文档。如果为no表示当前文档不是独立的文档，会依赖外部文件。

元素
<servlet>
1.元素是XML文档中最重要的组成部分，
2.普通元素的结构开始标签、元素体、结束标签组成。例如：<hello>大家好</hello>
3.元素体：元素体可以是元素，也可以是文本，例如：<b><a>你好</a></b>
4.空元素：空元素只有开始标签，而没有结束标签，但元素必须自己闭合，例如：<c/>
5.元素命名：
a)区分大小写
b)不能使用空格，不能使用冒号:
c)不建议以XML、xml、Xml开头
6.良好的XML文档，必须有一个根元素。

属性
<web-app version="2.5">
1.属性是元素的一部分，它必须出现在元素的开始标签中
2.属性的定义格式：属性名=属性值，其中属性值必须使用单引或双引
3.一个元素可以有0~N个属性，但一个元素中不能出现同名属性
4.属性名不能使用空格、冒号等特殊字符，且必须以字母开头

注释
XML的注释与HTML相同，即以“<!--”开始，以“-->”结束。注释内容会被XML解析器忽略！

转义字符
XML中的转义字符与HTML一样。
因为很多符号已经被XML文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符，例如：“<”、“>”、“’”、“””、“&”。
	

CDATA区
<![CDATA[
	任意内容
]]>
当大量的转义字符出现在xml文档中时，会使xml文档的可读性大幅度降低。这时如果使用CDATA段就会好一些。
在CDATA段中出现的“<”、“>”、“””、“’”、“&”，都无需使用转义字符。这可以提高xml文档的可读性。
在CDATA段中不能包含“]]>”，即CDATA段的结束定界符。

DTD约束
什么是DTD
DTD（Document Type Definition），文档类型定义，用来约束XML文档。规定XML文档中元素的名称，子元素的名称及顺序，元素的属性等。

DTD重点要求
开发中，我们很少自己编写DTD约束文档，通常情况我们都是通过框架提供的DTD约束文档，编写对应的XML文档。常见框架使用DTD约束有：struts2、hibernate等。
	通过提供的DTD“web-app_2_3.dtd”编写XML
	
<?xml version="1.0" encoding="UTF-8"?>
<!--
	传智播客DTD教学实例文档。
	模拟servlet2.3规范，如果开发人员需要在xml使用当前DTD约束，必须包括DOCTYPE。
	格式如下：
	<!DOCTYPE web-app SYSTEM "web-app_2_3.dtd">
-->
<!ELEMENT web-app (servlet*,servlet-mapping* , welcome-file-list?) >
<!ELEMENT servlet (servlet-name,description?,(servlet-class|jsp-file))>
<!ELEMENT servlet-mapping (servlet-name,url-pattern) >
<!ELEMENT servlet-name (#PCDATA)>
<!ELEMENT servlet-class (#PCDATA)>
<!ELEMENT url-pattern (#PCDATA)>

<!ELEMENT welcome-file-list (welcome-file+)>
<!ELEMENT welcome-file (#PCDATA)>

<!ATTLIST web-app version CDATA #IMPLIED>

案例实现
步骤1：创建web.xml文档，并将“web-app_2_3.dtd”拷贝相同目录下。

步骤2：从DTD文档开始处，拷贝需要的“文档声明”

	
步骤3：完成xml内容编写
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE web-app SYSTEM "web-app_2_3.dtd">
<web-app version="2.3">
	<servlet>
		<servlet-name></servlet-name>
		<servlet-class></servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name></servlet-name>
		<url-pattern></url-pattern>
	</servlet-mapping>
	
	<welcome-file-list>
		<welcome-file></welcome-file>
		<welcome-file></welcome-file>
		<welcome-file></welcome-file>
	</welcome-file-list>
</web-app>



DTD语法
文档声明
1.内部DTD，在XML文档内部嵌入DTD，只对当前XML有效。
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<!DOCTYPE web-app [
	... //具体的语法
]>
<web-app>
</web-app>
2.外部DTD—本地DTD，DTD文档在本地系统上，公司内部自己项目使用。
<?xml version="1.0" encoding="utf-8" standalone="no" ?>
<!DOCTYPE web-app SYSTEM "web-app_2_3.dtd">
<web-app>
</web-app>
3.外部DTD—公共DTD，DTD文档在网络上，一般都有框架提供。
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd">
<web-app>
</web-app>

元素声明
定义元素语法：<!ELEMENT 元素名 元素描述>
	元素名：自定义
	元素描述包括：符号和数据类型
		常见符号：? * + () | ,
		常见类型：#PCDATA 表示内容是文档，不能是子标签

实例
<!ELEMENT web-app (servlet*,servlet-mapping* , welcome-file-list?) >
	web-app 包括3个标签，且必须顺序出现。
		servlet子标签个数任意
		servlet-mapping 子标签个数任意
		welcome-file-list 子标签最多只能出现一次
<!ELEMENT servlet (servlet-name,description?,(servlet-class|jsp-file))>
	servlet 有3个子标签，且必须顺序出现
		servlet-name，必须有，且只能出现一次
		description，可选一次
		servlet-class 和 jsp-file 二选一，且只能出现一次
<!ELEMENT servlet-name (#PCDATA)>
	servlet-name 的标签体必须是文本
<!ELEMENT welcome-file-list (welcome-file+)>
	welcome-file-list 至少有一个子标签welcome-file

属性声明
属性的语法：
	<!ATTLIST 元素名 
		属性名 属性类型 约束
		属性名 属性类型 约束
		...
	>
	元素名：属性必须是给元素添加，所有必须先确定元素名
	属性名：自定义
	属性类型：ID、CDATA、枚举 …
		ID : ID类型的属性用来标识元素的唯一性
		CDATA：文本类型
		枚举：(e1 | e2 | ...) 多选一
	约束：
		#REQUIRED：说明属性是必须的；
		#IMPLIED：说明属性是可选的；
实例
<!ATTLIST web-app version CDATA #IMPLIED>
	给web-app元素添加 version属性，属性值必须是文本，且可选。
	<web-app version="2.3"> 和 <web-app> 都符号约束

Schema约束
什么是Schema
Schema是新的XML文档约束；
Schema要比DTD强大很多，是DTD 替代者；
Schema本身也是XML文档，但Schema文档的扩展名为xsd，而不是xml。
Schema 功能更强大，数据类型更完善
Schema 支持名称空间

Schema重点要求
与DTD一样，要求可以通过schema约束文档编写xml文档。常见框架使用schema的有：Spring等
	要求:可以通过提供“web-app_2_5.xsd”编写xml文档
	
<?xml version="1.0" encoding="UTF-8"?>
<!-- 
	传智播客Schema教学实例文档。
	模拟servlet2.5规范，如果开发人员需要在xml使用当前Schema约束，必须包括指定命名空间。
	格式如下：
	<web-app xmlns="http://www.example.org/web-app_2_5" 
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://www.example.org/web-app_2_5 web-app_2_5.xsd"
			version="2.5">
-->
<xsd:schema xmlns="http://www.w3.org/2001/XMLSchema" 
	targetNamespace="http://www.example.org/web-app_2_5"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns:tns="http://www.example.org/web-app_2_5" 
	elementFormDefault="qualified">
	
	<xsd:element name="web-app">
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element name="servlet">
					<xsd:complexType>
						<xsd:sequence>
							<xsd:element name="servlet-name"></xsd:element>
							<xsd:element name="servlet-class"></xsd:element>
						</xsd:sequence>
					</xsd:complexType>
				</xsd:element>
				<xsd:element name="servlet-mapping">
					<xsd:complexType>
						<xsd:sequence>
							<xsd:element name="servlet-name"></xsd:element>
							<xsd:element name="url-pattern"></xsd:element>
						</xsd:sequence>
					</xsd:complexType>
				</xsd:element>
				<xsd:element name="welcome-file-list">
					<xsd:complexType>
						<xsd:sequence>
							<xsd:element name="welcome-file" maxOccurs="unbounded"></xsd:element>
						</xsd:sequence>
					</xsd:complexType>
				</xsd:element>
			</xsd:choice>
			<xsd:attribute name="version" type="double" use="optional"></xsd:attribute>
		</xsd:complexType>
	</xsd:element>
</xsd:schema>

案例实现
1.步骤1：创建web.xml，并将“web-app_2_5.xsd”拷贝到同级目录

2.步骤2：从xsd文档中拷贝需要的“命名空间”

	
3.完成xml内容编写
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://www.example.org/web-app_2_5" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.example.org/web-app_2_5 web-app_2_5.xsd"
		version="2.5">

	<servlet>
		<servlet-name></servlet-name>
		<servlet-class></servlet-class>
	</servlet>

	<servlet-mapping>
		<servlet-name></servlet-name>
		<url-pattern></url-pattern>
	</servlet-mapping>
	
	<welcome-file-list>
		<welcome-file></welcome-file>
		<welcome-file></welcome-file>
		<welcome-file></welcome-file>
	</welcome-file-list>

</web-app>

命名空间（语法）
什么是命名空间
如果一个XML文档中使用多个Schema文件，而这些Schema文件中定义了相同名称的元素时就会出现名字冲突。这就像一个Java文件中使用了import java.util.*和import java.sql.*时，在使用Date类时，那么就不明确Date是哪个包下的Date了。
总之名称空间就是用来处理元素和属性的名称冲突问题，与Java中的包是同一用途。如果每个元素和属性都有自己的名称空间，那么就不会出现名字冲突问题，就像是每个类都有自己所在的包一样，那么类名就不会出现冲突。

约束文档和XML关系
当W3C提出Schema约束规范时，就提供“官方约束文档”。我们通过官方文档，必须“自定义schema 约束文档”，开发中“自定义文档”由框架编写者提供。我们提供“自定义文档”限定，编写出自己的xml文档。


声明命名空间
默认命名空间：<xxx xmlns=””> ，使用<标签>
显式命名空间：<xxx xmlns:别名=””> ， 使用<别名:标签>
实例：web-app_2_5.xsd
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" …>
	表示自定义schema约束文档引用官方文档作为显示命名空间。如果要使用官方提供的元素或属性，必须使用xsd前缀（自定义，此处表示官方文档，所以使用xsd）
	<xsd:schema>标签就有官方文档提供，默认命名空间直接使用。
实例：web.xml
<web-app xmlns=http://www.example.org/web-app_2_5 …>
	表示 xml 文档引用“自定义约束文档”作为默认命名空间
	因为使用默认命名空间，<web-app>直接使用

其他介绍
自定义约束：web-app_2_5.xsd
<xsd:schema targetNamespace=http://www.example.org/web-app_2_5
	表示给当前自定义约束文档进行起名，提供给xml文档使用。

xml文档：web.xml
<web-app 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation=http://www.example.org/web-app_2_5 web-app_2_5.xsd
	
	xmlns:xsi=”…” 固定写法
		表示是一个schema实例文档，就是被schema文档约束的xml文档。
	xsi:schemaLocation=”名称 路径  名称 路径  名称 路径 …”
		表示用于确定当前xml文档使用到的schema文档的位置。“名称 路径”是成对出现，与xmlns引用命名空间对应。

综合案例：




dom4j解析
XML解析概述
当将数据存储在XML后，我们就希望通过程序获得XML的内容。如果我们使用Java基础所学习的IO知识是可以完成的，不过你需要非常繁琐的操作才可以完成，且开发中会遇到不同问题（只读、读写）。人们为不同问题提供不同的解析方式，并提交对应的解析器，方便开发人员操作XML。

解析方式和解析器
开发中比较常见的解析方式有三种，如下：
1.DOM：要求解析器把整个XML文档装载到内存，并解析成一个Document对象。
a)优点：元素与元素之间保留结构关系，故可以进行增删改查操作。
b)缺点：XML文档过大，可能出现内存溢出显现。
2.SAX：是一种速度更快，更有效的方法。它逐行扫描文档，一边扫描一边解析。并以事件驱动的方式进行具体解析，每执行一行，都将触发对应的事件。（了解）
a)优点：处理速度快，可以处理大文件
b)缺点：只能读，逐行后将释放资源。
3.PULL：Android内置的XML解析方式，类似SAX。（了解）

解析器：就是根据不同的解析方式提供的具体实现。有的解析器操作过于繁琐，为了方便开发人员，有提供易于操作的解析开发包。

常见的解析开发包：
JAXP：sun公司提供支持DOM和SAX开发包
JDom：dom4j兄弟
jsoup：一种处理HTML特定解析开发包
dom4j：比较常用的解析开发包，hibernate底层采用。

DOM解析原理及结构模型
XML DOM 和 HTML DOM类似，XML DOM 将 整个XML文档加载到内存，生成一个DOM树，并获得一个Document对象，通过Document对象就可以对DOM进行操作


DOM中的核心概念就是节点，在XML文档中的元素、属性、文本等，在DOM中都是节点！

API使用
如果需要使用dom4j，必须导入jar包。

dom4j 必须使用核心类SaxReader加载xml文档获得Document，通过Document对象获得文档的根元素，然后就可以操作了。
常用API如下：
1.SaxReader对象
a)read(…) 加载执行xml文档
2.Document对象
a)getRootElement() 获得根元素
3.Element对象
a)elements(…) 获得指定名称的所有子元素。可以不指定名称
b)element(…) 获得指定名称第一个子元素。可以不指定名称
c)getName() 获得当前元素的元素名
d)attributeValue(…) 获得指定属性名的属性值
e)elementText(…) 获得指定名称子元素的文本值
f)getText() 获得当前元素的文本内容

@Test
public void demo03() throws Exception{
	//#1 获得document
	SAXReader saxReader = new SAXReader();
	Document document = saxReader.read(new File("src/cn/itcast/a_xml/web.xml"));
	
	//#2 获得根元素
	Element rootElement = document.getRootElement();
	
	//打印version属性值
	String version = rootElement.attributeValue("version");
	System.out.println(version);
	
	//#3 获得所有子元素。例如：<servlet>/<servlet-mapping>
	List<Element> allChildElement = rootElement.elements();
	
	//#4 遍历所有
	for (Element childElement : allChildElement) {
		// #5.1 打印元素名
		String childEleName = childElement.getName();
		System.out.println(childEleName);
		
		// #5.2 处理<servlet> ,并获得子标签的内容。例如：<servlet-name> 等
		if("servlet".equals(childEleName)){
			// 方式1：获得元素对象，然后获得文本
			Element servletNameElement = childElement.element("servlet-name");
			String servletName = servletNameElement.getText();
			System.out.println("\t" + servletName);
			
			// 方式2：获得元素文本值
			String servletClass = childElement.elementText("servlet-class");
			System.out.println("\t" + servletClass);
			
		}
		
		// #5.3 处理<servlet-mapping> 省略... 
		
	}
	
}

案例实现
准备工作
为了模拟服务器端程序，且可以同时存在多个类似程序。故提供接口，接口中有3个方法，我们人为约定三个方法的调用顺序。
public interface MyServlet {
	
	public void init();		//1.初始化
	
	public void service();	//2.执行
	
	public void destory();	//3.销毁

}
	在为接口编写实现类
		
public class HelloMyServlet implements MyServlet {

	@Override
	public void init() {
		System.out.println("1.初始化");
	}

	@Override
	public void service() {
		System.out.println("2.执行中....");
	}

	@Override
	public void destory() {
		System.out.println("3.销毁");
	}

}
	测试，创建实现类实例对象
public class TestApp {
	@Test
	public void demo01(){
		//手动创建执行
		MyServlet myServlet = new HelloMyServlet();
		myServlet.init();
		myServlet.service();
		myServlet.destory();
	}
}

反射执行
测试程序我们直接new HelloServlet，这种编程方式我们称为硬编码，及代码写死了。为了后期程序的可扩展，开发中通常使用实现类的全限定类名（cn.itcast.e_web.HelloMyServlet），通过反射加载字符串指定的类，并通过反射创建实例。
@Test
public void demo02() throws Exception{
	/* 反射创建执行
	 * 1) Class.forName 返回指定接口或类的Class对象
	 * 2) newInstance() 通过Class对象创建类的实例对象，相当于new Xxx();
	 */
	String servletClass = "cn.itcast.e_web.HelloMyServlet";
	
	//3 获得字符串实现类实例
	Class clazz = Class.forName(servletClass);
	MyServlet myServlet = (MyServlet) clazz.newInstance();
	//4 执行对象的方法
	myServlet.init();
	myServlet.service();
	myServlet.destory();
}

解析xml
使用反射我们已经可以创建对象的实例，此时我们使用的全限定类名，在程序是仍写死了，我们将器配置到xml文档中。
	xml文档内容：
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5">
	<servlet>
		<servlet-name>HelloMyServlet</servlet-name>
		<servlet-class>cn.itcast.e_web.HelloMyServlet</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>HelloMyServlet</servlet-name>
		<url-pattern>/hello</url-pattern>
	</servlet-mapping>
	
	<servlet>
		<servlet-name>HelloMyServlet2</servlet-name>
		<servlet-class>cn.itcast.e_web.HelloMyServlet2</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>HelloMyServlet2</servlet-name>
		<url-pattern>/hello2</url-pattern>
	</servlet-mapping>
</web-app>
	解析实现
@Test
public void demo03() throws Exception{
	/* 读取xml配置文件，获得<servlet-class>配置的内容，取代固定字符串
	 */
	
	//1.1 加载xml配置文件，并获得document对象
	SAXReader saxReader = new SAXReader();
	Document document = saxReader.read(new File("src/cn/itcast/e_web/web.xml"));
	//1.2 获得根元素
	Element rootElement = document.getRootElement();
	//1.3 获得第一个<servlet> 子元素
	Element servletElement = rootElement.element("servlet");
	//1.4 获得字符串实现类 <servlet-class>的值
	String servletClass = servletElement.elementText("servlet-class");
	
	//3 获得字符串实现类实例
	Class clazz = Class.forName(servletClass);
	MyServlet myServlet = (MyServlet) clazz.newInstance();
	//4 执行对象的方法
	myServlet.init();
	myServlet.service();
	myServlet.destory();
}

模拟浏览器路径
上面我们已经解析xml，不过我们获得内容是固定。我们希望如果用户访问的路径是/hello，将执行cn.itcast.e_web.HelloMyServlet程序，如果访问时/hello2，将执行cn.itcast.e_web.HelloMyServlet2程序。
	在执行测试程序前（@Before），解析xml文件，将解析的结果存放在Map中，map中数据的格式为：路径=实现类。
	
	解析xml思路：先解析<servlet>，将结果存放map，name=class，然后再解析<servlet-mapping>通过name获得class，再将url=class存放到map，最后将name=class移除。
//最终存放 key=请求路径，value=实现类
private Map<String, String> data = new HashMap<String,String>();
@Before
public void demo04Before() throws Exception{
	//在执行前执行，解析xml，并将结果存放到Map<路径，实现类>中
	//1 获得document
	SAXReader saxReader = new SAXReader();
	Document document = saxReader.read(new File("src/cn/itcast/e_web/web.xml"));
	//2 获得根元素
	Element rootElement = document.getRootElement();
	//3 获得所有的子元素 <servlet> 、<servlet-mapping>等
	List<Element> allChildElement = rootElement.elements();
	/* 4 遍历所有
	 * 1)解析到<servlet>，将其子标签<servlet-name>与<servlet-class>存放到Map中
	 * 2)解析到<servlet-mapping>，获得子标签<servlet-name>和<url-pattern>, 从map中获得1的内容，组合成 url = class 键值对
	 */
	for (Element childElement : allChildElement) {
		//4.1 获得元素名
		String eleName = childElement.getName();
		//4.2 如果是servlet，将解析内容存放到Map中
		if("servlet".equals(eleName)){
			String servletName = childElement.elementText("servlet-name");
			String servletClass = childElement.elementText("servlet-class");
			data.put(servletName, servletClass);
		}
		//4.3 如果是servlet-mapping，获得之前内容，组成成key=url,value=class并添加到Map中
		if("servlet-mapping".equals(eleName)){
			String servletName = childElement.elementText("servlet-name");
			String urlPattern = childElement.elementText("url-pattern");
			// 获得<servlet-name>之前存放在Map中<servlet-class>值
			String servletClass= data.get(servletName);
			// 存放新的内容 url = class
			data.put(urlPattern, servletClass);
			// 将之前存放的数据删除
			data.remove(servletName);
		}
		
		//打印信息
		System.out.println(data);
		
	}
}
	模拟浏览器请求路径，通过url从map获得class，并使用反射执行实现类。
@Test
public void demo04() throws Exception{
	
	//1 模拟路径
	String url = "/hello";
//		String url = "/hello2";
	
	//2 通过路径获得对应的实现类
	String servletClass = data.get(url);
	
	//3 获得字符串实现类实例
	Class clazz = Class.forName(servletClass);
	MyServlet myServlet = (MyServlet) clazz.newInstance();
	//4 执行对象的方法
	myServlet.init();
	myServlet.service();
	myServlet.destory();
}

浏览器访问（了解）
使用Socket编写服务，通过浏览器可以访问，并解析浏览器发送的请求数据，最终获得请求路径。
访问路径：http://localhost:8888/hello
@Test
public void demo05() throws Exception{
	//使用socket获得请求路径
	
	//1.1 给本地计算机绑定端口8888
	ServerSocket serverSocket = new ServerSocket(8888);
	//1.2 程序阻塞，等待浏览器请求。
	Socket accept = serverSocket.accept();
	//1.3 获得请求所有数据
	BufferedReader reader = new BufferedReader(new InputStreamReader(accept.getInputStream()));
	//1.4 获得第一行数据，请求行，例如：GET /hello HTTP/1.1
	String firstLine = reader.readLine();
	//1.5 请求行三部分数据由空格连接，获得中间数据。表示请求路径
	String url = firstLine.split(" ")[1];
	System.out.println(url);
	
	//2 通过路径获得对应的实现类
	String servletClass = data.get(url);
	
	//3 获得字符串实现类实例
	Class clazz = Class.forName(servletClass);
	MyServlet myServlet = (MyServlet) clazz.newInstance();
	//4 执行对象的方法
	myServlet.init();
	myServlet.service();
	myServlet.destory();
	//5 释放资源
	reader.close();
	client.close();
}
显示效果

控制台显示效果

几秒之后，服务程序没有做出任何响应，浏览器将显示“无法访问”

案例2-访问tomcat下已经发布的web项目
为了可以通过浏览器访问到自己tomcat下的web项目，我们需要先了解以下内容：
 Web开发概述
WEB通信
WEB采用B/S通信模式，通过超文本传送协议(HTTP, Hypertext transport protocol)进行通信。通过浏览器地址栏编写URL，向服务器发送一个请求，服务器端根据请求进行相应的处理，处理完成之后，会向浏览器作出一个响应，及将服务器端资源发送给浏览器。


软件架构
C/S架构：Client/Server 客户端/服务器。要求客户端电脑安装一个客户端程序。
常见应用：QQ，迅雷，360，旺旺 等
优点：
1.用户体验好，效果炫
2.对信息安全的控制较强
3.应用服务器运行数据负荷较轻，部分计算功能在客户端完成。
缺点：
1.占用硬盘空间
2.维护麻烦
3.安装使用依赖其他条件

B/S架构：Browser/Server 浏览器/服务器 。通过浏览器与服务器交互，不需要安装其他程序
常见应用：网银系统，淘宝，京东 12306 等
优点：
1.维护和升级简单，无缝升级。
2.不用必须安装程序，操作系统内置了浏览器。
缺点：
1.动画效果受浏览器限制
2.对信息安装控制较差。例如：网银就需要使用U盾，在浏览器端加密。
3.应用服务器运行数据负荷较重。大部分计算都在服务器端，增加服务器压力。使用Ajax可以改善部分用户体验。
WEB资源介绍
静态资源：指web页面中供人们浏览的数据始终是不变。比如：HTML、CSS、JS、图片、多媒体。
动态资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。比如：JSP/Servlet、ASP、PHP

WEB服务器
JCP（Java Community Process) Java技术规范制定与更新的国际组织。主要维护规范包括：J2ME、J2SE、J2EE，XML等。
J2EE 企业级开发Java规范。标准规范包括：servlet、jsp、jdbc、xml、jta、javamail等。在java中规范就是接口。J2EE又称为JavaEE。
	WEB服务器对JavaEE规范部分或全部支持，也就是WEB服务器实现部分或全部接口。
	常见的WEB服务器：
1.Tomcat:：Apache组织提供一个免费的小型的服务器软件。支持Servlet和JSP规范。
2.WebLogic：Bea公司的一个收费的大型的服务器软件，后被Oracle收购。支持EE的所有的规范
3.WebSphere：IBM公司的一个收费的大型的服务器软件，支持EE的所有的规范。
4.JBoss：是一个基于J2EE的开放源代码的应用服务器。JBoss是一个管理EJB的容器和服务器，JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。
    




 Tomcat 概述
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。
支持Servlet和JSP 规范,且最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现。
Apache 软件基金会有两款常用软件：apache web 服务器 和 tomcat web服务器。
apache web服务器专门处理HTML页面的。
tomcat web服务器，不仅可以处理servlet和jsp，而且也能处理html页面，不过不如apache web服务器。
在开发中，一般使用tomcat处理servlet和jsp，使用apache服务器处理html页面。及apache和tomcat被整合在一起使用。
学习阶段，我们使用tomcat所有的特性

 Tomcat版本（了解）
tomcat 目前存在很多版本，希望大家了解tomcat的版本，从而知道自己的创建的项目使用的是几版本规范，不同版本的规范技术可能不同。我们学习的WEB5.0，Servlet规范2.5，tomcat至少使用6版本。
官网地址：http://tomcat.apache.org/whichversion.html

Tomcat版本	Servlet版本	JSP版本	EL版本	JavaEE版本	JDK版本
9.0.x	4.0	2.4？	3.1？	?	8 (1.8)
8.0.x	3.1	2.3	3.0	7.0	7 (1.7)
7.0.x	3.0	2.2	2.2	6.0	6 (1.6)
6.0.x	2.5	2.1	N/A	5.0	5 (1.5)
	最新版本myeclipse可选的WEB项目版本。


使用tomcat
安装
步骤一：下载一个tomcat服务器软件.
http://tomcat.apache.org/download-70.cgi

步骤二：解压下载好的zip文件.
将解压后的文件copy到一个没有中文和空格的路径下即可.
例如：D:\java\tomcat\apache-tomcat-7.0.68

目录结构

bin：脚本目录
	启动脚本：startup.bat
	停止脚本：shutdown.bat
conf：配置文件目录
	核心配置文件：server.xml
	用户权限配置文件：tomcat-users.xml
	所有web项目默认配置文件：web.xml
lib：依赖库，tomcat和web项目中需要使用的jar包
logs：日志文件.
	localhost_access_log.*.txt tomcat记录用户访问信息，星*表示时间。
	例如：localhost_access_log.2016-02-28.txt
temp：临时文件目录，文件夹内内容可以任意删除。
webapps：默认情况下发布WEB项目所存放的目录。
work：tomcat处理JSP的工作目录。

启动和访问
tomcat解压目录/bin/startup.bat 双击运行启动tomcat

访问路径：http://localhost:8080/


 web项目
在JavaEE规范中，WEB项目存在一定的目录结构，具体结构如下：
     项目名称
            |-----静态资源.HTML，CSS，JS
            |-----WEB-INF
                       |----web.xml  当前WEB项目的核心配置，Servlet2.5必须有，3.0可省略。
                       |----lib		  当前WEB项目所需要的第三方的jar的存放位置。
                       |----classes  Java源码编译后生成class文件存放的位置。	



 STS发布web项目
配置Tomcat
步骤1：获得服务器运行环境配置，Window/Preferences/Server/Runtime Environmen

步骤2：添加服务器


步骤3：选择服务器在硬盘的地址，然后所有的都是确定/Next/Finish

步骤4：完成成功

步骤5：设置发布位置

	修改tomcat发布的位置
	

发布web项目
步骤1：项目右键/Run As/Run on Server

步骤2：选择WEB服务器执行程序。


步骤3：选择或添加文本框


 Tomcat常见问题
JAVA_HOME的配置
如果没有配置JAVA_HOME环境变量，在双击“startup.bat”文件运行tomcat时，将一闪立即关闭。且必须配置正确，及JAVA_HOME指向JDK的安装目录

端口号冲突
当同一台计算机启动两个tomcat时，第二个tomcat将会在控制台抛异常，摘要信息如下：
严重: Failed to initialize end point associated with ProtocolHandler ["http-bio-8080"]
java.net.BindException: Address already in use: JVM_Bind <null>:8080
...
Caused by: java.net.BindException: Address already in use: JVM_Bind
...
	控制台将出现大量异常信息，描述的是3个端口被占用（8080、8009、8005 ）
	通过 $JAVA_HOME/conf/server.xml修改端口号。
	
	
	


sts配置环境截图
修改字符集编码





修改字体





安装jre


修改jsp文件的默认字符集




展示需要的窗口

修改右键new的内容


目前需要展示的



Servlet
今日任务
完成系统的登录的功能
完成登录系统后页面定时跳转
记录系统登录成功后，系统被访问多少次
教学导航
教学目标	了解HTTP协议
掌握Servlet的编写
了解ServletConfig的使用
掌握ServletContext对象的使用
教学方法	案例驱动法
HTTP协议
HTTP协议:
协议的概念:
规定被约束的对象需要遵守的规则!!!
HTTP协议:
HTTP协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。

HTTP协议规定 浏览器(客户端)向服务器发送 何种格式的数据. 服务器 会处理数据. 向浏览器(客户端)作出响应.(向客户端发送何种格式的数据)

HTTP协议的特点:
* HTTP协议遵守一个请求响应模型.
    * 请求和响应必须成对出现.
    * 必须先有请求后有响应.
* HTTP协议默认的端口:80
HTTP协议的请求部分
客户端向服务器发送的数据的格式：
GET请求方式的抓包：
GET /WEB09/demo1/subSucc.html?username=aaa&password=123 HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
X-HttpWatch-RID: 63397-10023
Referer: http://localhost:8080/WEB09/demo1/demo1.html
Accept-Language: zh-Hans-CN,zh-Hans;q=0.5
User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko
Accept-Encoding: gzip, deflate
Host: localhost:8080
Connection: Keep-Alive

POST方式的抓包：
POST /WEB09/demo1/subSucc.html HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
X-HttpWatch-RID: 63397-10049
Referer: http://localhost:8080/WEB09/demo1/demo1.html
Accept-Language: zh-Hans-CN,zh-Hans;q=0.5
User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Host: localhost:8080
Content-Length: 25
Connection: Keep-Alive
Cache-Control: no-cache

username=aaa&password=123

【请求行】
请求方式 请求路径 协议版本
* 请求方式：请求方式有很多种 常用的是GET和POST.
* GET和POST区别?
     * GET：请求参数会显示到地址栏.GET方式有大小的限制.GET方式没有请求体
     * POST：请求参数不会显示到地址栏.在请求体中.POST没有大小限制.POST方式有请求体.
* 只有表单设置为method=”post”才是post请求.其他的都是get请求
【请求头】
* 请求头通常都是key:value的键值对的形式.一般情况下一个key对应一个value但也有一个key对应多个value的情况.
* Referer			:网站的来源.防盗链.
* User-Agent		:获得客户端浏览器的信息.(文件下载:IE:URL编码 火狐Base64)
* If-Modified-Since	:和响应中一个头一起使用 完成本地缓存的查找.
【请求体】
POST方式 提交的请求参数
HTTP协议的响应部分
服务器向客户端发送的数据的格式：
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Accept-Ranges: bytes
ETag: W/"147-1455670867735"
Last-Modified: Wed, 17 Feb 2016 01:01:07 GMT
Content-Type: text/html
Content-Length: 147
Date: Wed, 17 Feb 2016 01:17:06 GMT

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h1>鎻愪氦鎴愬姛</h1>
</body>
</html>
【响应行】
协议版本 状态码 状态码描述
200:响应成功
302:重定向
304:查找本地缓存
404:浏览资源不存在.
500:服务器内部错误.
【响应头】
一个key对应一个value，也有一个key对应多个value的头.
Last-Modified	:最后的修改文件的事件.与If-Modified-Since一起使用.
Refresh			:定时刷新.
Location		:重定向的路径.
Content-Disposition:文件下载的时候使用的头信息.
禁用浏览器缓存:
Pragma
Expires 
Cache-Control
【响应体】
页面要显示的内容.
案例一：商城的登录的功能的实现：
需求：
网上商城有一个登录的功能.

分析
技术分析
【Servlet的概述】
什么是Servlet：
是运行在服务器端的一小的Java程序,接收和响应从客户端发送请求.
Servlet的作用：
处理客户端的请求，并且对请求作出响应.
使用Servlet:
Servlet的入门:
* 编写一个类实现Servlet接口.
public class ServletDemo1 implements Servlet{

	@Override
	public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
		// System.out.println("");
		response.getWriter().println("Hello Servlet...");
	}
...
}

* 配置Servlet到WEB服务器.
  <!-- 配置Servlet -->
  <servlet>
  	<!-- Servlet的名称 -->
  	<servlet-name>aaa</servlet-name>
  	<!-- Servlet的类的全路径 -->
  	<servlet-class>com.itheima.servlet.demo1.ServletDemo1</servlet-class>
  </servlet>
  
  <!-- 配置Servlet的映射 -->
  <servlet-mapping>
    <!-- Servlet的名称 -->
  	<servlet-name>aaa</servlet-name>
  	<!-- Servlet的访问路径 -->
  	<url-pattern>/servletDemo1</url-pattern>
  </servlet-mapping>

步骤分析：
步骤一：设计一个登录页面.
步骤二：在登录页面上点击登录按钮.提交到Servlet.
步骤三：编写Servlet.在Servlet中接收参数.
步骤四：调用业务层去数据库进行查询.
步骤五：根据处理结果作出响应.
代码实现：
创建数据库
create database web09;
use web09;
create table user(
	id int primary key auto_increment,
	username varchar(20),
	password varchar(20),
	email varchar(20),
	name varchar(20),
	sex varchar(10),
	birthday date,
	hobby varchar(50)
);
insert into user values (null,'tom','123','tom@126.com','tom','1','1988-01-01',null);
导入页面:

代码实现:
1.引入jar包(mysql,c3p0,dbutils)
2.创建包和类
3.创建一个工具类JDBCUtils
4.编写Servlet,Service,DAO
总结：
Servlet的生命周期（*****）
生命周期:
指的是一个对象从创建到销毁的过程.
Servlet的生命周期,Servlet对象从创建到销毁的过程.

客户端第一次访问该Servlet的时候才会创建一个Servlet的对象,那么Servlet中的init方法就会执行.任何一次从客户端发送的请求,那么服务器创建一个新的线程执行Servlet中service方法为这次请求服务.
service方法的内部根据请求的方式的不同调用不同doXXX的方法.当Servlet从服务器中移除或者关闭服务器的时候Servlet对象就会被销毁.destroy的方法就会执行.
Servlet的接口的实现:
Servlet			接口
    |
GenericServlet	通用的Servlet
    |
HttpServlet		HttpServlet
配置Servlet的启动时加载:
在web.xml中<servlet>标签中配置
<load-on-startup>2</load-on-startup>
配置url-pattern
【完全路径匹配】
* 以/开头  如:/aaa /aaa/bbb
【目录匹配】
* 以/开头 以*结尾  如:/* /aaa/* /aaa/bbb/*
【扩展名匹配】
* 不能以/开始的 需要以*开始   如：*.jsp  *.do  *.action

完全路径匹配 > 目录匹配 > 扩展名匹配

练习:
有如下的一些映射关系：
    Servlet1 映射到 /abc/* 
    Servlet2 映射到 /*
    Servlet3 映射到 /abc 
    Servlet4 映射到 *.do 
问题:
当请求URL为“/abc/a.html”，“/abc/*”和“/*”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet1。
当请求URL为“/abc”时，“/*”和“/abc”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet3。
当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet1。
当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet2.
当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet2。

WEB开发中的路径的问题:（*****）
相对路径:不是以 / 开始的路径.
* localhost:8080/WEB09/servletDemo5
* localhost:8080/WEB09/demo2/demo1.html

绝对路径:
通常都是以  / 开始的路径.

带工程名的路径(客户端的路径)	:
不带工程名的路径(服务器端路径)	:
案例二：系统登录成功后页面5秒后跳转到成功页面
需求
网站登录成功后，隔5秒钟页面自动跳转到成功的页面.
分析：
技术分析：
【Refresh的响应头】
HttpServletResponse的操作响应头的方法:
* addHeader(String name,String value); --针对一个key对应多个value头的设置
    * addDateHeader(String name,long value);
    * addIntHeader(String name,int value);
* setHeader(String name,String value); --针对一个key对应一个value
    * setDateHeader(String name,long value);
    * setIntHeader(String name,int value);
步骤分析：
步骤一：在登录成功后的代码的地方设置响应头
步骤二：编写一个成功后的跳转的页面.
代码实现：
response.setContentType("text/html;charset=UTF-8");
response.getWriter().println("<h1>登录成功!页面将在5秒后跳转</h1>");
response.setHeader("Refresh", "5;url=/WEB09/loginSucc.html");
总结：
多学一招:
可以通过html页面中的一个标签设置头信息<meta>标签.
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="Refresh" content="5;url=/WEB09/succ.html">
<script type="text/javascript" src="/WEB09/js/jquery-1.11.3.min.js"></script>
<title>Insert title here</title>
<script type="text/javascript">
	$(function(){
		setInterval("changeTime()", 1000);
	});
	var i = 5;
	function changeTime(){
		// 获得id为s1的元素:
		i--;
		$("#s1").html(i);
	}
</script>
</head>
<body>
<h1>登录成功！！！页面将在<span id="s1">5</span>秒后跳转！</h1>
</body>
</html>
案例三：统计一下网站被登录的总次数.
需求：
系统已经完成的登录的基本功能,并且登录后页面5秒后跳转到成功页面.想在成功页面中显示被登录成功的次数.
分析：
技术分析
【ServletContext*****】
ServletContext	:Servlet中全部的内容ServletContext都了解.一个WEB应用只有一个ServletContext对象.服务器启动的时候，服务器为每个WEB工程创建一个属于自己项目的ServletContext对象.服务器关闭的时候或者项目从服务器中移除ServletContext才会被销毁.如果将值保存在ServletContext中.值就有一个作用的范围.所以这个对象称为”域对象”.
* 保存全局性信息和数据：
    * 网站的访问次数:
    * 聊天室：
* 在Servlet中获得ServletContext:
    * ServletContext getServletContext();

* 操作这个对象的方法：
    * void setAttribute(String name,Object value);
    * Object getAttribute(String name);
    * void removeAttribute(String name);
步骤分析：
步骤一：编写一个Servlet中的init方法.在init方法中初始化一个被登录次数0.将这个值存入到ServletContext域中.配置Servlet的load-on-startup.
步骤二：在登录成功代码中获得原来的次数+1.存回到ServletContext域中.
步骤三：在5秒后跳转的Servlet中,从ServletContext域中获得次数,并且显示到页面上.
代码实现:
配置SErvlet为启动时加载：
  <servlet>
    <servlet-name>UserServlet</servlet-name>
    <servlet-class>com.itheima.servlet.demo2.UserServlet</servlet-class>
 	<load-on-startup>2</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>UserServlet</servlet-name>
    <url-pattern>/userServlet</url-pattern>
  </servlet-mapping>

在Servlet的init方法中初始化次数为0
	@Override
	public void init() throws ServletException {
		// super.init();
		// 获得ServletContext对象.初始化一个值为0.
		ServletContext servletContext = this.getServletContext();
		servletContext.setAttribute("count", 0);
	}

在登录成功的代码中获得原来的次数并且+1，存回到SErvletContext域中。
// 登录成功的时候 获得原来的次数 + 1
				Integer count = (Integer) this.getServletContext().getAttribute("count");
				// 存回到ServletContext域中
				this.getServletContext().setAttribute("count", ++count);

在CountServlet中获得次数并且显示：
response.setContentType("text/html;charset=UTF-8");
		// 获得次数:
		Integer count = (Integer) this.getServletContext().getAttribute("count");
		response.getWriter().println("<h1>您是第"+count+"位登录成功的用户！</h1>");
总结：
ServletConfig:(了解)
这个对象可以获得到Servlet的配置信息:

		String servletName = this.getServletConfig().getServletName();
		System.out.println(servletName);
		// 获得初始化参数:
		String username = this.getServletConfig().getInitParameter("username");
		String password = this.getServletConfig().getInitParameter("password");
		System.out.println(username+"   "+password );

		// 获得所有初始化参数的名称
		Enumeration<String> names = this.getServletConfig().getInitParameterNames();
		while(names.hasMoreElements()){
			String name = names.nextElement();
			String value = this.getServletConfig().getInitParameter(name);
			System.out.println(name+"  "+value);
		}
ServletContext：
1.获得文件的MIME的类型.  -- 文件上传和下载.

2.获得全局初始化参数：

3.作为域对象存取数据:


4.读取WEB项目的文件:(***)



使用类加载器获得web项目的文件.
requet&response
今日任务
完成文件下载
商城系统注册功能.
教学导航
教学目标	掌握response设置响应头
掌握response重定向和转发的区别
掌握request接收请求参数
掌握request域的作用范围
教学方法	案例驱动法
案例一：完成登录用户对他提供文件的下载的功能.
需求：
之前的案例中已经完成的了一个登录的功能,登录失败后回到登录页面.登录成功以后,服务器提供多个文件的下载的链接,点击链接可以完成文件的下载的功能.
分析：
技术分析：
【响应对象-Response对象】
响应行：
Response设置状态码：

响应头：
Response设置响应头：
* 一个key对应一个value

* 一个key对应多个value

响应体：
Response设置响应体:

【response处理中文乱码】
字节流：
设置浏览器默认打开编码
response.setHeader("Content-Type", "text/html;charset=UTF-8");
中文转成字节数组编码
response.getOutputStream().write("王守义".getBytes("UTF-8"));

字符流:
设置response的缓冲区的编码
response.setCharacterEncoding("UTF-8");
设置浏览器默认打开的编码.
response.setHeader("Content-Type", "text/html;charset=UTF-8");

response.setContentType("text/html;charset=UTF-8");相当于上面两句
【文件下载】
一种:超链接方式.（不推荐）
    * <a href=”aa.zip”>下载</a>
    * <a href=”1.jpg”>下载</a>
二种:手动编码方式完成文件下载.
    * 设置两个头和一个流:
    * Content-Type:文件MIME的类型.
    * Content-Disposition:
    * 文件的输入流:
步骤分析：
之前的登录案例已经存在:
登录成功跳转的页面上提供一组链接:
当点击下载的链接之后,提交到Servlet:
设置两个头和一个流:
代码实现:
1.在页面中提供一组下载的链接：
		response.getWriter().println("<h2>手动编码方式下载</h2>");
		response.getWriter().println("<a href='/WEB10/downloadServlet?filename=a.bmp'>a.bmp</a><br/>");
		response.getWriter().println("<a href='/WEB10/downloadServlet?filename=WEB01.zip'>WEB01.zip</a>");

2.编写DownloadServlet：
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		/**
		 *  接收参数：
		 *  设置两个头和一个流：
		 *  文件输入流和响应的输出流对接：
		 */
		// 接收参数：get乱码  new String("中文".getBytes("ISO-8859-1"),"UTF-8");
		
		String filename = request.getParameter("filename");
		System.out.println(filename);
		// 设置两个头和一个流:
		// 设置Content-Type头
		String fileType = this.getServletContext().getMimeType(filename);
		response.setContentType(fileType);
		// 设置Content-Disposition:
		response.setHeader("Content-Disposition", "attachment;filename="+filename);
		// 设置文件的输入流：
		String path = this.getServletContext().getRealPath("/download/"+filename); // 
		InputStream is = new FileInputStream(path);
		OutputStream os = response.getOutputStream();
		int len = 0;
		byte[] b = new byte[1024];
		while((len = is.read(b))!=-1){
			os.write(b, 0, len);
		}
		is.close();
	}

总结：
中文文件名下载：
中文文件在不同的浏览器中编码方式不同：
IE			：URL编码
Firefox		:Base64编码

if(agent.contains("Firefox")){
			// 火狐浏览器
			filename = base64EncodeFileName(filename);
		}else{
			// IE，其他浏览器
			filename = URLEncoder.encode(filename, "UTF-8");
		}

public static String base64EncodeFileName(String fileName) {
		BASE64Encoder base64Encoder = new BASE64Encoder();
		try {
			return "=?UTF-8?B?"
					+ new String(base64Encoder.encode(fileName
							.getBytes("UTF-8"))) + "?=";
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}
	}
案例二:网站的注册的功能的实现：
需求：
在商城的网站上完成一个注册的功能:

分析:
技术分析
【请求对象-request对象】
获得客户机信息:
* getMethod();			---获得请求方式.
* getQueryString();		---获得请求路径后的参数.
* getRemoteAddr();		---获得客户机的IP地址.
* getRequestURI();		---获得请求的路径
* getRequestURL();		---获得请求的路径
* getContextPath();		---获得工程名
获得请求头

* request.getHeader(“User-Agent”);
* request.getHeader(“Referer”);
请求参数:

用来作为域对象存取值:


步骤分析：
步骤一：设计注册页面:
步骤二：点击页面中的注册的按钮:提交到Servlet中.
步骤三：在Servlet中接收参数：
步骤四：封装实体中.
步骤五：调用业务层.处理数据.
步骤六：根据处理的结果做出响应.
代码实现：
1.创建数据库
create database web10;
use web10;
create table user(
	id int primary key auto_increment,
	username varchar(20),
	password varchar(20),
	email varchar(20),
	name varchar(20),
	sex varchar(10),
	birthday date,
	hobby varchar(50)
);
2.接收参数：
* request.getParameter(String name);
* request.getParameterValues(String name);
* request.getParamaterMap();
3.参数接收中的乱码处理.
POST乱码处理：
* <form method=”post”>的时候,这种提交才是POST提交.其他的都是get.
* POST方式提交的参数在请求体中.request对象在后台接收参数.request对象有缓存区.默认缓冲区的编码ISO-8859-1.
* 处理方式：设置request的缓冲区的编码.
    * request.setCharacterEncoding(“UTF-8”);

GET方式乱码处理:
* GET方式提交的参数会在地址栏上显示 在请求行的路径后面.浏览器就会对路径进行一次编码.将编码后内容取出来.再进行一次编码.
* 处理方式：
     * 修改服务器提交的编码.
     * 采用URLEncoder 和 URLDecoder类对中文进行编码和解码.
     * 使用String类的构造方法:
         username = new String(username.getBytes("ISO-8859-1"),"UTF-8");
		System.out.println(username);

4.数据的封装：BeanUtils.(内省技术)
总结:
转发和重定向的区别:
【重定向】
response.sendRedirect(String path); -- 完成重定向
【转发】
request.getRequestDispatcher(String path).forward(request,response);
【区别】
1.转发的地址栏不变的.重定向的地址栏发生变化的.
2.转发是一次请求一次响应,重定向是两次请求两次响应.
3.request域对象存取的值在转发中是有效的,在重定向无效的.
4.转发的路径不需要加工程名.重定向的路径需要加工程名.
使用转发和重定向对登录的功能优化:
使用request域保存一个值:在一次请求范围内有效的.
登录失败就可以保存一个错误信息到request中在动态页面中取出这个值${msg}

requet&response
今日任务
完成文件下载
商城系统注册功能.
教学导航
教学目标	掌握response设置响应头
掌握response重定向和转发的区别
掌握request接收请求参数
掌握request域的作用范围
教学方法	案例驱动法
案例一：完成登录用户对他提供文件的下载的功能.
需求：
之前的案例中已经完成的了一个登录的功能,登录失败后回到登录页面.登录成功以后,服务器提供多个文件的下载的链接,点击链接可以完成文件的下载的功能.
分析：
技术分析：
【响应对象-Response对象】
响应行：
Response设置状态码：

响应头：
Response设置响应头：
* 一个key对应一个value

* 一个key对应多个value

响应体：
Response设置响应体:

【response处理中文乱码】
字节流：
设置浏览器默认打开编码
response.setHeader("Content-Type", "text/html;charset=UTF-8");
中文转成字节数组编码
response.getOutputStream().write("王守义".getBytes("UTF-8"));

字符流:
设置response的缓冲区的编码
response.setCharacterEncoding("UTF-8");
设置浏览器默认打开的编码.
response.setHeader("Content-Type", "text/html;charset=UTF-8");

response.setContentType("text/html;charset=UTF-8");相当于上面两句
【文件下载】
一种:超链接方式.（不推荐）
    * <a href=”aa.zip”>下载</a>
    * <a href=”1.jpg”>下载</a>
二种:手动编码方式完成文件下载.
    * 设置两个头和一个流:
    * Content-Type:文件MIME的类型.
    * Content-Dispostion:
    * 文件的输入流:
步骤分析：
之前的登录案例已经存在:
登录成功跳转的页面上提供一组链接:
当点击下载的链接之后,提交到Servlet:
设置两个头和一个流:
代码实现:
1.在页面中提供一组下载的链接：
		response.getWriter().println("<h2>手动编码方式下载</h2>");
		response.getWriter().println("<a href='/WEB10/downloadServlet?filename=a.bmp'>a.bmp</a><br/>");
		response.getWriter().println("<a href='/WEB10/downloadServlet?filename=WEB01.zip'>WEB01.zip</a>");

3.编写DownloadServlet：
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		/**
		 *  接收参数：
		 *  设置两个头和一个流：
		 *  文件输入流和响应的输出流对接：
		 */
		// 接收参数：get乱码  new String("中文".getBytes("ISO-8859-1"),"UTF-8");
		
		String filename = request.getParameter("filename");
		System.out.println(filename);
		// 设置两个头和一个流:
		// 设置Content-Type头
		String fileType = this.getServletContext().getMimeType(filename);
		response.setContentType(fileType);
		// 设置Content-Disposition:
		response.setHeader("Content-Disposition", "attachment;filename="+filename);
		// 设置文件的输入流：
		String path = this.getServletContext().getRealPath("/download/"+filename); // 
		InputStream is = new FileInputStream(path);
		OutputStream os = response.getOutputStream();
		int len = 0;
		byte[] b = new byte[1024];
		while((len = is.read(b))!=-1){
			os.write(b, 0, len);
		}
		is.close();
	}

总结：
中文文件名下载：
中文文件在不同的浏览器中编码方式不同：
IE			：URL编码
Firefox		:Base64编码

if(agent.contains("Firefox")){
			// 火狐浏览器
			filename = base64EncodeFileName(filename);
		}else{
			// IE，其他浏览器
			filename = URLEncoder.encode(filename, "UTF-8");
		}

public static String base64EncodeFileName(String fileName) {
		BASE64Encoder base64Encoder = new BASE64Encoder();
		try {
			return "=?UTF-8?B?"
					+ new String(base64Encoder.encode(fileName
							.getBytes("UTF-8"))) + "?=";
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}
	}
案例二:网站的注册的功能的实现：
需求：
在商城的网站上完成一个注册的功能:

分析:
技术分析
【请求对象-request对象】
获得客户机信息:
* getMethod();			---获得请求方式.
* getQueryString();		---获得请求路径后的参数.
* getRemoteAddr();		---获得客户机的IP地址.
* getRequestURI();		---获得请求的路径
* getRequestURL();		---获得请求的路径
* getContextPath();		---获得工程名
获得请求头

* request.getHeader(“User-Agent”);
* request.getHeader(“Referer”);
请求参数:

用来作为域对象存取值:


步骤分析：
步骤一：设计注册页面:
步骤二：点击页面中的注册的按钮:提交到Servlet中.
步骤三：在Servlet中接收参数：
步骤四：封装实体中.
步骤五：调用业务层.处理数据.
步骤六：根据处理的结果做出响应.
代码实现：
1.创建数据库
create database web10;
use web10;
create table user(
	id int primary key auto_increment,
	username varchar(20),
	password varchar(20),
	email varchar(20),
	name varchar(20),
	sex varchar(10),
	birthday date,
	hobby varchar(50)
);
5.接收参数：
* request.getParameter(String name);
* request.getParameterValues(String name);
* request.getParamaterMap();
6.参数接收中的乱码处理.
POST乱码处理：
* <form method=”post”>的时候,这种提交才是POST提交.其他的都是get.
* POST方式提交的参数在请求体中.request对象在后台接收参数.request对象有缓存区.默认缓冲区的编码ISO-8859-1.
* 处理方式：设置request的缓冲区的编码.
    * request.setCharacterEncoding(“UTF-8”);

GET方式乱码处理:
* GET方式提交的参数会在地址栏上显示 在请求行的路径后面.浏览器就会对路径进行一次编码.将编码后内容取出来.再进行一次编码.
* 处理方式：
     * 修改服务器提交的编码.
     * 采用URLEncoder 和 URLDecoder类对中文进行编码和解码.
     * 使用String类的构造方法:
         username = new String(username.getBytes("ISO-8859-1"),"UTF-8");
		System.out.println(username);

7.数据的封装：BeanUtils.(内省技术)
总结:
转发和重定向的区别:
【重定向】
response.sendRedirect(String path); -- 完成重定向
【转发】
request.getRequestDispatcher(String path).forward(request,response);
【区别】
5.转发的地址栏不变的.重定向的地址栏发生变化的.
6.转发是一次请求一次响应,重定向是两次请求两次响应.
7.request域对象存取的值在转发中是有效的,在重定向无效的.
8.转发的路径不需要加工程名.重定向的路径需要加工程名.
使用转发和重定向对登录的功能优化:
使用request域保存一个值:在一次请求范围内有效的.
登录失败就可以保存一个错误信息到request中在动态页面中取出这个值${msg}

Cookie&Session
今日任务
显示用户的上次访问时间
显示商品浏览记录
购买商品将商品添加到购物车
系统登录的验证码的校验
教学导航
教学目标	了解JSP的简单的使用
掌握Cookie的使用
掌握Session的使用
教学方法	案例驱动法
记录用户的上次访问时间:
需求:
用户登录以后,记录上次访问时间.在用户下次登录的时候显示上次的登录的时间.
分析:
技术分析:
【会话技术】
一次会话:用户打开浏览器访问一个页面开始,多次访问页面,到最后关闭浏览器的过程称为是一次会话.
【为什么要使用会话】

【常见的会话技术】
Cookie
是一种客户端的技术,将数据保存到客户端浏览器的内存中.
Session
是一种服务器端技术,将数据保存到服务器端.
【JSP技术】
SUN公司提供了一套动态网页技术.Servlet/JSP.
为什么有Servlet之后,还要有JSP技术.JSP:Java Server Pages.
Servlet缺点:
    * 需要配置.
    * 显示数据,显示表单...非常麻烦.
提供了一个动态网页开发技术:JSP.
JSP = JSP自身东西 + HTML + Java代码.
【JSP的执行的原理】
JSP本身就是一个Servlet.在执行的时候翻译成一个Servlet.将Servlet编译成一个class文件.
【JSP的脚本-----嵌入Java代码】
<%!   %>		:JSP声明.  翻译成Servlet的成员的东西.在声明当中定义 类,方法,变量.  Servlet本身是单例的.定义成员属性的话容易引发线程安全问题.
<%    %>		:JSP脚本.  翻译成Servlet的service方法内部的东西. 在脚本中定义 类,变量,语句
<%=   %>		:JSP表达式. 翻译成Servlet的service方法内部的out.print()中的内容. 
步骤分析：
步骤一：在CountServlet中编写代码.
步骤二：获得从客户端带过来的所有的Cookie.
步骤三：从客户端带过来的所有的Cookie中查找指定名称的Cookie.
步骤四：判断是否是第一次访问：
如果没有查找到：就是第一次访问
显示欢迎 
如果查找到：不是第一次访问
显示上次访问时间
步骤五：记录当前的时间,回写到浏览器.
代码实现：
/**
		 * 步骤一：在CountServlet中编写代码.
			步骤二：获得从客户端带过来的所有的Cookie.
			步骤三：从客户端带过来的所有的Cookie中查找指定名称的Cookie.
			步骤四：判断是否是第一次访问：
			如果没有查找到：就是第一次访问
				显示欢迎 
			如果查找到：不是第一次访问
				显示上次访问时间
			步骤五：记录当前的时间,回写到浏览器.
		 */
		Cookie[] cookies = request.getCookies(); // Cookie
		// 调用工具查找指定名称的Cookie:
		Cookie cookie = CookieUtils.findCookie(cookies, "lastVisited");
		// 判断：
		if(cookie == null){
			// 第一次访问
			response.getWriter().println("<h1>您是第"+count+"位登录成功的用户！欢迎登陆本网站！</h1>");
		}else{
			// 不是第一次
			// 获得上次访问时间:
			long lastVisited = Long.parseLong(cookie.getValue());
			Date date = new Date(lastVisited);
			response.getWriter().println("<h1>您是第"+count+"位登录成功的用户！上次访问时间为："+date.toLocaleString()+"</h1>");
		}
		
		long time = System.currentTimeMillis();
		// 回写到浏览器：
		Cookie c = new Cookie("lastVisited",""+time);
		response.addCookie(c);
总结：
Cookie的使用的总结:
【Cookie的使用的小结】
// 获得Cookie:
Cookie[] request.getCookies();
// 向浏览器回写Cookie：
response.addCookie(Cookie cookie);

// 构造Cookie
Cookie(String name,String value);
【Cookie的分类】
会话级别Cookie：默认的.关闭浏览器Cookie就会被销毁.
持久级别Cookie：将Cookie保存到本地的硬盘上.

Cookie的API：
* String getName();
* String getValue();

* void setDomain(String str);
    * 设置Cookie有效域名. 
* void setPath(String str);
    * 设置Cookie的有效路径. setPath(“/WEB11”);
* void setMaxAge(int maxAge);
    * 设置Cookie的有效时长. setMaxAge(0); --- 删除持久的Cookie.(有效路径必须一致.)
【Cookie的注意事项】
Cookie保存的时候一个浏览器上对Cookie的个数和大小都是由限制的.
Cookie默认不能保存中文.
     * URLEncoder.encode();
     * URLDecoder.decode();
完成商品浏览记录的显示:
需求：
在浏览购物网站上的商品的时候,将浏览记录记录下来.

分析:
技术分析:
使用Cookie技术:将商品的ID保存到Cookie中回写到浏览器.下次访问的时候,带着Cookie信息.可以从Cookie中获得商品的ID.显示.
使用持久的Cookie.
步骤分析:
步骤一：设计商品列表页面：
步骤二：修改图片的链接地址：提交到Servlet:
步骤三：在Servlet中接收参数：
步骤四：查找指定名称的Cookie：
步骤五：判断是否是第一次浏览:
如果是第一次：
将id放入到Cookie回写.
如果不是第一次：
判断点击商品是否已经在浏览记录中
如果已经在浏览记录中:
删除当前的商品在浏览记录中的位置
将商品的ID添加到列表之前.
如果商品没有在浏览记录中：
判断长度超过6个
移除最后一个
将商品ID添加到第一个位置
没有超过六个
将商品ID添加到第一个位置
获得列表中的所有的ID的值存入到Cookie回写到浏览器
步骤六：在页面中获得Cookie中存的ID的值,找到对应的图片并且显示.
代码实现:
/**
 * 商品浏览记录的Servlet：
 */
public class VisitServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// 1.接收参数：
		String id = request.getParameter("id");
		// 2.查找指定名称的Cookie：
		Cookie[] cookies = request.getCookies();
		Cookie cookie = CookieUtils.findCookie(cookies, "history");
		// 3.判断是否是第一次浏览商品
		if(cookie == null){
			// 是第一次的话：
			Cookie c = new Cookie("history",id);
			c.setPath("/WEB11");
			c.setMaxAge(7*24*60*60);
			response.addCookie(c);
		}else{
			// 不是第一次   2,1
			// 从Cookie中获得原来的存的ID的值.
			String value = cookie.getValue();// 2,1 
			// 因为数组 交换数组位置的时候比较麻烦的 将数组转成LinkedList:
			// Arrays.asList(value.split(","));
			LinkedList<String> list = new LinkedList<String>(Arrays.asList(value.split(",")));
			// 判断商品是否浏览过.
			if(list.contains(id)){
				// 说明之前浏览过该商品  // 2,1   ---> 1,2
				list.remove(id);
				list.addFirst(id);
			}else{
				// 说明之前没有浏览过该商品  // 2,1  ---> 3,2,1
				if(list.size() >= 3){
					// 超过3个   3,2,1 --->  4,3,2
					list.removeLast();
					list.addFirst(id);
				}else{
					// 没有超过3个 
					list.addFirst(id);
				}
			}
			// 将List中的值 转成一个字符串.
			StringBuffer sb = new StringBuffer();
			for(String pid:list){
				sb.append(pid+",");
			}
			// 删除最后一个逗号.  4,3,2,
			String v = sb.toString().substring(0, sb.length()-1);
			Cookie c = new Cookie("history",v);
			c.setPath("/WEB11");
			c.setMaxAge(7*24*60*60);
			response.addCookie(c);
		}
		
		// 页面跳转
		request.getRequestDispatcher("/product_info.htm").forward(request, response);
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}

总结:
清空浏览记录：
public class ClearHistoryServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// 设置Cookie有效路径和有效时长 设置0;
		Cookie[] cookies = request.getCookies();
		Cookie cookie = CookieUtils.findCookie(cookies, "history");
		// Cookie cookie = new Cookie("history",null);
		cookie.setPath("/WEB11");
		cookie.setMaxAge(0);
		response.addCookie(cookie);
		// 页面跳转：
		// request.getRequestDispatcher("/productList.jsp").forward(request, response);
		response.sendRedirect("/WEB11/productList.jsp");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}
将商品添加到购物车:
需求:
在商品详情页面点击添加到购物车！将商品加入购物车！！

分析：
技术分析
【Session会话】
Cookie有大小和个数的限制的.
而且Cookie数据保存在客户端数据.

Session保存在服务器端,没有大小的限制.


步骤分析：
步骤一：点击加入购物车的链接的时候.提交到Servlet
步骤二：在Servlet中接收商品的ID.
步骤三：是否是第一次往购物车中添加商品.
* 是第一次：
* 创建一个购物车
* 将商品添加到购物车
* 不是第一次：
    * 获得购物车:
    * 判断购物车中是否已经存在该商品.
* 已经存在:
* 获得原来的数量+1
* 将商品和对应的数量存入到购物车
* 不存在:
* 将商品和商品对应的数量1存入到购物车.
步骤四：页面跳转
代码实现：
public class CartServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// 1.接收商品的ID
		String id = request.getParameter("id");
		String[] names = {"大毛衣","毛呢大衣"};
		String name = names[Integer.parseInt(id)-1];
		// 2.判断是否是第一次购物:
		// 获得session,从session中获得购物车:
		Map<String, Integer> cart = (Map<String, Integer>) request.getSession().getAttribute("cart");
		if(cart == null){
			// 第一次购物
			// 创建购物车：
			cart = new LinkedHashMap<String,Integer>();
			// 将商品和对应的数量存入到购物车.
			cart.put(name, 1);
		}else{
			// 不是第一次购物
			// 判断购物车中是否已经存在该商品.
			if(cart.containsKey(name)){
				// 购物车中已经包含该商品
				Integer count=  cart.get(name);
				count++;
				cart.put(name, count);
			}else{
				// 购物车中没有包含该商品
				cart.put(name, 1);
			}
		}
		request.getSession().setAttribute("cart", cart);
		response.setContentType("text/html;charset=UTF-8");
		response.getWriter().println("<h1><a href='/WEB11/productList.jsp'>继续购物</a> | <a href='/WEB11/cart.jsp'>去购物车结算</a></h1>");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}
总结：
【清空购物车】
public class ClearCartServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		request.getSession().removeAttribute("cart");
		
		response.sendRedirect("/WEB11/cart.jsp");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}
【Session域对象】
ServletContext		：适合共享数据.
* 生命周期：
    * 服务器启动的时候创建.
    * 服务器关闭的时候销毁.
* 作用范围：
    * 整个web应用.
HttpSession			:私有的数据.登录用户的信息.
* 生命周期：
    * 服务器端第一次调用getSession()方法时候.才会创建一个session对象.
    * session销毁三种情况:
        * session过期:默认过期时间30分钟.
        * 非正常关闭服务器:(正常关闭服务器 序列化到硬盘)
        * 调用session.invalidate();
* 作用范围：
    * 多次请求(一次会话)
HttpServletRequest	:
* 生命周期:
    * 客户端向服务器发送请求的时候,服务器创建一个请求对象.
    * 服务器对这次请求作出响应之后.请求对象就会被销毁.
* 作用范围:
    * 一次请求
一次性验证码校验
需求：
在网站登录的时候,生成一个验证码.登录的时候对验证码进行校验.

分析:
步骤分析:
步骤一：生成验证码的时候,将随机产生的4个字母或数字存入到session中。
步骤二：在页面中输入一个验证码点击登录.提交到Servlet
步骤三：在Servlet中获得页面提交的验证码和session中验证码比较
步骤四：将session中存的验证码清空
步骤五：如果不一致返回登录页面.
步骤六：如果一致,再去比较用户名和密码

JSP&EL&JSTL
今日任务
商品信息的显示
教学导航
教学目标	掌握JSP的基本的使用
掌握EL的表达式的用法
掌握JSTL的常用标签的使用
教学方法	案例驱动法
案例一：商品信息的显示的案例:
需求:
将数据库中的商品的信息,显示到页面中.尽量少使用<%%>形式.
分析：
技术分析
【JSP技术】
JSP的概述：
JSP：Java Server Pages.
为什么要有JSP:Servlet显示页面元素的时候有自身缺陷.
使用JSP:
    * JSP的脚本：
    * JSP的注释:
    * JSP的内置对象:
    * JSP的指令:
    * JSP的标签：
JSP的脚本:
一种：<%! %>	:翻译成Servlet内部的内容
二种：<%  %> :翻译成Servlet的service方法内部东西.
三种：<%= %> :翻译成out.print();
JSP的执行原理:
JSP也会被翻译成Servlet.被编译成class.
JSP的注释:
JSP支持三种注释：HTML的注释 　Java代码注释  JSP的注释:
<h3>HTML的注释</h3>
<!-- HTML的注释:可以存在JSP源码中,翻译成的Servlet中的注释也存在,在HTML的代码中也会存在. -->
<h3>Java代码的注释</h3>
<%
	// 单行注释  可以存在于JSP源码中 在翻译成Servlet的时候，Java代码的注释也是会存在的.但是生成HTML的页面之后,注释就会消失了.
	
	/*
	 多行注释
	*/
	
	/**
	* 文档注释
	*/
%>
<h3>JSP的注释</h3>
<%-- JSP的注释：只会存在于JSP的源代码中,当代表翻译成Servlet了 JSP的注释就消失了. --%>
JSP的指令:
JSP的指令:JSP中的三大指令。
语法:<%@ 指令的名称 属性名=”属性值” 属性名=”属性值”%>
* page指令:
     * language		:JSP的语言的属性.现在只能是java.
     * contentType	:设置浏览器默认的打开的时候的编码.
     * pageEncoding	:设置JSP文件保存到硬盘,以及翻译成Servlet保存到硬盘的编码格式.
     * import		:设置JSP中引入其他的类.import属性可以出现多次的.
     * extends		:设置JSP被翻译成Servlet后继承的类:默认值:org.apache.jasper.runtime.HttpJspBase. 修改这个值得话一定要使这个类是一个Servlet才可以.
     * autoFlush		:设置自动刷出缓存
     * buffer		:JSP的缓冲区的大小。默认8kb
     * session		:默认值是true.设置JSP的页面中是否可以直接使用session对象.
     * isELIgnored	:设置JSP是否忽略EL表达式.默认值false 不忽略.可以在JSP中写EL表达式.
     * isErrorPage	:设置JSP页面中出现错误信息应该如何处理的.
     * errorPage		:设置JSP页面中出现错误信息应该如何处理的.
* 设置全局错误页面:
  <error-page>
  	<error-code>404</error-code>
  	<location>/404.jsp</location>
  </error-page>
  <error-page>
  	<error-code>500</error-code>
  	<location>/500.jsp</location>
  </error-page>

* include指令:用于引入其他的页面
    * file属性:属性中不能使用变量,不能传递参数
      <%@ include file="logo.jsp" %>
      <%@ include file="menu.jsp" %>

      <h1>Body</h1>

      <%@ include file="footer.jsp" %>

* taglib指令：用于在JSP中引入标签库
  <%@ taglib uri="" prefix="" %>
JSP的内置对象:(*****)
内置对象：JSP中可以直接使用的对象.
JSP的内置对象有哪些？常用的方法？真实对象是谁？
JSP中有9个内置对象:
* request						HttpServletRequest						getParameter(),setAttribute(),getAttribute();
* response						HttpServletResponse						setStatus(),sendRedirect(),getOutputStream();
* session						HttpSession								setAttribute(),getAttribute(),removeAttribute();
* application					ServletContext							setAttribute(),getAttribute(),removeAttribute();
* page							Object									toString(),wait(),
    * JSP翻译成Servlet的引用.
* pageContext					PageContext								setAttribute(),getAttribute(),removeAttribute();
* out							JspWriter								write(),print(),
* config						ServletConfig							getInitParamter(),getInitParameterNames(),
* exception						Throwable								getMessage(),getCause()

* out对象：先将自身缓存区中的内容输出到response的缓冲区中，由response向页面作出响应.
     * out					:JspWriter
     * response.getWriter() :PrintWriter
* pageContext：
     * 一类：用pageContext对象获得其他的8个内置对象. 用来编写一个通用性高的或者框架的时候.
     * 二类：用来存取数据.向四个域中存取数据.
JSP的四个域对象：
* pageContext			pageScope				页面范围			
* request				requestScope			请求范围
* session				sessionScope			会话范围
* application			applicationScope		应用范围
JSP的动作标签：
语法：<jsp:动作标签 属性=””/>
为什么使用标签：简化代码的编写,尽量要少在JSP中使用<%%>
<jsp:forward />
    * 转发：<jsp:forward page="/demo1/demo5.jsp"></jsp:forward>
<jsp:include />
    * 包含：<jsp:include page="/demo1/include2/logo.jsp"></jsp:include>
    ***** 静态包含 和 动态包含的区别?
    * 静态包含相对于代码的copy,最终被翻译成一个Servlet解释执行的.动态包含,包含其他页面的运行的结果.最终翻译成多个Servlet解释执行的.
<jsp:param />
    * 传递参数.
<jsp:useBean />
<jsp:setProperty />
<jsp:getProperty />
【EL表达式】
EL:
EL:Expression Language.表达式语言.
语法:${ EL表达式 }

JSP中尽量少使用<%%>代码块.使用EL和JSTL替换页面中<%%>
使用EL表达式:
用途:
1.获取数据.
2.EL执行运算
3.获得常用WEB开发的对象.
4.调用Java中的函数.
EL用来获取数据：（获取是四个域范围中的值）
* 获得普通的值：
* 获得数组的数据：
* 获得List集合的数据：
* 获得Map集合的数据：

[]和. 有什么区别?
[]获得带有下标的（数组,List） .获得一个对象的属性,如果属性名中包含了特殊字符.必须使用[]不能使用. 
<h1>EL获取数据</h1>
<%
	pageContext.setAttribute("pname", "王守义");
	request.setAttribute("rname", "王凤儿");
	session.setAttribute("sname", "王如花");
	application.setAttribute("aname", "王芙蓉");
%>
<h3>传统方式</h3>
<%= pageContext.getAttribute("pname")%>
<%= request.getAttribute("rname")%>
<%= session.getAttribute("sname")%>
<%= application.getAttribute("aname")%>
<h3>EL的方式</h3>
${ pageScope.pname }   
${ requestScope.rname }
${ sessionScope.sname }
${ applicationScope.aname }
<hr/>
<%
	//pageContext.setAttribute("name", "王守义");
	//request.setAttribute("name", "王凤儿");
	session.setAttribute("name", "王如花");
	application.setAttribute("name", "王芙蓉");
%>
${ name }
<h3>EL获得数组的数据</h3>
<%
	String[] arrs = {"王守义","王如花","王凤儿"};
	pageContext.setAttribute("arrs", arrs);
%>
${ arrs[1] }
<h3>EL获得List集合的数据</h3>
<%
	List<String> list = new ArrayList<String>();
	list.add("aaa");
	list.add("bbb");
	list.add("ccc");
	pageContext.setAttribute("list", list);
%>
${ list[1] }
<h3>获得Map集合的数据</h3>
<%
	Map<String,String> map = new HashMap<String,String>();
	map.put("aaa", "111");
	map.put("bbb", "222");
	map.put("ccc.ddd", "333");
	pageContext.setAttribute("map", map);
%>
${ map["ccc.ddd"] }
<h3>EL获得JavaBean中的数据</h3>
<%
	Person person = new Person();
	person.setId(1);
	person.setName("王美丽");
	pageContext.setAttribute("person", person);
%>
${ person.name }
EL执行运算:

执行算数运算：
+ - * / %
执行逻辑运算:
> < >= <= != ==
执行关系运算：
&& || !

<h1>EL执行运算</h1>
<h3>EL执行算数运算</h3>
<%
	pageContext.setAttribute("n1", "10");
	pageContext.setAttribute("n2", "20");
	pageContext.setAttribute("n3", "40");
	pageContext.setAttribute("n4", "60");
%>

${ n1+n2+n3 }
<h3>EL执行逻辑运算</h3>
${ n1 < n2 }
${ n1 > n2 }

<h3>EL执行关系运算</h3>
${ n1<n2 && n3<n4 }
${ n1<n2 || n3<n4 }
<%
	Person person = new Person();
	pageContext.setAttribute("person", person);
%>
${ empty person }
${ not empty person }
EL获得WEB开发的常用的对象：（EL的内置对象）
EL常用的对象：11个.
${pageScope}
${requestScope}
${sessionScope}
${applicationScope}
${ param }			:相当于request.getParameter();
${ paramValues }	:相当于request.getParameterValues();
${ header }			:获得请求头 一个key对应一个value
${ headerValues }	:获得请求头 一个key对应多个value 
${ initParam }		:获得初始化参数
${ cookie }			:获得Cookie的信息
${pageContext}		:相当于pageContext对象.

【JSTL标签库】
JSTL的标签库概述：
JSTL（JSP Standard Tag Library，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，是由apache的jakarta小组来维护的。JSTL只能运行在支持JSP1.2和Servlet2.3规范的容器上，如tomcat 4.x。在JSP 2.0中也是作为标准支持的。

作用：结合EL替换页面中的<% %>
使用JSTL的标签库:
JSTL的五大标签库:core、fmt、xml、sql、fn
JSTL的版本:JSTL1.0  JSTL1.1  JSTL1.2
* JSTL1.0是EL还没有被纳入规范的时候使用标签.
* JSTL1.1和1.2的版本中 EL已经被纳入到规范中.JSTL可以支持EL表达式了.
步骤一：引入标签库.
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

常用的标签:
c:set
c:if
c:forEach
c:choose
    * c:when
    * c:otherwise
JSTL的函数库(EL的函数库)
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>

${ fn:length("HelloWorld") }

${ fn:toLowerCase("ABCDEFG") }
${ fn:toUpperCase("abcdefg") }

${ fn:contains("www.baidu.com","baidu") }
步骤分析:
步骤一：准备工作:
创建一个商品表：
创建一个动态的web工程
引入相关的jar包和工具类:
* mysql,c3p0,dbutils,jstl
创建包结构:
* com.itheima
    * servlet
    * service
    * dao
    * domain
    * utils
步骤二：访问一个Servlet--->Service--->DAO
Servlet调用业务层,业务层调用DAO进行查询.
步骤三：查询到以后显示到JSP的页面中.
使用JSTL和EL表达式将数据显示到页面.
代码实现:
创建数据库和表:
create database day12;
use day12;
create table product(
	id int primary key auto_increment,
	pname varchar(20),
	price double,
	pdesc varchar(20)
);

insert into product values (null,'电视机',3200,'液晶曲面大电视');
insert into product values (null,'韭菜盒子',3,'味重请小心食用');
insert into product values (null,'益达',10,'韭菜伴侣');
insert into product values (null,'十三香',12,'守义牌');

实体bean
private int id;
private String pname;
private double price;
private String pdesc;
JSP模式&JDBC高级
今日任务
使用MVC设计模式开发一个转账案例
教学导航
教学目标	掌握JSP的设计模式
了解MYSQL的事务管理
掌握JDBC的事务管理
会使用DBUtils完成事务的管理
教学方法	案例驱动法
案例一：使用MVC设计模式完成转账的案例:
需求:
在页面中输入几个信息：收款人,付款人,转账金额.点击提交按钮可以完成转账的功能.在转账的过程中进行事务的管理.
分析：
技术分析：
【JSP的模式】

Model1:JSP+JavaBean  比较适合开发一些小应用.
Model2:JSP+Servlet+JavaBean 可以开发任何一个应用. MVC设计模式：
【MVC设计模式】

MVC是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。
【EE开发中的三层结构】
JavaEE开发中通常将一个应用分成：WEB层，业务层，持久层

【JavaBean】
JavaBean：JavaBean就是一个满足的特定格式要求的Java类.
* 有一个无参数的构造:
* 属性私有
* 私有属性提供public的get或set方法.

属于Model1年代的标签.数据提交到JSP中.
<jsp:useBean>
<jsp:setProperty>
<jsp:getProperty>

<jsp:useBean id="u" class="com.itheima.domain.User" scope="page"></jsp:useBean>
<jsp:setProperty property="*" name="u"/>

<jsp:getProperty property="username" name="u"/>
<jsp:getProperty property="password" name="u"/>

【事务管理-JDBC】
事务的概述:
什么是事务:事务指的是逻辑上的一组操作,组成这组操作的各个单元要么全都成功,要么全都失败.
事务作用：保证在一个事务中多次操作要么全都成功,要么全都失败.
MYSQL中的事务管理：
创建一个表：账户表.
create database web13;
use web13;
create table account(
	id int primary key auto_increment,
	name varchar(20),
	money double
);

insert into account values (null,'守义',10000);
insert into account values (null,'凤儿',10000);
insert into account values (null,'如花',10000);

进行事务的管理：
MYSQL中可以有两种方式进行事务的管理：MYSQL数据库默认事务是自动提交的.写一条SQL语句,事务就已经提交了.Oracle数据库事务不自动提交.手动执行commit;
一种：手动开启事务的方式：
 * start transaction;
 * update account set money=money-1000 where name='守义';
 * update account set money=money+1000 where name='凤儿';
 * commit;或者rollback;

二种：设置MYSQL中的自动提交的参数：
show variables like '%commit%';

* 设置自动提交的参数为OFF:
set autocommit = 0;  -- 0:OFF  1:ON
【JDBC进行事务管理】
Connection：
* 事务管理的API：
    
    
    
步骤分析：
步骤一：设计页面三个文本框.
步骤二：提交到Servlet
接收参数：
封装参数：
调用业务层处理数据
页面跳转
代码实现：
设计转账的页面：
<h1>转账的页面</h1>
	<form action="" method="post">
		<table border="1" width="400">
			<tr>
				<td>付款人:</td>
				<td><input type="text" name="from"/></td>
			</tr>
			<tr>
				<td>收款人:</td>
				<td><input type="text" name="to"/></td>
			</tr>
			<tr>
				<td>转账金额:</td>
				<td><input type="text" name="money"/></td>
			</tr>
			<tr>
				<td colspan="2"><input type="submit" value="转账"/></td>
			</tr>
		</table>
	</form>

Servlet：
/**
 * 转账的Servlet
 */
public class AccountServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		/**
		 * 1.接收数据:
		 * 2.封装数据:
		 * 3.调用业务层:
		 * 4.页面跳转作出响应:
		 */
		request.setCharacterEncoding("UTF-8");
		// 接收数据：
		String from = request.getParameter("from");
		String to = request.getParameter("to");
		double money = Double.parseDouble(request.getParameter("money"));
		// 调用业务层:
		AccountService accountService = new AccountService();
		accountService.transfer(from,to,money);
		
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}


}

Service：
public class AccountService {

	/**
	 * 业务层转账的方法：
	 * @param from	:付款人
	 * @param to	:收款人
	 * @param money	:转账金额
	 */
	public void transfer(String from, String to, double money) {
		// 调用DAO：
		AccountDao accountDao = new AccountDao();
		try {
			accountDao.outMoney(from, money);
			// int d = 1/0;
			accountDao.inMoney(to, money);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
	}
	
}

DAO：
public class AccountDao {

	/**
	 * 付款的方法
	 * @param name
	 * @param money
	 * @throws SQLException 
	 */
	public void outMoney(String name,double money) throws SQLException{
		Connection conn = null;
		PreparedStatement pstmt = null;
		try{
			// 获得连接:
			conn = JDBCUtils.getConnection();
			// 编写一个SQL:
			String sql = "update account set money = money-? where name=?";
			// 预编译SQL:
			pstmt = conn.prepareStatement(sql);
			// 设置参数:
			pstmt.setDouble(1, money);
			pstmt.setString(2, name);
			// 执行SQL：
			pstmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			pstmt.close();
			conn.close();
		}
	}
	
	/**
	 * 收款的方法
	 * @param name
	 * @param money
	 * @throws SQLException 
	 */
	public void inMoney(String name,double money) throws SQLException{
		Connection conn = null;
		PreparedStatement pstmt = null;
		try{
			// 获得连接:
			conn = JDBCUtils.getConnection();
			// 编写一个SQL:
			String sql = "update account set money = money+? where name=?";
			// 预编译SQL:
			pstmt = conn.prepareStatement(sql);
			// 设置参数:
			pstmt.setDouble(1, money);
			pstmt.setString(2, name);
			// 执行SQL：
			pstmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			pstmt.close();
			conn.close();
		}		
	}
}

通过两种Service编写完成事务的管理:
* 一种向下传递Connection：
* 二种将Connection绑定到当前的线程中：
总结：
事务的特性：
事务有四大特性:
* 原子性：强调事务的不可分割.
* 一致性：事务的执行的前后,数据的完整性保持一致.
* 隔离性：一个事务在执行的过程中,不应该受到其他事务的干扰.
* 持久性：事务一旦结束,数据就持久到数据库中.
如果不考虑事务的隔离性,引发一些安全性问题:
     读问题：三类
    * 脏读		：一个事务读到了另一个事务未提交的数据.
    * 不可重复读	：一个事务读到了另一个事务已经提交(update)的数据.引发一个事务中的多次查询结果不一致.
    * 虚读/幻读	：一个事务读到了另一个事务已经提交的（insert）数据.导致多次查询的结果不一致
解决读问题：
设置事务的隔离级别:
* read uncommitted	:脏读，不可重复读，虚读都可能发生.
* read committed	:避免脏读,但是不可重复读和虚读有可能发生.
* repeatable read	:避免脏读和不可重复读,但是虚读有可能发生的.
* serializable		:避免脏读,不可重复读和虚读.(串行化的-不可能出现事务并发访问)

安全性:serializable > repeatable read > read committed > read uncommitted
效率 :serializable< repeatable read < read committed < read uncommitted
MYSQL	:repeatable read
Oracle	:read committed
演示脏读的发生
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为read uncommitted
* set session transaction isolation level read uncommitted;
步骤四：在两个窗口中分别开启事务：
* start transaction;
步骤五：在B窗口中转账操作：
* update account set money = money - 1000 where name='守义';
* update account set money = money + 1000 where name='凤儿';
**** 在B窗口中没有提交事务的！！！
步骤六：在A窗口中进行查询：
* 已经转账成功!!!(脏读:一个事务中读到了另一个事务未提交的数据)
演示避免脏读，不可重复读发生
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为read committed;
* set session transaction isolation level read committed;
步骤四：在两个窗口中分别开启事务：
* start transaction;
步骤五：在B窗口中完成转账的操作：
* update account set money = money - 1000 where name='守义';
* update account set money = money + 1000 where name='凤儿';
**** 在B窗口中没有提交事务！！！
步骤六：在A窗口中进行查询：
* 没有转账的结果！！！（已经避免了脏读）
步骤七：在B窗口中提交事务！！！
* commit;
步骤八：在A窗口中进行查询：
* 转账成功！！！（不可重复读：一个事务读到了另一个事务已经提交的update的数据，导致一次事务中多次查询结果不一致.）
演示避免不可重复读：
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为repeatable read;
* set session transaction isolation level repeatable read;
步骤四：在两个窗口中分别开始事务：
* start transaction;
步骤五：在B窗口中完成转账的操作：
* update account set money = money - 1000 where name='守义';
* update account set money = money + 1000 where name='凤儿';
***** 在B窗口没有提交事务！！！
步骤六：在A窗口中进行查询：
* 没有转账成功！！！（已经避免脏读）
步骤七：在B窗口提交事务！！！
* commit;
步骤八：在A窗口进行查询：
* 转账没有成功！！（避免不可重复读）
步骤九：在A窗口中结束事务,再重新查询.
演示隔离级别为serializable
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为serializable;
* set session transaction isolation level serializable;
步骤四：在两个窗口中分别开启事务：
* start transaction;
步骤五：在B窗口中完成一个insert操作:
* insert into account values (null,'芙蓉',10000);
***** 事务没有提交！！
步骤六：在A窗口中进行查找：
* 没有任何结果！！！（不可以事务并发执行的）
步骤七：在B窗口中结束事务！
JDBC的隔离级别的设置：（了解）
Connection中的方法：

Connection中提供了隔离级别的常量：

使用DBUtils的进行事务的管理：
QueryRunner：
    * 构造：
    QueryRunner();
    QueryRunner(DataSource ds);

    * 方法：
    T query(String sql,ResultSetHanlder<T> rsh,Object... params);
    T query(Connection conn,String sql,ResultSetHanlder<T> rsh,Object... params);
    int update(String sql,Object... params);
    int update(Connection conn,String sql,Object... params);

方法分类：
    * 没有事务：
    QueryRunner(DataSource ds);
    T query(String sql,ResultSetHanlder<T> rsh,Object... params);
    int update(String sql,Object... params);

    * 有事务：
    QueryRunner();
    T query(Connection conn,String sql,ResultSetHanlder<T> rsh,Object... params);
    int update(Connection conn,String sql,Object... params);


JSP模式&JDBC高级
今日任务
使用MVC设计模式开发一个转账案例
教学导航
教学目标	掌握JSP的设计模式
了解MYSQL的事务管理
掌握JDBC的事务管理
会使用DBUtils完成事务的管理
教学方法	案例驱动法
案例一：使用MVC设计模式完成转账的案例:
需求:
在页面中输入几个信息：收款人,付款人,转账金额.点击提交按钮可以完成转账的功能.在转账的过程中进行事务的管理.
分析：
技术分析：
【JSP的模式】

Model1:JSP+JavaBean  比较适合开发一些小应用.
Model2:JSP+Servlet+JavaBean 可以开发任何一个应用. MVC设计模式：
【MVC设计模式】

MVC是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。
【EE开发中的三层结构】
JavaEE开发中通常将一个应用分成：WEB层，业务层，持久层

【JavaBean】
JavaBean：JavaBean就是一个满足的特定格式要求的Java类.
* 有一个无参数的构造:
* 属性私有
* 私有属性提供public的get或set方法.

属于Model1年代的标签.数据提交到JSP中.
<jsp:useBean>
<jsp:setProperty>
<jsp:getProperty>

<jsp:useBean id="u" class="com.itheima.domain.User" scope="page"></jsp:useBean>
<jsp:setProperty property="*" name="u"/>

<jsp:getProperty property="username" name="u"/>
<jsp:getProperty property="password" name="u"/>

【事务管理-JDBC】
事务的概述:
什么是事务:事务指的是逻辑上的一组操作,组成这组操作的各个单元要么全都成功,要么全都失败.
事务作用：保证在一个事务中多次操作要么全都成功,要么全都失败.
MYSQL中的事务管理：
创建一个表：账户表.
create database web13;
use web13;
create table account(
	id int primary key auto_increment,
	name varchar(20),
	money double
);

insert into account values (null,'守义',10000);
insert into account values (null,'凤儿',10000);
insert into account values (null,'如花',10000);

进行事务的管理：
MYSQL中可以有两种方式进行事务的管理：MYSQL数据库默认事务是自动提交的.写一条SQL语句,事务就已经提交了.Oracle数据库事务不自动提交.手动执行commit;
一种：手动开启事务的方式：
 * start transaction;
 * update account set money=money-1000 where name='守义';
 * update account set money=money+1000 where name='凤儿';
 * commit;或者rollback;

二种：设置MYSQL中的自动提交的参数：
show variables like '%commit%';

* 设置自动提交的参数为OFF:
set autocommit = 0;  -- 0:OFF  1:ON
【JDBC进行事务管理】
Connection：
* 事务管理的API：
    
    
    
步骤分析：
步骤一：设计页面三个文本框.
步骤二：提交到Servlet
接收参数：
封装参数：
调用业务层处理数据
页面跳转
代码实现：
设计转账的页面：
<h1>转账的页面</h1>
	<form action="" method="post">
		<table border="1" width="400">
			<tr>
				<td>付款人:</td>
				<td><input type="text" name="from"/></td>
			</tr>
			<tr>
				<td>收款人:</td>
				<td><input type="text" name="to"/></td>
			</tr>
			<tr>
				<td>转账金额:</td>
				<td><input type="text" name="money"/></td>
			</tr>
			<tr>
				<td colspan="2"><input type="submit" value="转账"/></td>
			</tr>
		</table>
	</form>

Servlet：
/**
 * 转账的Servlet
 */
public class AccountServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		/**
		 * 1.接收数据:
		 * 2.封装数据:
		 * 3.调用业务层:
		 * 4.页面跳转作出响应:
		 */
		request.setCharacterEncoding("UTF-8");
		// 接收数据：
		String from = request.getParameter("from");
		String to = request.getParameter("to");
		double money = Double.parseDouble(request.getParameter("money"));
		// 调用业务层:
		AccountService accountService = new AccountService();
		accountService.transfer(from,to,money);
		
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}


}

Service：
public class AccountService {

	/**
	 * 业务层转账的方法：
	 * @param from	:付款人
	 * @param to	:收款人
	 * @param money	:转账金额
	 */
	public void transfer(String from, String to, double money) {
		// 调用DAO：
		AccountDao accountDao = new AccountDao();
		try {
			accountDao.outMoney(from, money);
			// int d = 1/0;
			accountDao.inMoney(to, money);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
	}
	
}

DAO：
public class AccountDao {

	/**
	 * 付款的方法
	 * @param name
	 * @param money
	 * @throws SQLException 
	 */
	public void outMoney(String name,double money) throws SQLException{
		Connection conn = null;
		PreparedStatement pstmt = null;
		try{
			// 获得连接:
			conn = JDBCUtils.getConnection();
			// 编写一个SQL:
			String sql = "update account set money = money-? where name=?";
			// 预编译SQL:
			pstmt = conn.prepareStatement(sql);
			// 设置参数:
			pstmt.setDouble(1, money);
			pstmt.setString(2, name);
			// 执行SQL：
			pstmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			pstmt.close();
			conn.close();
		}
	}
	
	/**
	 * 收款的方法
	 * @param name
	 * @param money
	 * @throws SQLException 
	 */
	public void inMoney(String name,double money) throws SQLException{
		Connection conn = null;
		PreparedStatement pstmt = null;
		try{
			// 获得连接:
			conn = JDBCUtils.getConnection();
			// 编写一个SQL:
			String sql = "update account set money = money+? where name=?";
			// 预编译SQL:
			pstmt = conn.prepareStatement(sql);
			// 设置参数:
			pstmt.setDouble(1, money);
			pstmt.setString(2, name);
			// 执行SQL：
			pstmt.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			pstmt.close();
			conn.close();
		}		
	}
}

通过两种Service编写完成事务的管理:
* 一种向下传递Connection：
* 二种将Connection绑定到当前的线程中：
总结：
事务的特性：
事务有四大特性:
* 原子性：强调事务的不可分割.
* 一致性：事务的执行的前后,数据的完整性保持一致.
* 隔离性：一个事务在执行的过程中,不应该受到其他事务的干扰.
* 持久性：事务一旦结束,数据就持久到数据库中.
如果不考虑事务的隔离性,引发一些安全性问题:
     读问题：三类
    * 脏读		：一个事务读到了另一个事务未提交的数据.
    * 不可重复读	：一个事务读到了另一个事务已经提交(update)的数据.引发一个事务中的多次查询结果不一致.
    * 虚读/幻读	：一个事务读到了另一个事务已经提交的（insert）数据.导致多次查询的结果不一致
解决读问题：
设置事务的隔离级别:
* read uncommitted	:脏读，不可重复读，虚读都可能发生.
* read committed	:避免脏读,但是不可重复读和虚读有可能发生.
* repeatable read	:避免脏读和不可重复读,但是虚读有可能发生的.
* serializable		:避免脏读,不可重复读和虚读.(串行化的-不可能出现事务并发访问)

安全性:serializable > repeatable read > read committed > read uncommitted
效率 :serializable< repeatable read < read committed < read uncommitted
MYSQL	:repeatable read
Oracle	:read committed
演示脏读的发生
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为read uncommitted
* set session transaction isolation level read uncommitted;
步骤四：在两个窗口中分别开启事务：
* start transaction;
步骤五：在B窗口中转账操作：
* update account set money = money - 1000 where name='守义';
* update account set money = money + 1000 where name='凤儿';
**** 在B窗口中没有提交事务的！！！
步骤六：在A窗口中进行查询：
* 已经转账成功!!!(脏读:一个事务中读到了另一个事务未提交的数据)
演示避免脏读，不可重复读发生
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为read committed;
* set session transaction isolation level read committed;
步骤四：在两个窗口中分别开启事务：
* start transaction;
步骤五：在B窗口中完成转账的操作：
* update account set money = money - 1000 where name='守义';
* update account set money = money + 1000 where name='凤儿';
**** 在B窗口中没有提交事务！！！
步骤六：在A窗口中进行查询：
* 没有转账的结果！！！（已经避免了脏读）
步骤七：在B窗口中提交事务！！！
* commit;
步骤八：在A窗口中进行查询：
* 转账成功！！！（不可重复读：一个事务读到了另一个事务已经提交的update的数据，导致一次事务中多次查询结果不一致.）
演示避免不可重复读：
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为repeatable read;
* set session transaction isolation level repeatable read;
步骤四：在两个窗口中分别开始事务：
* start transaction;
步骤五：在B窗口中完成转账的操作：
* update account set money = money - 1000 where name='守义';
* update account set money = money + 1000 where name='凤儿';
***** 在B窗口没有提交事务！！！
步骤六：在A窗口中进行查询：
* 没有转账成功！！！（已经避免脏读）
步骤七：在B窗口提交事务！！！
* commit;
步骤八：在A窗口进行查询：
* 转账没有成功！！（避免不可重复读）
步骤九：在A窗口中结束事务,再重新查询.
演示隔离级别为serializable
步骤一：分别开启两个窗口A,B:
步骤二：分别查询两个窗口的隔离级别：
* select @@tx_isolation
步骤三：设置A窗口的隔离级别为serializable;
* set session transaction isolation level serializable;
步骤四：在两个窗口中分别开启事务：
* start transaction;
步骤五：在B窗口中完成一个insert操作:
* insert into account values (null,'芙蓉',10000);
***** 事务没有提交！！
步骤六：在A窗口中进行查找：
* 没有任何结果！！！（不可以事务并发执行的）
步骤七：在B窗口中结束事务！
JDBC的隔离级别的设置：（了解）
Connection中的方法：

Connection中提供了隔离级别的常量：

使用DBUtils的进行事务的管理：
QueryRunner：
    * 构造：
    QueryRunner();
    QueryRunner(DataSource ds);

    * 方法：
    T query(String sql,ResultSetHanlder<T> rsh,Object... params);
    T query(Connection conn,String sql,ResultSetHanlder<T> rsh,Object... params);
    int update(String sql,Object... params);
    int update(Connection conn,String sql,Object... params);

方法分类：
    * 没有事务：
    QueryRunner(DataSource ds);
    T query(String sql,ResultSetHanlder<T> rsh,Object... params);
    int update(String sql,Object... params);

    * 有事务：
    QueryRunner();
    T query(Connection conn,String sql,ResultSetHanlder<T> rsh,Object... params);
    int update(Connection conn,String sql,Object... params);


JDBC案例
今日任务
使用JDBC技术完成对商品的添加修改查询及分页的操作
教学导航
教学目标	掌握JDBC的CRUD的操作
掌握JDBC的分页操作
教学方法	案例驱动法

案例一：完成对商品的查询
需求:

分析:
步骤分析：
首页的页面在页面中提供一个链接：查询商品.
点击查询商品提交到ProductListServlet
调用业务层处理数据
页面跳转
跳转到productList.jsp
代码实现：
准备工作
1.创建项目
2.引入jar包
3.创建包结构
4.创建数据库和表.
create database web14;
use web14;
create table `product` (
	`pid` varchar (96),
	`pname` varchar (150),
	`market_price` double ,
	`shop_price` double ,
	`pimage` varchar (600),
	`pdate` date ,
	`pdesc` varchar (765)
); 
INSERT INTO `product` VALUES('1','小米 4c 标准版','1399','1299','products/1/c_0001.jpg','2015-11-02','小米 4c 标准版 全网通 白色 移动联通电信4G手机 双卡双待');
INSERT INTO `product` VALUES('10','华为 Ascend Mate7','2699','2599','products/1/c_0010.jpg','2015-11-02','华为 Ascend Mate7 月光银 移动4G手机 双卡双待双通6英寸高清大屏，纤薄机身，智能超八核，按压式指纹识别！!选择下方“移动老用户4G飞享合约”，无需换号，还有话费每月返还！');
INSERT INTO `product`  VALUES('11','vivo X5Pro','2399','2298','products/1/c_0014.jpg','2015-11-02','移动联通双4G手机 3G运存版 极光白【购机送蓝牙耳机+蓝牙自拍杆】新升级3G运行内存·双2.5D弧面玻璃·眼球识别技术');
INSERT INTO `product`  VALUES('12','努比亚（nubia）My 布拉格','1899','1799','products/1/c_0013.jpg','2015-11-02','努比亚（nubia）My 布拉格 银白 移动联通4G手机 双卡双待【嗨11，下单立减100】金属机身，快速充电！布拉格相机全新体验！');
INSERT INTO `product`  VALUES('13','华为 麦芒4','2599','2499','products/1/c_0012.jpg','2015-11-02','华为 麦芒4 晨曦金 全网通版4G手机 双卡双待金属机身 2.5D弧面屏 指纹解锁 光学防抖');
INSERT INTO `product`  VALUES('14','vivo X5M','1899','1799','products/1/c_0011.jpg','2015-11-02','vivo X5M 移动4G手机 双卡双待 香槟金【购机送蓝牙耳机+蓝牙自拍杆】5.0英寸大屏显示·八核双卡双待·Hi-Fi移动KTV');
INSERT INTO `product`  VALUES('15','Apple iPhone 6 (A1586)','4399','4288','products/1/c_0015.jpg','2015-11-02','Apple iPhone 6 (A1586) 16GB 金色 移动联通电信4G手机长期省才是真的省！点击购机送费版，月月送话费，月月享优惠，畅享4G网络，就在联通4G！');

代码实现：
首页----》ProductListServlet----》ProductService----》ProductDAO
           * 调用业务层
           * 页面跳转
案例二：添加商品
需求：
在首页点击添加链接 跳转到一个添加的页面 在添加页面中输入 商品的信息 点击添加 提交到Servlet 页面跳转回列表显示页面.
分析：
步骤分析
点击链接跳转到添加页面
设计一个添加页面
点击确定按钮----提交到AddProductServlet
在Servlet中接收数据，调用业务层，页面跳转
代码实现：

总结：
重复提交：
重复提交：
   * 添加完商品后 转发 到列表的Servlet：
   * 网速比较慢，点击提交的时候点击多次:

令牌机制：
   * 保证提交只能执行一次，令牌一次有效.
   * 生成一个令牌:
   * 放入session中一份.
   * 放入到页面中,隐藏字段.
   * 提交到Servlet以后从session中获得一个，从表单中也获得一个.
      * 让session的令牌失效.
   * 比较这两个值是否一致.
修改商品新
需求：
在列表页面上点击编辑 跳转到编辑页面（商品信息）点击确定 
分析：
步骤分析
在列表页面中编写一个编辑的链接 指向的路径Servlet
在Servlet中查询商品信息,并且显示到页面。
在页面中输入信息点击确定
提交到Servlet修改到数据库
页面跳转回列表页面
代码实现：

总结：
表单元素数据回显
修改的时候要先查询，再进行修改.
关于数据的回显：
* 单选按钮：
* 下拉列表：
    * <c:if test=”${p.sex==’男’}”>checked</c:if>
    * <input type=”radio” name=”sex” value=”男” <c:if test=”${p.sex==’男’}”>checked</c:if> />男<input type=”radio” name=”sex” value=”女” <c:if test=”${p.sex==’女’}”>checked</c:if>/>女

* 复选框:   篮球,足球,羽毛球
<c:if test=”${fn:contains(p.hobby,’篮球’)}”>checked</c:if>
<input type=”checkbox” name=”hobby” value=”篮球” <c:if test=”${fn:contains(p.hobby,’篮球’)}”>checked</c:if>>篮球
<input type=”checkbox” name=”hobby” value=”足球” <c:if test=”${fn:contains(p.hobby,’足球’)}”>checked</c:if>>足球
<input type=”checkbox” name=”hobby” value=”羽毛球” <c:if test=”${fn:contains(p.hobby,’羽毛球’)}”>checked</c:if>>羽毛球
<input type=”checkbox” name=”hobby” value=”排球” <c:if test=”${fn:contains(p.hobby,’排球’)}”>checked</c:if>>排球
删除商品信息：
需求：
在列表页面中 点击删除的链接 将这个商品的信息进行删除.
需求：
步骤分析：
在列表页面中添加一个删除的链接的路径 指向一个Servlet:
在Servlet中
接收数据
调用业务层
页面跳转
分页商品显示：
需求：
在首页上显示商品 由于商品过多导致页面中显示的数据特别多 而且导致页面特别长.需要进行分页显示商品.
分析：
技术分析
分页的操作分成两类：
    * 查询的时候一次只查3条.点击下一页，再去查询后3条.
        * 与数据库的交互次数多.
        * 数据量特别的大，也不会影响效率.

    * 一次性把所有数据都查询出来,封装到List集合中.List集合中有一个方法.subList(0,3);
        * 与数据库的交互的次数少.
        * 数据量特别的大，影响效率.

使用第一种分页显示数据：
    * 使用SQL语句控制分页：
         * MYSQL		:使用limit关键字.
             * 语法：select * from 表 limit a,b;
                 * a:从哪开始. 默认0
                 * b:查询几条记录.
             * 每页显示3条记录第一页:select * from product limit 0,3; -- select * from product limit 3;
             * 每页显示3条记录第二页:select * from product limit 3,3;
                 * begin = (currPage - 1) * pageSize;

         * SQLServer	:使用top关键字.
         * Oracle		:使用SQL嵌套

【首页】 【上一页】【下一页】【尾页】  
分页需要的数据：
JSP---Servlet：
    当前页数（currPage）

Servlet---JSP：
    总页数（totalPage）
    总记录（totalCount）：select count(*) from product;
         * 计算总页数:
    每页显示的记录数（pageSize）
    数据的集合List：select * from product limit 0,3;
步骤分析：
在首页上添加一个链接：显示分页的数据.
提交到Servlet：
接收数据：当前页数:1
调用业务层：
ProductService ps = new ProductService();
PageBean pageBean = ps.findByPage(currPage);
request.setAttribute(“pageBean”,pageBean);
class PageBean{
    Private List<Product> list;
    Private int currPage;
    Private int pageSize;
    Private int totalCount;
    Private int totalPage;
}
页面跳转
代码实现：

AJAX和JQuery
今日任务
使用AJAX完成用户名的异步校验
使用JQuery完成用户名异步校验
使用JQuery完成商品信息模糊显示
使用JQuery完成省市联动效果返回JSON
教学导航
教学目标	了解AJAX的基本使用
掌握JQuery的AJAX部分的代码
掌握JQuery返回JSON格式数据如何处理
教学方法	案例驱动法
使用AJAX完成用户名异步校验:
需求:


在注册页面中,当输入了用户名之后,光标离开文本框,显示用户名是否已经存在.
***** 用户名是否已经存在,需要到后台的数据库进行查询的.
分析：
技术分析：
【AJAX的概述】
AJAX的概念:


AJAX使用的是老的技术,新的思想.完成了RIA的应用:Rich Internet Application.
* 传统方式的开发：所有的数据提交到服务器端进行处理.(胖服务器)
* AJAX的方式开发：有一部分的代码写在客户端.

同步：
异步：
AJAX的作用：
完成页面局部刷新而不影响用户的体验.
* 用户名是否已经存在的校验
* 百度信息输入的提示
...
使用AJAX：
JavaScript和XML
* XMLHttpRequest:
    * 属性：
        * onreadystatechange:
        * readyState:
       
        * status:获得状态码
        * responseText	:响应的文本
        * responseXML	:响应的XML
    * 方法:
        * open(“请求方式”,”请求路径”,”是否异步”);
        * send(“提交的参数”);
        * setRequestHeader(“头信息”,”头的值”);

开发步骤：
1.获得XMLHttpRequest对象.
    * IE将XMLHttpRequest封装到一个ObjectXActive插件中.
    * Firefox直接可以创建XMLHttpRequest.
2.设置状态改变触发一个函数.
3.打开一个链接.
4.发送请求.
【AJAX的GET入门】
创建XMLHttpRequest
function createXMLHttpRequest() {
	var xmlHttp;
	try { // Firefox, Opera 8.0+, Safari
		xmlHttp = new XMLHttpRequest();
	} catch (e) {
		try {// Internet Explorer
			xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
		} catch (e) {
			try {
				xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
			} catch (e) {
			}
		}
	}

	return xmlHttp;
}

AJAX的代码：
function loadData() {
	// 1.创建异步XMLHttpRequest对象
	var xhr = createXMLHttpRequest();
	// 2.设置状态改变触发一个函数
	xhr.onreadystatechange = function(){
		// 回调函数.
		if(xhr.readyState == 4){// 请求发送完成
			if(xhr.status == 200){// 响应也正确
				var data = xhr.responseText;
				document.getElementById("d1").innerHTML=data;
			}
		}
	}
	// 3.打开一个连接：
	xhr.open("GET","/WEB15/ServletDemo1",true);

	// 4.发送请求
	xhr.send(null);
}
【AJAX的POST入门】
function loadData(){
	// 1.创建异步对象
	var xhr = createXMLHttpRequest();
	// 2.设置状态改变触发的函数
	xhr.onreadystatechange = function(){
		if(xhr.readyState == 4){
			if(xhr.status == 200){
				document.getElementById("d1").innerHTML=xhr.responseText;
			}
		}
	}
	// 3.打开连接
	xhr.open("POST","/WEB15/ServletDemo2",true);
	xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
	// 4.发送数据
	xhr.send("name=李四&password=456");
}
步骤分析:
创建一个用户表
设计一个注册页面:
在用户名文本框上绑定一个事件:onblur
在JS的函数中使用AJAX异步向Servlet发送请求.
在Servlet中接收参数-->调用业务层-->调用DAO
查询到了：用户名已经存在
没有查询到：用户名可以使用
代码实现：
创建用户表:
CREATE TABLE `user` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `username` VARCHAR(20) DEFAULT NULL,
  `password` VARCHAR(20) DEFAULT NULL,
  `email` VARCHAR(20) DEFAULT NULL,
  `name` VARCHAR(20) DEFAULT NULL,
  `sex` VARCHAR(10) DEFAULT NULL,
  `birthday` DATE DEFAULT NULL,
  `hobby` VARCHAR(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
INSERT  INTO `user`(`id`,`username`,`password`,`email`,`name`,`sex`,`birthday`,`hobby`) VALUES (1,'bbb','123','123@163.com','张三','男','1992-01-02','篮球, 足球, 排球'),(2,'ccc','123','ccc@itcast.cn','李四','女','1992-03-20','排球, 乒乓球'),(3,'aaa','123','aaa@itcast.cn','王守义','男','1990-08-11','足球, 排球'),(5,'tom','123','haha@qq.com','提莫','男',NULL,'篮球');

设计注册页面:

引入jar包和工具类:

创建包结构：

AJAX异步校验用户名:
function checkUsername(){
	// 获得文本框的值:
	var username = document.getElementById("username").value;
	// 创建对象:
	var xhr = createXMLHttpRequest();
	// 2.状态改变触发一个函数
	xhr.onreadystatechange = function(){
		if(xhr.readyState == 4){
			if(xhr.status == 200){
				// 获得到响应内容:
				var data = xhr.responseText;
				if(data == 1){
					// 可以使用
					document.getElementById("s1").innerHTML = "<font color='green'>用户名可以使用</font>";
					document.getElementById("regBut").disabled=false;
				}else if(data == 2){
					// 已经存在
					document.getElementById("s1").innerHTML = "<font color='red'>用户名已经被使用</font>";
					document.getElementById("regBut").disabled=true;
				}
			}
		}
	}
	// 3.打开连接
	xhr.open("GET","/WEB15/ServletDemo3?username="+username,true);
	// 4.发送数据
	xhr.send(null);
}

使用JQuery完成异步用户名的校验：
需求：


在注册页面中,当输入了用户名之后,光标离开文本框,显示用户名是否已经存在.
***** 用户名是否已经存在,需要到后台的数据库进行查询的.
分析:
技术分析:
【Jquery的AJAX部分的概述】
由于传统AJAX开发代码比较麻烦,而且还有浏览器兼容的问题.传统的AJAX的使用在企业中是很少的.使用AJAX的一些框架完成.

JQuery的AJAX部分的API：
* $(“”).load(url,data,function(){});
* $.get(url,data,function(){},dataType);
* $.post(url,data,function(){},dataType);
* $.ajax();
【Jquery的AJAX的部分的使用】
引入JQuery的JS.
【Jquery的AJAX的部分的入门】
// jquery的load方法
$(function(){
	// 给按钮1绑定一个click事件：
	$("#bt1").click(function(){
		$("#d1").load("/WEB15/ServletDemo4",{"name":"张三","password":"123"},function(data){
			if(data == 1){
				$(this).html("张三");
			}else{
				$(this).html("其他");
			}
		});
	});
});

// 使用jquery的get方法:
$(function(){
	$("#bt2").click(function(){
		$.get("/WEB15/ServletDemo4",{"name":"李四","password":"345"},function(data){
			$("#d2").html(data);
		});
	});
});

//使用jquery的post方法:
$(function(){
	$("#bt3").click(function(){
		$.post("/WEB15/ServletDemo4",{"name":"王五","password":"456"},function(data){
			$("#d3").html(data);
		});
	});
});

// 使用jquery的ajax方法:
$(function(){
	$("#bt4").click(function(){
		$.ajax({
			type:"post",
			url:"/WEB15/ServletDemo4",
			data:"name=aaa&password=123",
			success:function(data){
				$("#d4").html(data);
			}
			
		});
	});
});
代码实现：
$(function(){
	// 给用户名的文本框绑定一个事件：
	$("#username").blur(function(){
		// 获得文本框的值:document.getELementById().value;
		var username = $(this).val();
		// 使用jquery的ajax的操作异步发送请求.
		$.post("/WEB15/ServletDemo3",{"username":username},function(data){
			if(data==1){
				// 用户名可以使用
				$("#s1").html("<font color='green'>用户名可以使用</font>");
				$("#regBut").prop("disabled",false);
			}else if(data==2){
				// 用户名已经存在
				$("#s1").html("<font color='red'>用户名已经被占用</font>");
				$("#regBut").prop("disabled",true);
			}
		});
	});
});
案例三：使用JQuery完成仿百度的信息提示:
需求:
在一个搜索页面中,键盘输入一些信息,在文本框下面给出一些提示信息(需要从服务器端进行查询的).


分析：
步骤分析：
创建一个数据库和表:
设计一个页面
文本框绑定一个事件.keyup
在keyup所触发函数中:
获得文本框的值.
将这个值异步提交到服务器.$.post();
提交到Servlet：
接收参数:
调用业务层--调用DAO: select * from .. Where xx like ?;
查询之后页面跳转把数据显示到一个表格中.
代码实现:
创建数据库和表:
CREATE TABLE words(
 id INT PRIMARY KEY AUTO_INCREMENT,
 word VARCHAR(20)
);

设计一个页面：
<center><h1>黑马一下</h1></center>
<center><input type="text" name="word" id="word" style="width:300px"/><input type="button" value="黑马一下"><center>
<div id="d1" style="display:none;position:absolute;top:110px;left:494px;border:1px solid blue;width:300px;height:200px;"></div>

为文本框绑定事件:编写jquery代码
$(function(){
	// 为文本框绑定事件:
	$("#word").keyup(function(){
		// 获得文本框的值:
		var val = $(this).val();
		if(val != ""){
			// 异步将这个值提交给服务器:
			$.post("/WEB15/ServletDemo5",{"val":val},function(data){
				$("#d1").show();
				$("#d1").html(data);
			});
		}else{
			$("#d1").hide();
		}
	});
});
使用Jquery完成省市联动的案例:使用JSON作为响应数据:
需求:


完成省市联动的效果.市的信息从后台服务器端获得.通过AJAX使用这样的功能!!!
分析:
技术分析:
【JSON的概述】
JSON的概念:


JSON的案例:
* {key:value,key:value}
   * {id:1,name:aaa}
* [{key:value,key:value},{key:value,key:value}]
   * [{id:1,name:aaa},{id:2,name:bbb}]

将对象转成JSON:
使用JSONLIB将Java中对象或集合转成JSON.
* JSONArray		:将数组或List集合转成JSON的.
* JSONObject	:将对象或Map集合转成JSON的.
代码实现：

Listener&Filter
今日任务
使用过滤器完成自动登录的案例
使用过滤器统一网站的字符集编码
教学导航
教学目标	了解常见的监听器
理解过滤器的生命周期
能够使用过滤器完成自动登录
使用过滤器解决get和post的乱码
教学方法	案例驱动法
Listener:监听器：
Listener的概述：
什么是监听器：
    * 监听器就是一个Java类用来监听其他的JavaBean的变化.

监听器和过滤器属于Servlet中的高级技术.

监听器的应用:
* 主要在Swing编程.
* 在Android大量应用.

* 监听器的术语:
    * 事件源		：被监听的对象.汽车
    * 监听器对象	：监听的对象.汽车上报警器
    * 事件源与监听器绑定：
    * 事件		：指的是事件源的改变.
        * 获得事件源对象.
Servlet的监听器：
Servlet的监听器：
* 监听ServletContext,HttpSession,ServletRequest
* 事件源和监听器绑定的过程:通过配置完成.

Servlet中的监听器:提供了8个监听器.
一类:监听三个域对象的创建和销毁的监听器.3个
二类:监听三个域对象的属性变更的监听器.(属性添加,属性移除,属性替换)3个.
三类:监听HttpSession对象中的JavaBean的状态的改变.(绑定,解除绑定,钝化和活化)2个
一类监听器：监听三个域对象的创建和销毁的监听器：
ServletContextListener：监听ServletContext对象的创建和销毁.
【方法】


【问题】
* ServletContext对象何时创建和销毁:
    * 创建：服务器启动时候,服务器可以为每个WEB应用创建一个单独的ServletContext.
    * 销毁：服务器关闭的时候,或者项目从服务器中移除.

【入门案例】
1.编写一个类实现监听器的接口.
public class MyServletContextListener implements ServletContextListener{

	@Override
	/**
	 * 监听ServletContext对象的创建的方法:
	 * @param sce
	 */
	public void contextInitialized(ServletContextEvent sce) {
		System.out.println("ServletContext对象被创建了...");
	}

	@Override
	/**
	 * 监听ServletContext对象的销毁的方法:
	 * @param sce
	 */
	public void contextDestroyed(ServletContextEvent sce) {
		System.out.println("ServletContext对象被销毁了...");
	}

}
2.通过配置完成监听器和事件源的绑定.
  <!-- 配置监听器 -->
  <listener>
  	<listener-class>com.itheima.weblistener.MyServletContextListener</listener-class>
  </listener>

【企业中应用】
* 初始化工作.
* 加载配置文件:Spring框架.
    * ContextLoaderListener:
* 定时任务调度:
    * Timer,TimerTask.
HttpSessionListener:监听HttpSession对象的创建和销毁的监听器.
【方法】


【问题】
* HttpSession对象何时创建和销毁的?
    * 创建:服务器第一次调用getSession()方法的时候.
    * 销毁：
        * 非正常关闭服务器(正常关闭序列化到硬盘)
        * session过期了(默认30分钟)
        * session.invalidate()

【入门】
1.编写监听器:
public class MyHttpSessionListener implements HttpSessionListener {

	@Override
	public void sessionCreated(HttpSessionEvent se) {
		System.out.println("HttpSession对象被创建了...");
	}

	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		System.out.println("HttpSession对象被销毁了...");
	}

}

2.配置监听器:
  <listener>
  	<listener-class>com.itheima.weblistener.MyHttpSessionListener</listener-class>
  </listener>

【问题】
1.访问html是否创建session对象?			:不会
2.访问一个Servlet是否创建session对象?	:不会
3.访问一个jsp是否创建session对象?		:会
ServletRequestListener:监听ServletRequest对象的创建和销毁的监听器:
【方法】


【问题】
ServletRequest对象何时创建和销毁?
    * 创建:客户端向服务器发送请求的时候.
    * 销毁:服务器为这次请求作出了响应时候.

【入门】
1.编写一个监听器
public class MyServletRequestListener implements ServletRequestListener {
    public void requestInitialized(ServletRequestEvent sre)  { 
    	System.out.println("ServletRequest被创建了...");
    }
    public void requestDestroyed(ServletRequestEvent sre)  { 
    	System.out.println("ServletRequest被销毁了...");
    }
	
}
2.配置监听器
  <listener>
    <listener-class>com.itheima.weblistener.MyServletRequestListener</listener-class>
  </listener>

【问题】
1.访问html是否创建request对象?			:会
2.访问一个Servlet是否创建request对象?	:会
3.访问一个jsp是否创建request对象?		:会
二类监听三个域对象属性变更的监听器:
ServletContextAttributeListener：监听ServletContext对象中的属性变更的监听器
【方法】

HttpSessionAttributeListener：监听HttpSession对象中的属性变更的监听器
【方法】

ServletRequestAttributeListener:监听ServletRequest对象中的属性变更的监听器
【方法】

三类：监听HttpSession中的JavaBean的状态改变的监听器.(绑定，解决绑定，钝化，活化)
三类监听器非常特殊：
* 监听器作用在JavaBean上.JavaBean可以自己感知在session中状态.
* 这类监听器不用配置.
HttpSessionBindingListener:监听HttpSession中的JavaBean的绑定和解除绑定的状态.
【方法】

HttpSessionActivationListener:监听HttpSession中的JavaBean的钝化和活化的状态.
【方法】

sessionDidActivate(HttpSessionEvent se);  -- 活化
SessionWillPassivate(HttpSessionEvent se); -- 钝化

通过配置序列化session:
context.xml
* tomcat/conf/context.xml						:对tomcat中的所有虚拟主机和虚拟路径生效.
* tomcat/conf/Catalina/localhost/context.xml	:对tomcat下的localhost虚拟主机中的所有路径生效.
* 工程的META-INF/context.xml					:对当前的工程生效.

<?xml version="1.0" encoding="UTF-8"?>
<!--
	maxIdleSwap	:1分钟 如果session不使用就会序列化到硬盘.
	directory	:itheima 序列化到硬盘的文件存放的位置.
 -->
<Context>
	<Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="1">
		<Store className="org.apache.catalina.session.FileStore" directory="itheima"/>
	</Manager>
</Context>
监听器的总结:
Servlet的监听器分成三类8个:
* 一类：监听三个域对象的创建和销毁的监听器.
* 二类：监听三个域对象的属性的变更.
* 三类：监听HttpSession中JavaBean的状态的改变.
案例一：自动登录.
需求：
网站的首页：

在登录的页面中输入用户名和密码 将自动登录的额复选框选中. 点击登录。

关闭了浏览器再次访问网站的首页的时候：

分析：
技术分析：
【Cookie】
利用Cookie记住用户名和密码.
【Filter的概述】
什么是过滤器Filter:
Filter：一个实现了特殊接口的Java类.实现对请求资源的过滤的功能.
* 过滤器是Servlet技术中最为实用的技术.
过滤器的作用：
对目标资源进行过滤.
* 自动登录,解决网站乱码,进行页面静态化,进行响应压缩...
使用过滤器:
1.编写一个类实现过滤器的接口.
public class FilterDemo1 implements Filter{

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		
		System.out.println("FilterDemo1执行了...");
		
		// 放行
		chain.doFilter(request, response);
		
	}

	@Override
	public void destroy() {
		
	}

}
2.对过滤器进行配置.
  <filter>
  	<filter-name>FilterDemo1</filter-name>
  	<filter-class>com.itheima.filter.FilterDemo1</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>FilterDemo1</filter-name>
  	<url-pattern>/*</url-pattern>
  </filter-mapping>
【过滤器的生命周期】（了解）
* Servlet的生命周期(*****)
* Filter生命周期：过滤器从创建到销毁的过程.
    * 服务器启动的时候,服务器就会创建过滤器的对象,每次访问被拦截目标资源,过滤器中的doFilter的方法就会执行.当服务器关闭的时候,服务器就会销毁Filter对象.
【FilterConfig的作用】
【方法】


		// 获得初始化参数:过滤器的初始化参数.
		String username = fConfig.getInitParameter("username");
		String password = fConfig.getInitParameter("password");
		System.out.println("初始化参数"+username+"   "+password);
	
		// 获得所有的初始化参数的名称:
		Enumeration<String> names = fConfig.getInitParameterNames();
		while(names.hasMoreElements()){
			String name = names.nextElement();
			String value = fConfig.getInitParameter(name);
			System.out.println(name+"    "+value);
		}
		
		// 获得过滤器的配置的名称：
		String filterName = fConfig.getFilterName();
		System.out.println("过滤器名称"+filterName);

【FilterChain：过滤器链】
过滤器链中的过滤器的执行的顺序跟<filter-mapping>的配置顺序有关.
【方法】

【Filter的配置】
【url-pattern的配置】与servlet中的配置一样：
* 三种配置:
    * 完全路径匹配：以 / 开始   /aaa /aaa/bbb
    * 目录匹配:     以 / 开始   /*  /aaa/*
    * 扩展名匹配：  不能以 / 开始  *.do  *.jsp  *.action

【servlet-name的配置】通过url-pattern拦截一个Servlet的资源.也可以通过servlet-name标签进行拦截.

【dispatcher的配置】
* REQUEST	：默认值.
* FORWARD	：拦截转发
* ERROR		：拦截跳转到错误页面.全局错误页面.  
* INCLUDE	：拦截在一个页面中包含另一个页面.
步骤分析：
登录的功能的基础上实现的自动登录.
在登录的页面中勾选自动登录的复选框.点击提交.
在提交的Servlet中,在登录成功的地方记住用户名和密码.
在下次访问首页的时候带着Cookie过来.
编写一个过滤器:
获得Cookie的信息.
查找指定的名称的Cookie.
拿到Cookie以后获得用户名和密码
在去数据库进行查询.
能查询到,将用户的信息存入到session.放行.
不能查询到,跳转其他的页面.
代码实现：
创建数据库:

CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) DEFAULT NULL,
  `password` varchar(20) DEFAULT NULL,
  `email` varchar(20) DEFAULT NULL,
  `name` varchar(20) DEFAULT NULL,
  `sex` varchar(10) DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `hobby` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

引入jar包和工具类：

登录的功能的实现：

自动登录的过滤器：

案例二：通用网站的字符集编码
需求：
在整个网站中,可能会有get请求或post请求向服务器提交参数.参数中往往有中文信息.在后台每个Servlet中都需要去处理乱码.
* 无论get请求或者是post请求提交到Servlet中.就可以直接调用getParameter方法将乱码处理好.
分析：
技术分析：
【Filter的使用】
在到达目标资源之前对request中的getParameter方法进行增强.
【增强一个类中的某个方法】
1.继承		：能够控制这个类的构造.
2.装饰者		：被增强的对象和增强的对象实现相同的接口,在增强对象中获得到被增强对象的引用.
3.动态代理	：这个类实现了接口即可.
步骤分析：
设计一个页面：向Servlet中提交中文.
编写过滤器的方式到达目标资源之前进行增强.
* 增强request中的getParameter.
放行:将增强的request放行.
代码实现：

基础加强
今日任务
使用自定义注解完成仿@Test的作用.
使用Servlet3.0完成文件上传.
使用动态代理解决网站的字符集编码
教学导航
教学目标	了解JDK中提供的三个注解
会自定义注解及注解的反射.
能够简单使用Servlet3.0
掌握动态代理技术
了解类加载器
教学方法	案例驱动法
案例一：使用自定义注解完成@Test注解功能类似的效果:
需求
使用Junit是单元测试的工具.在一个类中使用 @Test 对程序中的方法进行测试.
自定义一个注解@MyTest 也将这个注解加在类的方法上. 使这个方法得到执行.
分析：
技术分析：
【注解】
程序中有 注释 和注解
* 注释：给开发人员.
* 注解：给计算机看的.

注解使用：学习框架支持注解开发.
【JDK提供的注解】
@Override			：描述方法的重写.
@SuppressWarnings	：压制警告.
@Deprecated			：标记过时.
自定义注解：
定义一个类:class
定义一个借口:interface
定义一个枚举:enum
定义一个注解:@interface

【自定义注解案例】
@interface MyAnno1{
	
}

带有属性的注解:
@interface MyAnno2{
	int a() default 1;
	String b();
	// 注解属性的类型：基本数据类型，字符串类型String,Class,注解类型,枚举类型,以及以上类型的一维数组.
	// Date d();
	Class clazz();
	MyAnno3 m3(); // 注解
	Color c(); // 枚举
	String[] arrs();
	
}

@MyAnno4("aaa") // 如果属性名称为value 那么使用的时候 value可以省略(只出现这一个value的属性情况下).
public class AnnotationDemo3 {

}

@interface MyAnno4{
	String value();
	int a() default 1;
}
步骤分析：
定义一个测试类
public class AnnotationDemo3 {

	@MyTest
	public void demo1(){
		System.out.println("demo1执行了...");
	}
	
	@MyTest
	public void demo2(){
		System.out.println("demo2执行了...");
	}
	
	public void demo3(){
		System.out.println("demo3执行了...");
	}
}
定义核心运行类：
在核心运行类中有一个主函数：
获得测试类中的所有的方法.
获得每个方法,查看方法上是否有@MyTest注解.
如果有这个注解,让这个方法执行.
代码实现：
通过元注解定义注解存在的阶段.
* 元注解也是一个注解：修饰注解的 注解.

自定义一个注解:

核心运行类：
public class CoreRunner {

	public static void main(String[] args) {
		// 反射：获得类的字节码对象.Class
		Class clazz = AnnotationDemo3.class;
		// 获得测试类中的所有的方法:
		Method[] methods = clazz.getMethods();
		// 遍历数组:
		for (Method method : methods) {
			// System.out.println(method.getName());
			// 判断方法上是否有@MyTest注解：
			boolean flag = method.isAnnotationPresent(MyTest.class);
			// System.out.println(method.getName()+"   "+flag);
			if(flag){
				// 让这个方法执行:
				try {
					method.invoke(clazz.newInstance(), null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}

}
总结：
使用注解完成JDBC工具类的编写：（了解）
public class JDBCUtils {
	private static  String driverClass;
	private static  String url;
	private static  String username;
	private static  String password;
	
	@JDBCInfo
	public static Connection getConnection() throws Exception{
		// 反射：
		Class clazz = JDBCUtils.class;
		
		Method method = clazz.getMethod("getConnection", null);
		
		// 获得方法上的注解：
		JDBCInfo jdbcInfo = method.getAnnotation(JDBCInfo.class);
		driverClass = jdbcInfo.driverClass();
		url = jdbcInfo.url();
		username = jdbcInfo.username();
		password = jdbcInfo.password();
		
		Class.forName(driverClass);
		Connection conn = DriverManager.getConnection(url, username, password);
		
		return conn;
	}
}
案例二：使用Servlet3.0技术完成文件的上传:
需求:

分析:
技术分析：
【Servlet3.0】
Servlet3.0 与 Servlet2.5：
    * Servlet3.0需要运行在tomcat7以上的服务器中.
    * Servlet3.0以后web.xml就不是必须的.
1.Servlet3.0支持注解开发.
2.支持文件上传.
【Servlet3.0支持注解开发】
使用@WebServlet替换web.xml中配置的Servlet：
@WebServlet(urlPatterns="/ServletDemo1",loadOnStartup=2,initParams=@WebInitParam(name="username",value="root"))

使用@WebListener替换web.xml中监听器的配置：
@WebListener

使用@WebFilter替换web.xml中的过滤器的配置:
@WebFilter(urlPatterns="/*")
【Servlet3.0的文件上传】
文件上传：
文件上传：指的是将本地的文件 写到 服务器上.
文件上传的要素：
1.表单的提交的方式必须是POST.
2.表单中必须有一个文件上传项:<input type=”file”>,而且文件上传项必须有name属性和值.
    * <input type=”file” name=”upload”/>
3.表单的enctype属性的值必须是multipart/form-data
文件上传的抓包分析：
未修改enctype属性的时候:

POST /WEB17_WEB/demo1/demo1.jsp HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
X-HttpWatch-RID: 22325-10011
Referer: http://localhost:8080/WEB17_WEB/demo1/demo1.jsp
Accept-Language: zh-Hans-CN,zh-Hans;q=0.5
User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Host: localhost:8080
Content-Length: 47
Connection: Keep-Alive
Cache-Control: no-cache
Cookie: JSESSIONID=99CD51DA9A47D29200168968AD983E9E

upload=C%3A%5CUsers%5Capple%5CDesktop%5Caaa.txt

已经修改了enctype属性:
POST /WEB17_WEB/demo1/demo1.jsp HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
X-HttpWatch-RID: 22325-10026
Referer: http://localhost:8080/WEB17_WEB/demo1/demo1.jsp
Accept-Language: zh-Hans-CN,zh-Hans;q=0.5
User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko
Content-Type: multipart/form-data; boundary=---------------------------7e02e526160b66
Accept-Encoding: gzip, deflate
Host: localhost:8080
Content-Length: 224
Connection: Keep-Alive
Cache-Control: no-cache
Cookie: JSESSIONID=99CD51DA9A47D29200168968AD983E9E

-----------------------------7e02e526160b66
Content-Disposition: form-data; name="upload"; filename="C:\Users\apple\Desktop\aaa.txt"
Content-Type: text/plain

Hello shouyi
-----------------------------7e02e526160b66—
【文件上传的原理】
根据分割线将请求体的部分分成几块:
* 判断 每块是 普通项还是文件上传项.
    * 普通项：获得名称和值.
    * 文件上传项：获得文件名 和 文件内容输入流. 
【文件上传的技术】
JspSmartUpload: jspSmartUpload组件是应用JSP进行B/S程序开发过程中经常使用的上传下载组件，它使用简单，方便。现在我又为其加上了下载中文名字的文件的支持，真个是如虎添翼，必将赢得更多开发者的青睐。-Model1年代的文件上传的工具.
FileUpload 是 Apache commons下面的一个子项目，用来实现Java环境下面的文件上传功能，与常见的SmartUpload齐名.应用在Model2年代了.
Servlet3.0	:
Struts2		:

步骤分析：
设计一个文件上传页面：
提交到Servlet：
接收普通项：request.getParameter();
接收上传项：Part：
通过Part对象中的方法完成文件的上传.
代码实现
package com.itheima.servlet;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import javax.servlet.ServletException;
import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.Part;

/**
 * 文件上传的Servlet
 */
@WebServlet("/UploadServlet")
@MultipartConfig
public class UploadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// 接收普通项:
		request.setCharacterEncoding("UTF-8");
		String desc = request.getParameter("desc");
		System.out.println("文件描述:"+desc);
		Part part = request.getPart("upload");
		// 获得上传的文件的大小
		long size = part.getSize();
		System.out.println("文件大小"+size);
		String type = part.getContentType();
		System.out.println("文件类型"+type); // text/plain  image/jpeg 
		String name = part.getName();
		System.out.println(name); 
		// 获得文件名：
		String header = part.getHeader("Content-Disposition");
		System.out.println(header);
		
		int idx = header.lastIndexOf("filename=\"");
		String fileName = header.substring(idx+10, header.length()-1);
		System.out.println(fileName);
		
		// 获得文件内容:
		InputStream is = part.getInputStream();
		
		// 获得文件上传路径：
		String path = this.getServletContext().getRealPath("/upload");
		
		OutputStream os = new FileOutputStream(path+"/"+fileName);
		int len = 0;
		byte[] b = new byte[1024];
		while((len = is.read(b))!=-1){
			os.write(b, 0, len);
		}
		is.close();
		os.close();
		
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}
总结:
文件名重名的问题：
UUID随机产生一个文件名.
文件上传的目录分离:
按用户分		：一个用户创建一个或多个路径.
按时间分		：按月，星期，天进行划分.
按个数分		：一个路径中存3000个文件.
按分离算法分	：按照一定的算法进行划分.

案例三：使用动态代理的方式统一网站的字符集编码
需求：
在一个表单中分别使用get和post提交到Servlet中，在Servlet中直接调用getParameter方法解决中文乱码的问题！！！
分析：
技术分析：
【动态代理】
增强一个类中的某个方法.对程序进行扩展.Spring框架中AOP.
什么是代理：
【入门案例】
class MyInvocationHandler implements InvocationHandler{
	
	private Waiter waiter;

	public MyInvocationHandler(Waiter waiter) {
		this.waiter = waiter;
	}

	@Override
	// 执行目标对象的任何一个方法 都相当于执行了invoke方法.
	/**
	 * proxy:产生代理对象.
	 * method:代表正在调用的方法.
	 * Object[]:在调用的方法的参数.
	 */
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// System.out.println("aaaaa");
		// System.out.println(method.getName());
		if("server".equals(method.getName())){
			// 增强server.
			System.out.println("微笑...");
			return method.invoke(waiter, args);
		}else{
			// 不增强:
			return method.invoke(waiter, args);
		}
		// return null;
	}
	
}
代码实现：
package com.itheima.encoding;

import java.io.IOException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;

@WebFilter(urlPatterns="/*")
public class GenericCharacterEncodingFilter implements Filter{

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		final HttpServletRequest req = (HttpServletRequest) request;
		
		// 对req产生代理对象:
		HttpServletRequest myReq = (HttpServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(),req.getClass().getInterfaces(), new InvocationHandler() {
			
			@Override
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				// 增强getParameter:
				if("getParameter".equals(method.getName())){
					// 增强.
					// 根据请求方式:
					String type = req.getMethod();
					if("get".equalsIgnoreCase(type)){
						// 调用原有的getParameter：
						String value = (String)method.invoke(req, args);
						String s = new String(value.getBytes("ISO-8859-1"),"UTF-8");
						return s;
						
					}else if("post".equalsIgnoreCase(type)){
						req.setCharacterEncoding("UTF-8");
						return method.invoke(req, args);
					}
					
				}
				// 不增强:
				return method.invoke(req, args);	
			}
		});
		
		chain.doFilter(myReq, response);
	}

	@Override
	public void destroy() {
		
	}

}

总结：
【类的加载器：了解】
类加载器就是将class文件加载到内存.

JDK中提供的类加载器：
* 引导/系统类加载器	：Java\jre7\lib\rt.jar
* 扩展类加载器		：Java\jre7\lib\ext\*.jar
* 应用类加载器		：自定义的类,类路径下的所有class文件.

类的加载器的机制	：全盘委托机制.
引导类加载器
    |
扩展类加载器
    |
应用类加载器

class A{
    String s;
}

class文件由应用类加载器获得到,没有加载,向上一层委托向扩展类加载器委托,向上一层进行委托委托给引导类加载器.引导类加载器查看class哪些它负责,将自己负责的这个class进行加载.不是其负责的就向下传递扩展类加载器.扩展类加载器查看是否是其管理的class,如果是加载,不是就再向下到应用类加载器.

网上商城实战1
今日任务
完成用户模块的功能
网上商城的实战：
演示网上商城的功能：

需求的演示：

数据库分析和设计：

代码实现:
通用的Servlet的编写:
传统的方式：
* 一个请求对应一个Servlet.
* 能不能一个模块对应一个Servlet.

一个模块对应一个Servlet:
<a href=”/UserServlet?method=add”>添加</a>
<a href=”/UserServlet?method=update”>修改</a>
<a href=”/UserServlet?method=delete”>删除</a>

public class UserServlet extends HttpServlet{

   public void service(HttpServletRequest req,HttpServletResponse resp){
           String method = req.getParameter(“method”);
           if(“add”.equals(method)){
               add(req,resp);
           }else if(“update”.equals(method)){
               update(req,resp);
           }
   }

   public void add(HttpServletRequest req,HttpServletResponse resp){
   
   }

   public void update(HttpServletRequest req,HttpServletResponse resp){
   
   }

}

改进以后：
public class BaseServlet extends HttpServlet{
   public void service(HttpServletRequest req,HttpServletResponse resp){
           String methodName = req.getParameter(“method”);
           // 反射:
           Class clazz = this.getClass(); // 指代的是子类的对象.
           Method method = clazz.getMethod(methodName ,HttpServletRequest.class,HttpServletResponse,class);
           method.invoke(this,req,resp);
   }

}


public class UserServlet extends BaseServlet{

   public void add(HttpServletRequest req,HttpServletResponse resp){
   
   }

   public void update(HttpServletRequest req,HttpServletResponse resp){
   
   }

}

public class A{
   public A(){
      System.out.println(this.getClass());
   }
}

public class B extends A{
    Public B(){

    }
}

public class Test{
   Public static void main(String[] args){
       B b = new B();
   }
}
BaseServlet的代码实现：
【创建包结构】

【代码实现】
public class BaseServlet extends HttpServlet{

	@Override
	// http://loacalhost:8080/store/UserServlet?method=add
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// 处理Post请求的乱码
		req.setCharacterEncoding("UTF-8");
		// 接收参数:
		String methodName = req.getParameter("method");
		// 反射获得类的字节码.
		Class clazz = this.getClass();
		// 获得正在执行的类的指定名称的方法
		try {
			Method method = clazz.getMethod(methodName, HttpServletRequest.class,HttpServletResponse.class);
			// 让这个方法执行:
			String path = (String) method.invoke(this, req,resp);
			if(path != null){
				req.getRequestDispatcher(path).forward(req, resp);
			}
		} catch (Exception e) {
			e.printStackTrace();
		} 
	}

}
环境的搭建：
【创建一个WEB工程】
【创建包结构】
【引入相应的jar包】
    * mysql驱动			1
    * dbutils			1
    * c3p0连接池			1
    * beanutils			2
    * JSTL				2
    * 文件上传			2
    * 发送邮件			1
【创建数据库和表】
CREATE TABLE `user` (
  `uid` varchar(32) NOT NULL,
  `username` varchar(20) DEFAULT NULL,
  `password` varchar(20) DEFAULT NULL,
  `name` varchar(20) DEFAULT NULL,
  `email` varchar(30) DEFAULT NULL,
  `telephone` varchar(20) DEFAULT NULL,
  `birthday` varchar(20) DEFAULT NULL,
  `sex` varchar(10) DEFAULT NULL,
  `state` int(11) DEFAULT NULL,
  `code` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
前台用户模块：
注册
异步校验用户名是否存在
1.JS的事件触发一个函数.
2.使用AJAX异步向服务器发送请求.
3.得到返回的数据进行判断.
4.将信息写入到文本框后面span元素中.
完成用户注册
1.在注册页面中输入信息.
2.点击注册,提交到Servlet.
3.接收数据,封装数据.
4.在Servlet调用业务层.
5.页面跳转.
发送激活邮件
1.使用JavaMail的技术-了解.
* 了解邮件相关内容:
    * 术语:
        * 电子邮箱：一个邮箱服务器上的一个账号,通过账号获得到服务器上一块空间.
        * 邮箱服务器：一台电脑安装一个邮箱的服务器.
        * 邮件收发的协议：协议规范双方的数据的格式.
    * 协议:
        * 接收：POP/POP3  IMAP
        * 发送：SMTP
    * 邮件收发过程:
    * 会配置邮箱的客户端:
【配置邮箱服务器：】

安装成功！
第一步：

第二步：

第三步：


【配置邮箱的客户端】
* Foxmail:免费的
    * 输入用户名
    * 输入密码:
    * 修改服务器的地址localhost.
* outlook:微软的收费的.
激活
在邮箱的界面点击激活链接：
提交到Servlet传递一个激活码:
根据激活码进行查询用户：
* 如果查询到该用户：修改用户的状态.
* 如果没有查询到该用户：激活失败.
登录
在登录页面上输入用户名和密码
点击提交：提交到Servlet.
在Servlet中接收参数
调用业务层
页面跳转
记住用户名
使用Cookie记住用户名:
* 自己完成
自动登录
使用Cookie记住用户名和密码：
使用过滤器：
* 自己完成
退出
* 在首页上点击退出的链接:
* 提交到Servlet:
    * 销毁session:
css & javascript
一.CSS
1.CSS介绍
CSS 指层叠样式表 (Cascading Style Sheets),用来定义网页的显示效果。

把样式添加到HTML中，可以将网页内容与显示相分离。(可以解决html代码对样式定义的重复，提高了后期样式代码的可维护性，并增强了网页的显示效果功能。)
外部样式表通常存储在 CSS 文件中,可以极大提高工作效率
一个HTML元素可以被不同位置的样式进行修饰，多个样式根据一定规则层叠为一个
2.CSS书写规则
基本语法 
Css规则主要由两部分组成 1.选择器 2.一条或多条声明
a.选择器主要作用是为了确定需要改变样式的HTML元素
b.每一条声明由一个属性和一个值组成，使用花括号来包围声明，属性与值之间使用冒号(:)分开,多条声明用分号(;)隔开.
如图:

值的单位


书写注意事项
如果值为若干单词，则要给值加引号
多个声明之间使用分号(;)分开
class与id名称对大小写敏感,其他属性对大小写不敏感

选择器{
属性1:值1;
属性2:”Times new roma”;
属性3:值31 值32;
}
3.导入CSS
内联样式表
用法:
在相关的标签内使用样式（style）属性。style 属性可以包含任何 CSS 属性
例如:
<div style="border:1px solid #ff0000">div内联样式表</div>

注意:
该方式比较灵活，但是对于多个相同标签的同一样式定义比较麻烦，适合局部修改。
内部样式表
用法:
在head标签中加入style标签，然后在style的标签体中再对多个标签的样式进行修改。
例如:
<style type="text/css">
div{
border:1px dashed #ff00ff;
}
</style>
注意:
这种方式只适用于当前页面
外部样式表
用法:
1.css文件,文件里存放的都是样式
例如:
myStyle.css文件里有如下内容
span{
	border: 10px double #0000ff
}
2.通过head标签里的link标签,导入myStyle.css文件
例如:
<link rel="stylesheet" href="myStyle.css" type="text/css">
@import导入
这种方式也是外部导入。
用法：
1.css文件,文件里存放的都是样式
例如:
myStyle.css文件里有如下内容
span{
	border: 10px double #0000ff
}

2.在head标签中加入style标签，然后通过style标签导入
<style type="text/css">
		@import "myStyle2.css";
	</style>
注意:
关于@import与引用外部样式表的区别:
	1.@import这种方式导入的css，会在整个页面加载后，才会加载样式。如果网络不好情况下，会先看到无样式修饰的页面，闪烁一下后，才会看到有样式修饰的页面。而使用外部样式表，会先装载样式表，这样看到的就是有样式修饰的页面。
2.@import不支持通过javascript修改样式，而link支持。

优先级问题
	最近原则:不同的导入方式中,如果有属性一样的样式,那个方式离此html元素近就用那种方式定义的样式.

4.CSS选择器
css选择器主要是用于选择需要添加样式的html元素。对于css来说，它的选择器有很多，我们主要介绍以下几种:
id选择器
要求:
html中的标签有id属性,并且有值.例如 <xxx id=”y1”>
css中使用#引入，它引用的是id属性中的值.例如 #y1{...}
类选择器
要求:
html中的标签有class属性,并且有值.例如 <xxx class=”yy1”>
css中使用.引入，它引用的是class属性中的值.例如 .yy1{...}
元素选择器
这是最常见的选择器，简单说，文档中的元素就是选择器.例如:div{...}
属性选择器
要求:
html的标签中必须有某个属性，不论属性是什么 例如 <input type=”text”>
css中定义时候使用 标签名[属性=属性值] 例如 input[type=”text”]{...}
伪类
css伪类用于向某些选择器添加特殊效果。
下面我们介绍一下锚伪类。
在支持css的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。

a:link {color: #FF0000}	/* 未访问的链接 */
a:visited {color: #00FF00}	/* 已访问的链接 */
a:hover {color: #FF00FF}	/* 鼠标移动到链接上 */
a:active {color: #0000FF}	/* 选定的链接 */
注意:
在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。
在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。
伪类名称对大小写不敏感。


5.CSS属性
字体
Css字体属性定义文本的字体系列，大小，加粗，风格(如斜体)和变形(如小型大写字母)
常用属性:
font:简写属性，作用是把所有针对字体的属性设置在一个声明中。
格式：{font :风格 异体 粗细 尺寸/行间距 字体系列}
例如：{ font: italic bold 12px/20px arial,sans-serif}
font-family:定义字体系列
具体字体的名称，例如：font-family:隶书。 
通常字体系列名称：例如 font-family:"serif","sans-serif","cursive","fantasy","monospace"
“,”的意思是指如果本地没有该字体系列，再使用下一个
font-size:定义字体的尺寸 例如 font-size:40px
font-style:定义字体风格 例如 font-style:italic

文本
CSS 文本属性可定义文本的外观。通过文本属性，您可以改变文本的颜色、字符间距，对齐文本，装饰文本，对文本进行缩进，等等.
常用属性
color:定义文本颜色  例如 color:#ffff00
text-align:定义文本对齐方式 例如:text-align:center
      text-decoration 向文本添加修饰。例如text-decoration:underline(下划线)
letter-spacing:定义字符间隔 
word-spacing:定义字间隔

背景
CSS 允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果。CSS 在这方面的能力远远在 HTML 之上。
常用属性:
background:简写属性，作用是将背景属性设置在一个声明中
格式：{background: 颜色 url(图片路径) 重复 滚动 位置}
例如:  {background: #00FF00 url(bgimage.gif) no-repeat fixed top}

background-color:定义背景颜色
background-image:定义背景图片  background-image:url(xx.jpg) 
background-position:定义背景图片的起始位置 background-position:10% 5%;
background-repeat:定义背景图片是否重复及如何重复 background-repeat:no-repeat
尺寸
CSS 尺寸 (Dimension) 属性允许你控制元素的高度和宽度。
常用属性:
width:设置元素的宽度
height:设置元素的高度		 
列表
CSS 列表属性允许你放置、改变列表项标志，或者将图像作为列表项标志。
常用属性:
list-style:简写属性。用于把所有用于列表的属性设置于一个声明中。
格式:{list-style : 图片 类型 位置}
例如:{list-style : url(liebiao.jpg) square inside}
      list-style-type:定义列表项标志的类型
  list-style-position:定义列表项标志的位置  常用值:inside ,outside
  list-style-image:定义列表项标志为图象

表格
CSS 表格属性可以帮助您极大地改善表格的外观
	  常用属性:
border-collapse:定义是否把表格边框合并为单一的边框。常用值:collapse,separate
border-spacing:定义分隔单元格边框的距离
caption-side:定义表格标题的位置		常用值:top,bottom
轮廓
轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。
CSS outline 属性规定元素轮廓的样式、颜色和宽度。
常用属性:
outline:在一个声明中设置所有的轮廓属性
格式:{outline:颜色 样式 宽度}
例如:{outline:#00FF00 dotted thick;}
      outline-style:定义轮廓的样式  常用值:solid(实线) ,dashed(虚线) ,double(双线)...
outline-color:定义轮廓的颜色
outline-width:定义轮廓的宽度 常用值:thin ,thick ,14px...


定位
CSS 定位 (Positioning) 属性允许你对元素进行定位。
定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置
常用属性:
position:把元素放置到一个静态的,相对的，绝对的，或固定的位置中。
absolute:绝对 相对于父元素
		relative:相对  相对于自己应该出现的位置
		fixed:相对于浏览器
top:定义了定位元素的上外边距边界与其包含块上边界之间的偏移量
right: 定义了定位元素右外边距边界与其包含块右边界之间的偏移
left: 定义了定位元素左外边距边界与其包含块左边界之间的偏移
bottom: 定义了定位元素下外边距边界与其包含块下边界之间的偏移。

分类
CSS 分类属性允许你控制如何显示元素，设置图像显示于另一元素中的何处，相对于其正常位置来定位元素，使用绝对值来定位元素，以及元素的可见度。
 常用属性
 float:定义元素在哪个方向浮动
 clear:设置一个元素的侧面是否允许其它的浮动元素
 cursor:当指向某元素之上时显示的指针类型
 display:定义是否显示及如何显示元素	  常用值 none和inline   消失
 visibility:定义元素是否可见或不可见。	 常用值 hidden和visible	占位隐藏
6.CSS框模型
盒子模型
CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。


元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素

边框
元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。
CSS border 属性允许你规定元素边框的样式、宽度和颜色。
  	常用属性:
	border:简写属性，用于把针对于四个边的属性设置在一个声明。
格式:{border:宽度 样式 颜色}
例如:{border:1px solid red;}
	border-color:简写属性，定义元素边框中可见部分的颜色，或为四个边分别设置颜色。
	border-style:用于定义所有边框的样式，或者单独为各边设置边框样式。
	border-width:简写属性，用于为元素的所有边框设置宽度，或则单独地为各边边框设置宽度
	border-top:简写属性，用于把上边框的所有属性设置到一个声明中
	border-right:简写属性，用于把右边框所有属性设置到一个声明中
	border-bottom:简写属性，用于把下边框的所有属性设置到一个声明中
	border-left:简写属性，用于把左边框的所有属性设置到一个声明中。

外边距
围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。
设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。
常用属性:
margin:简写属性，在一个声明中设置所有外边距属性
margin-top:定义元素的上外边距
margin-right:定义元素的右外边距
margin-bottom:定义元素的下外边距
margin-left定义元素的左外边距

注意:在使用margin来定义所有外边距时，可以使用值复制。
	如果缺少左外边距的值，则使用右外边距的值。
	如果缺少下外边距的值，则使用上外边距的值。
	如果缺少右外边距的值，则使用上外边距的值。


内边距
元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。
CSS padding 属性定义元素边框与元素内容之间的空白区域。
常用属性:
	padding:简写属性，作用是在一个声明中设置元素的所有内边距属性
	padding-top:定义元素的上内边距
	padding-right:定义元素的右内边距
	padding-bottom:定义元素的下内边距
	padding-left:定义元素的左内边距。
二.javaScript
1.javaScript介绍
1992 年，Nombas 公司开发 C 减减（C-minus-minus，简称 Cmm）的嵌入式脚本语言，后更名为ScriptEase。
1995 年 Netscape网景公司的Brendan Eich，开发Netscape Navigator 2.0浏览器内置的 LiveScript脚本语言，Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript
同时，微软进军浏览器，发布了 IE 3.0 并搭载了一个 JavaScript 的克隆版，叫做 JScript
3 种不同的 JavaScript 版本同时存在。1997 年，第 39 技术委员会（TC39）推出 ECMA-262标准，该标准定义了名为 ECMAScript 的全新脚本语言。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。
ECMAScript 仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。其他语言可以实现 ECMAScript 来作为功能的基准，JavaScript 就是这样(简称js)：

js组成:
一个完整的js实现是由下面三个不同部分组成的:
ECMAScript (js的核心,描述了js的基础语法和基本对象)
DOM(文件对象模型)
BOM(浏览器对象模型)

:

js简介:
javaScript是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。
脚本语言：脚本语言又被称为扩建的语言，或者动态语言，是一种解释型语言，由解释器来运行，用来控制软件应用程序，脚本通常以文本保存，只在被调用时进行解释或编译
javaScript是可插入 HTML 页面的编程代码,可由所有的现代浏览器执行。
javaScript与 Java 是两种完全不同的语言
JavaScript是Netscape公司的产品，前身是LiveScript；Java是Sun公司的产品，现在是Oracle公司的产品。
JavaScript是基于对象，Java是面向对象。
JavaScript只需解释就可以执行，Java需要先编译成字节码文件，再执行
JavaScript是弱类型，Java是强类型。
JavaScript与java一样都区分大小写


js作用: 
通过js可以改变html内容,改变html样式,进行验证输入等。


2.导入js
在html页面中直接插入javascript
在<script> 和 </script> 之间的编写JavaScript代码.
格式:
<script type=”text/javascript”>
js代码
</script>
老旧的实例可能会在 <script> 标签中使用 type="text/javascript"。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言。
引入外部的javascript
有时，我们希望在若干个页面中运行JavaScript，同时不在每个页面中写相同的脚本。
我们就可以将 JavaScript 写入一个外部文件之中。然后以 .js 为后缀保存这个文件。然后通过<script type=”text/javascript”>标签的src属性引入.
格式:
<script type=”text/javascript” src=”外部js路径”></script>
注意:
<script>存放的位置.一般建议放在<head>标签体中.由于js是解释性语言,
外部的js文件中不能包含<script>标签。
<script>标签如果使用了src属性,标签体内的代码不再解析.
3.js基础-变量声明
javascript中的变量与我们在java中的变量一样。
在javascript中使用用 var 运算符（variable 的缩写）加变量名定义
格式:
var 变量名 =初始化值;
var 变量名;
变量名=初始化值;
	
javascript 变量名称的规则和我们java中的规则一样：
变量必须以字母 ,下划线或者$开始 
区分大小写
不能是关键字
见名知意(js是弱类型,因此整数类型建议iXxx,boolean类型建议bXxx ,数组建议 aXxx等等)

注意:
1.变量声明不是必须的.
2.变量如果要声明,var可以省略,建议不要省略
3.每行结尾的分号可有可无,有的浏览器不兼容,建议不要省略
4.js基础-数据类型
在ECMAScript中，变量可以存在两种数据类型，即原始类型与引用类型。
原始类型
ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String.

我们先来了解下这5中原始类型.
Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。当函数无明确返回值时，返回的也是值 "undefined".
Null类型也只有一个值 null，即它的字面量。值undefined实际上是从值null派生来的，因此 ECMAScript 把它们定义为相等的。例如：alert(null == undefined); 输出"true"
Boolean 类型有两个值 true 和 false.
Number 类型,在js中任何数字都看成是Number类型,不论整数,还是浮点数,当然表示八进制首数字必须是0,十六进制使用0x开始等.数字的最大值:Number.MAX_VALUE,数字的最小值:Number.MIN_VALUE.
String类型是唯一没有固定大小的原始类型,字面量是由双引号（"）或单引号（'）声明的,没有字符类型概念.String 类型还包括几种字符字面量,像转义字符.

ECMAScript提供了typeof 运算符来判断一个值或变量是否在某种类型的范围内。可以用这个运算符判断一个值或者变量是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。
typeof 运算符有一个参数，就是要检查的变量或值
例如: typeof  变量或值


对变量或值调用 typeof 运算符将返回下列值之一：
undefined - 如果变量是 Undefined 类型的
boolean - 如果变量是 Boolean 类型的
number - 如果变量是 Number 类型的
string - 如果变量是 String 类型的
object - 如果变量是一种引用类型或 Null 类型的
注意：您也许会问，为什么 typeof 运算符对于 null 值会返回 "Object"。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。

引用类型
引用类型通常叫做类(class),也就是说，遇到引用值，所处理的就是对象。从传统意义上来说，ECMAScript 并不真正具有类。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。对象是由 new 运算符加上要实例化的对象的名字创建的
var obj=new Object();
Object对象自身用处不大，但是 ECMAScript 中的 Object 对象与 Java 中的 java.lang.Object 相似，ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中
常用的javascript对象有 Boolean,Number,Array,String,Date,Math,RegExp.可以使用instanceof运算符来判断对象的类型。
5.js基础-类型转换
ECMAScript为开发者提供了大量的类型转换方法。大部分类型具有进行简单转换的方法，还有几个全局方法可以用于更复杂的转换。布尔值、数字和字符串的原始值它们是伪对象，这意味着它们实际上具有属性和方法。
转换成字符串
toString()方法.
例如:
true.toString();  9.9.toString();
注意:
null和undefined类型,调用toString()会出错.
10.toString()也会报错
转换成数字
ECMAScript 提供了两种把非数字的原始值转换成数字的方法，即 parseInt() 和 parseFloat()。前者尝试着把值转换成整数，后者尝试这把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。
例如:
alert(parseInt(“9.9”));//9
alert(typeof parseInt(“9.9”));	//number

alert(parseFloat(“9.9.8hello”)); //9.9
alert(typeof parseFloat(“9.9.8hello”)); //number
强制类型转换
使用强制类型转换可以访问特定的值。ECMAScript 中提供了三种强制类型转换：
把给定的值转换成Boolean类型
把给定的值转换成数字
把给定的值转换成字符串

测试Boolean型的强制类型转换
alert(Boolean(undefined));

alert(Boolean(null));
alert(Boolean(new Object));

alert(Boolean(""));
alert(Boolean("hello"));

alert(Boolean(0));
alert(Boolean(2));

alert(Boolean(NaN));//false
非空对象,非空字符串,非零数字结果都为true;其余为false

测试强制转换成数字类型
alert(Number(""));//
alert(Number(" "));//
alert(Number("9"));//
alert(Number("9.9"));//
alert(Number(null));//
alert(Number(true));//
alert(Number(false));//

alert(Number("9kuai9"));//
alert(Number("chaoshi"));//
alert(Number(new Object()));//
alert(Number(undefined));//
测试强制转换成字符串
alert(String(null));
alert(String(undefined));
alert(String(50));
alert(String(true));
6.js基础-运算符与表达式
ECMAScript 运算符分类：
一元运算符
位运算符
逻辑运算符
算术运算符
关系运算符
等性运算符
条件运算符(三目)
赋值运算符
逗号运算符

一元运算符
delete 
delete 运算符删除对以前定义的对象属性或方法的引用。
面对对象中可能使用，在JS框架有涉及，一般情况下不使用。
例如：
var o = new Object;
o.name = "David";
alert(o.name);	//输出 "David"
delete o.name;
alert(o.name);	//输出 "undefined"
注意：delete 运算符不能删除开发者未定义的属性和方法。
	例如，下面的代码将引发错误：delete o.toString;
void (函数时使用)
void 运算符对任何值返回 undefined。该运算符通常用于避免输出不应该输出的值，例如，从 HTML 的 <a> 元素调用 JavaScript 函数时。要正确做到这一点，函数不能返回有效值，否则浏览器将清空页面，只显示函数的结果
需求：点击超链接，打开一个新的窗口
正确编写：
<a href="javascript:void(window.open('about:blank'))">Click me</a>

错误编写：
<a href="javascript:window.open('about:blank')">Click me</a>
现象：点击链接，屏幕上显示 "[object]"。
分析：window.open() 方法返回了新打开的窗口的引用。然后该对象将被转换成要显示的字符串
++和--
一元加法和一元减法
一元加法数字无任何影响：
var iNum = 20;
iNum = +iNum;
alert(iNum);	//输出 "20"
但对字符串却有有趣的效果，会把字符串转换成数字。
var sNum = "20";
alert(typeof sNum);	//输出 "string"
var iNum = +sNum;
alert(typeof iNum);	//输出 "number"
当一元加法运算符对字符串进行操作时，它计算字符串的方式与 parseInt() 相似，主要的不同是只有对以 "0x" 开头的字符串（表示十六进制数字），一元运算符才能把它转换成十进制的值。因此，用一元加法转换 "010"，得到的总是 10，而 "0xB" 将被转换成 11。
一元减法就是对数值求负（例如把 20 转换成 -20）：
var iNum = 20;
iNum = -iNum;
alert(iNum);	//输出 "-20"

位运算符 
| & ~ >> >>> <<
ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。在 ECMAScript 中，所有整数字面量默认都是有符号整数(32位).和java基本一样.
逻辑运算符 &&  ||  !


! (not运算符)
!运算符返回的一定是 Boolean 值。
!运算符的行为如下：
		如果运算数是对象，返回 false 
		如果运算数是数字 0，返回 true 
		如果运算数是 0 以外的任何数字，返回 false 
		如果运算数是 null，返回 true 
		如果运算数是 NaN，返回 true 
		如果运算数是 undefined，返回true

&&
&&运算的运算数可以是任何类型的.
如果运算数都是boolean类型,和java一样。
如果某个运算数不是原始的 Boolean 型值，&&运算并不一定返回 Boolean 值
	例如:
alert(false&&"abc");//
alert(true&&"abc");	//
alert("abc"&&true);	//
alert("abc"&&false);//
alert("abc"&&"bcd");//
alert(null&&true);//
alert(NaN && true);//
alert(NaN&&null);//
alert(null&&NaN);//
alert(undefined&&true);//	
alert(false&&undefined);//
alert(undefined&&undefined);//
结论:
一旦前面的表达式能确定了最终结果,那么最终的结果,就是能这个表达式的结果,后面的表达式也不再进行运算了.否则,最终结果为最后面这个表达式的结果.

||
||运算的运算数可以是任何类型的，
如果都是boolean类型,和java一样。
如果某个运算数不是原始的 Boolean 型值，||运算并不一定返回 Boolean 值
例如:
alert(false||"abc");//	
alert(true||"abc");//		
alert("abc"||false);//	
alert("abc"||true);	//
alert("abc"||"bcd");//
alert(null||false);	//	
alert(null||true);	//	
alert(null||undefined);//
alert(undefined||null);//	
alert(undefined||undefined);//
alert(NaN||true);//
alert(NaN||false);//
alert(NaN||NaN);//
alert(NaN||null);//
结论:
一旦前面的表达式能确定了最终结果,那么最终的结果,就是能这个表达式的结果,后面的表达式也不再进行运算了.否则,最终结果为最后面这个表达式的结果.
算术运算符
+-*/% 与java基本相同

加法特殊行为
某个运算数是 NaN，那么结果为 NaN。 
-Infinity 加 -Infinity，结果为 -Infinity。 
Infinity 加 -Infinity，结果为 NaN。 
+0 加 +0，结果为 +0。 
-0 加 +0，结果为 +0。 
-0 加 -0，结果为 -0。 
不过，如果某个运算数是字符串，那么采用下列规则：
	如果两个运算数都是字符串，把第二个字符串连接到第一个上。 
	如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。
减法特殊行为
某个运算数是 NaN，那么结果为 NaN。 
-Infinity 减 Infinity，结果为 NaN。 
-Infinity 减 -Infinity，结果为 NaN。 
Infinity 减 -Infinity，结果为 Infinity。 
-Infinity 减 Infinity，结果为 -Infinity。 
+0 减 +0，结果为 +0。 
-0 减 -0，结果为 -0。 
+0 减 -0，结果为 +0。 
某个运算符不是数字，那么结果为 NaN。
乘法特殊行为
如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。 
如果某个运算数是 NaN，结果为 NaN。 
Infinity 乘以 0，结果为 NaN。 
Infinity 乘以 0 以外的任何数字，结果为 Infinity 或 -Infinity。 
Infinity 乘以 Infinity，结果为 Infinity。
除法特殊行为
如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。 
如果某个运算数是 NaN，结果为 NaN。 
Infinity 被 Infinity 除，结果为 NaN。 
Infinity 被任何数字除，结果为 Infinity。 
0 除一个任何非无穷大的数字，结果为 NaN。 
Infinity 被 0 以外的任何数字除，结果为 Infinity 或 -Infinity。
取模（余）特殊行为
如果被除数是 Infinity，或除数是 0，结果为 NaN。 
Infinity 被 Infinity 除，结果为 NaN。 
如果除数是无穷大的数，结果为被除数。 
如果被除数为 0，结果为 0。
关系运算符
关系运算符有>,<, >=, <= ,它们的运算结果返回的是一个boolean值
数字比较:	和java一样
字符串比较:	ASCII大小进行比较,区分大小写
字符串形式的数字和数字比较:	字符串数字转成数字,然后比较大小
字符串和数字比较:	字符串无法转成数字,字符串将转成NaN,最终结果为false

等性运算符
在 ECMAScript 中，等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。为确定两个运算数是否相等，这两个运算符都会进行类型转换。
规则:
值 null 和 undefined 相等。 
在检查相等性时，不能把 null 和 undefined 转换成其他值。 
如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 
如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 
即使两个数都是 NaN，等号仍然返回 false，因为根据规则，NaN 不等于 NaN
如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 
如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 
如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 
如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。

例如:
alert(null == undefined)	//
alert("NaN" == NaN) //
alert(5 == NaN) //
alert(NaN == NaN)	// 
alert(NaN != NaN)//	 
alert(false == 0)//	 
alert(true == 1)	//	 
alert(true == 2)	// 
alert(undefined == 0)	// 
alert(null == 0)	 //
alert("5" == 5)//
alert("5" === 5)//
alert("5" === "5")//


全等号和非全等号
	两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。
全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。
例如:
var sNum = "66";
var iNum = 66;
alert(sNum == iNum);	
alert(sNum === iNum);	

非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。
var sNum = "66";
var iNum = 66;
alert(sNum != iNum);	//输出 "false"
alert(sNum !== iNum);	//输出 "true"

条件运算符(三目运算符)
和java中相同
赋值运算符 
= += -= *= /=等和java中相同
逗号运算符
用逗号运算符可以在一条语句中执行多个运算。
var iNum1 = 1, iNum = 2, iNum3 = 3;
逗号运算符常用变量声明中。



7.js基础-条件语句
if语句
javascrip中的if语句，与我们在java中使用基本相同，
例如:
if (i > 30) {
alert("大于 30");
}else {
alert("小于等于 30");
}

switch语句
switch语句也与我们在jdk1.7中使用基本相同，它可以直接判断字符串类型,case后面可以跟变量.
例如:
var BLUE = "blue", RED = "red", GREEN  = "green";
switch (sColor) {
  case BLUE: alert("Blue");
    break;
  case RED: alert("Red");
    break;
  case GREEN: alert("Green");
    break;
  default: alert("Other");
}


8.js基础-循环语句
在javascript中也存在循环语句for while do-while，基本与在java中使用相同.
for示例
var iCount = 6;
for (var i = 0; i < iCount; i++) {
  alert(i);
}
注意:在声明变量归我们使用var
	
while示例
var i = 0;
while (i < 10) {
  i += 2;
}

do-while示例
var i = 0;
do {
i += 2;
} while (i < 10);
注意:在while后面的分号



css & javascript
三.CSS
1.CSS介绍
CSS 指层叠样式表 (Cascading Style Sheets),用来定义网页的显示效果。

把样式添加到HTML中，可以将网页内容与显示相分离。(可以解决html代码对样式定义的重复，提高了后期样式代码的可维护性，并增强了网页的显示效果功能。)
外部样式表通常存储在 CSS 文件中,可以极大提高工作效率
一个HTML元素可以被不同位置的样式进行修饰，多个样式根据一定规则层叠为一个
2.CSS书写规则
基本语法 
Css规则主要由两部分组成 1.选择器 2.一条或多条声明
c.选择器主要作用是为了确定需要改变样式的HTML元素
d.每一条声明由一个属性和一个值组成，使用花括号来包围声明，属性与值之间使用冒号(:)分开,多条声明用分号(;)隔开.
如图:

值的单位


书写注意事项
如果值为若干单词，则要给值加引号
多个声明之间使用分号(;)分开
class与id名称对大小写敏感,其他属性对大小写不敏感

选择器{
属性1:值1;
属性2:”Times new roma”;
属性3:值31 值32;
}
3.导入CSS
内联样式表
用法:
在相关的标签内使用样式（style）属性。style 属性可以包含任何 CSS 属性
例如:
<div style="border:1px solid #ff0000">div内联样式表</div>

注意:
该方式比较灵活，但是对于多个相同标签的同一样式定义比较麻烦，适合局部修改。
内部样式表
用法:
在head标签中加入style标签，然后在style的标签体中再对多个标签的样式进行修改。
例如:
<style type="text/css">
div{
border:1px dashed #ff00ff;
}
</style>
注意:
这种方式只适用于当前页面
外部样式表
用法:
3.css文件,文件里存放的都是样式
例如:
myStyle.css文件里有如下内容
span{
	border: 10px double #0000ff
}
4.通过head标签里的link标签,导入myStyle.css文件
例如:
<link rel="stylesheet" href="myStyle.css" type="text/css">
@import导入
这种方式也是外部导入。
用法：
1.css文件,文件里存放的都是样式
例如:
myStyle.css文件里有如下内容
span{
	border: 10px double #0000ff
}

3.在head标签中加入style标签，然后通过style标签导入
<style type="text/css">
		@import "myStyle2.css";
	</style>
注意:
关于@import与引用外部样式表的区别:
	1.@import这种方式导入的css，会在整个页面加载后，才会加载样式。如果网络不好情况下，会先看到无样式修饰的页面，闪烁一下后，才会看到有样式修饰的页面。而使用外部样式表，会先装载样式表，这样看到的就是有样式修饰的页面。
3.@import不支持通过javascript修改样式，而link支持。

优先级问题
	最近原则:不同的导入方式中,如果有属性一样的样式,那个方式离此html元素近就用那种方式定义的样式.

4.CSS选择器
css选择器主要是用于选择需要添加样式的html元素。对于css来说，它的选择器有很多，我们主要介绍以下几种:
id选择器
要求:
html中的标签有id属性,并且有值.例如 <xxx id=”y1”>
css中使用#引入，它引用的是id属性中的值.例如 #y1{...}
类选择器
要求:
html中的标签有class属性,并且有值.例如 <xxx class=”yy1”>
css中使用.引入，它引用的是class属性中的值.例如 .yy1{...}
元素选择器
这是最常见的选择器，简单说，文档中的元素就是选择器.例如:div{...}
属性选择器
要求:
html的标签中必须有某个属性，不论属性是什么 例如 <input type=”text”>
css中定义时候使用 标签名[属性=属性值] 例如 input[type=”text”]{...}
伪类
css伪类用于向某些选择器添加特殊效果。
下面我们介绍一下锚伪类。
在支持css的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。

a:link {color: #FF0000}	/* 未访问的链接 */
a:visited {color: #00FF00}	/* 已访问的链接 */
a:hover {color: #FF00FF}	/* 鼠标移动到链接上 */
a:active {color: #0000FF}	/* 选定的链接 */
注意:
在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。
在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。
伪类名称对大小写不敏感。


5.CSS属性
字体
Css字体属性定义文本的字体系列，大小，加粗，风格(如斜体)和变形(如小型大写字母)
常用属性:
font:简写属性，作用是把所有针对字体的属性设置在一个声明中。
格式：{font :风格 异体 粗细 尺寸/行间距 字体系列}
例如：{ font: italic bold 12px/20px arial,sans-serif}
font-family:定义字体系列
具体字体的名称，例如：font-family:隶书。 
通常字体系列名称：例如 font-family:"serif","sans-serif","cursive","fantasy","monospace"
“,”的意思是指如果本地没有该字体系列，再使用下一个
font-size:定义字体的尺寸 例如 font-size:40px
font-style:定义字体风格 例如 font-style:italic

文本
CSS 文本属性可定义文本的外观。通过文本属性，您可以改变文本的颜色、字符间距，对齐文本，装饰文本，对文本进行缩进，等等.
常用属性
color:定义文本颜色  例如 color:#ffff00
text-align:定义文本对齐方式 例如:text-align:center
      text-decoration 向文本添加修饰。例如text-decoration:underline(下划线)
letter-spacing:定义字符间隔 
word-spacing:定义字间隔

背景
CSS 允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果。CSS 在这方面的能力远远在 HTML 之上。
常用属性:
background:简写属性，作用是将背景属性设置在一个声明中
格式：{background: 颜色 url(图片路径) 重复 滚动 位置}
例如:  {background: #00FF00 url(bgimage.gif) no-repeat fixed top}

background-color:定义背景颜色
background-image:定义背景图片  background-image:url(xx.jpg) 
background-position:定义背景图片的起始位置 background-position:10% 5%;
background-repeat:定义背景图片是否重复及如何重复 background-repeat:no-repeat
尺寸
CSS 尺寸 (Dimension) 属性允许你控制元素的高度和宽度。
常用属性:
width:设置元素的宽度
height:设置元素的高度		 
列表
CSS 列表属性允许你放置、改变列表项标志，或者将图像作为列表项标志。
常用属性:
list-style:简写属性。用于把所有用于列表的属性设置于一个声明中。
格式:{list-style : 图片 类型 位置}
例如:{list-style : url(liebiao.jpg) square inside}
      list-style-type:定义列表项标志的类型
  list-style-position:定义列表项标志的位置  常用值:inside ,outside
  list-style-image:定义列表项标志为图象

表格
CSS 表格属性可以帮助您极大地改善表格的外观
	  常用属性:
border-collapse:定义是否把表格边框合并为单一的边框。常用值:collapse,separate
border-spacing:定义分隔单元格边框的距离
caption-side:定义表格标题的位置		常用值:top,bottom
轮廓
轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。
CSS outline 属性规定元素轮廓的样式、颜色和宽度。
常用属性:
outline:在一个声明中设置所有的轮廓属性
格式:{outline:颜色 样式 宽度}
例如:{outline:#00FF00 dotted thick;}
      outline-style:定义轮廓的样式  常用值:solid(实线) ,dashed(虚线) ,double(双线)...
outline-color:定义轮廓的颜色
outline-width:定义轮廓的宽度 常用值:thin ,thick ,14px...


定位
CSS 定位 (Positioning) 属性允许你对元素进行定位。
定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置
常用属性:
position:把元素放置到一个静态的,相对的，绝对的，或固定的位置中。
absolute:绝对 相对于父元素
		relative:相对  相对于自己应该出现的位置
		fixed:相对于浏览器
top:定义了定位元素的上外边距边界与其包含块上边界之间的偏移量
right: 定义了定位元素右外边距边界与其包含块右边界之间的偏移
left: 定义了定位元素左外边距边界与其包含块左边界之间的偏移
bottom: 定义了定位元素下外边距边界与其包含块下边界之间的偏移。

分类
CSS 分类属性允许你控制如何显示元素，设置图像显示于另一元素中的何处，相对于其正常位置来定位元素，使用绝对值来定位元素，以及元素的可见度。
 常用属性
 float:定义元素在哪个方向浮动
 clear:设置一个元素的侧面是否允许其它的浮动元素
 cursor:当指向某元素之上时显示的指针类型
 display:定义是否显示及如何显示元素	  常用值 none和inline   消失
 visibility:定义元素是否可见或不可见。	 常用值 hidden和visible	占位隐藏
6.CSS框模型
盒子模型
CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。


元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素

边框
元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。
CSS border 属性允许你规定元素边框的样式、宽度和颜色。
  	常用属性:
	border:简写属性，用于把针对于四个边的属性设置在一个声明。
格式:{border:宽度 样式 颜色}
例如:{border:1px solid red;}
	border-color:简写属性，定义元素边框中可见部分的颜色，或为四个边分别设置颜色。
	border-style:用于定义所有边框的样式，或者单独为各边设置边框样式。
	border-width:简写属性，用于为元素的所有边框设置宽度，或则单独地为各边边框设置宽度
	border-top:简写属性，用于把上边框的所有属性设置到一个声明中
	border-right:简写属性，用于把右边框所有属性设置到一个声明中
	border-bottom:简写属性，用于把下边框的所有属性设置到一个声明中
	border-left:简写属性，用于把左边框的所有属性设置到一个声明中。

外边距
围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。
设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。
常用属性:
margin:简写属性，在一个声明中设置所有外边距属性
margin-top:定义元素的上外边距
margin-right:定义元素的右外边距
margin-bottom:定义元素的下外边距
margin-left定义元素的左外边距

注意:在使用margin来定义所有外边距时，可以使用值复制。
	如果缺少左外边距的值，则使用右外边距的值。
	如果缺少下外边距的值，则使用上外边距的值。
	如果缺少右外边距的值，则使用上外边距的值。


内边距
元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。
CSS padding 属性定义元素边框与元素内容之间的空白区域。
常用属性:
	padding:简写属性，作用是在一个声明中设置元素的所有内边距属性
	padding-top:定义元素的上内边距
	padding-right:定义元素的右内边距
	padding-bottom:定义元素的下内边距
	padding-left:定义元素的左内边距。
四.javaScript
1.javaScript介绍
1992 年，Nombas 公司开发 C 减减（C-minus-minus，简称 Cmm）的嵌入式脚本语言，后更名为ScriptEase。
1995 年 Netscape网景公司的Brendan Eich，开发Netscape Navigator 2.0浏览器内置的 LiveScript脚本语言，Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript
同时，微软进军浏览器，发布了 IE 3.0 并搭载了一个 JavaScript 的克隆版，叫做 JScript
3 种不同的 JavaScript 版本同时存在。1997 年，第 39 技术委员会（TC39）推出 ECMA-262标准，该标准定义了名为 ECMAScript 的全新脚本语言。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。
ECMAScript 仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。其他语言可以实现 ECMAScript 来作为功能的基准，JavaScript 就是这样(简称js)：

js组成:
一个完整的js实现是由下面三个不同部分组成的:
ECMAScript (js的核心,描述了js的基础语法和基本对象)
DOM(文件对象模型)
BOM(浏览器对象模型)

:

js简介:
javaScript是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。
脚本语言：脚本语言又被称为扩建的语言，或者动态语言，是一种解释型语言，由解释器来运行，用来控制软件应用程序，脚本通常以文本保存，只在被调用时进行解释或编译
javaScript是可插入 HTML 页面的编程代码,可由所有的现代浏览器执行。
javaScript与 Java 是两种完全不同的语言
JavaScript是Netscape公司的产品，前身是LiveScript；Java是Sun公司的产品，现在是Oracle公司的产品。
JavaScript是基于对象，Java是面向对象。
JavaScript只需解释就可以执行，Java需要先编译成字节码文件，再执行
JavaScript是弱类型，Java是强类型。
JavaScript与java一样都区分大小写


js作用: 
通过js可以改变html内容,改变html样式,进行验证输入等。


2.导入js
在html页面中直接插入javascript
在<script> 和 </script> 之间的编写JavaScript代码.
格式:
<script type=”text/javascript”>
js代码
</script>
老旧的实例可能会在 <script> 标签中使用 type="text/javascript"。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言。
引入外部的javascript
有时，我们希望在若干个页面中运行JavaScript，同时不在每个页面中写相同的脚本。
我们就可以将 JavaScript 写入一个外部文件之中。然后以 .js 为后缀保存这个文件。然后通过<script type=”text/javascript”>标签的src属性引入.
格式:
<script type=”text/javascript” src=”外部js路径”></script>
注意:
<script>存放的位置.一般建议放在<head>标签体中.由于js是解释性语言,
外部的js文件中不能包含<script>标签。
<script>标签如果使用了src属性,标签体内的代码不再解析.
3.js基础-变量声明
javascript中的变量与我们在java中的变量一样。
在javascript中使用用 var 运算符（variable 的缩写）加变量名定义
格式:
var 变量名 =初始化值;
var 变量名;
变量名=初始化值;
	
javascript 变量名称的规则和我们java中的规则一样：
变量必须以字母 ,下划线或者$开始 
区分大小写
不能是关键字
见名知意(js是弱类型,因此整数类型建议iXxx,boolean类型建议bXxx ,数组建议 aXxx等等)

注意:
3.变量声明不是必须的.
4.变量如果要声明,var可以省略,建议不要省略
3.每行结尾的分号可有可无,有的浏览器不兼容,建议不要省略
4.js基础-数据类型
在ECMAScript中，变量可以存在两种数据类型，即原始类型与引用类型。
原始类型
ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String.

我们先来了解下这5中原始类型.
Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。当函数无明确返回值时，返回的也是值 "undefined".
Null类型也只有一个值 null，即它的字面量。值undefined实际上是从值null派生来的，因此 ECMAScript 把它们定义为相等的。例如：alert(null == undefined); 输出"true"
Boolean 类型有两个值 true 和 false.
Number 类型,在js中任何数字都看成是Number类型,不论整数,还是浮点数,当然表示八进制首数字必须是0,十六进制使用0x开始等.数字的最大值:Number.MAX_VALUE,数字的最小值:Number.MIN_VALUE.
String类型是唯一没有固定大小的原始类型,字面量是由双引号（"）或单引号（'）声明的,没有字符类型概念.String 类型还包括几种字符字面量,像转义字符.

ECMAScript提供了typeof 运算符来判断一个值或变量是否在某种类型的范围内。可以用这个运算符判断一个值或者变量是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。
typeof 运算符有一个参数，就是要检查的变量或值
例如: typeof  变量或值


对变量或值调用 typeof 运算符将返回下列值之一：
undefined - 如果变量是 Undefined 类型的
boolean - 如果变量是 Boolean 类型的
number - 如果变量是 Number 类型的
string - 如果变量是 String 类型的
object - 如果变量是一种引用类型或 Null 类型的
注意：您也许会问，为什么 typeof 运算符对于 null 值会返回 "Object"。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。

引用类型
引用类型通常叫做类(class),也就是说，遇到引用值，所处理的就是对象。从传统意义上来说，ECMAScript 并不真正具有类。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。对象是由 new 运算符加上要实例化的对象的名字创建的
var obj=new Object();
Object对象自身用处不大，但是 ECMAScript 中的 Object 对象与 Java 中的 java.lang.Object 相似，ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中
常用的javascript对象有 Boolean,Number,Array,String,Date,Math,RegExp.可以使用instanceof运算符来判断对象的类型。
5.js基础-类型转换
ECMAScript为开发者提供了大量的类型转换方法。大部分类型具有进行简单转换的方法，还有几个全局方法可以用于更复杂的转换。布尔值、数字和字符串的原始值它们是伪对象，这意味着它们实际上具有属性和方法。
转换成字符串
toString()方法.
例如:
true.toString();  9.9.toString();
注意:
null和undefined类型,调用toString()会出错.
10.toString()也会报错
转换成数字
ECMAScript 提供了两种把非数字的原始值转换成数字的方法，即 parseInt() 和 parseFloat()。前者尝试着把值转换成整数，后者尝试这把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。
例如:
alert(parseInt(“9.9”));//9
alert(typeof parseInt(“9.9”));	//number

alert(parseFloat(“9.9.8hello”)); //9.9
alert(typeof parseFloat(“9.9.8hello”)); //number
强制类型转换
使用强制类型转换可以访问特定的值。ECMAScript 中提供了三种强制类型转换：
把给定的值转换成Boolean类型
把给定的值转换成数字
把给定的值转换成字符串

测试Boolean型的强制类型转换
alert(Boolean(undefined));

alert(Boolean(null));
alert(Boolean(new Object));

alert(Boolean(""));
alert(Boolean("hello"));

alert(Boolean(0));
alert(Boolean(2));

alert(Boolean(NaN));//false
非空对象,非空字符串,非零数字结果都为true;其余为false

测试强制转换成数字类型
alert(Number(""));//
alert(Number(" "));//
alert(Number("9"));//
alert(Number("9.9"));//
alert(Number(null));//
alert(Number(true));//
alert(Number(false));//

alert(Number("9kuai9"));//
alert(Number("chaoshi"));//
alert(Number(new Object()));//
alert(Number(undefined));//
测试强制转换成字符串
alert(String(null));
alert(String(undefined));
alert(String(50));
alert(String(true));
6.js基础-运算符与表达式
ECMAScript 运算符分类：
一元运算符
位运算符
逻辑运算符
算术运算符
关系运算符
等性运算符
条件运算符(三目)
赋值运算符
逗号运算符

一元运算符
delete 
delete 运算符删除对以前定义的对象属性或方法的引用。
面对对象中可能使用，在JS框架有涉及，一般情况下不使用。
例如：
var o = new Object;
o.name = "David";
alert(o.name);	//输出 "David"
delete o.name;
alert(o.name);	//输出 "undefined"
注意：delete 运算符不能删除开发者未定义的属性和方法。
	例如，下面的代码将引发错误：delete o.toString;
void (函数时使用)
void 运算符对任何值返回 undefined。该运算符通常用于避免输出不应该输出的值，例如，从 HTML 的 <a> 元素调用 JavaScript 函数时。要正确做到这一点，函数不能返回有效值，否则浏览器将清空页面，只显示函数的结果
需求：点击超链接，打开一个新的窗口
正确编写：
<a href="javascript:void(window.open('about:blank'))">Click me</a>

错误编写：
<a href="javascript:window.open('about:blank')">Click me</a>
现象：点击链接，屏幕上显示 "[object]"。
分析：window.open() 方法返回了新打开的窗口的引用。然后该对象将被转换成要显示的字符串
++和--
一元加法和一元减法
一元加法数字无任何影响：
var iNum = 20;
iNum = +iNum;
alert(iNum);	//输出 "20"
但对字符串却有有趣的效果，会把字符串转换成数字。
var sNum = "20";
alert(typeof sNum);	//输出 "string"
var iNum = +sNum;
alert(typeof iNum);	//输出 "number"
当一元加法运算符对字符串进行操作时，它计算字符串的方式与 parseInt() 相似，主要的不同是只有对以 "0x" 开头的字符串（表示十六进制数字），一元运算符才能把它转换成十进制的值。因此，用一元加法转换 "010"，得到的总是 10，而 "0xB" 将被转换成 11。
一元减法就是对数值求负（例如把 20 转换成 -20）：
var iNum = 20;
iNum = -iNum;
alert(iNum);	//输出 "-20"

位运算符 
| & ~ >> >>> <<
ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。在 ECMAScript 中，所有整数字面量默认都是有符号整数(32位).和java基本一样.
逻辑运算符 &&  ||  !


! (not运算符)
!运算符返回的一定是 Boolean 值。
!运算符的行为如下：
		如果运算数是对象，返回 false 
		如果运算数是数字 0，返回 true 
		如果运算数是 0 以外的任何数字，返回 false 
		如果运算数是 null，返回 true 
		如果运算数是 NaN，返回 true 
		如果运算数是 undefined，返回true

&&
&&运算的运算数可以是任何类型的.
如果运算数都是boolean类型,和java一样。
如果某个运算数不是原始的 Boolean 型值，&&运算并不一定返回 Boolean 值
	例如:
alert(false&&"abc");//
alert(true&&"abc");	//
alert("abc"&&true);	//
alert("abc"&&false);//
alert("abc"&&"bcd");//
alert(null&&true);//
alert(NaN && true);//
alert(NaN&&null);//
alert(null&&NaN);//
alert(undefined&&true);//	
alert(false&&undefined);//
alert(undefined&&undefined);//
结论:
一旦前面的表达式能确定了最终结果,那么最终的结果,就是能这个表达式的结果,后面的表达式也不再进行运算了.否则,最终结果为最后面这个表达式的结果.

||
||运算的运算数可以是任何类型的，
如果都是boolean类型,和java一样。
如果某个运算数不是原始的 Boolean 型值，||运算并不一定返回 Boolean 值
例如:
alert(false||"abc");//	
alert(true||"abc");//		
alert("abc"||false);//	
alert("abc"||true);	//
alert("abc"||"bcd");//
alert(null||false);	//	
alert(null||true);	//	
alert(null||undefined);//
alert(undefined||null);//	
alert(undefined||undefined);//
alert(NaN||true);//
alert(NaN||false);//
alert(NaN||NaN);//
alert(NaN||null);//
结论:
一旦前面的表达式能确定了最终结果,那么最终的结果,就是能这个表达式的结果,后面的表达式也不再进行运算了.否则,最终结果为最后面这个表达式的结果.
算术运算符
+-*/% 与java基本相同

加法特殊行为
某个运算数是 NaN，那么结果为 NaN。 
-Infinity 加 -Infinity，结果为 -Infinity。 
Infinity 加 -Infinity，结果为 NaN。 
+0 加 +0，结果为 +0。 
-0 加 +0，结果为 +0。 
-0 加 -0，结果为 -0。 
不过，如果某个运算数是字符串，那么采用下列规则：
	如果两个运算数都是字符串，把第二个字符串连接到第一个上。 
	如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。
减法特殊行为
某个运算数是 NaN，那么结果为 NaN。 
-Infinity 减 Infinity，结果为 NaN。 
-Infinity 减 -Infinity，结果为 NaN。 
Infinity 减 -Infinity，结果为 Infinity。 
-Infinity 减 Infinity，结果为 -Infinity。 
+0 减 +0，结果为 +0。 
-0 减 -0，结果为 -0。 
+0 减 -0，结果为 +0。 
某个运算符不是数字，那么结果为 NaN。
乘法特殊行为
如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。 
如果某个运算数是 NaN，结果为 NaN。 
Infinity 乘以 0，结果为 NaN。 
Infinity 乘以 0 以外的任何数字，结果为 Infinity 或 -Infinity。 
Infinity 乘以 Infinity，结果为 Infinity。
除法特殊行为
如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。 
如果某个运算数是 NaN，结果为 NaN。 
Infinity 被 Infinity 除，结果为 NaN。 
Infinity 被任何数字除，结果为 Infinity。 
0 除一个任何非无穷大的数字，结果为 NaN。 
Infinity 被 0 以外的任何数字除，结果为 Infinity 或 -Infinity。
取模（余）特殊行为
如果被除数是 Infinity，或除数是 0，结果为 NaN。 
Infinity 被 Infinity 除，结果为 NaN。 
如果除数是无穷大的数，结果为被除数。 
如果被除数为 0，结果为 0。
关系运算符
关系运算符有>,<, >=, <= ,它们的运算结果返回的是一个boolean值
数字比较:	和java一样
字符串比较:	ASCII大小进行比较,区分大小写
字符串形式的数字和数字比较:	字符串数字转成数字,然后比较大小
字符串和数字比较:	字符串无法转成数字,字符串将转成NaN,最终结果为false

等性运算符
在 ECMAScript 中，等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。为确定两个运算数是否相等，这两个运算符都会进行类型转换。
规则:
值 null 和 undefined 相等。 
在检查相等性时，不能把 null 和 undefined 转换成其他值。 
如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 
如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 
即使两个数都是 NaN，等号仍然返回 false，因为根据规则，NaN 不等于 NaN
如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 
如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 
如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 
如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。

例如:
alert(null == undefined)	//
alert("NaN" == NaN) //
alert(5 == NaN) //
alert(NaN == NaN)	// 
alert(NaN != NaN)//	 
alert(false == 0)//	 
alert(true == 1)	//	 
alert(true == 2)	// 
alert(undefined == 0)	// 
alert(null == 0)	 //
alert("5" == 5)//
alert("5" === 5)//
alert("5" === "5")//


全等号和非全等号
	两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。
全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。
例如:
var sNum = "66";
var iNum = 66;
alert(sNum == iNum);	
alert(sNum === iNum);	

非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。
var sNum = "66";
var iNum = 66;
alert(sNum != iNum);	//输出 "false"
alert(sNum !== iNum);	//输出 "true"

条件运算符(三目运算符)
和java中相同
赋值运算符 
= += -= *= /=等和java中相同
逗号运算符
用逗号运算符可以在一条语句中执行多个运算。
var iNum1 = 1, iNum = 2, iNum3 = 3;
逗号运算符常用变量声明中。



7.js基础-条件语句
if语句
javascrip中的if语句，与我们在java中使用基本相同，
例如:
if (i > 30) {
alert("大于 30");
}else {
alert("小于等于 30");
}

switch语句
switch语句也与我们在jdk1.7中使用基本相同，它可以直接判断字符串类型,case后面可以跟变量.
例如:
var BLUE = "blue", RED = "red", GREEN  = "green";
switch (sColor) {
  case BLUE: alert("Blue");
    break;
  case RED: alert("Red");
    break;
  case GREEN: alert("Green");
    break;
  default: alert("Other");
}


8.js基础-循环语句
在javascript中也存在循环语句for while do-while，基本与在java中使用相同.
for示例
var iCount = 6;
for (var i = 0; i < iCount; i++) {
  alert(i);
}
注意:在声明变量归我们使用var
	
while示例
var i = 0;
while (i < 10) {
  i += 2;
}

do-while示例
var i = 0;
do {
i += 2;
} while (i < 10);
注意:在while后面的分号



js
一.js常用对象 
js中的常见对象有以下几个:
Boolean
Number
String 
Array 数组
Date 日期
Math 数学
RegExp 正则
Global 全局
1．Boolean
Boolean对象描述
在 js中，布尔值是一种基本的数据类型。Boolean 对象是一个将布尔值打包的布尔对象。Boolean 对象主要用于提供将布尔值转换成字符串的 toString() 方法。
Boolean对象创建
Boolean 对象表示两个值："true" 或 "false"。
创建 Boolean 对象的语法：
new Boolean(value);	//构造函数
Boolean(value);		//转换函数
参数
参数 value 由布尔对象存放的值或者要转换成布尔值的值。
返回值
当作为一个构造函数（带有运算符 new）调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的 Boolean 对象。
如果作为一个函数（不带有运算符 new）调用时，Boolean() 只将把它的参数转换成一个原始的布尔值，并且返回这个值。
注意：
如果省略 value 参数，或者设置为 0、-0、null、""、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 "false"）。

2．Number
Number对象描述
在 js中，数字是一种基本的数据类型。js还支持 Number 对象，该对象是原始数值的包装对象。在必要时，js会自动地在原始数据和对象之间转换。
Number对象创建
Number 对象是原始数值的包装对象。
创建 Number 对象的语法：
new Number(value);//返回一个对象
Number(value);//返回一个值
参数
参数 value 是要创建的 Number 对象的数值，或是要转换成数字的值。
返回值
当 Number() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 Number 对象。如果不用 new 运算符，把 Number() 作为一个函数来调用，它将把自己的参数转换成一个原始的数值,并且返回这个值（如果转换失败，则返回 NaN）。
注意:
如果省略 value 参数，或者设置为null、""、”  ”、+0、-0、0、false，则返回0;参数为true则返回1;字符串形式的数字,则返回为转换后的数字,其余的则为NaN.

3．String 
String 对象描述		
字符串是 js的一种基本的数据类型。String 对象的 length 属性声明了该字符串中的字符数。String 类定义了大量操作字符串的方法，例如从字符串中提取字符或子串，或者检索字符或子串。需要注意的是，js的字符串是不可变的（immutable），String 类定义的方法都不能改变字符串的内容。像 String.toUpperCase() 这样的方法，返回的是全新的字符串，而不是修改原始字符串。
String对象创建
String 对象用于处理文本（字符串）。
创建 String 对象的语法：
new String(s);
String(s);
参数
参数 s 是要存储在 String 对象中或转换成原始字符串的值。
返回值
当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。
当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值。
方法:
只列举常用方法,其余方法参考api
获取指定字符
charAt(索引) 返回在指定位置的字符。  
charCodeAt(索引) 返回在指定的位置的字符的 Unicode 编码。
获取索引号
indexOf(检索字符串) 检索字符串。若找到则返回目标字符的索引,否则返回-1 
lastIndexOf(检索字符串) 从后向前搜索字符串。返回目标字符串最后出现位置的索引值,否则返回-1
连接字符串
concat(要连接的字符串) 连接接字符串
截取字符串
substring(开始的索引,结束的索引) 提取字符串中两个指定的索引号之间的字符。
substr(开始的索引,个数) 从起始索引号提取字符串中指定数目的字符。
slice(开始的位置,结束的位置) 提取字符串的片断，并在新的字符串中返回被提取的部分.参数可以为负数.
正则用到的方法(正则对象再讲)
match() 找到一个或多个正在表达式的匹配。 
replace() 替换与正则表达式匹配的子串。  
search() 检索与正则表达式相匹配的值
split() 把字符串分割为字符串数组。

4．Array 
Array 对象用于在单个的变量中存储多个值。
 Array对象创建：
new Array();	
new Array(size);
new Array(element0, element1, ..., elementn);
参数
参数 size 是期望的数组元素个数。返回的数组，length 字段将被设为 size 的值。
参数 element ..., elementn 是参数列表。当使用这些参数来调用构造函数 Array() 时，新创建的数组的元素就会被初始化为这些值。它的 length 字段也会被设置为参数的个数。
返回值
返回新创建并被初始化了的数组。
如果调用构造函数 Array() 时没有使用参数，那么返回的数组为空，length 字段为 0。
当调用构造函数时只传递给它一个数字参数，该构造函数将返回具有指定个数、元素为 undefined 的数组。
当其他参数调用 Array() 时，该构造函数将用参数指定的值初始化数组。
当把构造函数作为函数调用，不使用 new 运算符时，它的行为与使用 new 运算符调用它时的行为完全一样。
方法
只列举常用方法,其余方法参考api
打印数组
join(指定分隔符) 把数组的所有元素通过指定的分隔符进行分隔,以字符串形式输出。
链接数组
concat() 连接两个或更多的值或数组，并返回结果
对结构操作
reverse() 颠倒数组中元素的顺序。 
sort() 对数组的元素进行排序 

对内容操作
pop() 删除并返回数组的最后一个元素 
push() 向数组的末尾添加一个或更多元素，并返回新的长度。 
shift() 删除并返回数组的第一个元素 
unshift() 向数组的开头添加一个或更多元素，并返回新的长度。
5．Date 
Date 对象描述
Date 对象用于处理日期和时间。
创建 Date 对象的语法：
var myDate=new Date();
注意
Date 对象会自动把当前日期和时间保存为其初始值。
方法
只列举常用方法,其余方法参考api
getFullYear() 从 Date 对象以四位数字返回年份。
getMonth() 从 Date 对象返回月份 (0 ~ 11)。
getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。

getHours() 返回 Date 对象的小时 (0 ~ 23)。 
getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 
getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。

getTime() 返回 1970 年 1 月 1 日至今的毫秒数。
toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。

6．Math 
Math对象语法
Math 对象用于执行数学任务。直接使用 Math 的属性和方法的语法：
var pi_value=Math.PI;
var sqrt_value=Math.sqrt(15);
注意
Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。
方法
只列举常用方法,其余方法参考api
ceil(x) 对数进行上舍入。 
	floor(x) 对数进行下舍入。 
	round(x) 把数四舍五入为最接近的整数。
random() 返回 0 ~ 1 之间的随机数。 

7．RegExp 
RegExp对象描述
RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。
RegExp对象创建:
直接量语法
/pattern/attributes
创建 RegExp 对象的语法：
new RegExp(pattern, attributes);
参数
参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。
参数 attributes 是一个可选的字符串，包含属性 "g"、"i" 和 "m"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。
返回值
一个新的 RegExp 对象，具有指定的模式和标志。如果参数 pattern 是正则表达式而不是字符串，那么 RegExp() 构造函数将用与指定的 RegExp 相同的模式和标志创建一个新的 RegExp 对象。
如果不用 new 运算符，而将 RegExp() 作为函数调用，那么它的行为与用 new 运算符调用时一样，只是当 pattern是正则表达式时，它只返回 pattern，而不再创建一个新的 RegExp 对象。
方法:
RegExp 对象方法
test 检索字符串中指定的值。返回 true 或 false。
compile 编译正则表达式。
exec 检索字符串中指定的值。返回找到的值，并确定其位置。 
支持正则表达式的 String 对象的方法
split() 把字符串分割为字符串数组。
replace() 替换与正则表达式匹配的子串。
match() 找到一个或多个正在表达式的匹配。 
search() 检索与正则表达式相匹配的值

8．Global
顶层的函数:
编码:
encodeURI() 把字符串编码为 URI。 
decodeURI() 解码某个编码的 URI。 
encodeURIComponent() 把字符串编码为 URI 组件。 
decodeURIComponent() 解码一个编码的 URI 组件。 
强转
Number() 把对象的值转换为数字。 
String() 把对象的值转换为字符串。 
数字处理
parseFloat() 解析一个字符串并返回一个浮点数。
parseInt() 解析一个字符串并返回一个整数。 
eval执行函数
eval() 将函数参数字符串，当成js程序执行

二.函数
创建函数
在ECMAScript中函数有以下几种创建方式
第一种:
function 	函数名称(参数列表){
函数体;
}
第二种:	
var 函数名称=function(参数列表){
	函数体;
}
第三种:
var 函数名称=new Function(参数列表,函数体);//注意,参数和函数体用引号引起来
调用函数
函数可以通过其名字加上括号中的参数进行调用。

注意:
调用函数的时候参数个数可以不一样.
javascript中有一个特殊的对象arguments,我们可以通过它来获取所有函数中的参数.

函数返回值:
对于javascript来说，我们不必须在创建函数时，来声明其返回值类型，无返回值也不需要使用void来声明,但是，如果一个函数要想返回结果，我们在函数中必须使用return来返回结果,return后面的语句不再执行.如果函数无明确的返回值，或调用了没有参数的 return 语句，那么它真正返回的值是 undefined。
三.事件
事件通常与函数配合使用，这样我们可以通过发生的事件来驱动函数执行.
常见事件:
onblur 元素失去焦点 
onfocus 元素获得焦点 

onclick 鼠标点击某个对象 
ondblclick 鼠标双击某个对象 

onmousedown 某个鼠标按键被按下
onmouseup 某个鼠标按键被松开
onmousemove 鼠标被移动  
onmouseout 鼠标从某元素移开  
onmouseover 鼠标被移到某元素之上  
 

onkeydown 某个键盘的键被按下  
onkeypress 某个键盘的键被按下或按住  
onkeyup 某个键盘的键被松开 

onselect 文本被选定 
onchange 用户改变域的内容
onsubmit 提交按钮被点击 

onload 某个页面或图像被完成加载 

事件绑定
在javascript中事件经常与函数一起使用，那么我们介绍一下怎样将一个事件与函数绑定到一起，简单说，就是某个事件被触发后，函数如果被调用。
1.html事件属性
<input type=”button”  value=”点击” onclick="dianJi()"/>
2.html dom分配事件
<script>
	document.getElementById("myBtn").onclick=ddianJi;
</script>

阻止默认事件(兼容所有浏览器)
if(event&&event.stopPropagation){
	event.preventDefault();
}else{
	window.event.returnValue = false;
}
阻止事件传播(兼容所有浏览器)
if(event&&event.stopPropagation){
	event.stopPropagation();//firefox
}else{
	window.event.cancelBubble = true;//ie
}
四.BOM
介绍
IE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准。
BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括：
弹出新的浏览器窗口
移动、关闭浏览器窗口以及调整窗口大小
提供 Web 浏览器详细信息的定位对象
提供用户屏幕分辨率详细信息的屏幕对象
对 cookie 的支持
IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象,由于没有相关的 BOM 标准，每种浏览器都有自己的 BOM 实现。有一些事实上的标准，如具有一个窗口对象和一个导航对象，不过每种浏览器可以为这些对象或其他对象定义自己的属性和方法。

BOM的五个对象:Window History Location Navigator Screen 
1.Window 
Window 对象表示浏览器中打开的窗口,所有浏览器都支持该对象
如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象
常用属性:
top 最顶层的先辈窗口。 
parent 父窗口。
self 自己
opener 返回对创建此窗口的窗口的引用。 

常用方法:
消息框
alert("文本") ，警告框
confirm("文本")，确认框
		如果用户点击确认，那么返回值为 true。
		如果用户点击取消，那么返回值为 false。
	prompt("文本","默认值")，提示框。
		如果用户点击确认，那么返回值为输入的值。
	如果用户点击取消，那么返回值为 null。
定时器
setInterval(代码或者函数,间隔时间) 按照指定的周期（以毫秒计）来调用函数或计算表达式。
clearInterval() 取消由 setInterval() 设置的 timeout。
setTimeout(代码或者函数,间隔时间) 在指定的毫秒数后调用函数或计算表达式。
clearTimeout() 取消由 setTimeout() 方法设置的 timeout。
注意:参数如果是函数的,两种写法,
1.直接写函数名,不带括弧,例如setInterval(show,1000);
2.用引号引起来函数名加扩花,例如setInterval(“show()”,1000);
窗体
window.open(URL,name,features,replace) 打开一个新的浏览器窗口或查找一个已命名的窗口
 

2.History 
History 对象包含用户（在浏览器窗口中）访问过的 URL。
History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。
常用方法:
back() 加载 history 列表中的前一个 URL。 
forward() 加载 history 列表中的下一个 URL。 
go() 加载 history 列表中的某个具体页面。 

3.Location
Location 对象包含有关当前 URL 的信息。
Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。
对于Location对象，我们只需要掌握href这个属性就可以，它的作用是设置或返回完整的URL。


五.DOM
DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物。
什么是DOM
DOM 是 W3C（万维网联盟） 的推荐标准。
DOM 定义了所有文档元素的对象和属性，以及访问它们的方法（接口）。
DOM 定义了访问诸如 XML 和 XHTML 文档的标准。
“W3C 文档对象模型（DOM）是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口。”
W3C DOM 被分为 3 个不同的部分/级别（parts / levels）：
		核心 DOM，用于任何结构化文档的标准模型
		XML DOM，用于 XML 文档的标准模型
		HTML DOM，用于 HTML 文档的标准模型

HTML DOM 定义了访问和操作HTML文档的标准方法。
HTML DOM 把 HTML 文档呈现为带有元素、属性和文本的树结构（节点树）。



XML DOM与HTML DOM的关系
XML DOM 定义了访问和处理 XML 文档的标准方法 
HTML文档格式 符合XML语法标准，所以可以使用XML DOM API
在XML DOM每个元素 都会被解析为一个节点Node，而常用的节点类型又分为
元素节点  Element
属性节点  Attribute
文本节点  Text
文档节点  Document
HTML DOM定义了针对 HTML文档的对象,可以说是一套更加适用于js技术开发 的API
HTML DOM是对XML DOM的扩展
进行 JavaScript DOM开发 可以同时使用 XML DOM和 HTML DOM

常用的方法:
getElementById    <xxx id="...">
getElementsByTagName   <xxx>
getElementsByName  <xxx name="...">
getElementsByClassName()  <xxx class="...">
常用的属性:
innerHtml 获取元素内容的最简单方法是使用 innerHTML 属性。innerHTML 属性对于获取或替换 HTML 元素的内容很有用。
六.注册表单校验

mysql-1
一.数据库
1.数据库介绍
数据库就是存储数据的仓库，其本质是一个文件系统，数据按照特定的格式将数据存储起来，用户可以通过sql语句对数据库中的数据进行增加，修改，删除及查询操作
2.关系型数据库
关系数据库(Relationship DataBase Management System 简写:RDBMS) ，描述是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。说白了就是描述实体与实体之间的关系的数据库.例如用户购物下订单,订单包含商品.他们之间的关系可以通过E-R图表示(明天讲).

数据库发展历程如下所示：
没有数据库，使用磁盘文件存储数据；
层次结构模型数据库；
网状结构模型数据库；
关系结构模型数据库，使用二维表格来存储数据；
关系-对象模型数据库；No-sql
3.常见的关系型数据库
Oracle数据库：Oracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词，在英语里是“神谕”的意思，由Larry Ellison 和另两个编程人员在1977创办，他们开发了自己的拳头产品，在市场上大量销售，1979 年，Oracle公司引入了第一个商用SQL 关系数据库管理系统。Oracle公司是最早开发关系数据库的厂商之一，其产品支持最广泛的操作系统平台。目前Oracle关系数据库产品的市场占有率名列前茅。
SQL Server数据库：1987 年，微软和 IBM合作开发完成OS/2，IBM 在其销售的OS/2 ExtendedEdition 系统中绑定了OS/2Database Manager，而微软产品线中尚缺少数据库产品。为此，微软将目光投向Sybase，同Sybase 签订了合作协议，使用Sybase的技术开发基于OS/2平台的关系型数据库。1989年，微软发布了SQL Server 1.0 版。
DB2数据库：  作为关系数据库领域的开拓者和领航人，IBM在1997年完成了System R系统的原型，1980年开始提供集成的数据库服务器—— System/38，随后是SQL/DSforVSE和VM，其初始版本与SystemR研究原型密切相关。DB2 forMVSV1 在1983年推出。该版本的目标是提供这一新方案所承诺的简单性，数据不相关性和用户生产率。1988年DB2 for MVS 提供了强大的在线事务处理（OLTP）支持，1989 年和1993 年分别以远程工作单元和分布式工作单元实现了分布式数据库支持。最近推出的DB2 Universal Database 6.1则是通用数据库的典范，是第一个具备网上功能的多媒体关系数据库管理系统，支持包括Linux在内的一系列平台。
Sybase数据库：Sybase公司成立于1984年，公司名称“Sybase”取自“system”和 “database” 相结合的含义。Sybase公司的创始人之一Bob Epstein 是Ingres 大学版（与System/R同时期的关系数据库模型产品）的主要设计人员。公司的第一个关系数据库产品是1987年5月推出的Sybase SQLServer1.0。Sybase首先提出Client/Server 数据库体系结构的思想，并率先在Sybase SQLServer 中实现。
MySQL数据库： mySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购。而2009年，Sun公司又被Oracle公司收购。目前MySQL被广泛地应用在Internet上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库

4.数据库管理系统
我们通常将数据库管理系统(DataBase Management System,简写dbms)称为数据库,大白话就是我们安装的软件，当我们安装了数据库之后（数据库服务器），就可以在数据库服务器中创建数据库，每个数据库中还可以包含多张表.

通过上述图我们知道了数据库与表之间的关系，那么我们的数据又是怎样存储在数据库中。
		
数据库中的表就是一个多行多列的表格。在创建表时，需要指定表的列数，以及列名称，列类型等信息。而不用指定表格的行数，行数是没有上限的。
表中的列我们称之为字段，表中的行我们称之为记录。
用我们熟悉的java程序来与关系型数据对比，就会发现以下对应关系。
类-------表
类中属性-------表中的字段
对象--------记录。
5.mysql数据库安装,卸载与配置
社区版下载:http://downloads.mysql.com/archives/community/
mysql的安装与配置详见附件:MySQL的安装.doc
6.mysql登录
进入命令窗口
格式:mysql [-h主机地址] -u用户名 -p[密码]

启动mysql服务命令 net start mysql
关闭mysql服务命令 net stop mysql
7.mysql数据库密码重置
a.停止mysql服务器 运行输入services.msc 停止mysql服务
b.在cmd下,输入mysqld   --console  --skip-grant-tables 启动服务器,出现一下页面,不要关闭该窗口

c.新打开cmd,输入mysql -uroot  不需要密码 
	use mysql;
update user set password=password('abc') WHERE User='root';
d.关闭两个cmd窗口
二.SQL语句
1.SQL介绍
SQL:结构化查询语言(Structured Query Language),是一种数据库查询和程序设计语言，用于存取、查询、更新数据以及管理关系数据库系统.
2.SQL分类
数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等，例如创建、删除、修改数据库和表结构等；
数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新，例如：增、删、改表记录；
数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。
数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户；grant revoke 
DDL是对数据库或表的结构进行操作，而DML是对表的记录进行操作(增、删、改)。我们以后最常用的就是DDL、DML、DQL。
3.书写注意事项
SQL语句可以单行或多行书写，以分号结尾
MySQL数据库的SQL语句不区分大小写，建议使用大写，例如：SELECT * FROM user
4.DDL
对数据库的操作
创建数据库
格式:create database 数据库名称;
例如:create database day04;-- 使用数据库默认字符集.
扩展:
格式:create database [if not exists] 数据库名称 [character set 字符集] [collate 校对规则];
例如:
create database day0401 character set utf8;-- 使用指定的编码创建数据库
create database day0402 character set utf8 collate utf8_general_ci;-- 使用指定的编码和校对规则创建数据库

删除数据库
格式:drop database数据库名称;
例如:drop database day0402;

修改数据库
修改数据库编码或者校对规则
格式:alter database 数据库名称  character set 编码 collate 校对规则
例如:alter database day0401 character set gbk;-- 修改其字符集为gbk

常见的命令
查看所有数据库
 show databases;
 
查看数据库创建语句
格式:show create database 数据库名称;
例如:show create database day04;

查看字符集和校对规则
show character set;
对表的操作
常见的命令
切换数据库:
格式:use 数据库名称;
例如:use day04;

查看当前所在的数据库
select database();

查看当前数据库下所有的表
show tables;

查看表结构
格式:desc 表名称;
例如:desc user;

查看建表语句
格式: show create table 表名称;
例如: show create table user01;

mysql的数据类型
java中的数据类型	mysql中的数据类型	备注
byte	tinyint	
short	smallint	
int	int	
long	bigint	
float	float	
double	double	double(m,d) m数字长度，d精度及小数位,double(5,2)表示它的最大值是：999.99
String	char
varchar()	char固定长度的字符串.默认255,如果存储的字符没有达到指定长度，mysql将会在其后面用空格补足到指定长度；
varchar可变长度的字符串,长度可以由我们自己指定，它能保存数据长度的最大值是65535，如果存储的字符没有达到指定的长度，不会补足到指定长度；
java.sql.Date	date	日期,格式为yyyy-MM-dd
java.sql.Time	time	时间,格式为hh:mm:ss
java.sql.Timestamp	timestamp	时间戳,格式'YYYY-MM-DD HH:MM:SS'.若设置为空,将该列设置为当前的日期和时间
	datetime	时间,日期,格式'YYYY-MM-DD HH:MM:SS'
大文本 Clob	tinytext 255B
text  64kb
longtext  4gb	
大数据 Blob	tinyblob 255B
blob   64kb
longblob  4gb	

创建表
格式:
create table 表名(字段描述 ,字段描述 ,....);-- 最后一个字段没有逗号
字段描述格式:
字段名称  字段类型  [字段约束]
例如:
create table user(
id int,
username varchar(50),
password varchar(20)
);
练习:
创建一个张表user,该表具有以下字段:
id 整型 主键 自动增长
username 字符串 长度20 非空
password 字符串 长度20 非空
gender 字符串 长度10
email 字符串 长度50 唯一 非空
role 字符串 长度10 默认值 “admin”
   			  registTime  时间戳

create table user(
	id int,
	username varchar(20),
	password varchar(20),
	gender varchar(10),
	email varchar(50),
	role varchar(10),
	registTime timestamp
);

修改表
修改表名称
格式:
1.alter table 表名 rename [to] 新表名;
2.rename table 表名 to 新表名;
例如:
1.alter table user rename to user10;
2.rename table user10 to user;

添加字段(列) add
格式:alter table 表名 add [column] 字段描述;
例如:alter table user add column memo varchar(100);

修改字段(列)类型 modify
格式:alter table 表名 modify [column] 新字段描述
例如:alter table user modify memo int;

修改字段(列)名称	change
格式:alter table user change [column] 旧字段名称 新字段描述;
例如: alter table user change memo introduce varchar(100);

删除字段(列) drop
格式:alter table 表名 drop [column] 列名;
例如:alter table user drop introduce;
删除表
格式:drop table 表名;
例如:drop table user;

5.DML
插入数据
不指定列插入
格式:insert into 表名 values(字段值1,字段值2,...);
例如:insert into user values(null,'laobai','1234','male','laobai@126.com',null,null);
注意:
	没有给出要插入的列，表示插入所有列；
值的个数必须是该表的列的个数；
值的顺序，必须与表创建时给出的列的顺序相同。
插入指定列值
格式:insert into 表名(字段名1,字段名2,...) values(字段值1,字段值2,...);
例如:insert into user(username,password,email,registTime)
			values('laoqi','1234','laoqi@126.com',null);
注意:表名后面是当前表中部分字段名称
插入全部列值
格式:insert into 表名(字段名1,字段名2,...) values(字段值1,字段值2,...);
例如:insert into user(id,username,password,gender,email,role,registTime)
		    values(1,'shijin','1234','male','shijin@126.com',null,null);
注意:
表名后面是当前表中所有字段(列)
多个字段之间使用逗号分隔
			字段值必须使用引号（建议单引号）,如果是整型数据引号可以省略。




注意(编码问题):
插入中文的时候会报错,如下图:

因为mysql的客户端编码的问题我们的是utf8,而系统的cmd窗口编码是gbk.
查看所有的mysql编码
show variables like 'character%';

解决方案:
1.临时修改
set 变量名称=gbk;
例如:
 set character_set_client=gbk,character_set_connection=gbk,character_set_results=gbk;


重启mysql服务器后,就回复原样了.
2.永久修改
在mysql安装目录下,


更新数据
格式:update 表名 set 字段名1=字段值1, 字段名2=字段值2, ..... [where 条件];
例如:
1.update user set gender='male' ;## 修改所有人的性别为’male’
2.update user set username='xusanduo',email='xusanduo@qq.com' where id=3;## 修改id为3的人username和email.
删除数据
格式:delete from 表名 [where 条件];
例如:
1.delete from user;## 删除所有
2.delete from user where id=6; ##删除id为6的记录.

扩展:
删除整张表的内容,两种实现方式:
1.delete from 表名;
2.truncate [table] 表名;
区别:
1.delete属于DML语句 ,truncate属于DDL语句
2.delete是一行一行删除,truncate是将表结构销毁,再重新创建表结构,数据多的时候,效率高.
6.约束
mysql中常用的约束有主键约束,非空约束,唯一约束,外键约束(明天讲)
主键约束(primary key)
用于标识当前记录的字段。可以是一个字段，也可以是多个字段。它的特点是:数据唯一，不能为null.
三种写法:
格式1:定义表，声明字段时，定义主键.特点：primary key 只能修饰一个字段
例如:
create table user01(
id int primary key,
username varchar(20)
);

格式2:定义表，声明字段之后，在约束区域定义主键。特点  [constraint] primary key (字段1,字段2,....) 可以设置多个字段
例如:
create table user02(
	    id int ,
	    username varchar(20),
 	primary key(id)
);

格式3:定义表，声明字段，表创建之后。修改表结构添加约束。特点：也可以设置多个字段，更灵活。
create table user03(
	id int ,
	username varchar(20)
);
alter table user03 add primary key(id);

一般主键id为int的时候,还习惯配合 auto_increment使用,使主键自增.插入数据的时候,id列可以不写,写的时候写null,让数据库维护id.

例如:
create table user04(
	id int primary key auto_increment,
	username varchar(20)
);



唯一约束(unique)
被修饰的字段不能重复,但是对null值不起作用.
三种写法:
格式1:定义表，声明字段时，定义唯一约束.特点：unique 只能修饰一个字段
例如:
create table user01(
id int unique,
username varchar(20)
);

格式2:定义表，声明字段之后，在约束区域定义唯一约束。特点  [constraint] unique (字段1,字段2,....) 可以设置多个字段
例如:
create table user02(
	    id int ,
	    username varchar(20),
 	unique(id)
);

格式3:定义表，声明字段，表创建之后。修改表结构添加约束。特点：也可以设置多个字段，更灵活。
create table user03(
	id int ,
	username varchar(20)
);
alter table user03 add unique(id);

非空约束(not null)
被修饰字段不能为null.
格式:定义表,声明字段时，添加非空约束.
create table user01(
	id int,
	username varchar(20)  not null default ‘xu’
);
还可以使用default,给定一个默认值.

7.DQL
select基本查询
查询指定列
	select 字段 from 表名;

查询指定字段信息,如果要查询多个字段
	select 字段1,字段2,...from 表名;						

查询所有列
	select * from 表名;
	注意:使用"*"在练习，学习过程中可以使用，在实际开发中，不建议使用。		

去掉重复记录
	select distinct 字段 from 表名;				
	注意:distinct它的作用是去除重复.

使用别名				
	使用as 别名可以给表中的字段，表设置别名.
例如: select name as 书名 from products;

在查询中可以直接对列进行运算
	我们在sql操作中，可以直接对列进行运算。

ifnull函数使用
在对数值类型的列做运算的时候，如果做运算的列的值为null的时，运算结果都为null，为了解决这个问题可以使用ifnull函数,使用方法  ifnull(字段,0)

练习:
创建表products
CREATE TABLE `products` (
  `id` INT PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(40) ,
  `price` DOUBLE ,
  `category` VARCHAR(40) ,
  `pnum` INT(11) ,
  `description` VARCHAR(255)
);
 
向表中插入数据
INSERT INTO `products` VALUES(NULL,'感悟',100,'励志',100,'一次心灵的鸡汤');
INSERT INTO `products` VALUES(NULL,'java与模式',67,'计算机',200,'让你的编程，从些不一样');
INSERT INTO `products` VALUES(NULL,'java并发编程实战',190,'计算机',49,'实战大于理论');
INSERT INTO `products` VALUES(NULL,'设计模式解析',88,'计算机',86,'头脑风暴');
INSERT INTO `products` VALUES(NULL,'搭地铁游上海',28,'生活百科',120,'一次不一样的旅行');
INSERT INTO `products` VALUES(NULL,'时空穿行',65,'科技',87,'这是一本好书');
INSERT INTO `products` VALUES(NULL,'中国国家地理',45,'生活百科',100,'了解你生活的国家');
INSERT INTO `products` VALUES(NULL,'欧洲', NULL,'生活',200,'你梦中向往的地方');
INSERT INTO `products` VALUES(NULL,'网管员必备宝典',35,'计算机',120,'上网新手必备书籍');

1.查询出所有商品信息
2.查询出所有商品的名称，价格，类别及数量信息
3.查询出所有的商品类别
4.查询出所有商品的名称及价格，将所有商品价格加10
5.查询出每一个商品的总价及名称
	
where字句
我们在开发中，使用select操作，一般都是有条件查询，那以我们介绍一下关于where子句的使用
 	格式 :select 字段  from 表名  where 条件;				
		where条件种类:					
			1.比较运算符
				> >= < <= = !=(<>)
			2.逻辑运算符
				and or not
			3.between ...and
				相当于 >= and <=						
				注意:between 后面的值必须是小值 and后面的是大值							4.in
				可以比较多个值						
			5.like 
				模糊查询
				通配符使用:
					1.% 匹配多个
					2._ 匹配一个							
			6.null值操作
				is null; 判断为空 
				is not null; 判断不为空	

练习:
1.查询所有计算机类商品信息
2.查询出商品价格大于90的商品信息
3.查询出商品总价大于10000的商品信息
4.查询出价格在100-200之间的商品信息
5.查询出商品价格是65,100或190的商品信息
6.查询出商品的名称中包含java的商品信息。
7.查询出书名是两个字的商品信息
8.查询出商品价格不为null商品信息	
order by 排序
在开发中，我们从数据库中查询出的数据经常需要根据某些字段进行排序，可以使用order by关键字,后面跟的就是要排序的列,order by 子句是select的最后的一个子句。	`
asc 升序 (默认)
desc 降序
练习:
1.查询出所有商品，并根据价格进行升序排序
2.查询出所有商品，根据数量进行升序排列，如果数量相同，根据价格进行降序排列
聚集函数
之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。
今天我们学习如下五个聚合函数：
count：统计指定列不为NULL的记录行数；
sum：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；
max：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；
min：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；
avg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；
练习:
1.统计商品表中共有多少条记录
2.统计商品表中价格大于50的有多少条记录
3.统计有多少商品
4.统计所有商品的总价值
5.统计所有商品的平均价格
6.统计出记录中pnum的平均值
7.统计出商品表中price最大值
8.统计出商品表中price最小值
9.统计出生活百科类图书的总数量
group by分组
分组查询是指使用group by字句对查询信息进行分组,例如：我们要统计出products表中所有分类商品的总数量,这时就需要使用group by 来对products表中的商品根据category进行分组操作.
分组后我们在对每一组数据进行统计。
分组操作中的having子句是用于在分组后对数据进行过滤的，作用类似于where条件。
注意:
having和where的区别
1.having是在分组后对数据进行过滤. where是在分组前对数据进行过滤
2.having后面可以使用分组函数(统计函数),where后面不可以使用分组函数

练习:
1.对商品分类别统计，求出每一种类商品的总数量
2.对商品分类别统计，求出每一种类商品的总数量，数量要大于100
DQL语句操作总结
综合我们学习的查询相关关键字：select，from，where，group by，having，order by；它们的执行顺序是如下：
from：首先执行from，找到要查询的表；
where：判断条件，筛选符合条件所有记录；
group by：根据之前操作对记录按照指定列进行分组
having：对分组后的信息进行筛选；
select：选择所需要的列信息；
order by：对查询信息进行排序。
在SQL语言中，第一个被处理的子句是from字句，尽管select字句最先出现，但是几乎总是最后被处理。


mysql-2
一.数据库备份与恢复
1.备份
数据库的备份是指将数据库转换成对应的sql文件。
数据库导出sql脚本的格式：
		mysqldump  -u用户名 -p密码 数据库名>生成的脚本文件路径
例如:
mysqldump  -uroot  -p1234  day0401>d:\day04.sql
以上备份数据库的命令中需要用户名和密码，即表明该命令要在用户没有登录的情况下使用
2.恢复
数据库的恢复指的是使用备份产生的sql文件恢复数据库，即将sql文件中的sql语句执行就可以恢复数据库内容。因为数据库备份只是备份了数据库内容，所以备份产生的sql文件中没有创建数据库的sql语句，在恢复数据库之前需要自己动手创建数据库。
在数据库外恢复			
	格式:mysql  -uroot  -p密码 数据库名 < 文件路径
例如:mysql  -uroot  -p1234 day0401<d:\day04.sql
	注意:要求数据库必须先创建出来.					
在数据库内恢复			
格式:source SQL脚本路径
例如:source d:\day0401.sql
注意:使用这种方式恢复数据，首先要登录数据库.

二.多表设计与实现(外键约束)
系统设计中，实体之间的关系有三种:一对一，一对多，多对多

也就是说,数据库开发中表与表之间的关系有三种,而表与表之间关系是通过外键来维护的。

	外键约束特性如下：
外键必须是另一表主键的值；
外键可以重复；
外键可以为null；
一张表中可以有多个外键。

表之间关联关系

1.一对多
用户表
CREATE TABLE USER(
	id INT PRIMARY KEY AUTO_INCREMENT
	username VARCHAR(50)
)
订单表
CREATE TABLE orders(
	id INT PRIMARY KEY AUTO_INCREMENT,
	price DOUBLE
)
上述是订单与用户表，一个用户是可以有多个订单的，它们是很明显的一个一对多(多对一)的关系，那么我们怎样在表中描述它们的对应关系?
我们一般在多的一方表中简称(多表),添加一个外键字段，与一方表中的主键字段对应就可以描述其一对多的关系。例如,在orders表中添加一个字段,将其设置为外键.如下图:
订单表
CREATE TABLE orders(
	id INT PRIMARY KEY AUTO_INCREMENT,
	price DOUBLE,
    user_id INT -- 用户id
)
alter table orders add foreign key (user_id) references user(id);

2.多对多
订单表
CREATE TABLE orders(
	id INT PRIMARY KEY AUTO_INCREMENT,
	price DOUBLE
)
商品表
CREATE TABLE products(
	id INT PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(50)
)
订单与商品之间是一个很明显的多对多关系，那么我们怎样在表中描述它们的关系?开发中,一般新建一张中间表,这个中间表只放双方的id,然后就拆成了两个一对多的关系.然后一般将两个id设成联合主键,然后对每个id添加外键约束.如下图.
订单与商品关联表-中间表
CREATE TABLE order_product(
	oid INT,
	pid INT,
	PRIMARY KEY(oid,pid)
)
alter table order_product add foreign key (oid) references orders(id);
alter table order_product add foreign key (pid) references products(id);

3.一对一
person表
CREATE TABLE person(
	id INT PRIMARY KEY AUTO_INCREMENT, 
	name VARCHAR(20) -- 姓名
)
idcard表
CREATE TABLE idcard(
	id INT PRIMARY KEY AUTO_INCREMENT,
	num VARCHAR(20) -- 身份证号
)
上述是我们创建的person表与idcard表，它们之间是一对一关系，那么我们怎样来描述一个人只有一个身份证，而一个身份证只能属于一个人哪？
在开发中一般有两种思路
a.根据需求将一张表的主键设置外键，就可以描述其一对一的关系。例如,在idcard表设置外键.如下图:
idcard表
alter table idcard add foreign key (id) references person(id);
添加外键约束的格式为:
alter table 当前表 add [constraint] foreign key (需要设为外键的字段) references 指向表(指向表的主键字段)
b.两张表合二为一,例如,在person表中加入idcard的字段
person表
CREATE TABLE person(
	id INT PRIMARY KEY AUTO_INCREMENT, 
	name VARCHAR(20), -- 姓名
    num VARCHAR(20) -- 身份证号
)


总结:
	对于一对一关系，我们在表中描述时，可以在任意一方描述
	对于一对多关系，我们在表中描述时，在多的一方描述
	对于多对多关系，我们在表中描述时，会产生一个中间表

三.多表查询-内连接
数据准备:
-- 用户表(user) 
create table `user` (                                  
          `id` int auto_increment primary key,                
          `username` varchar(50)  -- 用户姓名                                                
        );

-- 订单表(orders)
create table `orders` (                                                  
          `id` int  auto_increment primary key,                                  
          `price` double,                                           
          `user_id` int                                       
        );

-- 给订单表添加外键约束
alter table orders add constraint user_fk foreign key (user_id) references user(id); 

-- 向user表中添加数据
		insert into user values(1,'张三');
		insert into user values(2,'李四');
		insert into user values(3,'王五');
		insert into user values(4,'赵六');

-- 向orders 表中插入数据
		insert into orders values(1,1314,1);
		insert into orders values(2,1314,1);
		insert into orders values(3,15,2);
		insert into orders values(4,315,4);
		insert into orders values(5,1014,null);
练习:
1.查询用户的订单,没有订单的用户不显示
2.查询所有用户的订单详情
3.查询所有订单的用户详情

内连接(inner join)是应用程序中用的普遍的"连接"操作，它一般都是默认连接类型。内连接基于连接谓词将两张表(如 A 和 B)的列组合在一起，产生新的结果表。查询会将 A 表的每一行和 B 表的每一行进行比较，并找出满足连接谓词的组合。当连接谓词被满足，A 和 B 中匹配的行会按列组合(并排组合)成结果集中的一行。连接产生的结果集，可以定义为首先对两张表做笛卡尔积(交叉连接) -- 将 A 中的每一行和 B 中的每一行组合，然后返回满足连接谓词的记录。实际上 SQL 产品会尽可能用其他方式去实现连接，笛卡尔积运算是非常没效率的.
SQL 定义了两种不同语法方式去表示"连接"。首先是"显式连接符号"，它显式地使用关键字 JOIN，其次是"隐式连接符号"，它使用所谓的"隐式连接符号"。隐式连接符号把需要连接的表放到 SELECT 语句的 FROM 部分，并用逗号隔开。这样就构成了一个"交叉连接"，WHERE 语句可能放置一些过滤谓词(过滤条件)。那些过滤谓词在功能上等价于显式连接符号.
常见的内连接有相等连接和交叉连接.

1.交叉连接(cross join)
又称笛卡尔连接(cartesian join)或叉乘(Product)，它是所有类型的内连接的基础。把表视为行记录的集合，交叉连接即返回这两个集合的笛卡尔积。这其实等价于内连接的链接条件为"永真"，或连接条件不存在.笛卡尔积引用自数学，在数学中，两个集合X和Y的笛卡尔积（Cartesian product），又称直积。假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。可以扩展到多个集合的情况。
	
2.相等连接  inner join…on…
例如:
select * from user inner join orders on user.id =orders.user_id;		
通过on后面的条件，将两张表中的数据过滤。这种写法可以将inner省略，因为join默认就是内连接(inner join),，省略inner后的语句变为
select * from user join orders on user.id=orders.user_id;
效果与写上inner是一样的。
执行的结果如下:


3.隐式内连接
我们在实际开发中,它的使用频率是最高的，其实就是将inner join省略，也不在使用on进行条件过滤，而是直接使用where进行过滤。如下面
select * from user ,orders where user.id=orders.user_id;
结果与inner join on一样。

总结:
	inner join on 它可以省略inner,在on后面直接书写比较条件，通过条件来消除迪卡尔积。
隐式内连接，它在开发应用比较多，我们可以省略inner join 表与表之间使用逗号分开，通过where条件来消除迪卡尔积
四.多表查询-外连接
如果我们在开发中需要将所有用户及其订单查询出来，如果用户没有订单，也要查询出用户信息。那么使用内连接是做不到了，这时就需要使用外连接。
				
外连接并不要求连接的两表的每一条记录在对方表中都一条匹配的记录. 连接表保留所有记录,甚至这条记录没有匹配的记录也要保留. 外连接可依据连接表保留左表, 右表或全部表的行而进一步分为左外连接, 右外连接和全连接.
注意:mysql只支持左外连接与右外连接，而不支持全连接。
1.左外连接 left outer join on 注意outer 可以省略
例如:select * from user left outer join orders on user.id=orders.user_id;
上面这条sql我们使用的是左外连接，它的意思就是说以user表为准，保留user表中所有数据，右表orders中没有关联的数据，那么就以null关联显示出来,
执行的结果如下:

2.右外连接 right outer join on 注意 outer可以省略
例如:select * from user right outer join orders on user.id=orders.user_id;
这条sql我们使用的是右外连接，它的意思就是说以orders表为准，保留orders表中所有数据，左表user中没有关联的数据，那么就以null关联显示出来

五.多表查询-子查询
练习:
1.查看用户为张三的订单详情
2.查询出订单的价格大于300的所有用户信息。
3.查询订单价格大于300的订单信息及相关用户的信息。

在sql语言中，当一个查询是另一个查询的条件时，称之为子查询。
按查询结果分类
单行单列子查询
可以使用关系运算符操作
例如:查看用户为张三的订单详情。
i.先根据用户名查询出张三的id
select id from user where username='张三';----得到了一个结果 1
ii.根据用户的id查询该用户的订单
select * from orders where user_id=(select id from user where username='张三');

单列多行子查询
	可以使用in,any或all操作
>any：大于子查询中的最小值。
>all：  大于子查询中的最大值。
<any：小于子查询中的最大值。
<all：  小于子查询中的最小值。
!=any或<>any：不等于子查询中的任意值。
!=all或<>all：不等于子查询中的所有值。
=any：等于子查询中任意值。
例如:查询出订单的价格>300的所有用户信息。
i.先查询出所有订单价格>300的用户的id.
select distinct user_id from orders where price >=300;
ii.根据上面查询出的结果，在用户表中查询出用户信息
select * from user where id in(select distinct user_id from orders where price >300);

多行多列子查询
子查询返回的就是一张表，我们直接对这张表操作即可。
例如:查询订单价格大于300的订单信息及相关用户的信息。
i.先得到订单价格大于300的订单信息
select * from orders where price>300;
ii.在查询出用户信息，与上面的多行多列关联
select * from user u ,(select * from orders where price>300) o where o.user_id=u.id;

	上面的操作，不使用子查询也可以完成:
select * from user u,orders o where o.price>300 and o.user_id =u.id;

练习





dbutils & 案例
一.dbutils 
1.dbutils的介绍
dbutils的介绍及其作用
dbutils是java编程中的数据库操作实用工具,小巧简单实用。 
作用:
封装了对JDBC的操作,简化了JDBC操作,可以少写代码。
例如:
对于数据表的读操作,可以把结果转成Array,List等java集合,便于程序员操作；
对于数据表的写操作,也变得很简单（只需写sql语句）
可以使用数据源,使用JNDI,数据库连接池等技术来优化性能--重用已经构建好的数据库连接对象
dbutils三个核心功能介绍
QueryRunner类
QueryRunner中提供了对sql语句操作的API
主要有一下三个方法:
query() 用于执行select
update() 用于执行 insert update delete
batch() 批处理
ResultSetHandler接口
用于定义select操作后,怎样封装结果集.
DbUtils类
就是一个工具类,定义了关闭资源与事务处理的方法
2.dbutils入门案例
a.导入jar包	(除了commons-dbutils-1.4.jar还需连接池和驱动jar包)		
b.创建QueryRunner对象
c.使用query方法执行select语句
d.使用ResultSetHandler封装结果集
e.使用DbUtils类释放资源
public static void main(String[] args) throws SQLException {
		//创建QueryRunner对象
		QueryRunner runner=new QueryRunner(DataSourceUtils.getDateSource());
		//调用查询方法
		List<User> list=runner.query("select * from user", new ResultSetHandler<List<User>>() {
			@Override
			public List<User> handle(ResultSet rs) throws SQLException {
				List<User> list=new ArrayList<User>();
				while(rs.next()){
					list.add(new User(rs.getInt(1), rs.getString(2), rs.getString(3)));
				}
				return list;
			}
		});
		//遍历结果
		if(list.size()>0){
			for (User user : list) {
				System.out.println(user);
			}
		}
	}

3.dbutils API详解-DbUtils类
关闭操作

事务操作



4.dbutils API详解-QueryRunner类
构造方法
QueryRunner runner=new QueryRunner(DataSouce ds);有参数构造.
这时代表它的事务是自动事务,一条sql一个事务.
QUeryRunner runner=new QueryRunner();无参数构造
它的事务是手动事务

有参数的QueryRunner与无参数的QueryRunner它们在执行query,update,batch方法时,是不一样的。有参数QueryRunner----它使用的query,update,batch方法时,是不用传递Connection参数的.	无参数QueryRunner----它使用的query,update,batch方法时,是需要有Connection参数的.如果使用的是QueryRunner()无参数,底层使用的是PreparedStatement对象,使用完成后会自动关闭PreparedStatement,但是Connection对象不会关闭.如果使用的是QueryRunner(DataSource ds)有参数,底层会先根据传递的数据源对象,获取一个Connection对象.它使用的是也是PreparedStatement对象,使用完成后关闭了PreparedStatement对象,并且也关闭了Connection对象.
query方法

update方法

batch方法

5.dbutils API详解-ResultSetHandler接口
ResultSetHandler功能分析
它主要是用于将结果集封装到对象中.
自定义封装就是创建一个ResultSetHandler的实现类去完成封装。
在dbutils的api中提供了ResultSetHandler的实现类:
ArrayHandler :将ResultSet中第一行的数据转化成对象数组
ArrayListHandler将ResultSet中所有的数据转化成List,List中存放的是Object[]
BeanHandler :将ResultSet中第一行的数据转化成类对象
BeanListHandler :将ResultSet中所有的数据转化成List,List中存放的是类对象
ColumnListHandler :将ResultSet中某一列的数据存成List,List中存放的是Object对象
KeyedHandler :将ResultSet中存成映射,key为某一列对应为Map。Map中存放的是数据
MapHandler :将ResultSet中第一行的数据存成Map映射
MapListHandler :将ResultSet中所有的数据存成List。List中存放的是Map
ScalarHandler :将ResultSet中一条记录的其中某一列的数据存成Object
ResultSetHandler中handler方法作用

它的主要作用是用于将结果集数据封装到我们指定的一个对象中。

6.ResultSetHandler九个实现类的介绍
ArrayHandler

ArrayListHandler

BeanHandler

BeanListHandler

ColumnListHandler

MapHandler

MapListHandler

KeyedHandler

ScalarHandler

jdbc
一、JDBC介绍
1.JDBC定义
JDBC（Java Data Base Connectivity,java数据库连接）,说白了就是用Java语言来操作数据库.它是一种用于执行SQL语句的Java API,可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序.


JDBC是接口，而JDBC驱动才是接口的实现，没有驱动无法完成数据库连接！每个数据库厂商都有自己的驱动，用来连接自己公司的数据库。
2.JDBC的优点
有了JDBC，向各种关系数据发送SQL语句就是一件很容易的事。换言之，有了JDBC API，就不必为访问MySql数据库专门写一个程序，为访问Oracle数据库又专门写一个程序，或为访问DB2数据库又编写另一个程序等等，程序员只需用JDBC API写一个程序就够了，它可向相应数据库发送SQL调用。
3.JDBC作用
通过上面介绍，我们知道了，如果要java语言来操作数据库，就需要使用JDBC,那么我们使用JDBC到底可以做些什么操作哪?
	简单的说，通过JDBC我们可以做三件事：
		与数据库建立连接
		发送sql语句给数据库
处理返回数据集
二、JDBC入门案例


1.新建java项目
2.导入mysql数据库驱动:mysql-connector-java-5.1.22-bin.jar


3.新建数据库
            CREATE DATABASE day06;
			USE day06

			CREATE TABLE USER(
			   id INT PRIMARY KEY AUTO_INCREMENT,
			   username VARCHAR(20) ,
			   PASSWORD VARCHAR(20) ,
			   email VARCHAR(40)
			);

			INSERT INTO USER VALUES(NULL,'tom','123','tom@163.com');
			INSERT INTO USER VALUES(NULL,'fox','456','fox@163.com');
			INSERT INTO USER VALUES(NULL,'james','789','james@163.com');
4.常用的类与接口
在java体系结构中,有这样两个包是与jdbc有关的
	java.sql.*    javax.sql.*
在java.sql.*包下有以下类与接口，是我们在使用jdbc时需要用到的。
	DriverManager类:它主要用于管理驱动
	Connection接口:它用于与数据库建立连接
	Statement接口:它用于向数据库发送sql语句
PreparedStatement接口:它是Statement的子接口，它提供了预编译功能
CallableStatement接口:它是PreparedStatement的子接口，它用于处理存储过程
ResultSet接口:它用封装查询操作返回的结果信息。

5.编写java代码连接mysql数据库，并获取user表中数据步骤
a)通过DriverManger注册驱动
b)通过DriverManager获取连接对象Connection
c)通过Connection获取一个可以向数据库发送sql语句的对象Statement		d)通过Statement对象执行sql语句(select) 得到一个结果集ResultSet			e)遍历结果集ResultSet，得到数据表中的数据
f)释放资源
编写java代码
        // 1.通过DriverManger注册驱动
		DriverManager.registerDriver(new Driver());

		// 2.通过DriverManager获取连接对象
		Connection con = DriverManager.getConnection(
				"jdbc:mysql://localhost:3306/day06", "root", "1234");

		// 3.通过Connection获取一个操作sql语句的对象Statement
		Statement st = con.createStatement();

		// 4.执行sql语句(select) 得到一个ResultSet
		String sql = "select * from user";
		ResultSet rs = st.executeQuery(sql);

		// 5.操作结果集，得到数据
		while (rs.next()) {
			System.out.println("ID:" + rs.getInt("id") + "\tUSERNAME:"
					+ rs.getString("username") + "\tPASSWORD:"
					+ rs.getString("password") + "\tEMAIL:"
					+ rs.getString("email"));
		}
		// 6.释放资源
		rs.close();
		st.close();
		con.close();

运行结果:



三、JDBC api详情
1.DriverManager
Drivermanager是java.sql包下的一个类，它的作用是用于管理一组JDBC驱动程序的基本服务。
常用方法:
static void registerDriver(Driver driver) :向 DriverManager 注册给定驱动程序。
registDriver方法分析:
我们可以查看mysql驱动中Driver类的加载，会发现在其内部有一个静态代码块
static {
		try {
			java.sql.DriverManager.registerDriver(new Driver());
		} catch (SQLException E) {
			throw new RuntimeException("Can't register driver!");
		}
	}
在其中它也完成了一个注册操作，那么很明显在我们的程序中会将驱动注册两次。并且我们在使用registDriver方法是，还需要在程序中显示的导入mysql驱动中的driver类import com.mysql.jdbc.Driver;
通过以上分析，我们通过registDriver方法完成驱动的注册存在两个问题:
1.驱动对象在注册了两次
2.我们的程序依赖于数据库驱动
为了解决上述问题，我们在实际开发中，一般会通过反射的方式来加载我们的驱动程序
Class.forName("com.mysql.jdbc.Driver");
static Connection getConnection(String url,String user,String password):试图建立到给定数据库 URL 的连接。
getConnection方法分析:
通过这个方法，我们可以获取一个java.sql.Connection对象
getConnection方法有三个参数：
url: URL用于标识数据库的位置，程序员通过URL地址告诉JDBC程序连接哪个数据库
user:这个是数据库的用户名，对于我们来说，就是root用户
password:这个是root用户的密码

关于URL
对于url，它的基本格式如下:
协议 : 子协议 : 子名称
例如: jdbc:mysql://localhost:3306/day06
如果我们连接的是本机并且端口号是3306，以上代码也可以简写成
jdbc:mysql:///day06
我们在jdbc中使用url很重要的一个目的是为了让DriverManager知道我们要通过哪一个数据库驱动来完成与数据库的连接。
扩展:常用的数据库连接URL
Oracle写法：jdbc:oracle:thin:@localhost:1521:sid
对于url来说，我们有时也会在其后面携带参数例如:
jdbc:mysql://localhost:3306/day06?useUnicode=true&characterEncoding=UTF-8



2.Connection
Connection是java.sql包下的一个接口
Connection代表的是一个与数据库连接的对象，当我们获取了一个Connection对象时，我们就可以说，已经与数据库连接成功.
Connection对象的获取是通过DriverManager的getConnection方法的返回值获取到的。
常用方法:
	Statement createStatement():创建一个 Statement 对象来将 SQL 语句发送到数据库
	PreparedStatement prepareStatement(String sql):创建一个PreparedStatement 对象来将参数化的 SQL 语句发送到数据库
	CallableStatement prepareCall(String sql):创建一个 CallableStatement 对象来调用数据库存储过程
3.Statement
Statement是java.sql包下的一个接口
Statement对象用于执行静态 SQL 语句并返回它所生成结果的对象。
常用方法:
	ResultSet executeQuery(String sql) :执行给定的sql语句，该语句通常是select，返回单个的ResultSet对象
	int executeUpdate(String sql):执行给定的sql语句,该语句可能为update,delete,insert,返回的是行计数
	boolean execute(String sql) :执行给定的sql语句，该语句返回多个结果，如果第一个结果为ResultSet对象，则返回true,其它则返回false,
4.ResultSet
ResultSet是java.sql包下的一个接口
ResultSet对象表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。
Resultset封装执行结果时，采用的类似于表格的方式。ResultSet 对象维护了一个指向表格数据行的游标cursor，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进而调用方法获取该行的数据。
常用方法
	boolean next():将光标从当前位置向前移一行。ResultSet 光标最初位于第一行之前；第一次调用 next 方法使第一行成为当前行；第二次调用使第二行成为当前行，依此类推。如果存在下一行，则返回true,不存在则返回false.
获取数据
	获取任意类型数据
Object getObject(String columnLabel):参数 columnLabel代表的是列的名称
Object getObject(int columnIndex) :参数columnIndex代表的是列的序号，第一列序号为1，第二列是2，以此类推
	获取指定类型数据
int getInt(int columnIndex)
int getInt(String columnLabel)
Date getDate(int columnIndex) 
Date getDate(String columnLabel)
String getString(int columnIndex) 
String getString(String columnLabel)
以上只是列举出一部分获取指定类型数据的方法，其它的可以查看API
四、JDBC CRUD操作
1.添加
    @Test
	public void insertTest() throws ClassNotFoundException, SQLException {
		// 1加载驱动
		Class.forName("com.mysql.jdbc.Driver");
		// 2.获取Connection对象取
		Connection con = DriverManager.getConnection("jdbc:mysql:///day06",
				"root", "1234");
		// 3.获取Statement对象
		Statement st = con.createStatement();
		// 4.添加操作
		String sql = "insert into user values(null,'张三','123','zs@itcast.cn')";
		int row = st.executeUpdate(sql);
		if (row != 0) {
			System.out.println("添加成功");
		}
		// 5.关闭资源
		st.close();
		con.close();
	}

2.修改
    @Test
	public void updateTest() throws ClassNotFoundException, SQLException {
		// 1加载驱动
		Class.forName("com.mysql.jdbc.Driver");
		// 2.获取Connection对象取
		Connection con = DriverManager.getConnection("jdbc:mysql:///day06",
				"root", "1234");
		// 3.获取Statement对象
		Statement st = con.createStatement();
		// 4.添加操作
		String sql = "update user set username='李四' where id=4";
		int row = st.executeUpdate(sql);
		if (row != 0) {
			System.out.println("修改成功");
		}
		// 5.关闭资源
		st.close();
		con.close();
	}

3.删除
@Test
public void deleteTest() throws ClassNotFoundException, SQLException {
		// 1加载驱动
		Class.forName("com.mysql.jdbc.Driver");
		// 2.获取Connection对象取
		Connection con = DriverManager.getConnection("jdbc:mysql:///day06",
				"root", "1234");
		// 3.获取Statement对象
		Statement st = con.createStatement();
		// 4.添加操作
		String sql = "delete from user where id=4";
		int row = st.executeUpdate(sql);
		if (row != 0) {
			System.out.println("删除成功");
		}
		// 5.关闭资源
		st.close();
		con.close();
	}
4.查询
    @Test
	public void findById() throws ClassNotFoundException, SQLException {
		// 1加载驱动
		Class.forName("com.mysql.jdbc.Driver");
		// 2.获取Connection对象取
		Connection con = DriverManager.getConnection("jdbc:mysql:///day06",
				"root", "1234");
		// 3.获取Statement对象
		Statement st = con.createStatement();
		// 4.添加操作
		String sql = "select * from user where id=1";
		ResultSet rs = st.executeQuery(sql);
		if (rs.next()) {
			System.out.println("ID:" + rs.getInt("id") + "\tUSERNAME:"
					+ rs.getString("username") + "\tPASSWORD:"
					+ rs.getString("password") + "\tEMAIL:"
					+ rs.getString("email"));

		}
		// 5.关闭资源
		st.close();
		con.close();
	}

五、JDBC工具类抽取
经过上面的CRUD操作之后,发现有重复的步骤:
加载驱动
获取连接对象
释放资源
那么我们是否可以将这部分内容抽取出来，当使用时，调用一下就可以了呢?
1.工具类抽取1:
public class JdbcUtils {
	
	public static Connection getConnection() throws ClassNotFoundException,
			SQLException {
		//加载驱动
		Class.forName("com.mysql.jdbc.Driver");
		//获取连接对象
		return  DriverManager.getConnection("jdbc:mysql:///day06","root", "1234");
	}
   
    public static void closeResource(Connection conn,Statement st,ResultSet rs){
		if(rs!=null){
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		if (st!=null) {
			try {
				st.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		if (conn!=null) {
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
上述代码，我们只是简单的抽取加载驱动与获取连接对象，那么这种方式存在一些问题，例如，当每一次调用JdbcUtils.getConnection()方法时，都会重新加载驱动，并且我们连接的数据库也已经固定了，可扩展性太差，为了解决这些问题，我们使用下面的方式会更加合适。
2.工具类抽取2:
在src下新建一个properties文件,
DRIVERCLASSNAME=com.mysql.jdbc.Driver
URL=jdbc:mysql:///day06
USER=root
PASSWORD=1234


public class JdbcUtils {
	private static final String DRIVERCLASSNAME;
	private static final String URL;
	private static final String USER;
	private static final String PASSWORD;

	static {
		// 通过读取配置文件给常量赋值
		ResourceBundle bundle = ResourceBundle.getBundle("jdbc");
		DRIVERCLASSNAME = bundle.getString("DRIVERCLASSNAME");
		URL = bundle.getString("URL");
		USER = bundle.getString("USER");
		PASSWORD = bundle.getString("PASSWORD");
	}
	static {
		// 加载驱动
		try {
			Class.forName(DRIVERCLASSNAME);
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static Connection getConnection() throws ClassNotFoundException,
			SQLException {
		// 获取连接对象
		return  DriverManager.getConnection(URL,USER,PASSWORD);
	}
    public static void closeResource(Connection conn,Statement st,ResultSet rs){
		if(rs!=null){
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		if (st!=null) {
			try {
				st.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		if (conn!=null) {
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
六、JDBC案例-登录
功能描述
	要求在控制台上输入用户名与密码，如果信息正确，会显示出用户的详细信息
功能分析
1.要从键盘录入用户名与密码我们需要使用Scanner类完成操作
2.接收到用户名与密码后，我们需要调用jdbc程序根据用户名与密码查询数据库
select * from user where username=xxx and password=xxx;
3.若有该用户,则把用户的所有信息都打印出来;若无,则打印登录失败
代码实现:
user类
public class User {
	private int id;
	private String username;
	private String password;
	private String email;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	@Override
	public String toString() {
		return "User [id=" + id + ", username=" + username + ", password="
				+ password + ", email=" + email + "]";
	}
}

userOperation操作类
public class UserOperation {
	public User login(String username, String password) {
		User user = null;
		Connection conn = null;
		Statement st = null;
		ResultSet rs = null;

		try {
			con = JdbcUtils.getConnection();
			st = con.createStatement();
			String sql = "select * from user where username='" + username
					+ "' and password='" + password + "'";
			rs = st.executeQuery(sql);
			if (rs.next()) {
				user = new User();
				user.setId(rs.getInt("id"));
				user.setUsername(rs.getString("username"));
				user.setPassword(rs.getString("password"));
				user.setEmail(rs.getString("email"));
			}
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			JdbcUtils.closeResource(conn,st,rs);
		}
		return user;
	}
}

程序入口
public class LoginDemo {
	public static void main(String[] args) {
		Scanner sc =new Scanner(System.in);
		
		System.out.println("请输入用户名");
		String username = sc.nextLine();
		
		System.out.println("请输入密码");//1' or 1=1 or '1
		String password = sc.nextLine();
		
		UserOperation uo = new UserOperation();
		User user=uo.login(password, username);
        if (user != null) {
			System.out.println("用户登陆成功");
			System.out.println(user);
		} else {
			System.out.println("登陆失败");
		}

	}
}

七、sql注入
对于上面的程序，如果我们在输入用户名与密码时，输入的信息如下：
		用户名:tom' or 1=1 or 1=' 
		密码:任意输入
	这时会发现，我们的程序正确运行了，并显示用户登陆成功及用户的详细信息。这就产生了SQL注入问题.所谓SQL 注入是用户利用某些系统没有对输入数据进行充分的检查，从而进行恶意破坏的行为。对于SQL注入问题，我们可以使用PreparedStatement来替换Statement来解决这类问题。
八、PreparedStatement(解决sql注入)
PreparedStatement是java.sql包下的一个接口。它是Statement的一个子接口,表示预编译的 SQL 语句的对象。
SQL 语句被预编译并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行该语句。
通过 Connection的preparedStatement(sql)获取该对象
注意:
	参数sql,代表的是要预编译的sql语句，在语句中可以使用 “?”占位符来占位
常用方法:
ResultSet executeQuery() :用于执行select操作，注意无参数
int executeUpdate():用于执行update delete insert操作，注意无参数

对预编译的sql语句中?占位符赋值操作
void setInt(int parameterIndex,int x) 
void setString(int parameterIndex,String x) 
void setObject(int parameterIndex,Object x)
参数parameterIndex代表的是第几个?号，也就是参数的序号，从1开始计数,后一个参数，是要赋的值
更多方法大家可以查询帮助文档。




修改字符编码







修改默认jdk

连接池
连接池
1.连接池介绍
什么是连接池
数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

以下是使用连接池与没有使用连接池的一个比较图例


连接池的优点
节省创建连接与释放连接性能消耗 
连接池中连接起到复用的作用，提高程序性能
连接池的原理
连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。
连接池的规定
javax.sql包下有一个 DataSource
所有的支持java的连接池都应该实现javax.sql.DataSource接口，在这个接口中提供了一个方法  getConnection()它就是获取一个连接对象的。

如果连接对象Connection是通过连接池获取的，当通过Connection对象调用close()方法时，不在是销毁连接对象，而是将连接对象放回到连接池。

2.dbcp连接池
dbcp连接池介绍
DBCP 是 Apache 软件基金组织下的开源连接池实现，使用DBCP数据源，应用程序应在系统中增加如下两个 jar 文件：
commons-dbcp.jar：连接池的实现
commons-pool.jar：连接池实现的依赖库
Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用.


dbcp连接池配置(代码)
// 1.创建连接池对象
BasicDataSource ds = new BasicDataSource();
// 2.设置相关属性
ds.setDriverClassName("com.mysql.jdbc.Driver");
ds.setUrl("jdbc:mysql:///day14");
ds.setUsername("root");
ds.setPassword("1234");

dbcp连接池配置(配置文件)
//1.加载配置信息
Properties props = new Properties();					
props.load(new FileInputStream(properties配置文件路径);
		
//properties文件内容
	driverClassName=com.mysql.jdbc.Driver
	url=jdbc:mysql:///day14
	username=root
	password=1234

// 2.通过BasicDataSourceFactory获取一个连接池对象
DataSource ds = BasicDataSourceFactory.createDataSource(props);

3.c3p0连接池
c3p0连接池介绍
C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。
c3p0与dbcp区别
dbcp没有自动回收空闲连接的功能
c3p0有自动回收空闲连接功能
在使用c3p0连接池时将c3p0的jar 复制WEB-INF/lib下，我们使用的版本
c3p0-0.9.1.2.jar

c3p0连接池配置(代码)
//1.创建连接池对象
ComboPooledDataSource ds = new ComboPooledDataSource();
// 2.手动配置参数
ds.setDriverClass("com.mysql.jdbc.Driver");
ds.setJdbcUrl("jdbc:mysql:///day14");
ds.setUser("root");
ds.setPassword("1234");

c3p0连接池配置(配置文件)
只要在src下创建c3p0.properties 或者 c3p0-config.xml名称的配置文件，c3p0会自动查找.
ComboPooledDataSource ds = new ComboPooledDataSource();
自动查找配置文件
在src/c3p0-config.xml
<c3p0-config>
	<default-config>
		<property name="driverClass">com.mysql.jdbc.Driver</property>
		<property name="jdbcUrl">jdbc:mysql:///day14</property>
		<property name="user">root</property>
		<property name="password">1234</property>
	</default-config>
</c3p0-config>

或者在src/c3p0.properties
c3p0.jdbcUrl=jdbc:mysql://localhost:3306/day07
c3p0.driverClass=com.mysql.jdbc.Driver
c3p0.user=root
c3p0.password=1234

4.tomcat内置连接池
tomcat内置连接池介绍
我们在web开发中，可以将链接池交给服务器管理，如果需要时，就可以直接从服务器中获取连接对象。在tomcat中提供了一个context.xml文件,我们可以将连接池配置在这个文件中，详细信息大家可以查看tomcat帮助文档
context.xml文件可以放置在三个位置:
1.tomcat/conf下  这个配置是被服务器下所有应用所使用的.
2.tomcat/Catalina/xxx目录下，这个配置被某一个虚拟主机使用
3.在web工程的META-INF目录下创建一个context.xml文件，它是被当前工程所使用
JNDI介绍
JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展
配置tomcat内置连接池
<Context>
  	<Resource name="jdbc/abc" auth="Container"
		type="javax.sql.DataSource" username="root" password="1234"
		driverClassName="com.mysql.jdbc.Driver" url="jdbc:mysql:///day14"
		maxActive="8" maxIdle="4"/>
</Context>

获取连接的方法:
Context context = new InitialContext(); // 初始化上下文对象
Context envCtx = (Context) context.lookup("java:comp/env"); // 固定写法
DataSource ds = (DataSource) envCtx.lookup("jdbc/abc");// 通过绑定名称，查找指定java对象

XML和tomcat
一.XML基础知识
1.xml介绍
XML 指可扩展标记语言（EXtensible Markup Language）,也是一种标记语言，很类似 HTML.它的设计宗旨是传输数据，而非显示数据它;标签没有被预定义,需要自行定义标签。
XML 被设计为具有自我描述性,是 W3C 的推荐标准,在电子计算机中，标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种的信息比如文章等。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。是Internet环境中跨平台的、依赖于内容的技术，也是当今处理分布式结构信息的有效工具。早在1998年，W3C就发布了XML1.0规范，使用它来简化Internet的文档信息传输。
xml的作用:
XML 是各种应用程序之间进行数据传输的最常用的工具，并且在信息存储和描述领域变得越来越流行。简单的说，我们在开发中使用XML主要有以下两方面应用:
a.XML做为数据交换的载体，用于数据的存储与传输
b.XML做为配置文件
2.书写规范
注意事项:
xml必须有根元素(只有一个)
xml标签必须有关闭标签
xml标签对大小写敏感
xml的属性值须加引号
特殊字符必须转义
xml中的标签名不能有空格
空格/回车/制表符在xml中都是文本节点
xml必须正确地嵌套
我们将符合上述书写规则的XML叫做格式良好的XML文档。
组成部分:
在讲述XML组成部分前，我们必须对XML的树型结构有所了解.下面是一个简单的XML文件内容
<bookstore>
<book category="COOKING">
  <title lang="en">Everyday Italian</title> 
  <author>Giada De Laurentiis</author> 
  <year>2005</year> 
  <price>30.00</price> 
</book>
<book category="CHILDREN">
  <title lang="en">Harry Potter</title> 
  <author>J K. Rowling</author> 
  <year>2005</year> 
  <price>29.99</price> 
</book>
<book category="WEB">
  <title lang="en">Learning XML</title> 
  <author>Erik T. Ray</author> 
  <year>2003</year> 
  <price>39.95</price> 
</book>
</bookstore>

对于一个xml文件，首先必须要有根元素，该元素是所有其它元素的父元素。而在xml中所有元素形成了一棵树。父，子及同胞等术语描述了元素之间的关系。所有的元素都可以拥有子元素。相同层级上的子元素成为同胞。
所有元素都可以拥有文本内容和属性。
	Root  根元素
	Element 元素
	Attribute 属性
	Text  文本
在开发中，我们将上述内容也统称为Node（节点）。
 	接下来,我们就分析一下，对于一个xml文档它的主要组成部分有哪些?

文档声明
作用:它的作用就是声明当前文件是一个xml文件.必须放在文档的第一行;必须是以<?xml开始, 以 ?>结束.它可以存在三个属性.version  encoding  standalone
version:版本   version="1.0"
encoding:编码 utf-8  gb2312 gbk  iso8859-1
standalone:不常用,标识当前xml文件是否是一个独立文档.
注意:
在书写xml文件时要注意编码问题,必须保证文件编码与文件内容编码一致
元素
XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。
简单说，元素就是我们所说的标签,
标签必须结束。
		<a>内容</a>
		<a/>
标签可以嵌套，但是必须合理嵌套
		<a><b><c></c></b></a>
对于合法的xml文档，它必须只能有一个根元素.
Xml中的空格与换行会被保留
		<网址>www.itcast.cn</网址> 
		上行xml代码，在解析时得到网址中的内容就是www.itcast.cn
		<网址>
			www.itcast.cn
		</网址>
		上行xml代码，在解析时得到网址中的内容是\r\nwww.itcat.cn\r\n	
XML 元素必须遵循以下命名规则：
名称可以含字母、数字以及其他的字符
名称不能以数字或者标点符号开始
名称不能以字符 “xml”（或者 XML、Xml）开始
名称不能包含空格
可使用任何名称，没有保留的字词。
属性
属性值必须使用引号引起来.
在实际开发中，标签的属性一般做为子元素存在.
	例如:<inpu type='text'/>
可以使用子元素来对属性进行修改
	<input>
		<type>text1</type>
		<type>text2</type>
	</input>
注释.<!--注释-->与html中一样.
CDATA区域
这个区域中的信息会按照原样输出，不会被解析器解析.CDATA 部分由 "<![CDATA[" 开始，由 "]]>" 结束,如果是一些特殊符号我们也可以使用转义字符.例如:&gt; &lt;等



3.xml约束介绍
约束xml编写什么样内容.
xml的约束有两种:
DTD约束和SCHEMA约束
应用：
		DTD：struts、hibernate等
		Schema：web项目、spring等
4.xml约束--DTD
入门案例
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE bookstore[
	<!ELEMENT bookstore (book+)>
	<!ELEMENT book (title,author,year,price)>
	<!ELEMENT title (#PCDATA)>
	<!ELEMENT author (#PCDATA)>
	<!ELEMENT year (#PCDATA)>	
	<!ELEMENT price (#PCDATA)>	
	<!ATTLIST book category CDATA #REQUIRED>
	<!ATTLIST title lang CDATA #REQUIRED>
]>
<bookstore>
	<book category="COOKING">
		<title lang="en">Everyday Italian</title>
		<author>Giada De Laurentiis</author>
		<year>2005</year>
		<price>30.00</price>
	</book>
	<book category="CHILDREN">
		<title lang="en">Harry Potter</title>
		<author>J K. Rowling</author>
		<year>2005</year>
		<price>29.99</price>
	</book>
	<book category="WEB">
		<title lang="en">Learning XML</title>
		<author>Erik T. Ray</author>
		<year>2003</year>
		<price>39.95</price>
	</book>
</bookstore>
DTD与XML关联
xml和dtd约束 建立联系
内部关联
格式:<!DOCTYPE 文档根节点 [语法]>
		我们上面入门案例中使用的就是内部关联					
外部关联
		本地文件
			格式: <!DOCTYPE 文档根节点 SYSTEM  "DTD文件的本地URL">
			例如:<!DOCTYPE bookstore SYSTEM "../dtd/bookstore2.dtd">
		网络(公共)文件
			格式:<!DOCTYPE 文档根节点 PUBLIC "DTD名称" "DTD文件的URL">
			例如：<!DOCTYPE web-app PUBLIC 
					"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"							"http://java.sun.com/dtd/web-app_2_3.dtd">
DTD详解
元素
声明元素格式
格式1: <!ELEMENT 元素名称 类别>
格式2: <!ELEMENT 元素名称 (元素内容)>

符号描述
符号	符号类型	描述
？	问号	表示该对可以出现，但只能出现一次
*	星号	表示该对象可以出现0次或多次
+	加号	表示该对象可以出现1次或多次
（）	括号	用来给元素分组
｜	竖条	表示在列出的对象中选择一个
，	逗号	表示该对象必须按照指定顺序出现

元素类别 #PCDATA 必须用括号引起来


属性
格式: 
<!ATTLIST 元素名称 属性名称 属性类型 默认值>



5.xml约束--SCHEMA
XML Schema 是基于 XML 的 DTD 替代者,用来描述XML 文档的结构.
XML Schema 语言也称作 XML Schema 定义（XML Schema Definition，XSD）.
Schema与dtd区别:
    XML从SGML中继承了DTD，并用它来定义内容的模型，验证和组织元素。同时，它也有很多局限：
•	DTD不遵守XML语法；
•	DTD不可扩展；
•	DTD不支持名称空间的应用；
•	DTD没有提供强大的数据类型支持，只能表示很简单的数据类型。
    Schema完全克服了这些弱点，使得基于Web的应用系统交换XML数据更为容易。下面是它所展现的一些新特性：
•	Schema完全基于XML语法，不需要再学习特殊的语法；
•	Schema能用处理XML文档的工具处理，而不需要特殊的工具；
•	Schema大大扩充了数据类型，支持boolean、numbers、dates and times、URIs、integers、decimal numbers和real numbers等；
•	Schema支持原型，也就是元素的继承。如：我们定义了一个“联系人”数据类型，然后可以根据它产生“朋友联系人”和“客户联系”两种数据类型；
•	Schema支持属性组。我们一般声明一些公共属性，然后可以应用于所有的元素，属性组允许把元素、属性关系放于外部定义、组合；
•	开放性。原来的DTD只能有一个DTD应用于一个XML文档，现在可以有多个Schema运用于一个XML文档。
入门案例
xml文件

<?xml version="1.0" encoding="UTF-8"?>
<bookstore xmlns="http://www.example.org/bookstore2"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.example.org/bookstore2 bookstore2.xsd">
	<book category="COOKING">
		<title lang="en">Everyday Italian</title>
		<author>Giada De Laurentiis</author>
		<year>2005-10-10</year>
		<price>30.00</price>
	</book>
	<book category="CHILDREN">
		<title lang="en">Harry Potter</title>
		<author>J K. Rowling</author>
		<year>2005-01-01</year>
		<price>29.99</price>
	</book>
	<book category="WEB">
		<title lang="en">Learning XML</title>
		<author>Erik T. Ray</author>
		<year>2003-09-09</year>
		<price>39.95</price>
	</book>
</bookstore>

约束文件 xsd
<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.org/bookstore2"
	elementFormDefault="qualified">
	<element name="bookstore">
		<complexType>
			<sequence maxOccurs="3">
				<element name="book">
					<complexType>
						<sequence>
							<element name="title">
								<complexType>
									<simpleContent>
										<extension base="string">
											<attribute name="lang" type="string" />
										</extension>
									</simpleContent>
								</complexType>
							</element>
							<element name="author" type="string" />
							<element name="year" type="date" />
							<element name="price" type="double" />
						</sequence>
						<attribute name="category" type="string" use="required" />
					</complexType>
				</element>
			</sequence>
		</complexType>
	</element>
</schema>


名称空间
编写了一个XML Schema约束文档后，通常需要把这个文件中声明的元素绑定到一个URI地址上，在XML Schema技术中有一个专业术语来描述这个过程，即把XML Schema文档声明的元素绑定到一个名称空间上，以后XML文件就可以通过这个URI（即名称空间）来告诉解析引擎，xml文档中编写的元素来自哪里，被谁约束.
<schema xmlns="http://www.w3.org/2001/XMLSchema" 
        targetNamespace="http://www.example.org/bookstore2"
	    elementFormDefault="qualified">

xsd文件中的 xmlns是一个固定值,引用的官方规定的自定义schema文档如何编写
targetNamespace给当前的约束文档起个名字,便于xml文件引用(唯一)
elementFormDefault元素用于指定局部元素是否受到该schema定targetNamespace所指定的名称空间限定,如果该值是 unqualified，实例xml的根元素必须有名称空间的的限定，这个名称空间必须是schema中定义的targetNameSpace。但是其下子元素无须也不允许用名称空间前缀限定目标名称空间。 子元素的名称空间为空名称空间;如果该值是 qualified，实例xml根元素及其下所有子元素都必须通过名称空间前缀限定目标名称空间。这个名称空间必须是schema中定义的targetNameSpace

    名称空间的名字语法容易让人混淆，尽管以 http:// 开始，那个 URL 并不指向一个包含模式定义的文件。事实上，这个 URL：http://www.example.org/bookstore2根本没有指向任何文件，只是一个分配的名字。
在XML Schema中，每个约束模式文档都可以被赋以一个唯一的名称空间，名称空间用一个唯一的URI（Uniform Resource Identifier，统一资源标识符）表示。 在Xml文件中书写标签时，可以通过名称空间声明（xmlns），来声明当前编写的标签来自哪个Schema约束文档。
<bookstore xmlns="http://www.example.org/bookstore2"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.example.org/bookstore2 bookstore2.xsd">
xmlns:名称空间,和xsd中的targetNamespace保持一致
schemaLocation此属性有两个值。第一个值是需要使用的名称空间。第二个值是供名称空间使用的 XML schema 的位置，两者之间用空格分隔。
注意，在使用schemaLocation属性时，也需要指定该属性来自哪里。

元素
XML Schema规范中将元素分为两种类型
简单类型元素(<simpleType>):简单类型元素只能包含字符内容。这些字符可以被约束为特殊的预定义类型或派生类型。例如，可以指定一个简单元素的内容必须是日期、整数、字符串或者仅仅是一个字符或者一系列字符。
复杂类型元素(<complexType>):复杂类型元素是包含子元素内容或者属性的元素,常用

<element name=”元素名称”> 确定元素
<sequence> 确定顺序


 

属性
格式:
<attribute  name=”名称” type=”类型” use=”属性选项”> 
例如:
<attribute name="id" type="string" use="required"/>
 
用attribute元素的use属性来定义是否是必须的属性
required是必须值
optional是可选值

prohibited是无属性值
缺省值如何定义
<attribute name="quantity" type="integer" default="1"/>
二.XML解析
1.xml解析介绍
XML解析方式分为两种：dom和sax
dom：(Document Object Model, 即文档对象模型) 是 W3C 组织推荐的解析XML 的一种方式。
sax： (Simple API for XML) 不是官方标准，但它是 XML 社区事实上的标准，几乎所有的 XML 解析器都支持它。
XML解析开发包
JAXP(SUN)  JDOM  DOM4J  pull  xstream
DOM和SAX只是XML解析方式，没有API
JAXP是 Sun 提供的一套XML解析API,JAXP很好的支持DOM和SAX解析方式

DOM和SAX区别
DOM  
支持回写
会将整个XML载入内存，以树形结构方式存储
XML比较复杂的时候，或者当你需要随机处理文档中数据的时候不建议使用
SAX
相比DOM是一种更为轻量级的方案
采用串行方法读取 --- 逐行读取
编程较为复杂
无法修改XML数据

2.dom4j介绍与查询操作
Dom4j是一个简单、灵活的开放源代码的库。Dom4j是由早期开发JDOM的人分离出来而后独立开发的。与JDOM不同的是，dom4j使用接口和抽象基类，虽然Dom4j的API相对要复杂一些，但它提供了比JDOM更好的灵活性.Dom4j是一个非常优秀的Java XML API，具有性能优异、功能强大和极易使用的特点。现在很多软件采用的Dom4j，例如Hibernate，包括sun公司部分技术也使用Dom4j
使用Dom4j开发，需下载dom4j相应的jar文件
dom4j的查询操作

解析xml获取Document
import java.net.URL;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

public class Foo {
    public Document parse(URL url) throws DocumentException {
        SAXReader reader = new SAXReader();
        Document document = reader.read(url);
        return document;
    }
}

	节点操作
1.获取文档的根节点.
    Element root = document.getRootElement();
2.取得某个节点的子节点.
	Element element=node.element(“书名");
3.取得节点的文字
    String text=node.getText();
4.取得某节点下所有名为“member”的子节点，并进行遍历.
List nodes = rootElm.elements("member");
for (Iterator it = nodes.iterator(); it.hasNext();) 
{    Element elm = (Element) it.next();   // do something}
	节点对象属性
1.取得某节点下的某属性  
   Element root=document.getRootElement();       //属性名name
   Attribute attribute=root.attribute(“属性”);//getValue()
2.取得属性的文字  
String text=attribute.getText(); === getValue();
3.取得某属性的文字
    String value=node.attributeValue(“属性”);

3.dom4j-xpath使用
XPath 是一门在 XML 文档中查找信息的语言
XPath 可用来在 XML 文档中对元素和属性进行遍历
XPath简化了Dom4j查找节点的过程
使用XPath必须导入jaxen-1.1-beta-6.jar否则出现NoClassDefFoundError: org/jaxen/JaxenException
在DOM4J中使用XPATH:
获取所有符合条件的节点
   selectNodes(String xpathExpression) 返回List集合
获取符合条件的单个节点
   selectSingleNode(String xpathExpression) 返回一个Node对象。	
如果符合条件的节点有多个，那么返回第一个。

三.tomcat
1.web相关概念
WEB
在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。
Internet上供外界访问的Web资源分为：
静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变。
动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。

静态web资源开发技术：Html
常用动态web资源开发技术：JSP/Servlet、ASP、PHP等
在Java中，动态web资源开发技术统称为Javaweb，我们课程的重点也是教大家如何使用Java技术开发动态的web资源，即动态web页面。

CS与BS结构
C/S结构:即Client/Server (客户端/服务器) 结构，是大家熟知的软件系统体系结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，需要安装客户端才可进行管理操作。客户端和服务器端的程序不同，用户的程序主要在客户端，服务器端主要提供数据管理、数据共享、数据及系统维护和并发控制等，客户端程序主要完成用户的具体的业务。开发比较容易，操作简便，但应用程序的升级和客户端程序的维护较为困难。
B/S结构:即Browser/Server (浏览器/服务器) 结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现。客户端基本上没有专门的应用程序，应用程序基本上都在服务器端。由于客户端没有程序，应用程序的升级和维护都可以在服务器端完成，升级维护方便。

Web开发如何通信

2.web服务器介绍
WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。WebLogic是美商Oracle的主要产品之一，系并购BEA得来。是商业市场上主要的Java（J2EE）应用服务器软件（application server）之一，是世界上第一个成功商业化的J2EE应用服务器, 已推出到12c(12.1.3) 版。
WebSphere 是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的软件。WebSphere Application Server 是该设施的基础，其他所有产品都在它之上运行，支持JAVAEE规范
Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。目前最新版本是8.0。Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选,它还是一个Servlet和JSP容器
3.tomcat的安装与目录介绍
Tomcat安装
Tomcat官方站点：http://tomcat.apache.org/
获取Tomcat安装程序包
	tar.gz(zip)文件是Linux操作系统下的安装版本
	exe文件是Windows系统下的安装版本
	zip文件是Windows系统下的压缩版本 
安装Tomcat --- 必须配置JAVA_HOME
Tomcat测试
双击 bin 目录下的 startup.bat 文件
输入 http://localhost:8080/
显示如下界面代表安装成功

Tomcat安装相关问题
JAVA_HOME配置  闪退
端口冲突
a)	修改tomcat的端口  在tomcat安装目录 下conf 下有一个server.xml文件
<Connector port="8888" protocol="HTTP/1.1"
              		 connectionTimeout="20000"
             		 redirectPort="8443" />
b)在cmd打开的窗口中输入   netstat –aov
查看到占用端口的程序的PID 在任务管理器中找到PID对应的程序结束进程。
注意:有的时候这个进程是一个系统进程，结束不了，只能采用第一种方式。
CATALINA_HOME问题,CATALINA_HOME配置的是tomcat的根目录
Tomcat退出
在bin目录  shutdown.bat
直接关闭窗口
ctrl+c

Tomcat目录结构

4.web的目录介绍
开发web应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错。


5.发布web应用至tomcat
Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射。
虚似目录的映射有三种方式：
让tomcat自动映射： tomcat服务器会自动管理webapps目录下的所有web应用，并把它映射成虚拟目录。换句话说，tomcat服务器webapps目录中的web应用，外界可以直接访问

在server.xml文件的host元素中配置,
在文件中<Host>标签，
在</Host>结束前
<Context path=”/访问的虚拟路径” docBase=”应用所在位置”/>




在Tomcat6中，不再建议在server.xml文件中配置context元素，
在tomcat/conf/Catalina/localhost目录下新建一个aaa.xml文件
在文件中写入
<Context docBase=”应用所在位置” />
其实xml文件的名称 aaa就是上一种方式中 path的值.
6.myeclipse和tomcat整合


7.war文件生成
通过myeclipse生成


压缩成zip文件，修改后缀名
通过jdk中jar命令 进入项目目录 运行jar cvf myweb.war */
四.HTTP
1.http介绍
超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法.HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求
它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。
2.http协议格式
httml请求格式


http响应格式

请求头
Accept: text/html,image/*		--支持数据类型
Accept-Charset: ISO-8859-1	--字符集
Accept-Encoding: gzip		--支持压缩
Accept-Language:zh-cn 		--语言环境
Host: www.itcast.cn:80		--访问主机
If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT	  --缓存文件的最后修改时间
Referer: http://www.itcast.com/index.jsp	 --来自哪个页面、防盗链
User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)
Cookie
Connection: close/Keep-Alive   	--链接状态
Date: Tue, 11 Jul 2000 18:23:51 GMT	--时间


响应头
Location: http://www.it315.org/index.jsp 	--跳转方向
Server:apache tomcat			--服务器型号
Content-Encoding: gzip 			--数据压缩
Content-Length: 80 			--数据长度
Content-Language: zh-cn 		--语言环境
Content-Type: text/html; charset=GB2312 		--数据类型
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT	--最后修改时间
Refresh: 1;url=http://www.it315.org		--定时刷新
Content-Disposition: attachment; filename=aaa.zip	--下载
Set-Cookie:SS=Q0=5Lb_nQ; path=/search
Expires: -1					--缓存
Cache-Control: no-cache  			--缓存
Pragma: no-cache   				--缓存
Connection: close/Keep-Alive   			--连接
Date: Tue, 11 Jul 2000 18:23:51 GMT

修改项目的名称



Servlet
一.Servlet
1.servlet介绍
Servlet 是在服务器上运行的小程序。Servlet 的主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。这个过程为如图： 

a.客户端发送请求至服务器端；
b. 服务器将请求信息发送至 Servlet；
c.Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求；
d.服务器将响应返回给客户端。

一个 Servlet 就是 Java语言中的一个类，它被用来扩展服务器的性能，服务器上驻留着可以通过“请求-响应”编程模型来访问的应用程序。虽然 Servlet 可以对任何类型的请求产生响应，但通常只用来扩展 Web 服务器的应用程序。

我们通过tomcat上提供的案例来看下servlet的写法:
如图:


启动tomcat服务器，访问examples工程，查看其下的servlets。


点击Servlets examples，我们可以看到下图


查看一个示例，例如Hello World这个示例。


这是Hello World这个示例的源代码，我们可以很清楚的知道，servlet其实就是一个java类，这个类继承了HttpServlet，注意，HttpServlet是java servlet api下的一个类，它不在我们的jdk中，所以使用时我们需要单独导入这个jar包，我们可以在tomcat中的lib下找到这个包.
路径: ***\apache-tomcat-7.0.42\lib\servlet-api.jar

那么我们在浏览器上输入一个路径后，怎样就可以访问到这个servlet呢?
我们来查看examples这个工程的配置文件web.xml,在这个文件中有下面这段内容:
    <servlet>
        <servlet-name>HelloWorldExample</servlet-name>
        <servlet-class>HelloWorldExample</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>HelloWorldExample</servlet-name>
    <url-pattern>/servlets/servlet/HelloWorldExample</url-pattern>
 </servlet-mapping>

其实这段内容就是对我们访问的HelloWorld这个servlet在tomcat服务器上的一个配置路径，简单说，当我们访问 http://localhost:8080/examples/servlets/servlet/HelloWorldExample时，就会通过<url-pattern>映射的路径查找到对应的servlet 类。
2.servlet入门案例
通过上面的分析，我们接下来自己完成一个servlet的入门案例
1.在myeclipse中创建一个web project
注意:因为我们使用的是myeclipse这个”神器”,当我们创建一个web project时，会自动帮助我们导入javaee的libraries，所以不需要在手动导入servlet api.如果我们是纯手动创建，那么就需要自己导入servlet api.


2.创建一个java类 HelloWorldServlet


3.编写代码
package cn.itcast.a_helloworldservlet;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloWorldServlet extends HttpServlet {//继承httpservlet
	//重写doGet方法
	public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		System.out.println("hello world servlet");
	}
}
4.配置web.xml文件
	<servlet>
		<servlet-name>HelloWorldServlet</servlet-name>
		<servlet-class>cn.itcast.a_helloworldservlet.HelloWorldServlet</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>HelloWorldServlet</servlet-name>
		<url-pattern>/hello</url-pattern>
	</servlet-mapping>

5.访问servlet
将工程部署到tomcat中，并启动tomcat。在浏览器中访问 http://localhost/day08/hello
我们在控制台上就可以看到结果


通过上述的操作，我们就完成了一个简单的servlet创建，那么我们总结一下：
	对于一个servlet来说，我们要创建它的步骤如下:
1.创建一个类，继承HttpServlet
2.重写doGet(和doPost)方法
3.在web.xml文件中配置servlet。

3.Servlet体系结构与api详解
通过上面的入门案例，我们知道了怎样创建及访问一个servlet，那么我们接下来深入了解一下servlet。
HttpServlet类
Javax.servlet.http.HttpServlet类，是一个抽象类，它的作用是提供将要被子类以创建适用于web 站点的Http servlet的抽象类。而对于HttpServlet的子类，一般需要重写以下方法。
doGet，如果 servlet 支持 HTTP GET 请求 
doPost，用于 HTTP POST 请求 
init 和 destroy，用于管理 servlet 的生命周期内保存的资源 
getServletInfo，servlet 使用它提供有关其自身的信息 
我们在操作中一般重写doPost或doGet方法就可以。
通过API查询，我们会发现HttpServlet有一个父类，GenericServlet.
GenericServletd类
这个类是HttpServlet的父类，它也是一个抽象类，它主要是处理一般的，与协议无关的servlet,如果，要编写关于http协议请使用HttpServlet。
对于我们创建一个servlet,也可以直接继承GenericServlet,虽然这种方式不常见，但也是创建servlet的一种方式。
对于GenericServlet，它实现了一个Servlet接口，这个接口定义了所有的servlet都必须实现的方法。
Servlet接口
定义所有 servlet 都必须实现的方法。 
servlet 是运行在 Web 服务器中的小型 Java 程序。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。 
要实现此接口，可以编写一个扩展 javax.servlet.GenericServlet 的一般 servlet，或者编写一个扩展 javax.servlet.http.HttpServlet 的 HTTP servlet。 
此接口定义了初始化 servlet 的方法、为请求提供服务的方法和从服务器移除 servlet 的方法。这些方法称为生命周期方法，它们是按以下顺序调用的：
1.构造 servlet，然后使用 init 方法将其初始化。 
2.处理来自客户端的对 service 方法的所有调用。 
3.从服务中取出 servlet，然后使用 destroy 方法销毁它，最后进行垃圾回收并终止它。 
除了生命周期方法之外，此接口还提供了 getServletConfig 方法和 getServletInfo 方法，servlet 可使用前一种方法获得任何启动信息，而后一种方法允许 servlet 返回有关其自身的基本信息，比如作者、版本和版权。

接下来，我们通过一个图来将上述内容总结一下：



4.servlet生命周期
加载和实例化 Servlet。这项操作一般是动态执行的。然而，Server 通常会提供一个管理的选项，用于在 服务器启动时强制装载和初始化特定的 Servlet。
Server 创建一个 Servlet的实例
第一个客户端的请求到达服务器
服务器调用 Servlet 的 init() 方法（可配置为 服务器 创建 Servlet 实例时调用，在 web.xml 中 <servlet> 标签下配置 <load-on-startup> 标签，配置的值为整型，值越小 Servlet 的启动优先级越高）
一个客户端的请求到达 服务器, 服务器实例化一个 Servlet的实例
服务器创建一个请求对象，处理客户端请求
服务器创建一个响应对象，响应客户端请求
服务器激活 Servlet 的 service() 方法，传递请求和响应对象作为参数
service() 方法获得关于请求对象的信息，处理请求，访问其他资源，获得需要的信息
service() 方法使用响应对象的方法，将响应传回Server，最终到达客户端。service()方法可能激活其它方法以处理请求，如 doGet() 或 doPost() 或程序员自己开发的新的方法。

对于更多的客户端请求，服务器创建新的请求和响应对象，仍然激活此 Servlet 的 service() 方法，将这两个对象作为参数传递给它。如此重复以上的循环，但无需再次调用 init() 方法。一般 Servlet 只初始化一次(只有一个对象)，当 服务器不再需要 Servlet 时（一般当 服务器关闭时），服务器 调用 Servlet 的 destroy() 方法。
简单描述如下:
1.客户端请求该 Servlet；
2.加载 Servlet 类到内存；
3.实例化、初始化该 Servlet；
4.init() 初始化参数；
5.service()（doGet() 或者 doPost()）；
6.destroy()。
示例代码如下:


注意:我们在重写init方法是，不需要重写带参数的，只需要重写无参数的init方法就可以。

原因: 在GenericServlet中已经将有参数的init方法重写，并调用了一个无参数的init，所以我们在重写时，不需要在重写有参数init方法


5.url-pattern配置
我们在创建servlet后，如果想要这个servlet可以被我们访问到，必须在web.xml文件中对其进行配置。
在其中有一个<url-pattern>这个标签是用于确定我们访问一个servlet的路径，接下来，我们详细介绍一下关于这个标签的配置
<url-pattern>它是用于确定我们访问一个servlet的路径.
一个servlet可以被不同的路径映射,换句话说多个不同配置可以映射同一个servlet.我们可以通过下面的示例来说明上面的问题

上面是关于Demo1Servlet的配置，大家发现我们对于Demo1Servlet它有两个<servlet-mapping>与其映射，那么这时当我们访问
http://localhost/day08/demo1
http://localhost/day08/hellodemo1
时都可以访问到Demo1Servlet.
那么对于<url-pattern>我们在值的写法到底应该怎样处理哪？
对于<url-pattern>我们在开发中它的写法有以下几种:
完全匹配  我们之前写的都是完全匹配方式 ，它要求必须以”/”开始
目录匹配  必须以”/”开始，以”*”结束
扩展名匹配  不能以”/”开始，以*.xxx结束 xxx代表的是后缀名
优先级 完全匹配>目录匹配>扩展名匹配

练习:
有如下的一些映射关系：
Servlet1 映射到 /abc/* 
Servlet2 映射到 /*
Servlet3 映射到 /abc 
Servlet4 映射到 *.do 
问题:
当请求URL为“/abc/a.html”，“/abc/*”和“/*”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet1。
当请求URL为“/abc”时，“/*”和“/abc”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet3。
当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet1。
当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet2.
当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
	Servlet引擎将调用Servlet2。

我们现在查看几个例子，我们找到tomcat/conf/web.xml ,在这个文件中配置的所有内容，其实是被我们自己的工程中的web.xml文件继承了，在这个配置文件中有以下几段内容:

对于这段配置，只要访问时后缀名是jsp或jspx就会执行名称叫jsp的servlet内容，这是一个很典型的扩展名匹配效果
在tomcat/conf/web.xml中还有这样一段配置

注意：这时<url-pattern>它的值就是”/”那么这时它就是一个默认(缺省)的servlet.。
默认的servlet其作用是用于处理其它的servlet处理不了的请求。
6.load-on-startup
上面我们提到过<load-on-startup>,它可以让我们在服务器实例化servlet时就调用这个servlet，简单说就是可以让一个servlet可以在服务器启动时，就加载这个servlet。我们以LifeServlet类为例来说明一下。
Servlet的配置


我们在<servlet>标签中添加了一个<load-on-startup>，它的值为2,那么这时LifeServlet就会在服务器启动时，跟随启动。
注意:<load-on-startup>的值越小代表的是优先级越高。
7.servlet模版修改
我们通过myeclipse创建servlet时，会发现在java文件上有很多注释，并且在servlet请求处理方法内也有很多代码，那么我们是否可以在创建一个servlet时，让代码简洁一些哪，这时我们就可以修改myeclipse中的servlet模板。
具体操作:		
a.关闭myeclipse,在mycelipse安装目录下查找到common/plugins目录 ，在其目录下找到
b.com.genuitec.eclipse.wizards_9.0.0.me201211011550.jar这个文件
c.使用解压工具将其打开
d.将其中templates/Servlet.java复制出来
e.进行修改
f.重新将Servlet.java copy回去
g.重新启动myeclipse，创建servlet
8.客户端访问servlet路径问题
我们在开发中，经常在页面上通过表单或超连接向服务器发送请求，如果我们访问的是一个servlet，那么这时访问servlet的路径应该如何书写？接下来我们就介绍一下，关于在客户端访问servlet的路径问题.
在介绍之前，我们先看一下，现阶段我们有多少种方式可以访问服务器端的一个资源
在地址栏上直接输入url
超连接的方式
通过表单方式
通过js的location.href方式
  通过js的window.open()方法
对于以上方式，只有表单提交的方式才可能有POST请求，其它的都是GET请求。
下面我们通过示例来说明一下关于在客户端访问servlet的路径问题:
1.创建一个Demo2Servlet


2.在WebRoot下创建demo2.html页面

以上操作，访问到demo2servlet时在控制台上输出了get请求访问。

3.在WebRoot下创建一个目录main,将demo2.html文件赋值到main目录下在次访问
http://localhost/day08/main/demo2.html
这时我们在访问时，绝对路径是不会出现问题的，但是当访问相对路径时，页面上报出了404,代表找不到资源。
我们分析一下原因:
相对路径，是指我们的servlet访问路径与当前的页面之间的一个相对关系。
那么我们的servlet访问路径是  http://localhost/day08/demo2
而我们访问main/demo2.html的路径是 http://localhost/day08/main/demo2.html
这时通过路径对比我们发现demo2.html的路径与demo2的路径它们之间不是在一个层次下，如果想要访问到，可以修改成以下结果:

这时，在次访问，会发现访问成功。
结论:
对于我们后续的学习与开发中，我们使用绝对路径会比较多一些，而在使用绝对路径时，我们主要使用的是不带协议的绝对路径，而带协议的绝对路径只要在访问站外资源时才会使用。对于相对路径，我们需要分析它们的相对关系，所以不建议大家使用。
二.ServletConfig
1.servletConfig介绍和作用
ServletConfig是javax.servlet包下的一个接口，它是由servlet容器(tomcat)创建，并封装了servlet相关配置信息的对象，并在servlet容器初始化期间传递给了servlet. 通过init(ServletConfig config)方法传递。
关于有参数init(ServletConfig config)与无参数init()方法关系:
有参数的init方法，是servlet接口中定义的。
而无参数的init方法是GenericServlet中定义的。
在GenericServlet中重写了有参数的init方法，并在其中调用了无参数的init方法。
那么，我们在创建一个servlet时，如果是继承了HttpServlet,在重写init方法时，
就可以只重写无参数init就可以。
对于ServletConfig我们使用它主要作用有以下三个方面：
	获取Servlet名称    getServletName()
	获取Servlet初始化参数    getInitParameter()   getInitParameterNames()
	获取ServletContext对象
什么是Servlet初始化参数：
	在web.xml文件中我们可以对servlet进行配置，在<servlet>配置标签内可以有以下这样的子标签
		<init-param>
			<param-name>参数名称</param-name>
			<param-value>参数值</param-value>
</init-param>
这就是用于声明servlet的初始化参数
2.获取servletConfig
对于ServletConfig对象，我们在自己的servlet中如果想要获取到，可以通过getServletConfig()对象来获取。这个方法是在javax.servlet.Servlet接口中定义的，在GenericServlet中对getServletConfig()方法进行了实现。在servlet中以过下面代码就可以获取ServletConfig对象。
ServletConfig config=this.getServletConfig();
3.servletConfig的api详解
String getServletName() 
获取在web应用程序中部署的servlet实例的名称(servletName中定义的)
String getInitParameter(String name) 
获取指定初始化参数的值,如果不存在，返回null
Enumeration getInitParameterNames()
以 String 对象的 Enumeration 的形式返回 servlet 的初始化参数的名称
ServletContext getServletContext()
返回对调用者在其中执行操作的 ServletContext 的引用(获取servlet的管理者)。
三.ServletContext
1.servletContext的介绍和作用
ServletContext它是javax.servlet.包下的一个接口。
WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。
结论:
它代表的是web应用上下文
	获取context=this.getServletConfig().getServletContext();
	在开发中可以通过以下方式获取
		ServletContext context=this.getServletContext();在getServletContext()方法内部也是通过ServletContext ServletConfig获取的。
     ServlectContext作用
		获取全局初始化参数
		实现servlet共享资源
		获取web资源
		其它操作
2.servletContext获取初始化参数
在web.xml文件中有<context-param>标签可以设置全局初始化参数.
<context-param>
	<param-name>encoding</param-name>
	<param-value>utf-8</param-value>
</context-param>
	对于ServletContext对象它也提供了以下两个方法用于获取初始化参数
		String getInitParameter(String name)
Enumeration getInitParameterNames()
3.servletContext实现servlet共享
ServletContext对于一个web应用只有一个，所有的servlet使用的就是同一个ServletContext。
ServletContext提供以下方法用于在域中进行数据操作
Object getAttribute(String name) 
返回具有给定名称的 servlet 容器属性，如果不具有该名称的属性，则返回 null。
void setAttribute(String name,Object object) 
将对象绑定到此 servlet 上下文中的给定属性名称。如果已将指定名称用于某个属性，则此方法将使用新属性替换具有该名称的属性。 
void removeAttribute(String name) 
从 servlet 上下文中移除具有给定名称的属性。

案例:统计访问站点的人数

做一个VisitServlet用于记录次数
		做一个ShowCountServlet用于显示次数
4.servletContext获取资源案例
ServletContext可以获取web工程中资源，通过以下方式
String getRealPath(String path)
为给定虚拟路径返回包含实际路径的 String(返回的路径到项目名称)
InputStream getResourceAsStream(String path) 
以 InputStream 对象的形式返回位于指定路径上的资源。 
5.其他作用
String getMimeType(String file)   可以获取一个文件的mimeType类型.			
URL getResource(String path) 它返回的是一个资源的URL
  还提供 log(String msg),getRequestDispatcher(String path) 等这样的方法，可以做日志与转向操作
四.Classpath
java project----所有class都在bin目录下
web project-----所有的class都在classes目录下
1.Class获取
Class.getResource("/").getPath();获取classes目录的绝对磁盘路径
Class.getResource("").getPath();获取的是当前Class对象代表的类所在的包的路径。
2.ClassLoader获取
Class.getClassLoader().getResource("/").getPath(); 
获取的是classes目录的绝对磁盘路径
Class.getClassLoader().getResource("").getPath(); 
获取的是classes目录的绝对磁盘路径
这两个getResource()是使用当前ClassLoader加载资源(即资源在 Class path中),这样资源和class直接打在jar包中,避免文件路径问题.两者不同是Class的getResource()方法是从当前.class 文件路径查找资源,ClassLoader则是从jar包根目录查找.。

案例-获取资源
	需求:在web工程中创建四个txt文件，并在文件中任意写入内容。
			 1.txt   src目录下  (tomcat/webapps/项目名/WEB-INF/classes)
			 2.txt   WebRoot目录下(tomcat/webapps/项目名)
			 3.txt   WEB-INF目录下(tomcat/webapps/项目名/WEB-INF)
			 4.txt   src/cn/itcast/工程的根目录下(tomcat/webapps/项目名/WEB-INF/classes/cn/itcast)

1.txt    A.class.getClassLoader().getResource(“/1.txt”).getPath();
2.txt	   this.getServletContext().getRealPath(“/2.txt”)
3.txt    this.getServletContext().getRealPath(“/WEB-INF/3.txt”)
4.txt    A.class.getClassLoader().getResource(“/cn/itcast/4.txt”).getPath()
           A.class.getResource(“4.txt”).getPath()


	在Servlet中将这些txt文件中的内容读取出来，打印到控制台。

作业
			简述servlet生命周期
			简述url-patter的配置方式
			简述什么是默认(缺省)的servlet
			简述load-start-up的作用
			简述ServletConfig的作用其常用API
			简述ServletContext的作用其常用API
客户端访问servlet的路径案例
ServletContext获取资源案例


修改new的菜单项








修改项目名称的时候必须修改web的名称,否则部署的时候还是老名字





配置new















选择其他view

文件下载
一.文件下载
1.下载介绍与超链接下载
所谓的下载，其实就是将服务器端的资源通过io流写回到浏览器端。
超链接实现下载
如果文件可以直接被浏览器解析，会直接在浏览器上打开。
如果不能解析，可以下载
通过另存为进行下载 
这种下载方式:当路径提交时，会通过缺省的servlet将文件直接写回到浏览器端
超链接下载问题分析
	原因是在http响应头中content-type,如果它的值可以被浏览器解析，那么响应回的内容就会被浏览器端直接解析，如果content-type的值，不可以被浏览器直接解析，那么就会下载。
注意:不能被浏览器直接访问的文件，不可以使用超连接下载.
2.下载操作-服务器端编码实现下载
服务器端编码下载原理分析
通过response可以获取输出流，我们将要下载的资源，通过response获取的输出流直接写回到浏览器端就可以。
服务器端下载两个响应头设置
通过response.setContentType()正设置响应数据的mimeType类型.	
获取一个文件的mimeType类型
		ServletContext.getMimeType(String filename);
再添加一个头信息,下载的时候就可以弹出一个提示框了
response.setHeader("Content-Disposition","attachment;filename=下载文件名");

3.关于下载时乱码问题分析与解决
乱码分析:
对于下载时，我们在显示下载文件名称时，如果包含了中文，就可能出现乱码问题，出现的原因，是对于不同的浏览器，它们在处理下载文件时的编码不一致，ie浏览器使用的是utf-8编码，而firefox浏览器使用的是base64编码
解决方案1:根据浏览器类型
下载文件名称中文乱码问题
	response.setHeader("content-disposition", "attachment;filename="+ filename);			这段代码中的filename是指定下载文件时的名称				
	对于IE浏览器，它要求必须给一个UTF-8码
	对于firefox浏览器，它要求必须给一个base64编码
代码如下:
if (agent.contains("MSIE")) {
// IE浏览器
filename = URLEncoder.encode(filename, "utf-8");
filename = filename.replace("+", " ");
} else if (agent.contains("Firefox")) {
// 火狐浏览器
BASE64Encoder base64Encoder = new BASE64Encoder();
filename = "=?utf-8?B?"+ base64Encoder.encode(filename.getBytes("utf-8")) + "?=";
} else {
// 其它浏览器
filename = URLEncoder.encode(filename, "utf-8");
}

解决方案2:简单处理
response.setHeader( "Content-Disposition", "attachment;filename=" + new String( fileName.getBytes("gb2312"), "ISO8859-1" ) );


request&response
一.request和response的介绍
1.request和response的作用
Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象
request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了.

2.request和response的体系结构
javax.servlet.Servlet接口中的service方法
public abstract void service(ServletRequest req, ServletResponse res)
javax.servlet.GenericServlet类中的service方法
public abstract void service(ServletRequest req, ServletResponse res) 
javax.servlet.http.HttpServlet类中的service方法
在这个类中对service方法进行了重载
public void service(ServletRequest req, ServletResponse res)
protected void service(HttpServletRequest req, HttpServletResponse resp)

二.response
1.response常用api简单介绍

2.response操作响应行
在http响应行中，包括协议,版本号,以及有一个很重要的值，它叫做响应状态码.响应行中我们主要就是操作这些状态码,它可以有五种类型取值:

常用状态码
	200请求成功（其后是对GET和POST请求的应答文档。）
	302所请求的页面已经临时转移至新的url。
304未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
	404没有找到文件或目录。
	405请求中指定的方法不被允许
	500请求未完成。服务器遇到不可预知的情况
HttpServletResponse操作状态码API
void setStatus(int sc,String sm) 设置状态代码
void sendError(int sc) throws IOException 设置错误状态码
  void sendError(int sc,String msg) throws IOException 设置错误状态码及信息
3.response操作响应头
http响应头的格式是  name:value的格式，如果有多个value值，以”,”分开,
例如:
		Content-Encoding: gzip 
Content-Length: 123 
Content-Language: zh-cn 
Content-Type: text/html; charset=GB2312 
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT
HttpServletResponse操作响应头 API
public void setHeader(String name,String value)
用给定名称和值设置响应头。如果已经设置了头，则新值将重写以前的值
public void addHeader(String name, String value)
用给定名称和值添加响应头。此方法允许响应头有多个值
public void setIntHeader(String name, int value)
用给定名称和整数值设置响应头。如果已经设置了头，则新值将重写以前的值。
public void addIntHeader(String name, int value)
用给定名称和整数值添加响应头。此方法允许响应头有多个值。
public void setDateHeader(String name, long date)
用给定名称和日期值设置响应头。该日期根据距历元时间的毫秒数指定。如果已经设置了头，则新值将重写以前的值。
public void addDateHeader(String name, long date)
用给定名称和日期值添加响应头。该日期根据距历元时间的毫秒数指定。此方法允许响应头有多个值。
案例1:重定向
图解

实现:
//1.设置状态码
response.setStatus(302);
//2.设置相应头--跳转目录
response.setHeader(“location”,”http://localhost/day09/second”);
//response.setHeader(“location”,”day09/second”);

开发中我们使用sendRedirect(url);
例如:response.sendRedirect(“day09/second”);
案例2:定时跳转
在servlet中,我们通过
response.setHeader(“refresh”,”3,url=http://localhost/day09/demo2.html”);
response.setHeader("refresh", "3;url=/day09/demo2.html");
在页面中,我们可以通过
<meta http-equiv="refresh" content="5;url=http://localhost/day09/responseDemo3">

页面中通过<meta http-equiv=””>方式操作时，也会将标签内容写入到http响应中。
4.response操作响应体
http响应正文是我们最终在浏览器上看到的结果。
	对于HttpServletResponse如果想要操作响应正文，需要通过response对象获取到输出流，将信息写回到浏览器端
获得向客户端进行数据输出的流对象
OutputStream out = response.getOutputStream();字节流数据输出
PrintWriter pw = response.getWriter();字符流数据输出
设置输出数据的编码格式
默认情况下，编码格式是ISO-8859-1
public void setCharacterEncoding(String charset)
设置发送到客户端的响应的字符编码 
public void setContentType(String type)
设置将发送到客户端的响应的内容类型，如果该响应尚未提交。给定内容类型可能包含字符编码规范，例如 text/html;charset=UTF-8
操作响应正文注意事项
getOutputStream和getWriter方法分别用于得到输出二进制数据、输出文本数据的ServletOuputStream、Printwriter对象。
getOutputStream和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。  
Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端。 
Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎tomcat将调用close方法关闭该输出流对象。调用close的时候，会调用flushBuffer方法.
5.生成动态验证码
代码:
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;
import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//验证码
public class ImageCodeServlet extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		// 使用java图形界面技术绘制一张图片

		int charNum = 4;
		int width = 30 * 4;
		int height = 30;

		// 1. 创建一张内存图片
		BufferedImage bufferedImage = new BufferedImage(width, height,
				BufferedImage.TYPE_INT_RGB);

		// 2.获得绘图对象
		Graphics graphics = bufferedImage.getGraphics();

		// 3、绘制背景颜色
		graphics.setColor(Color.YELLOW);
		graphics.fillRect(0, 0, width, height);

		// 4、绘制图片边框
		graphics.setColor(Color.BLUE);
		graphics.drawRect(0, 0, width - 1, height - 1);

		// 5、输出验证码内容
		graphics.setColor(Color.RED);
		graphics.setFont(new Font("宋体", Font.BOLD, 20));

		// 随机输出4个字符
		Graphics2D graphics2d = (Graphics2D) graphics;
		 String s = "ABCDEFGHGKLMNPQRSTUVWXYZ23456789";
		Random random = new Random();
		//session中要用到
		String msg="";
		int x = 5;
		for (int i = 0; i < 4; i++) {
			int index = random.nextInt(32);
			String content = String.valueOf(s.charAt(index));
			msg+=content;
			double theta = random.nextInt(45) * Math.PI / 180;
			//让字体扭曲
            graphics2d.rotate(theta, x, 18);
			graphics2d.drawString(content, x, 18);
			graphics2d.rotate(-theta, x, 18);
			x += 30;
		}

		// 6、绘制干扰线
		graphics.setColor(Color.GRAY);
		for (int i = 0; i < 5; i++) {
			int x1 = random.nextInt(width);
			int x2 = random.nextInt(width);

			int y1 = random.nextInt(height);
			int y2 = random.nextInt(height);
			graphics.drawLine(x1, y1, x2, y2);
		}

		// 释放资源
		graphics.dispose();

		// 图片输出 ImageIO
		ImageIO.write(bufferedImage, "jpg", response.getOutputStream());
	

	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}

常见的汉字:
String s = "\u7684\u4e00\u4e86\u662f\u6211\u4e0d\u5728\u4eba\u4eec\u6709\u6765\u4ed6\u8fd9\u4e0a\u7740\u4e2a\u5730\u5230\u5927\u91cc\u8bf4\u5c31\u53bb\u5b50\u5f97\u4e5f\u548c\u90a3\u8981\u4e0b\u770b\u5929\u65f6\u8fc7\u51fa\u5c0f\u4e48\u8d77\u4f60\u90fd\u628a\u597d\u8fd8\u591a\u6ca1\u4e3a\u53c8\u53ef\u5bb6\u5b66\u53ea\u4ee5\u4e3b\u4f1a\u6837\u5e74\u60f3\u751f\u540c\u8001\u4e2d\u5341\u4ece\u81ea\u9762\u524d\u5934\u9053\u5b83\u540e\u7136\u8d70\u5f88\u50cf\u89c1\u4e24\u7528\u5979\u56fd\u52a8\u8fdb\u6210\u56de\u4ec0\u8fb9\u4f5c\u5bf9\u5f00\u800c\u5df1\u4e9b\u73b0\u5c71\u6c11\u5019\u7ecf\u53d1\u5de5\u5411\u4e8b\u547d\u7ed9\u957f\u6c34\u51e0\u4e49\u4e09\u58f0\u4e8e\u9ad8\u624b\u77e5\u7406\u773c\u5fd7\u70b9\u5fc3\u6218\u4e8c\u95ee\u4f46\u8eab\u65b9\u5b9e\u5403\u505a\u53eb\u5f53\u4f4f\u542c\u9769\u6253\u5462\u771f\u5168\u624d\u56db\u5df2\u6240\u654c\u4e4b\u6700\u5149\u4ea7\u60c5\u8def\u5206\u603b\u6761\u767d\u8bdd\u4e1c\u5e2d\u6b21\u4eb2\u5982\u88ab\u82b1\u53e3\u653e\u513f\u5e38\u6c14\u4e94\u7b2c\u4f7f\u5199\u519b\u5427\u6587\u8fd0\u518d\u679c\u600e\u5b9a\u8bb8\u5feb\u660e\u884c\u56e0\u522b\u98de\u5916\u6811\u7269\u6d3b\u90e8\u95e8\u65e0\u5f80\u8239\u671b\u65b0\u5e26\u961f\u5148\u529b\u5b8c\u5374\u7ad9\u4ee3\u5458\u673a\u66f4\u4e5d\u60a8\u6bcf\u98ce\u7ea7\u8ddf\u7b11\u554a\u5b69\u4e07\u5c11\u76f4\u610f\u591c\u6bd4\u9636\u8fde\u8f66\u91cd\u4fbf\u6597\u9a6c\u54ea\u5316\u592a\u6307\u53d8\u793e\u4f3c\u58eb\u8005\u5e72\u77f3\u6ee1\u65e5\u51b3\u767e\u539f\u62ff\u7fa4\u7a76\u5404\u516d\u672c\u601d\u89e3\u7acb\u6cb3\u6751\u516b\u96be\u65e9\u8bba\u5417\u6839\u5171\u8ba9\u76f8\u7814\u4eca\u5176\u4e66\u5750\u63a5\u5e94\u5173\u4fe1\u89c9\u6b65\u53cd\u5904\u8bb0\u5c06\u5343\u627e\u4e89\u9886\u6216\u5e08\u7ed3\u5757\u8dd1\u8c01\u8349\u8d8a\u5b57\u52a0\u811a\u7d27\u7231\u7b49\u4e60\u9635\u6015\u6708\u9752\u534a\u706b\u6cd5\u9898\u5efa\u8d76\u4f4d\u5531\u6d77\u4e03\u5973\u4efb\u4ef6\u611f\u51c6\u5f20\u56e2\u5c4b\u79bb\u8272\u8138\u7247\u79d1\u5012\u775b\u5229\u4e16\u521a\u4e14\u7531\u9001\u5207\u661f\u5bfc\u665a\u8868\u591f\u6574\u8ba4\u54cd\u96ea\u6d41\u672a\u573a\u8be5\u5e76\u5e95\u6df1\u523b\u5e73\u4f1f\u5fd9\u63d0\u786e\u8fd1\u4eae\u8f7b\u8bb2\u519c\u53e4\u9ed1\u544a\u754c\u62c9\u540d\u5440\u571f\u6e05\u9633\u7167\u529e\u53f2\u6539\u5386\u8f6c\u753b\u9020\u5634\u6b64\u6cbb\u5317\u5fc5\u670d\u96e8\u7a7f\u5185\u8bc6\u9a8c\u4f20\u4e1a\u83dc\u722c\u7761\u5174\u5f62\u91cf\u54b1\u89c2\u82e6\u4f53\u4f17\u901a\u51b2\u5408\u7834\u53cb\u5ea6\u672f\u996d\u516c\u65c1\u623f\u6781\u5357\u67aa\u8bfb\u6c99\u5c81\u7ebf\u91ce\u575a\u7a7a\u6536\u7b97\u81f3\u653f\u57ce\u52b3\u843d\u94b1\u7279\u56f4\u5f1f\u80dc\u6559\u70ed\u5c55\u5305\u6b4c\u7c7b\u6e10\u5f3a\u6570\u4e61\u547c\u6027\u97f3\u7b54\u54e5\u9645\u65e7\u795e\u5ea7\u7ae0\u5e2e\u5566\u53d7\u7cfb\u4ee4\u8df3\u975e\u4f55\u725b\u53d6\u5165\u5cb8\u6562\u6389\u5ffd\u79cd\u88c5\u9876\u6025\u6797\u505c\u606f\u53e5\u533a\u8863\u822c\u62a5\u53f6\u538b\u6162\u53d4\u80cc\u7ec6";
三.request
1.request常用api简单介绍
HttpServletRequest对象用于封装http请求，对于http请求它有三部分组成，http请求行，http请求行及请求正文，下图描述了关于封装请求信息方法

2.request操作请求行
public String getMethod()
返回用于发出此请求的 HTTP 方法的名称，例如 GET、POST 
public String getRequestURI()
返回此请求的 URL 的一部分，从协议名称一直到 HTTP 请求的第一行中的查询字符串。
public String getProtocol()
以 protocol/majorVersion.minorVersion 的形式（例如 HTTP/1.1）返回请求使用的协议的名称和版本。
public String getQueryString()
返回包含在请求 URL 中路径后面的查询字符串。如果 URL 没有查询字符串，则此方法返回 null。
3.request获取客户信息
public String getContextPath()
返回请求 URI 指示请求上下文的那一部分。
public StringBuffer getRequestURL()
重新构造客户端用于发出请求的 URL。返回的 URL 包含一个协议、服务器名称、端口号、服务器路径，但是不包含查询字符串参数。
public String getRemoteAddr()
返回发送请求的客户端或最后一个代理的 Internet Protocol (IP) 地址
4.request操作请求头
public String getHeader(String name)
以 String 的形式返回指定请求头的值。
public java.util.Enumeration<E> getHeaders(String name)
以 String 对象的 Enumeration 的形式返回指定请求头的所有值。
public java.util.Enumeration<E> getHeaderNames()
返回此请求包含的所有头名称的枚举。如果该请求没有头，则此方法返回一个空枚举。
public int getIntHeader(String name)
以 int 的形式返回指定请求头的值。如果该请求没有指定名称的头，则此方法返回 -1。如果无法将头转换为整数，则此方法抛出 NumberFormatException。 
public long getDateHeader(String name)
以表示 Date 对象的 long 值的形式返回指定请求头的值
5.request获取请求参数
请求参数是浏览器发送请求时携带的信息。
对于请求方式GET与POST，请求参数存在位置不同。
	GET：请求参数存在于请求的资源路径中。
	POST:请求参数存在于正文中

public String getParameter(String name)
以 String 形式返回请求参数的值，如果该参数不存在，则返回 null
public String[] getParameterValues(String name)
返回包含给定请求参数拥有的所有值的 String 对象数组，如果该参数不存在，则返回 null。
public java.util.Map<K, V> getParameterMap()
返回此请求的参数的 java.util.Map。请求参数是与请求一起发送的额外信息。对于 HTTP servlet，参数包含在查询字符串或发送的表单数据中。
public java.util.Enumeration<E> getParameterNames()
返回包含此请求中所包含参数的名称的 String 对象的 Enumeration。如果该请求没有参数，则此方法返回一个空的 Enumeration。
6.request获取参数中文出现乱码
原因:
汉字在不同的编码表中的码值不一样，那么在使用不同的编码表进行解码与编码操作时，就会出现乱码问题.
请求参数中如果有中文，它是以utf-8码进行了编码。
Tomcat得到请求参数是使用iso8859-1进行了解码，封装到了request中。
在通过request获取请求信息就是乱码。
解决:
使用iso8859-1进行编码
在使用utf-8进行解码
new String(username.getBytes(“iso8859-1”),”utf-8”);

如果请求方式是POST,可以直接使用request.setCharacterEncoding(“utf-8”);就可以解决。
7.request域对象的介绍
request对象同时也是一个域对象，开发人员通过request对象在实现转发时，把数据通过request对象带给其它web资源处理.
setAttribute方法 
getAttribute方法  
removeAttribute方法
getAttributeNames方法

request对象提供了一个getRequestDispatcher方法，该方法返回一个RequestDispatcher对象，调用这个对象的forward方法可以实现请求转发，从而共享请求中的数据
8.请求转发
请求转发可以实现路径的跳转操作.
	ReqeustDispatcher dispatcher=request.getRequestDispatcher("路径")
	dispatcher.forward(request,response)
请求转发和重定向的区别
1.请求转发是服务器内部跳转，地址栏不会发生改变
重定向地址栏会发生改变。

2.请求转发，只有一次请求，一次响应.
重定向，有两次请求，两次响应。

3.请求转发存在request域，可以共享数据.
重定向不存在request域。

4.请求转发只能在服务器的内部跳转，简单说，只能访问本站内资源。
重定向可以访问站外资源，也可以访问站内资源.

5.请求转发是由request 发起的 . request.getRequestDispatcher().forward()
重定向是由response 发起的  response.sendRedirect();

6.请求转发与重定向时路径写法不一样.
重定向要跳转的路径是从浏览器在次发起的，是浏览器端路径，写法: /工程名/资源
请求转发是服务器内部跳转，这时它与浏览器无关 写法:/资源
9.请求包含
RequestDispatcher.include()方法用于将RequestDispatcher对象封装的资源内容作为当前响应内容的一部分包含进来，从而实现可编程的服务器端包含功能
被包含的Servlet程序不能改变响应消息的状态码和响应头，如果它里面存在这样的语句，这些语句的执行结果将被忽略.include在程序执行上效果类似forward,但是使用forward只有一个程序可以生成响应，include可以由多个程序一同生成响应 ----- 常用来页面布局






cookie & session
一.jsp
1.jsp的介绍
JSP全名为Java Server Pages，中文名叫java服务器页面，本质是一个简化的Servlet设计，它是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML文件(*.htm,*.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。
它实现了Html语法中的java扩张（以 <%, %>形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。
jsp的作用:将内容的生成和显示进行分离 
用JSP技术，Web页面开发人员可以使用HTML或者XML标识来设计和格式化最终页面，并使用JSP标识或者小脚本来生成页面上的动态内容

2.jsp的原理
jsp原理

上图描述的是一个jsp页面hello.jsp在服务器中处理的过程。
创建web工程day10,创建一个hello.jsp页面。
1.在浏览器中输入 http://localhost/day10/hello.jsp
2.服务器得到请求，会通过jsp引擎查找到hello.jsp页面
3.服务器将查找到的hello.jsp页面翻译成hello_jsp.java(其本质就是一个servlet)
4.jvm会将hello_jsp.java文件编译成hello_jsp.class
5.服务器运算hello_jsp.class文件
6.服务器生成响应结果
jsp对应java文件分析
上述是我们对于一个jsp运行的原理的简单分析，我们可以通过查看hello.jsp文件翻译后的.java文件来了解具体内容，生成的hello.jsp页面的java源文件存在于tomcat/work目录 下。
hello.jsp页面源代码
<%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>hello.jsp</title>
  </head>  
 <body>
    hello jsp
  </body>
</html>

hello_jsp.java文件源代码
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.util.*;
public final class hello_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=utf-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\r\n");
      out.write("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\r\n");
      out.write("<html>\r\n");
      out.write("  <head>    \r\n");
      out.write("    <title>hello.jsp</title>\r\n");
      out.write("  </head>\r\n");
      out.write("  \r\n");
      out.write("  <body>\r\n");
      out.write("    hello jsp\r\n");
      out.write("  </body>\r\n");
      out.write("</html>\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try { out.clearBuffer(); } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

通过上面的内容，大家会发现在jsp页面中的所有的html代码，最终都会被流写回到浏览器端，所以我们可以在浏览器上查看到jsp页面上的html内容
3.jsp的脚本与注释
jsp中三种脚本元素
有三个基本的脚本元素，作用是使JAVA代码可以直接插入到HTML代码中
声明标签
格式:<%! int a = 1; %>
作用:声明的变量在类的成员位置上
脚本片断
格式:<% int a = 1; out.println(a); %>
作用:内容会生成在_jspService()方法中
脚本表达式
格式:<%= "hello " + a %>
	作用:它就相当于是out.println()将内容直接输出到页面中，注意表达式不能以分号结尾
jsp中的注释
在jsp页面中可以使用三种注释
可以使用html中注释  
<!-- html的注释  -->
可以对jsp脚本内容使用java注释  
 		//单行注释  /* 多行注释 */
可以使用jsp注释(推荐)
<%--  jsp注释  --%>
4.jsp与servlet的结合使用
把昨天的登录操作使用jsp实现一下,流程稍稍改变一下:

创建数据库与表
CREATE DATABASE day10;
USE day10;
CREATE TABLE USER(
	id INT PRIMARY KEY AUTO_INCREMENT,
	username VARCHAR(20),
	PASSWORD VARCHAR(20),
	email VARCHAR(50),
	sex VARCHAR(20),
	telephone VARCHAR(20),
	introduce VARCHAR(200)
)
INSERT INTO USER VALUES(NULL,"tom","123","tom@itcast.cn","男","13888888888","good boy");

导入mysql驱动jar包
创建JdbcUtils工具类及jdbc.properties配置文件
创建User类
public class User {
	private int id;
	private String username;
	private String password;
	private String email;
	private String sex;
	private String telephone;
	private String introduce;

	get/set方法省略	
｝

login.jsp页面
<%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>登陆窗口</title>
  </head>  
  <body>
  	<%=request.getAttribute("loginmsg") %>
    <form action="/day10/login" method="post">
    	USERNAME:<input type="text" name="username"><br>
    	PASSWORD:<input type="password" name="password"><br>
    	<input type="submit" value="登陆">
    </form>
  </body>
</html> 

LoginServlet类
public void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
	// 1.获取请求参数 username password
	String username = request.getParameter("username");
	String password = request.getParameter("password");
	// 2.调用UserOperation类中的login方法
	UserOperation uo = new UserOperation();
	User user = uo.login(username, password);
	//3.判断user是否为null来确定是否登陆成功
	if(user==null){
		//登陆失败，请求转发到login.jsp页面
		request.setAttribute("loginmsg", "登陆失败");
		request.getRequestDispatcher("/login.jsp").forward(request, response);
	}else{
		//登陆成功，重定向到success.jsp
		response.sendRedirect("/day10/success.jsp");
	}
}

UserOperation操作类
public User login(String username, String password) {
		User user = null;
		// 1.定义sql语句
		String sql = "select * from user where username=? and password=?";
		// 2.查找数据库操作
		Connection con = null;
		PreparedStatement pst = null;
		ResultSet rs = null;

		try {
			// 2.1获取Connection对象
			con = JdbcUtils.getConnection();
			// 2.2 获取执行sql语句的PreparedStatement对象
			pst = con.prepareStatement(sql);
			// 2.3对占位符赋值
			pst.setString(1, username);
			pst.setString(2, password);
			// 2.4执行sql获取ResultSet
			rs = pst.executeQuery();
			// 2.5操作ResultSet
			if (rs.next()) {
				user = new User();
				user.setId(rs.getInt("id"));
				user.setEmail(rs.getString("email"));
				user.setUsername(rs.getString("username"));
				user.setPassword(rs.getString("password"));
				user.setSex(rs.getString("sex"));
				user.setTelephone(rs.getString("telephone"));
				user.setIntroduce(rs.getString("introduce"));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			// 2.6关闭资源
			JdbcUtils.closeResource(con,pst,rs);
		}
		return user;
	}

success.jsp页面
<%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>登陆成功窗口</title>
  </head>  
  <body>
    <h1>登陆成功</h1>
  </body>
</html>
首次进入登录页面的时候发现最上面显示为null,需要先判断一下loginmsg是否为空,在输出.这段代码用el表达式(明天讲)实现起来特别简单.
EL 全名为Expression Language
语法：${标识符}
常用功能:获取各种域中存储的数据
jsp写法:<%=request.getAttribute("loginmsg");>
el写法:${requestScope.loginmsg}
修改之后的login.jsp
<%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>登陆窗口</title>
  </head>  
  <body>
  	${requestScope.loginmsg}
    <form action="/day10/login" method="post">
    	USERNAME:<input type="text" name="username"><br>
    	PASSWORD:<input type="password" name="password"><br>
    	<input type="submit" value="登陆">
    </form>
  </body>
</html>

二.会话技术
会话的介绍:
会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话
会话的作用:
每个用户与服务器进行交互的过程中，各自会有一些数据，程序要想办法保存每个用户的数据。
例如：用户点击超链接通过一个servlet购买了一个商品，程序应该保存用户购买的商品，以便于用户点结帐servlet时，结帐servlet可以得到用户商品为用户结帐

会话技术会为两类			
Cookie
Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。

Session
Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。
三.cookie
1.cookie的介绍
什么是cookie
Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。
Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入jsessionid，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。
cookie与http
cookie与http协议关系
Cookie是Http协议制定的，并不是Java语言独有的，PHT、.NET中也使用了cookie技术，因此只要是和HTTP协议相关，那么就可以使用cookie技术。
我们知道cookie是服务器创建的一个键值对，并保存在浏览器端。那么服务器是如何将cookie发送给浏览器的呢?
在服务器端先创建cookie，如 Cookie cookie=new Cookie(String name,String value)，其中Cookie可以在javaeeAPI中查到的，详情可参考java_ee API。然后再通过response对象将cookie信息作为响应头发送到浏览器端。我们可以通过HttpWatch抓包工具查看响应信息，可以发现cookie是基于一个Set-Cookie响应头工作的，由于Set-Cookie响应头可以有多个，所以我们可以通过response.addHeader(String name,String value)方法发送Set-Cookie响应头，例如，有两个cookie，分别为one=aaa，two=bbb，其中one、two是cookie的名称，aaa、bbb是cookie的值。发送响应头如下所示：
response.addHeader(“Set-Cookie”,”one=aaa”)；
response.addHeader(“Set-Cookie”,”two=bbb”)；
当浏览器再次访问服务器时，会将cookie送还给服务器。那么浏览器是如何将cookie带给服务器的呢?其实通过Cookie请求头传递过去的。请求头Cookie与响应头Set-Cookie有区别，多个cookie对应多个Set-Cookie响应头，但是只对应一个Cookie请求头，格式为：Cookie：one=aaa； two=bbb。即多个cookie之间用分号和空格隔开。
需要注意的是：cookie是不能跨浏览器的。例如，张三首先使用IE浏览器访问服务器，服务器发送了一个cookie，这个cookie只会保存在IE浏览器，如果再使用火狐浏览器访问服务器，服务器会再发送一个cookie个火狐浏览器，在火狐浏览器中不能获取IE浏览器中的cookie，同理IE浏览器也获取不到火狐浏览器中的cookie。
http协议规定
Http协议对Cookie做了一些规定，如下所示：
a.一个Cookie的大小，最大为4KB；
b.一个服务器最多向一个浏览器保存20个Cookie；
c.一个浏览器最多可以保存300个Cookie。
我们知道，浏览器将服务器发送过来的cookie保存在本地磁盘，如果cookie过多，必然会加大浏览器的压力，因此Http协议对Cookie做了以上规定。
但是，目前浏览器之间因为竞争，很多都在一定范围内违反了Http规定，例如，一个浏览器最多保存的Cookie个数超过300个。但是也不会出现浏览器允许一个Cookie的大小超过4GB。

2.cookie常用api及其原理
javax.servlet.http.Cookie类用于创建一个Cookie，response接口也中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。 同样，request接口中也定义了一个getCookies方法，它用于获取客户端提交的Cookie。
构造方法
public Cookie(String name, String value):构造带指定名称和值的 cookie。 
成员方法
public String getName():返回 cookie 的名称
public String getValue():返回 cookie 的值。 
public void setMaxAge(int expiry):设置 cookie 的最大生存时间，以秒为单位
public void setPath(String uri):指定客户端应该返回 cookie 的路径。
接下来,咱们来做个案例看下cookie是如何使用的.
在day10工程下创建一个CookieDemo1Servlet,写入以下代码：
//1.创建cookie
Cookie cookie=new Cookie("cookieName","cookieValue");
//2.通过response对象将cookie响应到浏览器
response.addCookie(cookie);

然后通过抓包工具看下:
当在浏览器上访问http://localhost/day10/cookieDemo1时,抓取到的http请求与响应信息如下:
请求信息:
GET /day10/cookieDemo1 HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
Accept-Language: zh-CN
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)
Accept-Encoding: gzip, deflate
Host: localhost
Connection: Keep-Alive

响应信息
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: cookieName=cookieValue
Content-Length: 0
Date: Tue, 12 May 2015 05:26:53 GMT

再次访问此页面
请求信息:
GET /day10/cookieDemo1 HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
Accept-Language: zh-CN
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)
Accept-Encoding: gzip, deflate
Host: localhost
Connection: Keep-Alive
Cookie: cookieName=cookieValue

通过以上分析，我们通过下面图进行总结：






3.cookie的持久化
持久化
如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用Cookie类的setMaxAge方法，并给出一个以秒为单位的时间。
0代表的是删除持久cookie，注意，删除cookie时，path必须一致，否则不会删除
-1代表的是浏览器关闭后失效.
路径:
Cookie的路径是在服务器创建Cookie时设置的，它的作用是决定浏览器访问服务器的某个资源时，需要将浏览器端保存的那些Cookie归还给服务器，可以通过Cookie类的setPath方法来设置cookie的路径.
关于路径包含关系
例如，浏览器中保存如下几个cookie，它们的路径分别是：
aCookie.path=/day10/
bCookie.path=/day10/jsps/
cCookie.path=/day10/jsps/cookie/
访问路径是：http://localhost:8080/day10/index.jsp
浏览器发送给服务器的cookie有：aCookie；
访问路径是：http://localhost:8080/day10/jsps/a.jsp
浏览器发送给服务器的cookie有：aCookie，bCookie；
访问路径是：http://localhost:8080/day10/jsps/cookie/b.jsp
浏览器发送给服务器的cookie有：aCookie，bCookie，cCookie。
4.案例--记录上次访问时间
功能描述
当访问day10工程下的某一个servlet时，会显示出上一次访问这个资源的时间。
案例分析


使用到的知识点分析
	Cookie cookie=new Cookie(); 创建cookie
	response.addCookie()  将cookie添加到http响应中
request.getCookies();  获取所有的cookie

代码实现
VisitServlet
public class VisitServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

	doPost(request, response);
}

public void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
	//1.得到系统当前时间
	Date date=new Date();
	
	//2.创建一个cookie
	Cookie cookie=new Cookie("time",date.getTime()+"");
	
	//3.将 cookie通过response响应到浏览器端
	response.addCookie(cookie);
}
}

ShowTimeServlet
public class ShowTimeServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

	doPost(request, response);
}

public void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
	//设置响应编码
	response.setContentType("text/html;charset=utf-8");
	//1.得到名称叫time的cookie
	Cookie[] cs = request.getCookies();
	//2.遍历cs，得到cookie
	for(Cookie c:cs){
		if("time".equals(c.getName())){//判断cookie的名称是否有叫time
			long time=Long.parseLong(c.getValue()); //得到名称叫time的cookie的value
			Date date=new Date(time); //构造出新的时间
			response.getWriter().write(date.toLocaleString());
			return;
		}
	}
	
	response.getWriter().write("第一次访问:"+new Date().toLocaleString());
	
}
}

上面的代码已经实现了我们的需求,但是不妥的地方是还得需要单独访问一下才知道上次的时间.我们完全可以把两个合二为一
public class ShowCurrentTimeServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

	doPost(request, response);
}

public void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
	// 1.设置响应编码
	response.setContentType("text/html;charset=utf-8");

	// 2.获取一个名称叫time的cookie.
	Cookie cookie = findCookieByName("time", request.getCookies());
	Date now = new Date();
	if (cookie == null) {
		// 说明第一次访问
		response.getWriter().write("第一次访问时间是:" + now.toLocaleString());
	} else {
		// 不是第一次访问
		long time = Long.parseLong(cookie.getValue());
		response.getWriter().write("上次访问时间是:" + new Date(time).toLocaleString());
	}

	// 需要将这时访问的时间存储到cookie中。
	cookie = new Cookie("time", now.getTime() + "");
	//持久化cookie
	//cookie.setMaxAge(60*60*24*7);
	cookie.setMaxAge(0);//删除cookie
	response.addCookie(cookie);

}

// 根据名称查找cookie
private Cookie findCookieByName(String name, Cookie[] cs) {
	if (cs == null || cs.length == 0) {
		return null;
	}
	for (Cookie c : cs) {
		if (name.equals(c.getName())) {
			return c;
		}
	}
	return null;
}
}



5.案例--查看历史记录
功能描述
做一个商品页面，当我们访问后，在页面上点击查看商品浏览记录后，可以查看到以前浏览过的商品信息
案例分析


使用到的知识点分析
超连接带参数  <a href=”/day10/book?id=1”>
获取请求参数  request.getParameter()
创建Cookie cookie=new Cookie()
获取所有cookie   request.getCookies()
将cookie响应到浏览器端   response.addCookies()



代码实现
book.jsp
<a href="/day10/book?id=1">西游记</a><br>
<a href="/day10/book?id=2">水浒传</a><br>
<a href="/day10/book?id=3">红楼梦</a><br>
<a href="/day10/book?id=4">三国演义</a><br>
<hr>
<a href="/day10/bookHistory.jsp">查看浏览商品记录</a>

BookServlet
public class BookServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

	doPost(request, response);
}

public void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
	response.setContentType("text/html;charset=utf-8");
	// 1.得到商品的id
	String id = request.getParameter("id");

	// 2.将id值保存到cookie的名称叫ids这个cookie中。
	Cookie cookie = CookieUtils.findCookieByName("ids",
			request.getCookies());

	if (cookie == null) { // 第一次没有ids,就得到null
		cookie = new Cookie("ids", id);
	} else { // 不是第一次，就得到的不是null.
				// 3.得到cookie的value值。
		String ids = cookie.getValue();

		// 判断id是否重复
		List<String> list = Arrays.asList(ids.split("-")); //将数组转换成集合。

		if (!list.contains(id)) {
			ids = ids + "-" + id;
		}
		cookie = new Cookie("ids", ids);

	}

	response.addCookie(cookie);
	response.getWriter().write("商品展示成功,<a href='/day10/book.jsp'>继续浏览</a>");
}
}

bookHistory.jsp
<%
		String[] books = { "西游记", "水浒传", "红楼梦", "三国演义" };

		//1.得到所有的cookie，得到名称叫ids的cookie
		Cookie[] cs = request.getCookies();
		Cookie c = CookieUtils.findCookieByName("ids", cs);

		if (c == null) {
			//没有浏览记录
			out.print("无浏览记录");
		} else {
			//有浏览记录
			//2.得到cookie的value
			out.print("浏览记录如下:<br>");
			String ids = c.getValue(); //1-2-4

			String[] id = ids.split("-");

			for (int i = 0; i < id.length; i++) {
				int bookid = Integer.parseInt(id[i]) - 1;
				out.print(books[bookid] + "<br>");
			}

		}
%>



四.session
1.session的介绍
首先，HttpSession是javax.servlet.http包下的一个接口。从名字来看，我们可以知道HttpSession与Http协议有一定的关系，但是它并不是由Http协议定义的，而是由Javaweb提供。我们可以在JavaEE api中查看它的详细信息。
其次，HttpSession是用来进行会话跟踪的接口，我们之前也学过另外一个与会话相关的技术Cookie。在Cookie介绍中我们了解到，Cookie是由Http协议制定的，在请求信息和响应信息中分别对应了Cookie请求头和Set-Cookie响应头，并且Cookie是由服务器创建，保存在客户端。而HttpSession对象也是由服务器创建，但是与Cookie不同的是，它保存在服务器端。
HttpSession对象是Servlet的三大域对象之一，其他两个域对象是HttpServletRequest和ServletContext。这三个域中，request的域范围最小，它的域范围是整个请求链，并且只在请求转发和包含时存在；session域对象的域范围是一次会话，而在一次会话中会产生多次请求，因此session的域范围要比request大；application的域范围是最大的，因为一个web应用只有唯一的一个application对象，只有当web应用被移出服务器或服务器关闭它才死亡，它的域范围是整个应用。
2.session常用api,生命周期及其原理
session底层是依赖Cookie的，如果浏览器禁用Cookie则session会依赖URL重写。详情我们会在后面介绍。如何获取HttpSession对象?在服务器端，例如在Servlet中，我们通过request对象的getSession()方法获取服务器为当前用户创建的session对象，即：HttpSession session=request.getSession()。而在jsp中，session是jsp的内置对象，不用获取就可以直接使用。
session的常用api
我们知道每一个域对象都会有以下三个方法，HttpSession也不例外：
void setAttribute(String name,Object value)：向域中添加域属性；
Object getAttribute(String name)：从域中获取指定名称的属性值；
Void removeAttribute(String name)：移出域中指定名称的域属性

接下来,咱们来做个案例看下session是如何使用的.
在day10工程下创建一个SessionDemo1Servlet,写入以下代码：
	// 1.获取session
HttpSession session = request.getSession();
// 2.向session中存储数据据
session.setAttribute("name", "tom");

在day10工程下创建一个SessionDemo2Servlet,写入以下代码：
// 1.获取session
HttpSession session = request.getSession();
// 2.获取session中信息
String name = (String) session.getAttribute("name");
System.out.println(name);

接下来使用抓包工具看下:
打开浏览器访问http://localhost/day10/sessionDemo1
请求信息:
GET /day10/sessionDemo1 HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
Accept-Language: zh-CN
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)
Accept-Encoding: gzip, deflate
Host: localhost
Connection: Keep-Alive


响应信息:
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=2021FCEFDF31A6DAC8E7CC201F7AF404; Path=/day10/; HttpOnly
Content-Length: 0
Date: Tue, 12 May 2015 21:58:39 GMT

再次访问http://localhost/day10/sessionDemo2:
请求信息:
GET /day10/sessionDemo2 HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
Accept-Language: zh-CN
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)
Accept-Encoding: gzip, deflate
Host: localhost
Connection: Keep-Alive
Cookie: JSESSIONID=2021FCEFDF31A6DAC8E7CC201F7AF404

响应信息
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Length: 0
Date: Tue, 12 May 2015 22:00:46 GMT
程序执行完成后，在控制台上打印出tom.

session对象的创建分析
如果请求时，cookie中有jsessionid这个cookie，那么我们通过request.getSession()时，
就会根据jsessionid值查找session的id,如果查找到，会使用已有的，如果没有查找到，会创建。
如果请求时，cookie中没有jsessionid这个cookie,那么request.getSession()就会创建一个新的session对象.
session对象的销毁分析
浏览器关闭了，session对象不会销毁的，session的销毁与关闭浏览器无关.
session对象销毁方式:	
	1.关闭服务器		
	2.默认超时		
		在tomcat/conf/web.xml文件中设置了session默认超时时间
		   <session-config>
				<session-timeout>30</session-timeout>
			</session-config>			
		默认30分钟超时		
	3.可以设置session超时时间(以秒为单位)
		 void setMaxInactiveInterval(int interval)  
	4.销毁session
		invalidate();
session的原理


第一次访问,请求中不存在jsessionid值，这时发送请求到服务器端就会创建HttpSession对象.工将session的id值存储到cookie中响应到浏览器端
当下一次在请求时，这时会在请求中存在jsessionid值,到服务器端后，就会根据jsessionid值，查找指定id的session对象。
如果查找到，就直接使用，而不会重新创建。如果没有查找到，会重新创建.
HttpSession session=request.getSession();
扩展
HttpSession session=request.getSession(true/false);
如果值是true与无参数一样.			
如果是false,它不会重新创建session对象，会返回null值。(用的很少)
3.案例--购物车
功能描述
有一个商品页面，可以点击超连接将商品添加到购物车，并可以查看购物车中商品信息
案例分析


使用到的知识点分析
购物车使用的数据结构 Map<String,Integer>
获取session    request.getSession()
解决请求参数乱码   new String(name.getBytes(“iso8859-1”),”utf-8”)

代码实现
Productlist.jsp
<table border='1' width="65%" align="center">
  		<tr>
  			<td>商品名称</td>
  			<td>操作</td>
  		</tr>
  		<tr>
  			<td>洗衣机</td>
  			<td><a href="/day10/addProductToCart?name=洗衣机">添加到购物车</a></td>
  		</tr>
  		<tr>
  			<td>电视机</td>
  			<td><a href="/day10/addProductToCart?name=电视机">添加到购物车</a></td>
  		</tr>
  		<tr>
  			<td>缝纫机</td>
  			<td><a href="/day10/addProductToCart?name=缝纫机">添加到购物车</a></td>
  		</tr>
  		<tr>
  			<td>打火机</td>
  			<td><a href="/day10/addProductToCart?name=打火机">添加到购物车</a></td>
  		</tr>
  		
  	</table>

AddProductToCartServlet
public class AddProductToCartServlet extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		doPost(request, response);
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setContentType("text/html;charset=utf-8");
		
		// 1.获取商品名称
		String name = request.getParameter("name");
		// 2.解决乱码
		name = new String(name.getBytes("iso8859-1"), "utf-8");
		// 3.获取购物车
		HttpSession session = request.getSession();
		Map<String, Integer> cart = (Map<String, Integer>) session
				.getAttribute("cart");

		// 4.判断购物车是否存在
		Integer count = null; //代表的是商品数量
		if (cart == null) {
			cart = new HashMap<String, Integer>();
			// cart.put(name, 1);
			count = 1;
		} else {
			// 如果购物车存在，我们需要考虑商品在购物车中是否存在。
			count = cart.get(name);
			if (count == null) {
				// 说明购物车中无此商品
				count = 1;
			} else {
				// 如果有此商品，将数量加1
				count += 1;
			}

		}
		cart.put(name, count);
		// 5.将购物车存储到session中.
		session.setAttribute("cart", cart);
		
		response.getWriter().write("添加成功,<a href='/day10/productlist.jsp'>继续购物</a>,<a href='/day10/cart.jsp'>查看购物车</a>");

	}
}

cart.jsp
<table border='1' align="center" width="65%">

		<tr>
			<td>商品名称</td>
			<td>商品数量</td>
		</tr>

		<%
			//1.得到session
			HttpSession mysession = request.getSession();

			//2.得到购物车
			Map<String, Integer> cart = (Map<String, Integer>) mysession
					.getAttribute("cart");

			//3.判断购物车是否存在
			if (cart == null || cart.size() == 0) {
				out.print("购物车中无商品<br>");
			} else {
				//4.遍历cart
				for (String name : cart.keySet()) {

					out.print("<tr><td>" + name + "</td><td>" + cart.get(name)
							+ "</td></tr>");

				}
			}
		%>

	</table>

4.案例--验证码
5.url重写
url重写介绍
如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求头的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。

url重写作用
当客户机不接受cookie时，server就使用URL重写作为会话跟踪的基本方式.URL重写，添加了附加数据(会话ID)到请求的URL路径上. 
会话ID必须被编码作为该URL字符串中的路径参数。该参数的名称为jsessionid,
简单说就是cookie禁用了jsessionid就不能携带，那么每次请求，都是一个新的session对象。
	如果想要使用同一个session对象，可以使用url重写.

url重写实现
		response. encodeRedirectURL(java.lang.String url) 
			用于对sendRedirect方法后的url地址进行重写。
		response. encodeURL(java.lang.String url)
			用于对表单action和超链接的url地址进行重写




修改jsp文件的默认字符编码

























修改文件的打开方式

JSP & EL & JSTL
一.JSP
1.jsp回顾
jsp作用
jsp全称java server pages(java服务器页面),本质是一个servlet.它是在传统的网页HTML文件(*.htm,*.html)中插入Java程序段(Scriptlet)和JSP标记(tag),从而形成JSP文件,后缀名为(*.jsp).
jsp作用:将内容的生成和显示进行分离 
用JSP技术，Web页面开发人员可以使用HTML或者XML标识来设计和格式化最终页面，并使用JSP标识或者小脚本来生成页面上的动态内容
jsp原理

jsp脚本
有三个基本的脚本元素，作用是使JAVA代码可以直接插入到HTML代码中
声明标签
格式:<%! int a = 1; %>
作用:声明的变量在类的成员位置上
脚本片断
格式:<% int a = 1; out.println(a); %>
作用:内容会生成在_jspService()方法中
脚本表达式
格式:<%= "hello " + a %>
	作用:它就相当于是out.println()将内容直接输出到页面中，注意表达式不能以分号结尾
jsp注释
在jsp页面中可以使用三种注释
可以使用html中注释  
<!-- html的注释  -->
可以对jsp脚本内容使用java注释  
 		//单行注释  /* 多行注释 */  /**文档注释*/
可以使用jsp注释(推荐)
<%--  jsp注释  --%>

2.jsp指令简单介绍
jsp指令介绍
当我们创建一个jsp页面时，在页面第一行有一段代码如下：
<%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>
这个就是指令，对于指令它有以下作用
a.用于指示JSP执行某些步骤
b.用于指示JSP表现特定行为
jsp指令格式
格式:
<%@指令名 attr1=”” attr2=””%>
注意:
其中attr1和attr2表示指令中的属性，通常我们将JSP指令写在JSP文件的的最上方，但是这不是必须的。


jsp指令分类
JSP中有三大指令，分别是以下三个：
page
include
taglib
其中这三个指令中，page是最复杂的,我们会详细讲解(导入类,编码的设置等等)；include指令表示静态包含，我们之前学习的请求包含属于动态包含；taglib指令是用来导入标签库，后面会学习一些标签库，在这里只做简单介绍。
3.jsp指令-page
重点属性:
import
作用:在jsp页面上导包操作.
这个属性可以有多个.
pageEncoding
作用：指定当前jsp页面的编码。这个编码是给服务器看的，服务器需要知道当前页面的编码，否则服务器无法正确的把jsp翻译成Java文件。
contentType
在jsp文件中有如下指令：
<%@page language="java" import="java.util.*"  contentType="text/html; charset=utf-8"%>
其中contentType属性的作用等同于response.setContentType(“text/html;charset=utf-8”)的作用。response的setContentType()方法这里我们就不再多说，当我们在jsp文件中提供了contentType属性，那么jsp对应的java文件中就会存在response.setContentType(“text/html;charset=utf-8”)这句代码。contentType属性的默认值是“text/html; charset=ISO-8859-1”，但是我们知道iso-8859-1并不支持中文，所以我们需要将charset的值修改为“utf-8“。

pageEncoding与contentType的区别与联系
pageEncoding与contentType都是page指令的属性，它们都是用来设置编码，有如下联系：
如果这两个属性只提供了其中一个，那么没有提供的那个属性的编码值就是提供的这个属性的编码值，例如：在jsp页面中设置了contentType=”text/html;charset=utf-8”，那么没有设置的pageEncoding的值就为utf-8，反之亦然；
如果两个属性都没有提供，那么两者的默认编码就是ISO-8859-1。 
根据对这两个属性的讲解，它们有如下区别：
pageEncoding是设置当前页面的编码，该编码是给服务器看的，可以让服务器正确的将jsp文件翻译成Java文件；
contentType有两个作用：一是设置响应字符流的编码，二是设置Content-Type响应头，即通知浏览器使用什么编码方式解码响应信息。
了解属性:
language
代表在jsp脚本中可以写的语言, 只有一个值 java
extends
它用于设置jsp翻译后的java类的父类. 要求必须是HttpServlet或其子类.
session
面上是否禁用session。可取值为true/false  如果值为false,在页面上不能使用session。
isELIgnored
用是否忽略el表达式.可取值为true/false  如果值为true,那么页面上的el表达式就不会被解析.
autoFlush与buffer
用于设置jsp中out流的默认缓冲区大小以及是否自动刷新.
errorPage
设置错误页面，当jsp中如果出现了异常，会自动跳转到指定的错误页面
isErrorPage
指示当前页面是一个错误页面，这时就可以使用一个内置对象 exception，
通过这个内置对象就可以获取异常信息.
4.jsp指令-include和taglib
include
include指令作用
include指令的作用是在JSP页面中静态包含一个文件，同时由JSP解析包含的文件内容
include指令格式
<%@ include file=“filename” %>
include指令功能分析
包含的是目标文件的源码；包含过来，一起翻译
main.jsp中的代码
<%
	  String s = “abc”;
%>
<%include file=“part.jsp” %>

part.jsp中的代码
<%=s %> 没有定义变量s

尽管part.jsp本身会有错误但是运行main.jsp就可以正确引入part.jsp
taglib
taglib指令作用
作用:是用于导入标签库.
taglib指令格式
<%@taglib prefix="" uri="" %>
uri  标签文件的URI地址
prefix  标签组的命名空间前缀
5.jsp内置对象
jsp九个内置对象及其类型


内置对象	类型
request	HttpServletRequest
response	HttpServletResponse
session	HttpSession
application	ServletContext
config	ServletConfig
page	this(Servlet)
pageContext	PageContext
exception	Throwable
out	JspWriter


jsp九个内置对象的创建过程
我们可以创建一个demo1.jsp页面，启动服务器，在浏览器中访问 demo1.jsp页面，在tomcat下的work目录中查找到它翻译后的demo1_jsp.java文件，在java文件中我们可以查找到每一个内置对象的创建。

request,response这两个对象是_jspService的参数

final javax.servlet.jsp.PageContext pageContext;
javax.servlet.http.HttpSession session = null;
final javax.servlet.ServletContext application;
final javax.servlet.ServletConfig config;
javax.servlet.jsp.JspWriter out = null;
final java.lang.Object page = this;

java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);
if (exception != null) {
  response.setStatus(javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
}
注意:exception对象只有在jsp页面上设置了page指令的isErrorPage才会有exception对象。
jsp中的四个域对象
jsp有四个域对象，分别是：
application：域范围是整个应用；
session：域范围是整个会话，注意一个会话中只有一个用户，如果要统计站点的访问次数,使用的域是ServletContext，因为这个时候统计的是多个用户，而非一个用户；
request：域范围是整个请求链；
  pageContext：域范围是一个jsp页面，在一个页面中存数据再取数据没有任何意义，所以这里所说的域指的是在当前jsp页面和当前jsp页面中使用的标签之间共享数据。
6.jsp内置对象-pageContext的作用
获取其他内置对象
可以通过pageContext对象获取jsp中其他的内置对象. PageContext类中定义了如下八个方法：getPage()、getRequest()、getResponse()、getServletConfig()、getServletContext()、getException()、getSession()等方法，其中getOut()放是在其父类中定义的，有了这些方法，pageContext对象自然能够获取其他八个内置对象了。
操作四个域对象
pageContext也是一个域对象,所以他有以下方法：
void setAttribute(String name,Object value)
Object getAttribute(String name);
Void removeAttribute(String name);
我们还可以利用以下方法操作其他域中的对象:
Object getAttribute(String name, int scope)：
该方法的第一个参数是域属性的名称，第二个参数指定是从那个域中取出域属性；
在PageContext中已经定义了如下几个静态常量作为scope的可选值：
int APPLICATION_SCOPE：表示从application域中获取数据；
int PAGE_SCOPE：表示从pageContext域中获取数据；
int REQUEST_SCOPE：表示从request域中获取数据；
int SESSION_SCOPE：表示从session域中获取数据。
void setAttribute(String name,Object value,int scope)：
该方法的第一个参数指的是域属性的名称，第二参数指的是域属性的值，第三个参数指定域属性保存的域，scope的取值同上；
void removeAttribute(String name,int scope)：
该方法的第一个参数指的是域属性的名称，第二个参数指的是将指定域属性从哪个域中移出，scope的取值同上；

便捷查询域中数据
PageContext类的父类中定义了如下方法：
Object findAttribute(String name)：该方法是从jsp的四个域pageContext、request、session、application依次查找指定名称的域属性，如果找到就停止，这说明如果这四个域中存在同名的属性，那么返回的数据是从page范围中获取的。即表示谁的域范围越小，谁的优先级越高。

7.jsp动作标签
jsp标签介绍
JSP标签也称之为Jsp Action(JSP动作)元素，它用于在Jsp页面中提供业务逻辑功能，避免在JSP页面中直接编写java代码，造成jsp页面难以维护。
常用的jsp标签
jsp:forward
<jsp:forward>标签是用来做请求转发，它与RequestDispatcher接口的forward()方法一样，唯一不同的是它是在jsp页面中使用。
jsp:include
<jsp:include>标签的作用使用来包含其他jsp页面，之前学习的include指令属于静态包含，而include动作标签是动态包含，它和RequestDispatcher接口的include()方法一样，是运行级别的包含
jsp:param
<jsp:param>标签作为<jsp:forward>标签和<jsp:include>标签的子标签，用来给转发或包含的页面传递数据。
静态包含与动态包含的区别


include标签与inclue指令区别:
1.include指令是静态包含，包含文件中包含了被包含文件的内容.
  include标签是动态包含，它包含的是被包含文件执行后的结果.
  
2.include指令不能带参数
  include标签是可以带参数的
二.EL
1.EL表达式介绍
EL表达式的介绍
EL是Expression Language的缩写，它是jsp内置的表达式语言，从jsp2.0开始，就不让再使用java脚本，而是使用el表达式或动态标签来代替java脚本。EL表达式的格式如下：
${表达式}
EL表达式代替的是java脚本中的<%= …%>，也就是说EL表达式也是向浏览器端输出数据。例如${1+2}会向浏览器端输出3。
EL表达式的作用
为了使JSP写起来更加简单,更加安全，可以通过EL表达式来替换我们jsp页面上的脚本
EL主要作用：
获取数据：
EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的web域 中检索java对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组)
执行运算：
利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null}
获取web开发常用对象
EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。
调用Java方法
EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。
EL表达式使用时注意事项
EL表达式是JSP 2.0(JavaEE1.4)规范中的一门技术 。因此，若想正确解析EL表达式，需使用支持Servlet2.4/JSP2.0技术的WEB服务器。
注意：有些Tomcat服务器如不能使用EL表达式
（1）升级成tomcat6
（2）在JSP中加入<%@ page isELIgnored="false" %>
以下为jsp,servlet,javaee,jdk版本之间的对应关系
jsp	javaee	servlet	tomcat	jdk
Jsp2.0	javaee1.4	servlet2.4	tomcat5.x	jdk1.4
Jsp.2.0/2.1	javaee5.0	servlet2.5	tomcat6.0	jdk1.5
Jsp2.1	javaee6.0	servlet3.0	tomcat7.x	jdk1.6


2.EL表达式获取数据
EL表达式之域查找
1.pageContext--------------------${pageScope.xxx}
2.request--------------------------${requestScope.xxx}
3.session--------------------------${sessionScope.xxx}
4.application---------------------${applicationScope.xxx}	
通过el获取时，如果没有查找到，会返回"".除了上面的获取方式外还有一种,例如
${requestScope[“xxx”]}
关于.与[]区别
	[]与.在使用方式上是一样的.但是如果名称中包含了"."等特殊字符，就必须使用[]来获取.	例如
	request.setAttribute("login.message", "登录失败");
	${requestScope.login.message}<br>错误的
	${requestScope["login.message"] }正确的	
如果没有写范围，会默认从page,request,session.application依次查找
EL表达式获取复杂数据
获取数组中数据
例如:${数组名称[索引] }
获取List中数据
例如:${集合名称[索引]}
  获取Map中数据
例如:${集合名称.key名称}
EL表达式之javabean导航
如果在域中保存的是javaBean对象，那么也可以使用EL表达式来访问javaBean的属性，因为EL表达式只做读操作，所以javaBean一定要为属性提供get方法，而对set方法没有要求。使用EL表达式获取javaBean属性就是javaBean导航。
3.EL表达式执行运算
常见的运算符

empty我们在开发中检查对象是否为null或“空”或判断容器size是否为0
注意事项:
EL表达式支持三元运算符
EL表达式不可以嵌套
${a+${b}}这种是不允许的。
EL中的加号问题
EL表达式中加号两边必须是数字或者字符串形式的数字
4.EL表达式内置对象
EL表达式的11个内置对象介绍
EL表达式的11个内置对象。11个内置对象如下所示：
pageScope
requestScope
sessionScope
applicationScope
param
paramValues
header
headerValues
initParam
cookie
pageContext
其中，pageScope，requestScope，sessionScope，applicationScope是域相关的内置对象，这里我们就不再多说。这11个内置对象中，有10个内置对象的类型是Map类型，只有pageContext的类型不是Map类型，它的类型是PageContext。
关于pageContext内置对象的介绍
EL表达式的11个内置对象中，有10个内置对象的类型是Map类型，只有pageContext的类型是PageContext。它的使用类似于我们jsp的内置对象pageContext,. 通过pageContext对象可以获取其他内置对象的任意的属性值。
	常用操作：${pageContext.request.contextPath}
关于请求参数相关内置对象的介绍
请求参数相关的内置对象是： 
param：该内置对象的类型是Map<String,String>，可以用来获取值为单值的请求参数，其中key指的是请求参数的名称，value指的是请求参数的值，使用param获取请求参数与request.getParameter()方法一样。
paramValues：该内置对象的类型是Map<String,String[]>，可以用来获取值为多值的请求参数，其中key是参数名，value是多个参数值组成的字符串数组。

注意，在使用EL获取参数时，如果参数不存在，返回的是空字符串，而不是null。这一点与使用request.getParameter()方法是不同的。
关于请求头相关内置对象的介绍
与请求头相关的内置对象是：
header:该内置对象的类型是Map<String,String>，用来获取值为单值的请求头信息，其中key代表的是请求头名称，value代表的是请求头的值；
  headerValues：该内置对象的类型是Map<String,String[]>，用来获取值为多值的请求头信息，key代表的是请求头名称，value代表的是请求头的多个值。
关于全局初始化参数的内置对象的介绍
我们再学习Servlet时，讲过在web.xml文件中配置全局初始化参数，并且全局初始化参数可以使用ServletContext对象获取，现在在EL表达式中内置了一个与初始化参数相关的对象：
initParam:该内置对象的类型是Map<String,String>，用来获取web.xml文件中<context-param>标签的参数值，其中key代表的是参数名，value代表的是参数值。
关于cookie相关内置对象的介绍
EL表达式也内置一个名为cookie的对象，该内置对象与cookie相关，如下：
cookie：该内置对象的类型为Map<String,Cookie>，其中key是Cookie的名字，value是Cookie对象本身。
5.EL函数使用
EL函数库介绍
EL函数库是由第三方对EL的扩展，我们现在学习的EL函数库是有JSTL提供的，JSTL我们会在后面的课程中详解。EL函数库就是定义了一些有返回值的静态方法，然后通过EL表达式来调用它们
在jsp页面中使用taglib指令导入EL函数库，就可以在页面中使用函数库中的方法。另外，导入的函数库可以使用的前提是，我们的项目中有相关的jar包

EL函数库使用
要使用EL函数库，首先要在jsp文件的上面使用taglib指令导入函数库：
	<%@ taglib prefix=”fn” uri=”http://java.sun.com/jsp/jstl/functions”%>
其中，uri的值并不是一个网络路径，只是在定义函数库时，拟定的一个位置。
下面我们来了解EL函数库中的相关方法，具体如下：
String toUpperCase(String input)：把字符串参数转换成大写，并返回；
String toLowerCase(String input)：把字符串参数转换成小写，并返回；
int indexOf(String input, String substring)：返回input中substring出现的索引位置；
boolean contains(String input, String substring)：查看input中是否包含substring，包     含返回true，否则返回false；
boolean containsIgnoreCase(String input, String substring)：在忽略大小写的情况下，查看input中是否包含substring，包含返回true，否则返回false；
boolean startsWith(String input, String substring)：判断input是否是以substring为前缀，如果是就返回true，否则就返回false；
boolean endsWith(String input, String substring)：判断input是否是以substring为后缀，如果是就返回true，否则就返回false；
String substring(String input, int beginIndex, int endIndex)：以beginIndex为开始值，endIndex为结束值，在input上截取子串；
String substringAfter(String input, String substring)：获取input中，substring所在位置后面的字符串；
substringBefore(String input, String substring)：获取input中，substring所在位置前面的字符串；
String escapeXml(String input)：把input中“<”、“>“、”&“、”'“、“"”进行转义；
String trim(String input)：去除input中的前后空格；
String replace(String input, String substringBefore, String substringAfter)：将input中的substringBefore替换成substringAfter；
String[] split(String input, String delimiters)：以delimiters为标识分割input，返回一个字符串数组；
int length(Object obj)：可以获取字符串、数组、各种集合的长度！
String join(String array[], String separator)：将array数组中的元素以separator连接起来，返回一个字符串。

示例代码
<!-- 导入函数库 -->
<%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8" import="java.util.*"%>
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>

<!-- 以下为body内容,头部自行添加 -->
<body>
<%
	String[] strs = {"a", "b","c"};//定义一个字符数组
	List list = new ArrayList();//定义一个list集合
	list.add("a");//向集合中添加一个字符
	pageContext.setAttribute("arr", strs);//将字符数据以arr的名字保存在page域中
	pageContext.setAttribute("list", list);//将list集合以list的名字保存在page域中
%>
	${fn:length(arr) }<br/><!--返回arr的长度-->
	${fn:length(list) }<br/><!--返回list的长度-->
	${fn:toLowerCase("Hello") }<br/> <!-- 将Hello变成小写 -->
	${fn:toUpperCase("Hello") }<br/> <!-- 将Hello变成大写 -->
	${fn:contains("abc", "a")}<br/><!-- 判断abc中是否包含a -->
	${fn:containsIgnoreCase("abc", "Ab")}<br/><!-- 在忽略大小写的情况下，判断abc中是否包含Ab -->
	${fn:contains(arr, "a")}<br/><!-- 判断arr数组中是否包含a -->
	${fn:containsIgnoreCase(list, "A")}<br/><!-- 在忽略大小写的情况下，判断list集合中是否包含A -->
	${fn:endsWith("Hello.java", ".java")}<br/><!-- 判断Hello.java是否以.java结束 -->
	${fn:startsWith("Hello.java", "Hell")}<br/><!-- 判断Hello.java是否以Hell开始 -->
	${fn:indexOf("Hello-World", "-")}<br/><!-- 返回“-”在Hello-World中出现的位置 -->
	${fn:join(arr, "-")}<br/><!-- 将arr数组中的元素以“-”连接，并返回 -->
	${fn:replace("Hello-World", "-", "+")}<br/><!-- 将Hello-World中的“-”替换成“+” -->
	${fn:join(fn:split("a;b;c;", ";"), "-")}<br/><!--最终是将数组的元素以“-”连接，并返回 -->
	
	${fn:substring("0123456789", 6, 9)}<br/><!-- 返回0123456789中索引值为6到索引值为9之间的元素 -->
	${fn:substring("0123456789", 5, -1)}<br/><!-- 返回0123456789中索引值为6到结束的元素  -->
	${fn:substringAfter("Hello-World", "-")}<br/><!-- 返回Hello-World中“-”后面的字符串 -->
	${fn:substringBefore("Hello-World", "-")}<br/><!-- 返回Hello-World中“-”前面的字符串  -->
	${fn:trim("     a b c     ")}<br/><!-- 去掉     a b c     前后的空格 -->
	${fn:escapeXml("<html></html>")}<br/> <!-- 将“<html></html>”中的“<”，“>”转义，即原样输出 -->
</body>


三.JSTL
1.JSTL标签介绍
jstl标签库介绍
JSTL(JSP Standard Tag Library，jsp标准标签库)是Apache对EL表达式的扩展，也就是说JSTL依赖EL表达式。JSTL是标签语言，使用起来非常方便。但是它不是jsp内置的标签，所以用的时候需要我们自己导包，以及指定标签库。
如果你使用Myeclipse开发javaweb，那么把项目发布到Tomcat时，你会发现，Myeclipse会在当前工程的lib目录下存放jstl的jar包，如果没有使用Myeclipse开发，那么就需要自己导入这个jstl的jar包：jstl-1.2.jar。
jstl标签库功能介绍
Jstl标签库一共包含了四大标签库：
core：核心标签库，这是我们学习的重点；
fmt：格式化标签库,用的很少；
sql：数据库标签库，这个标签库已经过时，本文档不再对其进行介绍；
xml：xml标签库，这个标签库已经过时，本文档不再对其进行介绍。
另外Jstl标签库中还包含了jstl函数。
如何使用jstl标签库
除了jsp动作标签外，使用其他第三方的标签都需要做以下两件事：
a.导入jar包；
b.在使用标签的jsp页面中使用taglib指令导入标签库。
例如:
在jsp页面导入jstl的核心标签库：
<%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core”%>
其中：
		prefix="c"：指定标签库的前缀，这个前缀可以赋任意的值，但大家都会在使用core标签库时指定前缀为c；
		uri="http://java.sun.com/jsp/jstl/core"：指定标签库的uri，它不一定是真实存在的网址，但它可以让JSP找到标签库的描述文件。
jstl核心标签库标签介绍
JSTL core标签库中 12个标签 
1、c:out 输出内容到浏览器端 
2、c:set 设置值到四种数据范围，设置四个范围中java对象的一个属性值 
3、c:remove 用来删除四个数据范围的数据 
4、c:catch 捕获程序异常 
5、c:if 取代页面中if条件语句，记住没有c:else 
<c:if test="${m>5}" > </c:if>
6、c:choose c:when c:otherwise 一起使用 ，取代if elseif else 结构 、switch-case 结构
7、c:forEach 取代页面中for循环 
8、c:forTokens 切割字符串 
9、c:import 效果和include类似 
10、c:url 完成URL重写 （禁用cookie的session追踪 ） ---- 结合c:param完成 中文URL编码
11、c:redirect 完成请求重定向
12、c:param 设置参数 一般和c:url,c:redirect或者c:import一起使用.
重点: c:if   c:foreach  c:set
2.JSTL核心标签
c:set
格式1:设置域中属性的值
<c:set var=’域中属性名称’ value=’属性的值’ [scope=’page(默认)|request|session|application’]></c:set>
例如:	
<c:set var="password" value="tom" scope="request"></c:set>
格式2:设置域中对象属性的值
<c:set property=’对象的属性’ value=’属性的值’ target=’域中对象’></c:set>
例如:
<c:set property="id" value="10" target="${user }"></c:set>
c:if
作用:页面上的逻辑判断
格式:
<c:if test="判断的内容(一般是el表达式)" var="给前面表达式的结果起个名称" [scope="page|request|session|application"] />
注意:
scope 用来表达式结果存放的域
若指定了标签的scope属性，则必须指定var属性
例如:
<c:if test="${3>4 }" var="flag">
		三大于四
</c:if>
<c:if test="${3<=4}" var='flag1'>
		三不大于四
</c:if>
c:choose与c:when c:otherwise
作用:用于指定多个条件选择的组合边界，它必须与<c:when>和<c:otherwise>标签一起使用。使用<c:choose>，<c:when>和<c:otherwise>三个标签，可以构造类似 “if-else if-else” 的复杂条件判断结构。
格式:
<c:choose>
<c:when test=”el表达式”>
语句
</c:when>
<c:otherwise>
语句
</c:otherwise>
</c:choose>	
例如:
<c:set var="day" value="17"/>
	<c:choose>
		<c:when test="${day ==1 }">
			周1
		</c:when>
		<c:when test="${day ==2 }">
			周2
		</c:when>
		<c:when test="${day ==3 }">
			周3
		</c:when>
		<c:when test="${day ==4 }">
			周4
		</c:when>
		<c:when test="${day ==5 }">
			周5
		</c:when>
		<c:when test="${day ==6 }">
			周6
		</c:when>
		<c:when test="${day ==7 }">
			周7
		</c:when>
		<c:otherwise>
			你估计来自火星
		</c:otherwise>
	</c:choose>
c:forEach
begin属性
设置循环变量从几开始
end属性
设置循环变量到几结束；
step属性
设置循环变量的步长
var属性
定义一个变量，用于接收循环或把数组或集合中遍历的每一个元素赋值给var指定的变量
varStatus属性
varStatus属性就是用来记录循环状态的，它可以创建一个循环变量vs，该循环变量有如下属性：
count：用来记录循环元素的个数；
index：用来记录所循环元素的下标；
first：判断当前循环的元素是否是第一个元素；
last：判断当前循环的元素是否是最后一个元素；
current：代表当前循环的元素。
  items:属性
指定要循环的变量，可以是一个数组也可以是一个集合，默认是支持EL表达式

c:out
格式:
<c:out value=’要输出的值’ default=’默认值’ escapeXml=’是否不解析为xml’></c:out>
例如:
在域中有 username=”<a href='#'>jack</a>”
<c:out value="${username }" default="ok" escapeXml="false" ></c:out>
显示的效果为 超链接的jack


c:remove
作用:移除域中的属性
格式:
<c:remove var=’属性的名称’ [scope=’page|request|session|application’]></c:remove>
例如:
<c:set var="password" value="123" scope='request'></c:set>
<c:remove var="password"  scope=’request’></c:remove>
注意:
scope不写的时候,会把所有域中的同名的属性删除掉.
c:catch
作用:
用于捕获嵌套在标签体中的内容抛出的异常
格式:
<c:catch var='异常对象名称'>
...
</c:catch>
例如:

<c:catch var="e">
		<%
			int i=0;
			int j=1;
			double k=j/i;
		%>
	</c:catch>
	
	<c:out value="${e }"></c:out>    将异常输出
<c:out value="${e.message }"></c:out>  将异常信息输出


c:forTokens
作用:用指定的分隔符切分指定内容
格式:
<c:forTokens items=’指定的内容或者el表达式’ delims=’分隔符[分隔符]’ var=’给分割出来的对象起个名字’>
</c:forTokens>
例如:
<c:set var="arr" value="12,23,34|45,56"></c:set>
	<c:forTokens items="${arr }" delims="|," var='a'>
		${a }-
	</c:forTokens>

c:import
作用:用于在JSP页面中导入一个URL地址指向的资源内容，其作用有点类似<jsp:include>这个JSP标准标签
最基本的使用
<c:import url="if.jsp"></c:import>
c:url
作用:用于在JSP页面中构造一个URL地址
格式:
<c:url value=’路径’ [context=’工程名’] [var=’给当前路径起个名称’] [scope=’page|request|session|application’]></c:url>
例如:
<c:url value="/jstl/if.jsp" var="ifurl" context="/day11" scope="request"/>

c:redirect
作用:主要应用于重定向
例如:
<c:redirect url="/jstl/if.jsp" context='/day11'></c:redirect>
c:param
作用:在地址栏后面设置参数,一般和c:import ,c:url,c:redirect一起使用
例如:
<c:url value="/jstl/if.jsp" var="ifurl" context="/day11" scope="request">
	<c:param name="username" value="sansan"></c:param>
	<c:param name="password" value="123"></c:param>
</c:url>

修改jsp的默认编码

javaweb设计模式
一.javaweb的设计模式
1.jsp模式介绍
SUN公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean模式(model1模式)，一种是Servlet+JSP+JavaBean模式(model2模式)。
Model1模式介绍
model1模式各部分功能分析
JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用程序，这种模式下，JavaBean用于封装业务数据，JSP即负责处理用户请求，又显示数据


model1模式的优缺点
优点
简单快捷，对开发人员要求不高
缺点
所有的操作都在jsp页面中，其中访问数据库的API是在jsp页面中完成的，难以维护，不适合做比较复杂应用 ,它只适合中小型项目.
Model2模式介绍
model2模式各部分功能分析
Servlet+JSP+JavaBean(MVC)模式适合开发复杂的web应用，在这种模式下，servlet负责处理用户请求，jsp负责数据显示，javabean负责封装数据。 Servlet+JSP、JavaBean模式程序各个模块之间层次清晰，web开发推荐采用此种模式。


model2模式的优缺点
优点:
维护方便，开发人员各司其职，互不干涉，有利于开发中的分工，有利于组件的重用。比较适合做比较复杂应用，它适合做中大型项目
缺点:
	项目开发难度增大，对开发人员的要求也随之提高。

2.javaBean介绍
什么是javaBean
JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。众所周知，属性名称符合这种模式，其他Java 类可以通过自身机制发现和操作这些JavaBean 的属性。
JavaBean可分为两种：一种是有用户界面（UI，User Interface）的JavaBean；还有一种是没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的JavaBean。JSP通常访问的是后一种JavaBean。而我们在javaweb开发中使用JavaBean主要是用于进行数据的运算(数据的封装)
javaBean在model1模式下的使用
jsp:useBean
jsp:setProperty
jsp:getProperty
例如:
username:<input type="text" name="username"><br>
password:<input type="password" name="password"><br>

jsp中使用bean标签来封装数据
<jsp:useBean id="user" class="cn.itcast.doamin.User"></jsp:useBean>	
<jsp:setProperty property="*" name="user"/>

通过getProperty标签获取数据
<jsp:getProtery property=’username’ name=’user’/>

要求：页面上组件的名称必须与javaBean的bean属性名称一致.
  bean属性是get/set 后面的名称

3.BeanUtils工具类的使用
javaBean在model2模式下的使用(BeanUtils工具使用)
在model1模式下我们使用jsp提供的标签来将数据封装到javaBean中，那么我们在model2模式下，因为jsp已经不在进行功能的处理，只是用于显示数据，这时怎样将数据封装到JavaBean中?
如果我们通过手动封装是可以的，但是如果参数过多，那么代码量很大，这时我们可以通过反射机制来完成请求参数的封装。
1.得到所有请求参数    request.getParameterMap();
2.得到javaBean类的Class对象，得到这个类中所有方法   getDeclaredMethods();
3.判断methods中是否具有  setXxx方法   从map集合的key中获取
4.如果查找到这个方法，通过这个方法的invoke进行调用  method.invoke()方法
        Class clazz = user.getClass();
		Method[] methods = clazz.getDeclaredMethods();
		Set<String> fields = map.keySet();
		for (Method m : methods) {
			for (String f : fields) {
				if(("set"+f).equalsIgnoreCase(m.getName())){
					m.invoke(user, map.get(f)[0]);
				}
			}
		}

上述代码我们自己完成会很复杂，在开发中，我们可以使用BeanUtils工具来完成它的底层实现就是通过java中的内省机制(最底层就是反射)来完成的。

BeanUtils工具介绍
Apache组织开发了一套用于操作JavaBean的API，这套API考虑到了很多实际开发中的应用场景，因此在实际开发中很多程序员使用这套API操作JavaBean，以简化程序代码的编写
BeanUtils工具的使用步骤
1.导入jar包
	commons-logging-1.1.1.jar
	commons-beanutils-1.8.3.jar	
2.使用
	BeanUtils.populate(javaBean对象, request.getParameterMap());
BeanUtils工具类型转换
在使用BeanUtils工具对数据进行封装时，它是如何做到将请求参数(字符串)封装到javaBean的不同类型的属性上的呢？
BeanUtils默认类型转换介绍
在BeanUtils工具中，有默认的类型转换，我们可以在org.apache.commons.beanutils.converters包下查看到它们提供的默认的类型转换器
BeanUtils自定义类型转换器
在开发中，有很多情况下，数据类型的转换使用BeanUtils工具可能不完全够用，这时我们就可以通过自定义类型转换器来完成操作。步骤如下:
1.创建一个类，实现这个接口org.apache.commons.beanutils.Converter 
	这个接口就是BeanUtils中所有类型转换器的根接口.
	
2.重写方法	public Object convert(Class type, Object value) 
	在这个方法中完成类型转换.	
	这个方法的返回值就是赋值给javaBean中对应的属性.
	type:要转换成的类型	
	value:表单传递过来的属性值	
3.注册类型转换器.		
	ConvertUtils.register(javaBean对象,要转换成的类型.class);

4.MVC设计模式
MVC模型介绍
MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。MVC模式最早被Trygve Reenskaug提出，成为施乐帕罗奥多研究中心（Xerox PARC）的Smalltalk语言发明的一种软件设计模式。MVC可对程序的后期维护和扩展提供了方便，并且使程序某些部分的重用提供了方便。而且MVC也使程序简化，更加直观。
MVC各部分功能
需要注意的是MVC设计模式并不是java语言独有的设计模式，几乎所有的B/S结构的项目都在使用这种设计模式。其中M、V、C分别代表如下含义：
M：model层，即模型层，用来维护数据以及提供数据访问方法；
V：view层，即视图层，通常由jsp充当，用于展示模型的部分数据或所有数据的可视化视图；
C：controller层，即控制层，用于对处理请求。

javaweb中的MVC
JSP Model2模式已经可以清晰的看到MVC完整的结构了，在JSP Model2中层次划分的很清晰，如下所示：
	JSP：视图层，用来与用户打交道，负责接收用户的数据，以及显示数据给用户；
	Servlet：控制层，负责找到合适的模型对象来处理业务逻辑，转发到合适的视图；
JavaBean：模型层，完成具体的业务工作，例如：开启、转账等。

5.javaweb三层架构
javaweb三层架构介绍
所谓的三层架构是由web层，业务层及数据层组成的，它们分别完成各自的工作，如下所示：
Web层：包含jsp和Servlet等与web相关的内容；
业务层：也称Service层，业务层中不包含JavaWeb的API，它只关心业务逻辑；
数据层：有时候也称为是持久层，其功能主要是负责数据库的访问，简单的说法就是实现对数据表的Select，Insert，Update，Delete的操作。

其中，web层是与web相关的内容，包括jsp和servlet，以及request、response、session、ServletContext等，这些对象只能出现在web层，不能出现在业务层；同样，业务层只关心业务逻辑，例如登录，注册功能，其中注册就是向数据库中插入一条数据，这样在数据层就对应一个方法，因此业务层依赖于数据层，可以这样理解：业务层的一个功能是由数据层的若干个对数据库的操作组成的。而web层将用户输入的数据传递给业务层，业务层处理之后将结果返回给web层，由web层再展示给用户。也就是说web层依赖于业务层。
由于业务层和数据层没有出现javaweb的API，因此业务层和数据层是可重用的，甚至可以应用在非web环境中。



javaweb三层架构与MVC的区别分析
三层架构是一个分层式的软件体系架构设计，它可适用于任何一个项目。
MVC是一个设计模式，它是根据项目的具体需求来决定是否适用于该项目。
那么架构跟设计模式有什么区别呢？
我们从接手一个项目开始，首先，我们需要进行架构设计，一般我们采用的就是分层式的架构设计，即我们的三层架构。
然后，在确定了架构以后，我们再根据项目的具体需求去考虑是否需要应用一些设计模式，比如是否应用我们的MVC模式，抽象工厂模式等等。

事务
一.事务
1.事务介绍
什么是事务 
事务，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元。这些单元要么全都成功，要么全都不成功。
事务在开发中的作用
下面我们来举例说明什么是事务，如下所示：
现实生活中的银行转账业务，张三要给李四转账1000元，而在程序员眼中两条SQL语句就可以搞定，如下：
给张三的账户减去1000元；
给李四的账户加上1000元；
如果在转账的业务中，成功的将张三的账户减去1000元，而在给李四的账户加1000元的时候，程序出现了问题，李四的账户没有加上1000元，而张三的账户却减掉了1000元，在现实生活中，这种情况肯定是不允许存在的。当我们将这个转账业务放在一个事务中，就不会出现以上情况了。
事务中有多个操作，这些操作要么全部成功，要么全部失败，也就是说给张三的账户减去1000元如果成功了，那么给李四的账户加上1000元的操作也必须是成功的，否则给张三减去1000元，以及给李四加上1000元都必须是失败的
2.mysql中的事务
mysql中默认事务处理
在mysql登录的情况下执行以下命令
show variables like '%commit%'; ---- autocommint 值是 on，说明开启自动提交

mysql数据库默认是开启事务的，一条sql一个事务.
oracle它默认情况下autocommit是off，就需要手动提交事务.

关闭mysql的自动事务处理命令
set autocommit = off;( set autocommit = 0)
如果设置autocommit 为 off，意味着以后每条SQL 都会处于同一个事务中，相当于第一条SQL执行前执行了 start transaction
mysql中手动事务处理
start transaction:-- 开启事务 一旦手动开启了事务,事务自动提交失效.
commit;-- 提交事务
rollback;-- 事务回滚
3.jdbc中的事务
jdbc中事务处理api
java.sql.Connection接口中提供了关于事务操作的API
setAutoCommit(boolean flag); 参数为false相当于start transaction
commit(); 事务提交
rollback(); 事务回滚	
回滚（Rollback）指的是程序或数据处理错误，将程序或数据恢复到上一次正确状态的行为
回滚点介绍
Savepoint setSavepoint(String name)
在当前事务中创建一个具有给定名称的保存点，并返回表示它的新 Savepoint 对象。
	例如:
Savepoint sp = conn.setSavepoint();
Conn.rollback(sp);
4.事务的特性
事务的四大特性是面试官经常问的问题，简称ACID(Atomicity Consistency Isolation Durability)，分别是：
原子性：原子性对应的英文是Atomicity，即表示事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败；
一致性：一致性对应的英文是Consistency，事务执行后，数据库状态与其它业务规则保持一致。例如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的；
隔离性：隔离性对应的英文是Isolation，是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰；
持久性：持久性对应的英文是Durability，指的是一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。
不同的事务，其一致性的表现形式是不同的，事务的其他三大特性其实都是为了事务的一致性服务的。
5.事务的隔离级别与问题
不考虑隔离性产生的问题介绍
脏读 一个事务读取到了另一个事务未提交数据.
不可重复读 一个事务内，两次读取到的数据不一致.(update)
虚读(幻读) 两次读取的数据不一致(insert)
事务的4种隔离级别介绍
数据库内部定义了四种隔离级别，用于解决三种隔离问题
1 Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化）
2 Repeatable read：可避免脏读、不可重复读情况的发生。（可重复读）不可以避免虚读
3 Read committed：可避免脏读情况发生（读已提交）
4 Read uncommitted：最低级别，以上情况均无法保证。(读未提交)
mysql数据库默认的事务隔离级别-----repeatable read级别.
oracle数据默认的事务隔离级别 ----read committed
设置事务隔离级别
mysql中设置
数据库默认有事务的隔离级别,mysql 中查看与修改事务的隔离级别
	set session transaction isolation level 隔离级别;设置事务隔离级别
	select @@tx_isolation;	查询当前事务隔离级别

jdbc中设置事务隔离级别
在java.sql.Connection接口中提供
		setTransactionIsolation(int level) ;
参数可以取 Connection 常量之一：
Connection.TRANSACTION_READ_UNCOMMITTED、
Connection.TRANSACTION_READ_COMMITTED、
Connection.TRANSACTION_REPEATABLE_READ 
Connection.TRANSACTION_SERIALIZABLE。					
（注意，不能使用 Connection.TRANSACTION_NONE，因为它指定了不受支持的事务。）
6.演示设置隔离级别来解决问题
脏读分析与解决
脏读:一个事务读取到另一个事务未提交数据.
1.打开两个窗口 A  B
2.在A 窗口中设置事务的隔离级别为Read uncommitted
3.在A窗口中设置事务的隔离级别为Read uncommitted
4.在A窗口中开启事务，将aaa---bbb  转500
5.在B窗口查看account表中数据,，发现可以查看 到A窗口中的未提交的事务  操作结果。就出现了脏读。

解决脏读  设置事务的隔离级别为 read committed
不可重复读分析与解决
在上面的例子基础上操作，当我们将事务的隔离级别设置 为read committed时，B窗口在查询时，就没有查询到A窗口未提交的数据，解决了脏读。
1.当A窗口将数据提交
2.这时B窗口之前查询过一次，再次查询，这时就发现，我们在一个事务中两次查询结果不一致，就出现了不可重复读。

解决不可重复读  设置事务的隔离级别为  Repeatable read
虚读分析
它主要强调的是多次查询的结果的条不一样，而不可重复读强调的是结果不一样。
串行化演示
设置隔离级别为 Serializable

注意
对于隔离级别四种
	安全性  Serializable>Repeatable read>read committed >read uncommitted;
性能    Serializable<Repeatable read<read committed <read uncommitted;
在开发中，一般使用  read committed  repeatable read两种。
7.案例-转账汇款
功能描述
实现帐户之间转账操作，在创建一个account.jsp页面，在页面上有三个文本框，分别是转款人，收款人及金额，提交到服务器端，服务器端调用jdbc完成汇款操作。
我们采用web三层架构
涉及到的页面与类
Web层   account.jsp  AccountServlet
Service层  AccoountService
	Dao层   AccountDao
案例分析

注意:
在service层中使用事务
代码实现
8.案例-使用ThreadLocal解决转账汇款问题
ThreadLocal介绍与原理分析
public class ThreadLocal<T>extends Object
该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。 
它的底层是使用了一个Map集合
Map<Thread,Object>
它的key就是当前的线程对象.
set(Object obj) 它就相当于  map.put(Thread.currentThread(),obj);
get()它就相当于 map.get(Thread.currentThread()));

第8章 标准标签库(JSTL)
8.1 准备实验环境
本章中所有的例子程序都在名为JSTL的WEB应用程序中运行，使用的Tomcat服务器版本为Tomcat5.5。为了简化代码和突出重点，本章中所有的JSP网页文件的例子程序都省略了<html>、<head>、<title>、<body>等HTML全局架构标签。本章中用于描述标签的语法的各种符号的意义如下：
[…]：表示方括号中的内容是可选的；
{option1|option2|option3|…}：表示花括号中用“|”字符分隔的各个选项不能同时出现，只能出现其中的一项；
如果属性的值字体加粗，表示这个值是对应属性的默认值；
如果属性的值用斜体字表示，表示该属性可以是表达式；如果标签体的内容用斜体字表示，表示标签体的内容可以是JSP代码。
为了本章后面讲解的方便，这里先创建一个名为UserBean的JavaBean程序，如例程8-1所示。
例程 8-1  UserBean.java 

package org.it315;
public class UserBean
{
	private String userName;
	private String password;
	private String address;
	private int visitCount;
	public void setUserName(String userName)
	{
		this.userName = userName;
	}
	public String getUserName()
	{
		return userName;
	}
	public void setPassword(String password)
	{
		this.password = password;
	}
	public String getPassword()
	{
		return password;
	}
	public void setAddress(String address)
	{
		this.address = address;
	}
	public String getAddress()
	{
		return address;
	}
	public void setVisitCount(int visitCount)
	{
		this.visitCount = visitCount;
	}
	public int getVisitCount()
	{
		return visitCount;
	}
}

编译这个源程序，将编译后的UserBean.class文件放在<TOMCAT_HOME>\webapps\JSTL\WEB-INF\classes\org\it315目录中。
8.2  JSTL概述
8.2.1  JSTL简介
从JSP 1.1规范开始JSP就支持使用自定义标签，使用自定义标签大大降低了JSP页面的复杂度，同时增强了代码的重用性，因此自定义标签在WEB应用中被广泛使用。许多WEB应用厂商都开发出了自己的一套标签库提供给用户使用，这导致出现了许多功能相同的标签，令网页制作者无所适从，不知道选择哪一家的好。为了解决这个问题，Apache Jakarta小组归纳汇总了那些网页设计人员经常遇到的问题，开发了一套用于解决这些常用问题的自定义标签库，这套标签库被SUN公司定义为标准标签库（The JavaServer Pages Standard Tag Library），简称JSTL。使用JSTL可以解决用户选用不同WEB厂商的自定义标签时的困惑，JSP规范同时也允许WEB容器厂商按JSTL标签库的标准提供自己的实现，以获取最佳性能。
由于JSTL是在JSP 1.2规范中定义的，所以JSTL需要运行在支持JSP 1.2及其更高版本的WEB容器上，例如，Tomcat 5.5。
1．JSTL的逻辑组成
笔者在写本章内容时的JSTL规范的最新版本是JSTL 1.1，它是JSP 2.0最新规范中的一个重要组成部分。JSTL 1.1中包含四个标签库和一组EL函数。为方便用户使用，JSP规范中描述了JSTL的各个标签库的URI地址和建议使用的前缀名，如表8.1所示。本章中在使用JSTL标签时，使用的都是这些建议的前缀。

表8.1  JSTL
标签库功能描述	标签库的URI	建议前缀
核心标签库	http://java.sun.com/jsp/jstl/core	c
XML标签库	http://java.sun.com/jsp/jstl/xml	x
国际化/格式化标签库	http://java.sun.com/jsp/jstl/fmt	fmt
数据库标签库	http://java.sun.com/jsp/jstl/sql	sql
EL自定义函数	http://java.sun.com/jsp/jstl/functions	fn

下面对JSTL的各个标签库进行简单的介绍：
（1）核心标签库中包含了实现WEB应用中的通用操作的标签。例如，用于输出一个变量内容的<c:out>标签、用于条件判断的<c:if>标签、用于迭代循环的<c:forEach>标签。
（2）国际化/格式化标签库中包含实现WEB应用程序的国际化的标签。例如，设置JSP页面的本地信息、设置JSP页面的时区、绑定资源文件，使本地敏感的数据（例如数值、日期等）按照JSP页面中设置的本地格式显示。
（3）数据库标签库中包含用于访问数据库和对数据库中的数据进行操作的标签。例如，从数据源中获得数据库连接、从数据库表中检索数据等。由于在软件分层的开发模型中，JSP页面仅用作表现层，我们一般不在JSP页面中直接操作数据库，而是在业务逻辑层或数据访问层操作数据库，所以，JSTL中提供的这套数据库标签库没有多大的实用价值。
（4）XML标签库中包含对XML文档中的数据进行操作的标签。例如，解析XML文档、输出XML文档中的内容，以及迭代处理XML文档中的元素。因为XML广泛应用于WEB开发，对XML文档的处理非常重要，XML标签库使处理XML文档变得简单方便，这也是JSTL的一个重要特征。  
（5）JSTL中提供的一套EL自定义函数包含了JSP页面制作者经常要用到的字符串操作。例如，提取字符串中的子字符串、获取字符串的长度和处理字符串中的空格等。
2．JSTL的物理组成
完整的JSTL应包含SUN公司提供的jstl.jar 包和WEB容器产商提供的JSTL实现包，以Apache Jakarta 小组提供的JSTL实现包为例，完整的JSTL包含jstl.jar、standard.jar 和 xalan.jar 三个 jar 包。sun 公司提供的jstl.jar 包封装了 JSTL所要求的一些API 接口和类，Apache Jakarta 小组编写的 JSTL API 实现类封装在standard.jar包中。由于 JDK 在 JDK 1.5 版本中才引入了 XPath API，而 apache Jakarta 小组开发的 JSTL API 是在 JDK1.5 之前推出的，所以 apache Jakarta 小组在 JSTL 中使用的是他们自己开发的 XPath API，这些 API 封装在 xalan.jar 包中。Standard.jar 包中包括核心标签库、国际化/格式化标签库、数据库标签库中的标签和标准的EL自定义函数的实现类，xalan.jar 包中包括 JSTL 解析 XPath 的相关 API 类。
8.2.2  安装和测试JSTL
1．下载JSTL包
可以从Apache的网站下载JSTL的jar包。进入http://jakarta.apache.org/taglibs/ 页面，根据相关的提示信息下载 zip压缩文件，这个压缩文件中包含JSTL的三个jar包。
提示：由于网站的不断升级，下载JSTL 的jar包的网址可能改变。读者在下载这些文件时，如果在指定的网址没有下载的链接，可以进入Apache的网站首页，然后根据相关的提示下载所需的文件。例如，笔者在编写JSTL初稿时，从http://jakarta.apache.org/taglibs/ 下载的压缩文件中只包含jstl.jar和standard.jar两个 jar 包，而 xalan.jar包要从 http://xml.apache.org/xalan-j/downloads.html 下载。
2．安装JSTL
在Tomcat中安装JSTL很简单，只要将 JSTL的jar包复制到<WEB应用程序>\WEB-INF\lib目录下即可。本章中所有的例子程序都在一个名为JSTL的WEB应用程序中运行，所以，将JSTL的三个jar包复制到 <TOMCAT_HOME>\webapps\JSTL\WEB-INF\lib目录下即完成了JSTL的安装。
提示：Tomcat 5.5自带的JSP例子应用程序中提供了使用JSTL标签的例子，在<TOMCAT_HOME>\webapps\jsp-examples\WEB-INF\lib目录中有JSTL的jstl.jar包和standard.jar包，所以，对于读者来说，如果不使用JSTL的XML标签库中的标签，可以直接将这两个包复制到<WEB应用程序的主目录>\WEB-INF\lib目录中，而不用事先从Apache的网站下载JSTL的jar包。
3．测试JSTL
安装完JSTL后，接下来就可以准备测试JSTL安装得是否成功了。
Apache小组在提供JSTL时，同时也提供了JSTL标签的标签描述文件（即TLD文件），它们都封装在standard.jar包中，位于该jar文件的META-INF目录中。用WinRAR 打开standard.jar包，进入META-INF目录，可以看到JSTL标签的标签库描述文件。查看这些TLD源文件，可以看到文件中定义的 <uri> 元素的内容与表8.1中列出的标签库的URI相同。因为standard.jar 包中封装了JSTL标签的标签库描述文件，Tomcat在启动时会自动加载standard.jar包中的META-INF目录下的所有TLD文件，所以使用JSTL时不必在web.xml文件中配置JSTL标签库的URI信息，就可以在JSP文件中直接使用JSTL标签。
要在JSP文件中使用JSTL，首先就需要使用taglib指令导入所需要使用的JSTL标签库，taglib指令的uri属性必须为相应标签库的TLD文件中的<uri>元素的值，taglib指令的prefix属性可以自己随意指定，但最好是采用表8.1中的建议前缀。在JSTL应用程序的主目录中按例程8-2编写一个包含JSTL标签的简单JSP文件test.jsp。
例程8-2 test.jsp

<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<c:out value="hello world!" />

上面的test.jsp页面中的<c:out>标签用于向浏览器输出文本内容，它属于JSTL的核心标签库中的标签。由于在test.jsp文件中只使用了JSTL的核心标签库中的标签，所以，只需要使用一条taglib指令导入JSTL的核心标签库，而不必使用多条taglib指令导入JSTL的所有标签库。
启动Tomcat后，在浏览器地址栏中输入test.jsp页面的地址进行访问，如果浏览器中显示出了“hello world!”，说明JSTL安装成功。
8.3  核心标签库
JSTL核心标签库包含了一组用于实现WEB应用中的通用操作的标签，JSP规范为核心标签库建议的前缀名为c。
8.3.1  <c:out>标签
<c:out> 标签用于输出一段文本内容到pageContext对象当前保存的“out”对象中，在通常情况下，pageContext对象当前保存的“out”对象的数据是输出到客户端浏览器，所以，<c:out> 标签通常用于输出一段文本内容到客户端浏览器。如果<c:out> 标签输出的文本内容中包含了需要进行转义的HTML特殊字符，例如，<、>、'、"、&等，<c:out> 标签默认对它们按表8.2进行HTML编码转换后再进行输出，这样就可以在浏览器中显示出这些字符。
表8.2 特殊字符转换

<c:out>标签标签有两种语法格式：
语法1，没有标签体的情况：
<c:out value="value" 
		[escapeXml="{true|false}"]
	 	[default="defaultValue"] />
语法2，有标签体的情况，在标签体中指定输出的默认值：
<c:out value="value" 
	 	[escapeXml="{true|false}"] >
	default value
</c:out>
<c:out>标签的属性说明如表8.3所示。
表8.3  <c:out>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
value	true	Object	指定要输出的内容
escapeXml	true	Boolean	指定是否将>、<、&、'、" 等特殊字符进行HTML编码转换后再进行输出。默认值为true
default	true	Object	指定如果value属性的值为null时所输出的默认值

当且仅当value属性的值为null时，<c:out> 标签输出默认值；如果没有指定默认值，默认为空字符串。<c:out> 标签的标签体的内容用于指定输出的默认值，如果value属性的值不为null，即使标签体部分不为空，标签体的内容也不会被输出。如果value属性不是指向一个java.io.Reader对象，<c:out> 标签将调用这个对象的toString方法，然后输出获得的字符串内容。如果value属性指向一个java.io.Reader对象，<c:out> 标签将从这个Reader对象中读取数据后进行输出，当有大量数据要被输出时，将这些数据以Reader对象的形式提供给<c:out>标签进行输出，将会极大提高系统性能。当采用escapeXml属性的默认设置值true时，<c:out>标签将对要输出的特殊字符按表8.2进行转换；如果将escapeXml属性设置为false，<c:out>标签将不对要输出的特殊字符进行转换，而是直接输出这些特殊字符。
例程8-3是<c:out> 标签的一个演示例子程序。
例程8-3  c_out1.jsp 

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%
	session.setAttribute("test_session", "testValue_session");
%>
直接输出一个字符串：
<c:out value="test" default="123456" /><br /><hr />
输出Web域中不存在的属性的值：<br />
<c:out value="${test_request}" default="这个属性不存在"/><br /><hr />
输出Web域中的test_session属性的值：<br />
<c:out value="${test_session}" />

例程8-3的运行结果如图8.1所示。

图8.1
例程8-4和例程8-5是两个用于演示<c:out>标签的escapeXml属性的例子程序，例程8-4没有设置escapeXml属性，例程8-5将escapeXml属性设置为了false。
例程8-4  c_out2.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:out value="${null}" >
	<meta http-equiv="refresh" content="0;url=http://www.it315.org" />
</c:out>

例程8-5 c_out3.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:out value="${null}" escapeXml="false">
	<meta http-equiv="refresh" content="0;url=http://www.it315.org" /> 
</c:out>

例程8-4和例程8-5的运行结果分别如图8.2和图8.3所示。

图8.2 

图8.3 
8.3.2  <c:set>标签
<c:set>标签用于设置各种Web域中的属性，或者设置Web域中的java.util.Map类型的属性对象或JavaBean类型的属性对象的属性。<c:set>标签有四种语法格式：
语法1，使用value属性设置指定域中的某个属性的值：
<c:set value="value"
		var="varName"
		[scope="{page|request|session|application}"] />
语法2，在标签体中设置指定域中的某个属性的值：
<c:set var="varName"
		[scope="{page|request|session|application}"]>
	body content
</c:set>
语法3，使用value属性设置Web域中的一个属性对象的某个属性：
<c:set value="value" 
		target="target" 
		property="propertyName" />
语法4，在标签体中设置Web域中的一个属性对象的某个属性性：
<c:set target="target" 
		property="propertyName">
	body content
</c:set>
<c:set>标签的属性说明如表8.4所示。
表8.4 <c:set>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
value	true	Object	用于指定属性值
var	false	String	用于指定要设置的Web域属性的名称
scope	false	String	用于指定属性所在的Web域
target	true	Object	用于指定要设置属性的对象，这个对象必须是JavaBean对象或java.util.Map对象
property	true	string	用于指定当前要为对象设置的属性名称

如果使用第1种语法格式时的value属性值为null，或者使用第2种语法格式时的标签体内容为空，<c:set>标签将从scope属性指定的域范围中删除var属性指定的属性。
在第3种语法格式和第4语法格式中，如果target属性的值是java.util.Map对象，property属性表示该Map对象的关键字，如果Map对象没有指定的关键字，就给Map对象增加指定的关键字；如果target属性的值是JavaBean对象，property属性表示JavaBean对象的属性，如果value的类型与JavaBean属性的类型不匹配时，会根据EL的转换规则自动进行转换。当使用第3种语法格式或第4种语法格式时，如果target属性的值为null(即target属性指定的对象不存在)，或者target属性的值是一个JavaBean对象，但该JavaBean中不存在property属性指定的属性，<c:set>标签将抛出异常。如果使用第3种语法格式时value属性的值为null，或者使用第4种语法格式时标签体的内容为空，如果target属性的值是一个java.util.Map对象，就从Map对象中删除property属性指定的关键字对应的项；如果target属性的值是一个JavaBean对象，就将JavaBean的相应属性的值设置为null。
例程8-6是使用<c:set>标签设置某个Web域中的属性的一个演示例子程序。
例程8-6 c_set1.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<c:set var="userName" scope="session">
	zxx
</c:set>
输出session 作用域中的userNamer属性的值:
<c:out value="${userName}" /><br /><hr />
输出session 作用域中的bookname属性的值:
<c:set var="bookname" scope="session" />
<c:out value="${bookname}" />

例程8-6的运行结果如图8.4所示。

图8.4
例程8-7是使用<c:set>标签设置UserBean对象和Map对象的属性的一个演示例子程序。
例程8-7  c_set2.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.HashMap" %>
<jsp:useBean id="user" class="org.it315.UserBean" />
<%	
	HashMap preferences = new HashMap();
	session.setAttribute("preferences",preferences);
%>
设置和输出UserBean对象的userName属性值:
<c:set value="zxx" target="${user}" property="userName" />
<c:out value="${user.userName}" /><br /><hr />
设置和输出UserBean对象的password属性值:
<c:set target="${user}" property="password" />
<c:out value="${user.password}" /><br /><hr />
设置和输出Map对象的color关键字的值:
<c:set target="${preferences}" property="color" value="${param.color}" />
<c:out value="${preferences.color}" />

在浏览器地址栏输入如下地址访问例程8-7：
	http://localhost:8080/JSTL/c_set2.jsp?color=green
例程8-7的运行结果如图8.5所示。

图8.5
8.3.3  <c:remove>标签
<c:remove>标签用于删除各种Web域中的属性，其语法格式如下：
<c:remove var="varName" 	
		[scope="{page|request|session|application}"] />
var属性用于指定要删除的属性的名称，scope属性用于指定要删除的属性所属的Web域，它们的值都不能接受动态值。如果没有指定scope属性，<c:remove>标签就调用PageContext.removeAttribute(varName)方法，否则就调用PageContext.removeAttribute(varName, scope) 方法。<c:remove>与<c:set>标签第一种语法格式的value属性值为null时的作用相同。
例程8-8是使用<c:remove>标签的一个演示例子程序。
例程8-8 c_remove.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<c:set value="org.it315" var="company" scope="request" />
<c:set var="passWord" scope="session">
	a123456a
</c:set>
在没有使用 &lt;c:remove&gt; 标签之前，变量的值为：<br />
company:<c:out value="${company}" /><br />
passWord:<c:out value="${passWord}" /><br />
<c:remove var="company" scope="request" />
<!--c:set var="company" scope="request" 此行与黑体字的一行作用是一样的/-->
<c:remove var="passWord" scope="session" /><hr />
在使用 &lt;c:remove&gt; 标签之后，变量的值为：<br />
company:<c:out value="${company}" /><br />
passWord:<c:out value="${passWord}" />

例程8-8的运行结果如图8.6所示。

图8.6
8.3.4  <c:catch>标签
<c:catch>标签用于捕获嵌套在标签体中的内容抛出的异常，其语法格式如下：
<c:catch [var="varName"]>
	nested actions
</c:catch>
var属性用于标识<c:catch>标签捕获的异常对象，其值是一个静态的字符串，不支持动态属性值。<c:catch>标签将捕获的异常对象以var指定的名称保存到page这个Web域中，如果没有指定var属性，则<c:catch>标签仅捕获异常，不在page域保存异常对象。如果<c:catch>标签体中的内容没有抛出异常，<c:catch>标签将从page域中删除var属性指定的属性。
<c:catch>标签可以捕获任何标签抛出的异常，并且可以同时处理多个标签抛出的异常，这样，可以对JSP页面的异常进行统一处理，显示给用户一个更友好的页面。JSP处理异常的通用机制是出现重要异常后跳转到错误处理页面，建议尽量不要用<c:catch>标签来代替JSP的错误处理机制，只对一些次要异常才使用<c:catch>标签进行捕获处理。
例程8-9是使用<c:catch>标签进行异常捕获处理的一个演示例子程序。
例程8-9  c_catch.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<c:catch var="myex">
<%
	int i = 0;
	int j = 10;
	out.println(j + "/" + i + "=" + j/i);
%>
</c:catch>
异常：<c:out value="${myex}" /><br />
异常 myex.getMessage：<c:out value="${myex.message}" /><br />
异常 myex.getCause：<c:out value="${myex.cause}" /><br />
异常 myex.getStackTrace：<c:out value="${myex.stackTrace}" />

在例程8-9中，<c:catch>标签内嵌套的脚本元素抛出了异常，<c:catch var="myex">将捕获到这个异常，调用<c:out value="${myex.message}" />，相当于调用<%=myex.getMessage()%>。例程8-9的运行结果如图8.7所示。

图8.7
8.3.5  <c:if>标签
JSP页面的显示逻辑中也经常需要进行条件判断，<c:if>标签可以构造简单的“if-then”结构的条件表达式，如果条件表达式的结果为真就执行标签体部分的内容。<c:if>标签有两种语法格式：
语法1，没有标签体的情况：
<c:if test="testCondition" var="varName"
		[scope="{page|request|session|application}"] />
语法2，有标签体的情况，在标签体中指定要执行的内容：
<c:if test="testCondition" [var="varName"] 
		[scope="{page|request|session|application}"]>
	body content
</c:if>
<c:if>标签的属性说明如表8.5所示。
表8.5   <c:if>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
test	true	boolean	决定是否处理标签体中的内容的条件表达式 
var	false	String	用于指定将test属性的执行结果保存到某个Web域中的某个属性的名称
scope	false	String	指定将test属性的执行结果保存到哪个Web域中

对于语法2，如果指定了<c:if>标签的scope属性，则必须指定var属性。
例程8-10是使用<c:if>标签的一个演示例子程序。
例程8-10  c_if.jsp 

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<jsp:useBean id="user" class="org.it315.UserBean" />
<c:set value="${param.count}" target="${user}" property="visitCount" />
<c:if test="${user.visitCount == 1}">
	这是您第一次访问本网站，欢迎您！
</c:if>

在浏览器地址栏输入如下地址访问例程8-10：
	http://localhost:8080/JSTL/c_if.jsp?count=1 
例程8-10的运行结果如图8.8所示。

图8.8
8.3.6  <c:choose>标签
<c:choose>标签用于指定多个条件选择的组合边界，它必须与<c:when>和<c:otherwise>标签一起使用。使用<c:choose>，<c:when>和<c:otherwise>三个标签，可以构造类似 “if-else if-else” 的复杂条件判断结构。
<c:choose>标签没有属性，在它的标签体内只能嵌套一个或多个<c:when>标签和0个或一个<c:otherwise>标签，并且同一个<c:choose>标签中的所有<c:when>子标签必须出现在<c:otherwise>子标签之前。如果<c:choose>标签内嵌套一个<c:when>标签和<c:otherwise>标签，就相当于“if-else”的条件判断结构；如果<c:choose>标签内嵌套多个<c:when>标签和一个<c:otherwise>标签，就相当于“if-else if-else”标签。
<c:when>标签只有一个test属性，该属性的值为布尔类型。test属性支持动态值，其值可以是一个条件表达式，如果条件表达式的值为true，就执行这个<c:when>标签体的内容。<c:when>标签体的内容可以是任意的JSP代码。<c:otherwise>标签没有属性，它必须作为<c:choose>标签的最后分支出现。
当JSP页面中使用<c:choose>标签时，嵌套在<c:choose>标签内的test条件成立的第一个<c:when>标签的标签体内容将被执行和输出。当且仅当所有的<c:when>标签的test条件都不成立时，才执行和输出<c:otherwise>标签的标签体内容。如果所有的<c:when>标签的test条件都不成立，并且<c:choose>标签内没有嵌套<c:otherwise>标签，则不执行任何操作。
例程8-11是使用<c:choose>、<c:when>、<c:otherwise>标签的一个演示例子程序。
例程8-11 c_choose.jsp 

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<c:set value="${param.count}" var="count" />
<c:choose>
	<c:when test="${count == 0}">
		对不起，没有符合您要求的记录。
	</c:when>
	<c:otherwise>
		符合您要求的记录共有${count}条.
	</c:otherwise>
</c:choose>

在浏览器地址栏输入如下地址访问例程8-11：
	http://localhost:8080/JSTL/c_choose.jsp?count=0 
例程8-11的运行结果如图8.9所示。如果将参数count的值修改为10，则运行结果如图8.10所示。



图8.9

图8.10 

例程8-12是一个综合使用<c:if>标签和<c:choose>等标签的例子程序，在这个例子程序中，首先使用<c:if>标签判断表单提交的方式是否是POST，如果是，就再使用<c:choose>等标签根据表单提交的内容进行不同的处理。
例程8-12  c_customLogic.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:if test="${pageContext.request.method=='POST'}">
	<c:choose>
		<c:when test="${param.favor == 'computer'}">
			Your favourite course is <b>computer</b>.
		</c:when>
		<c:otherwise>
			Your favourite course is <i>other</i>.
		</c:otherwise>
	</c:choose>
</c:if>
<form method="POST">What is your favourite course?<br/>
<input type="text" name="favor" />
<input type="submit" value="submit" />
</form>

在浏览器地址栏中直接访问c_customLogic.jsp的运行结果如图8.11所示，在文本框中输入“computer”，单击其中的submit按钮后的运行结果如图8.12所示。

图8.11

图8.12
8.3.7  <c:forEach>标签
JSP页面的显示逻辑中也经常需要对集合对象进行循环迭代操作，<c:forEach>标签用于对一个集合对象中的元素进行循环迭代操作，或者按指定的次数重复迭代执行标签体中的内容。<c:forEach>标签有两种语法格式：
语法1，在集合对象中迭代：
<c:forEach [var="varName"] 
			items="collection"
			[varStatus="varStatusName"]
			[begin="begin"] [end="end"] [step="step"]>
	body content
</c:forEach>
语法2，迭代固定的次数：
<c:forEach [var="varName"]
			[varStatus="varStatusName"]
			begin="begin" end="end" [step="step"]>
	body content
</c:forEach>
<c:forEach>标签的属性说明如表8.6所示。
表8.6  <c:forEach>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
var	false	String	指定将当前迭代到的元素保存到page这个Web域中的属性名称
items	true	任何支持的类型	将要迭代的集合对象
varStatus	false	String	指定将代表当前迭代状态信息的对象保存到page这个Web域中的属性名称
begin	true	int	如果指定items属性，就从集合中的第begin个元素开始进行迭代，begin的索引值从0开始编号；如果没有指定items属性，就从begin指定的值开始迭代，直到end值时结束迭代
end	true	int	参看begin属性的描述
step	true	int	指定迭代的步长，即迭代因子的迭代增量

在使用<c:forEach>标签时，需要注意如下几点说明：
如果指定begin属性，其值必须大于或等于零；
如果指定步长（step属性），其值必须大于或等于1；
如果items属性的值为null，则要处理的集合对象为空，这时不执行迭代操作；
如果指定的begin属性的值大于或等于集合对象的长度，不执行迭代操作；
如果指定的end属性的值小于begin属性的值，不执行迭代操作；

<c:forEach>标签的items属性的值支持下面的数据类型：
任意类型的数组
java.util.Collection
java.util.Iterator
java.util.Enumeration
java.util.Map
String
items属性还支持与数据库有关的数据类型java.sql.ResultSet(包括javax.sql.RowSet)，这些数据类型将在8.5 节的数据库标签中进行介绍。对字符串的迭代操作通常使用<c:forTokens>标签或JSTL函数，例如fn:split和fn:jion，JSTL函数将在8.7节进行介绍。

1．迭代Collection类型的集合对象
例程8-13是使用<c:forEach>标签迭代Collection类型的集合对象的一个应用举例。
例程8-13  c_forEach_collection.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.*,org.it315.UserBean" %>
<%
	Collection users = new ArrayList();
	for(int i=0; i<5; i++)
	{
		UserBean user = new UserBean();
		user.setUserName("user" + i);
		user.setPassword("guess" + i);
		users.add(user);
	}
	session.setAttribute("users", users);
%>
	<div style="text-align:center">User List
	<table border="1">
		<tr><td>用户名</td><td>密码</td></tr>
		<c:forEach var="user" items="${users}">
			<tr>
				<td>${user.userName}</td><td>${user.password}</td>
			</tr>
		</c:forEach>
	</table></div>

例程8-13的运行结果如图8.13所示。

图8.13
2．迭代Map对象
使用<c:forEach>标签迭代Map类型的集合对象时，迭代出的每个元素的类型为Map.Entry，Map.Entry代表Map集合中的一个条目项，其中的getKey()方法可获得条目项的关键字，getValue()方法可获得条目项的值。
EL中的requestScope隐含对象代表request作用域中的所有属性的Map对象，所以我们可以使用<c:forEach>标签迭代输出EL中的requestScope隐含对象中的所有元素，如例程8-14所示。
例程8-14 c_forEach_map.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
	<%
		request.setAttribute("attr1","value1");
		request.setAttribute("attr2","value2");
	%>
	<div style="text-align:center">Properties(Map)
	<table border="1">
		<tr><td>Map的关键字</td><td>Map的对应关键字的值</td></tr>
		<c:forEach var="entry" items="${requestScope}">
			<tr><td>${entry.key}</td><td>${entry.value}</td></tr>
		</c:forEach>
	</table></div>

例程8-14的运行结果如图8.14所示。

图8.14
3．迭代指定的次数
<c:forEach>标签可以按指定的次数重复迭代执行标签体中的内容，使用这种方式迭代时，可以指定迭代的步长。例程8-15中分别演示了指定迭代步长和没有指定迭代步长的情况。
例程8-15 c_forEach_count.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
从11到16迭代，指定迭代步长为2：
<c:forEach var="i" begin="11" end="16" step="2">
	${i}
</c:forEach><br /><hr />
从0到5迭代，没有指定迭代步长：
<c:forEach var="i" begin="0" end="5">
	${i}
</c:forEach>

例程8-15的运行结果如图8.15所示。

图8.15
4．指定迭代集合对象的范围和步长
<c:forEach>标签迭代集合类对象时，也可以指定迭代的范围和步长，如例程8-16所示。
例程8-16 c_forEach_col.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.*,org.it315.UserBean" %>
<%
	Collection users = new ArrayList();
	for(int i=0; i<6; i++)
	{
		UserBean user = new UserBean();
		user.setUserName("user" + i);
		user.setPassword("guest" + i);
		users.add(user);
	}
	session.setAttribute("users", users);
%>
<div style="text-align:center">User List(指定迭代范围和步长)
<table border="1">
	<tr><td>用户名</td><td>密码</td></tr>
	<c:forEach var="user" items="${users}" end="5" step="2">
		<tr>
			<td>${user.userName}</td><td>${user.password}</td>
		</tr>
	</c:forEach>
</table></div>

例程8-16的运行结果如图8.16所示。

图8.16
5．获取迭代的状态信息
不管是迭代集合对象，还是迭代指定的次数，在迭代时都可以获得当前的迭代状态信息。<c:forEach>标签可以将代表当前迭代状态信息的对象保存到page域中，varStatus属性指定了这个对象保存在page域中的属性名称。代表当前迭代状态信息的对象的类型为javax.servlet.jsp.jstl.core.LoopTagStatus，从JSTL规范中可以查看到这个类的详细信息，其中定义了如下一些方法：
public java.lang.Integer getBegin()
返回为标签设置的begin属性的值，如果没有设置begin属性则返回null
public int getCount()
返回当前已循环迭代的次数
public java.lang.Object getCurrent()
返回当前迭代到的元素对象
public java.lang.Integer getEnd()
返回为标签设置的end属性的值，如果没有设置end属性则返回null
public int getIndex()
返回当前迭代的索引号
public java.lang.Integer getStep()
返回为标签设置的step属性的值，如果没有设置step属性则返回null
public boolean isFirst()
返回当前是否是第一次迭代操作
public boolean isLast()
返回当前是否是最后一次迭代操作

例程8-17是一个获取迭代状态信息的例子程序。
例程8-17 c_forEach_col2.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.*,org.it315.UserBean" %>
<%
	Collection users = new ArrayList();
	for(int i=0; i<6; i++)
	{
		UserBean user = new UserBean();
		user.setUserName("user" + i);
		user.setPassword("guest" + i);
		users.add(user);
	}
	session.setAttribute("users", users);
%>
<div style="text-align:center">User List
<table border="1">
	<tr><td>用户名</td><td>密码</td><td>index</td>
	<td>count</td><td>first?</td><td>last?</td></tr>
	<c:forEach var="user" items="${users}" varStatus="sta" begin="1" step="2">
		<tr>
			<td>${user.userName}</td><td>${user.password}</td>
			<td>${sta.index}</td><td>${sta.count}</td>
			<td>${sta.first}</td><td>${sta.last}</td>
		</tr>
	</c:forEach>
</table></div><hr>

<div style="text-align:center">迭代固定的次数
<table border="1">
	<tr><td>数值</td><td>index</td><td>count</td>
	<td>first?</td><td>last?</td></tr>
	<c:forEach var="i" varStatus="sta1" begin="101" end="103">
		<tr>
			<td>${i}</td><td>${sta1.index}</td><td>${sta1.count}</td>
			<td>${sta1.first}</td><td>${sta1.last}</td>
		</tr>
	</c:forEach>
</table></div>

例程8-17的运行结果如图8-17所示。

图8.17 
6．与条件标签结合使用
迭代标签可以与条件标签结合使用，对数据进行有条件的迭代，应用举例如例程8-18所示。
例程8-18 c_forEach_com.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<div style="text-align:center">
<table border="1"><tr><td>number</td><td>count</td><td>even|odd</td></tr>
<c:forEach var="i" begin="11" end="13" varStatus="status">
	<tr><td>${i}</td><td>${status.count}</td><td>
	<c:choose>
		<c:when test="${status.count % 2 == 0}">
			偶数行
		</c:when>
		<c:otherwise>
			奇数行
		</c:otherwise>
	</c:choose></td></tr>
</c:forEach>
<table></div>

例程8-18的运行结果如图8.18所示。

图8.18 
8.3.8  <c:forTokens>标签
<c:forTokens>标签专门用于实现类似java.util.StringTokenizer类的迭代功能，但它是以单个字符作为分隔符，同时可以指定多个字符作为多个并行的分隔符。<c:forTokens>标签的语法格式如下：
<c:forTokens items="stringOfTokens" delims="delimiters"
			[var="varName"]
			[varStatus="varStatusName"]
			[begin="begin"] [end="end"] [step="step"]>
	body content
</c:forTokens>
<c:forTokens>标签的属性说明如表8.7所示。
表8.7  c:forTokens
属性名	是否支持EL	属性类型	属 性 描 述
var	false	String	指定将当前迭代出的子字符串保存到page这个Web域中的属性名称
items	true	String	将要迭代的字符串
delims	true	String	指定一个或多个分隔符
varStatus	false	String	指定将代表当前迭代状态信息的对象保存到page这个Web域中的属性名称，代表当前迭代的状态信息的对象的类型为javax.servlet.jsp.jstl.core.LoopTagStatus，从JSTL规范中可以查看这个类的详细信息
begin	true	int	指定从第begin个子字符串开始进行迭代，begin的索引值从0开始编号
end	true	int	指定迭代到第begin个子字符串，begin的索引值从0开始编号
step	true	int	指定迭代的步长，即每次迭代后的迭代因子增量

在使用<c:forTokens>标签时，需要注意如下几点说明：
如果指定begin属性，其值必须大于或等于零。
如果指定步长（step属性），其值必须大于或等于1。
如果指定的end属性的值小于begin属性的值，不执行迭代操作。
例程8-19是一个使用<c:forTokens>标签的例子程序。
例程8-19 c_forTokens.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
使用"|"作为分隔符<br />
<c:forTokens var="token" items="spring,summer|autumn,winter" delims="|">
	${token}&copy;
</c:forTokens><br />
使用"|"和","作为分隔符<br />
<c:forTokens var="token" items="spring,summer|autumn,winter" delims="|," end="3">
	${token}&copy;
</c:forTokens><br />
使用"-"作为分隔符<br />
<c:forTokens var="token" items="year--season--month-week" delims="-">
	${token}&copy;
</c:forTokens>

例程8-19的运行结果如图8.19 所示。

图8.19
8.3.9  URL相关的标签概述
JSTL核心标签库中提供了如下一些与URL操作相关的标签：
<c:import>
<c:url>
<c:redirect>
<c:param>
在举例讲解上面的某些标签时，要引用另外一个JSP文件，这里先创建好这个JSP文件，如例程8-20所示。
例程8-20 register.jsp

<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%
	String name = request.getParameter("name");
	name = new String(name.getBytes("iso-8859-1"),"gb2312");
	session.setAttribute("name",name);
	String country = request.getParameter("country");
	country = new String(country.getBytes("iso-8859-1"),"gb2312");
	session.setAttribute("country",country);
%>
name=${name};
country=${country}<br />

8.3.10  <c:param>标签
在JSP页面进行URL的相关操作时，经常要在URL地址后面附加一些参数。<c:param>标签可以嵌套在<c:import>、<c:url>或<c:redirect>标签内，为这些标签所使用的URL地址附加参数。<c:param>标签在为一个URL地址附加参数时，将自动对参数值进行URL编码，例如，如果传递的参数值为“中国”，则将其转换为“%d6%d0%b9%fa”后再附加到URL地址后面，这也就是使用<c:param>标签的最大好处。<c:param>标签有两种语法格式：
语法1，使用value属性指定参数的值：
<c:param name="name" value="value" />
语法2，在标签体中指定参数的值：
<c:param name="name">
	parameter value
</c:param>
<c:param>标签的属性说明如表8.8所示。
表8.8  <c:param>标签的属性

8.3.11  <c:url>标签
<c:url>标签用于在JSP页面中构造一个URL地址，其主要目的是实现URL重写。URL重写就是将会话标识号以参数形式附加在URL地址后面，详细细节请参看笔者编著的《深入体验java Web开发内幕——核心基础》一书中的第7.4.8的讲解。<c:url>标签有两种语法格式：
语法1，没有标签体的情况：
<c:url value="value" 
		[context="context"]
		[var="varName"] 
		[scope="{page|request|session|application}"] />
语法2，有标签体的情况，在标签体中指定构造的URL的参数：
<c:url value="value" 
		[context="context"]
		[var="varName"] 
		[scope="{page|request|session|application}"]>
	<c:param>标签
</c:url>
<c:url>标签的属性说明如表8.9所示。
表8.9  <c:url>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
value	true	String	指定要构造的URL
context	true	String	当要使用相对路径导入同一个服务器下的其他WEB应用程序中的URL地址时，context属性指定其他WEB应用程序的名称
var	false	String	指定将构造出的URL结果保存到Web域中的属性名称
scope	false	String	指定将构造出的URL结果保存到哪个Web域中

value属性所指定的URL可以是相对路径和绝对路径，其具体细节与8.3.12节的<c:import>标签的url属性的细节相同。使用<c:url>标签构造URL时，可以通过嵌套的<c:param>标签指定参数，或在value属性中直接指定参数。
例程8-21是一个使用<c:url>标签的例子程序。
例程8-21 c_url.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
使用绝对路径构造URL:
<c:url value="http://localhost:8080/JSTL/URL/register.jsp" var="myUrl1">
	<c:param name="name" value="张三" />
	<c:param name="country" value="${param.country}" />
</c:url>
<a href="${myUrl1}">Register1</a><hr />
使用相对当前JSP页面的路径构造URL:
<c:url value="register.jsp?name=wangwu&country=France" var="myUrl2" />
<a href="${myUrl2}">Register2</a><hr />
使用相对当前WEB应用的路径构造URL:
<c:url value="/URL/register.jsp?name=zhaoliu&country=England" var="myUrl3" />
<a href="${myUrl3}">Register3</a>

在浏览器地址栏输入如下地址访问例程8-21：
	http://localhost:8080/JSTL/c_url.jsp?country=China
查看例程8-21的运行结果的源文件，内容如例程8-22所示。
例程8-22 c_url.jsp运行结果的源文件

使用绝对路径构造URL:
<a href="http://localhost:8080/JSTL/URL/register.jsp?name=%d5%c5%c8%fd&country=China">Register1</a><hr />
使用相对当前JSP页面的路径构造URL:
<a href="register.jsp?name=wangwu&country=France">Register2</a><hr />
使用相对当前WEB应用的路径构造URL:
<a href="/JSTL/URL/register.jsp?name=zhaoliu&country=England">Register3</a>

8.3.12  <c:import>标签
<c:import>标签用于在JSP页面中导入一个URL地址指向的资源内容，其作用有点类似<jsp:include>这个JSP标准标签，但功能更强大。<c:import>标签标签有两种语法格式：
语法1，将URL地址指向的资源内容以字符串形式输出或以字符串形式保存到一个变量中：
<c:import url="url" 
		[context="context"]
		[var="varName"]
		[scope="{page|request|session|application}"]
		[charEncoding="charEncoding"]>
	optional body content for <c:param> subtags
</c:import>
语法2，将URL地址指向的资源内容保存到一个Reader对象中：
<c:import url="url"
		[context="context"]
		varReader="varReaderName"
		[charEncoding="charEncoding"]>
	body content where varReader is consumed by another action
</c:import>
<c:import>标签的属性说明如表8.10所示。
表8.10  <c:import>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
url	true	String	指定要导入的资源的URL地址
context	true	String	当要使用相对路径导入同一个服务器下的其他WEB应用程序中的资源时，context属性指定其他WEB应用程序的名称
var	false	String	指定将导入的资源内容保存到Web域中的属性名称
scope	false	String	指定将导入的资源内容保存到哪个Web域中
charEncoding	true	String	将导入的资源内容转换成字符串时所使用的字符集编码
varReader	false	String	指定将导入的资源内容保存到page域中的一个java.io.Reader对象中，varReader属性指定了该Reader对象在page这个Web域中的属性名称。

使用<c:import>标签导入其他资源文件时，如果被导入的资源文件中含有非ASCII码字符，必须注意指定charEncoding属性，否则可以不设置这个属性。
当使用第1种语法格式时，如果指定了var属性，导入的资源内容以字符串形式保存到一个变量中，var属性指定了这个变量保存在Scope属性指定的Web域中的名称；如果没有指定var属性，导入的资源内容将以字符串形式直接输出。第1种语法格式的标签体内中可以嵌套<c:param>标签来给导入的资源传递参数。
使用第2种语法格式时，导入的资源内容保存到page域中的一个java.io.Reader对象中，varReader属性指定了该Reader对象在page这个Web域中的属性名称。因为<c:import>标签在标签结束时将关闭Reader对象对应的输入流，所以varReader属性指定的变量只在标签内有效。第2种语法格式的标签体内中应该且只能嵌套调用varReader属性指定的reader对象的其他标签。当使用第2种语法格式时，<c:import>标签体内不能嵌套<c:param>标签，如果要给导入的资源传递参数，则必须在url属性值中设置好这些参数，这时可以使用<c:url>标签来创建一个带参数的URL地址，此时如果有必要，<c:import>标签将删除导入资源中的所有URL重写后产生的session id信息。

使用<c:import>标签导入外部资源文件时，url属性可以设置为被导入资源的相对URL或绝对URL。
1．使用相对URL导入其他资源文件
（1）当被导入的外部资源文件与当前JSP文件属于同一个WEB应用程序时，JSP容器对资源路径的处理与<jsp:include>标签相同，这时路径可以以“/”字符开始，也可以以文件名或目录名开始。如果路径以“/”字符开始，则被导入资源文件的路径是相对于JSP页面所在的WEB应用的根路径；如果路径以文件名或目录名开始，则被导入的资源文件的路径就是相对于当前的JSP页面的路径。
（2）当被导入的外部资源文件与JSP文件属于同一个服务器下的不同的WEB应用时，如果要使用相对路径，路径必须以“/”开始。此时，<c:import>标签的context属性必须被设置为被导入的资源文件所在的WEB应用程序的名称。注意：使用相对路径导入其它WEB应用程序中的资源时，必须在<TOMCAT_HOME>\conf\server.xml配置文件中将使用<c:import>标签的WEB应用程序的<Context>元素的crossContext属性设置为true，如下所示：
<Context path="/JSTL" docBase="JSTL" crossContext="true"/>
2．使用绝对URL导入其他资源
使用绝对路径导入外部资源文件时，即使被导入的文件与当前JSP文件属于同一个WEB应用程序，被导入的资源文件也不会共享当前JSP页面的request和session对象。因为在这种情况下，当前JSP文件所属的Web服务器充当了一个Http客户端程序，去访问绝对路径所指定的外部资源文件，然后将响应结果的实体内容加入到当前JSP页面中，此时，访问当前JSP页面的客户端是浏览器，而访问绝对路径所指定的外部资源文件的客户端是当前JSP文件所属的Web服务器，这显然属于两个不同的客户端，所以，被导入的资源文件和当前JSP页面不可能共享request和session对象。
例程8-23是使用<c:import>标签的一个应用举例。
例程8-23 c_import.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
使用相对路径导入同一个WEB应用中的资源:<br />
<c:import url="/register.jsp?name=zhangsan">
	<c:param name="name" value="zxx" />
</c:import><hr />
使用相对路径导入同一个服务器下的不同WEB应用中的资源:<br />
<c:import url="/hello.jsp" context="/EL" /><hr />
使用绝对路径导入资源示例1:
<c:import url="http://localhost:8080/EL/hello.jsp" /><hr />
使用绝对路径导入资源示例2:
<c:import url="http://localhost:8080/JSTL/register.jsp" var="myImport" 
			charEncoding="gb2312">
	<c:param name="name" value="${param.name}" />
	<c:param name="country" value="中国" />
</c:import>
${myImport}

在浏览器地址栏输入如下地址访问例程8-23，其运行结果如图8.20 所示：
	http://localhost:8080/JSTL/c_import.jsp?name=zxx&country=China

图8.20 
在<c:import>标签中使用相对路径导入其他资源时，其工作原理与<jsp:include>标签相同，所以，在被导入的资源文件中可以获得传递给当前JSP页面的请求参数，例如，例程8-23中的第一个<c:import>标签并没有在目标url后增加country参数，但是，在register.jsp页面中获得了country参数。
8.3.13  <c:redirect>标签
<c:redirect>标签用于将当前的访问请求转发或重定向到其他资源，它可以根据url属性所指定的地址，执行类似<jsp:forward>这个JSP标准标签的功能，将访问请求转发到其他资源；或执行response.sendRedirect()方法的功能，将访问请求重定向到其他资源。<c:redirect>标签有两种语法格式：
语法1，没有标签体的情况：
<c:redirect url="value" [context="context"] />
语法2，有标签体的情况，在标签体中指定重定向时的参数：
<c:redirect url="value" [context="context"]>
	<c:param>subtags
</c:redirect>
<c:redirect>标签的属性说明如表8.11所示。
表8.11  <c:redirect>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
url	true	String	指定要转发或重定向到的目标资源的URL地址
context	true	String	当要使用相对路径重定向到同一个服务器下的其他WEB应用程序中的资源时，context属性指定其他WEB应用程序的名称

url属性指定将要重定向的资源的URL时，可以使用相对路径和绝对路径，其具体细节与<c:import>标签的url属性相同。例程8-24是一个使用<c:redirect>标签的应用例子。
例程8-24 c_redirect.jsp

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=gb2312" %>
<c:url value="http://localhost:8080/JSTL/URL/register.jsp" var="myUrl">
	<c:param name="name" value="张三" />
	<c:param name="country" value="中国" />
</c:url>
<c:redirect url="${myUrl}" />

例程8-24的运行结果如图8.21 所示。

图8.21 
8.4  国际化标签
8.4.1  国际化标签库概述
为了简化WEB应用的国际化开发，JSTL中提供了一个用于实现国际化和格式化功能的标签库，我们将其简称为国际化标签库，JSP规范为国际化标签库建议的前缀名为fmt。国际化标签库中包括了一组用于实现WEB国际化功能的标签，这组标签封装了Java语言中java.util和java.text这两个包中与国际化相关的API类的功能。国际化标签库中提供了绑定资源包和从资源包中的本地资源文件内读取文本内容的标签，也提供了对数值和日期等本地敏感的数据按本地化信息进行显示和解析的标签，还提供了按本地特定的时区来调整时间的标签。
国际化标签库中的标签可以根据客户端浏览器的信息来自动确定本地信息，也可以由JSP页面作者显式地指定本地信息。如果没有特别指定，本章案例假设默认的本地信息为“中文（中国）”。
在举例讲解国际化标签库中的标签时， 通常要使用到包含有多个资源文件的资源包，这个资源包中的各个资源文件分别对应几个不同本地信息。这里先创建好一组资源包文件。首先按例程8-25和例程8-26创建两个名称分别为greetings.properties和temp.properties的资源文件。
例程8-25 greetings.properties

org.it315.heading=The first WEB application
org.it315.welcome=Welcome to www.it315.org !
org.it315.okKey=Today is {0,date,full}, you have {1,number,currency} dollars.

例程8-26 temp.properties

org.it315.heading=第一个WEB应用程序
org.it315.welcome=欢迎访问www.it315.org网站!
org.it315.okKey=今天是{0,date,full}，你有{1,number,currency}元。

接着使用JDK中提供的native2ascii程序将temp.properties文件中的中文字符转换成其Unicode码形式的转义序列。在命令行窗口中进入temp.properties文件所在的目录，执行如下命令：
	native2ascii -encoding GB2312 temp.properties greetings_zh.properties
上面的命令执行后产生的greetings_zh.properties文件内容如例程8-27所示。
例程8-27 greetings_zh.properties 

org.it315.heading=\u7b2c\u4e00\u4e2aWEB\u5e94\u7528\u7a0b\u5e8f
org.it315.welcome=\u6b22\u8fce\u8bbf\u95eewww.it315.org\u7f51\u7ad9!
org.it315.okKey=\u4eca\u5929\u662f{0,date,full}\uff0c\u4f60\u6709{1,number,
currency}\u5143\u3002

英文本地环境所对应的资源文件只需复制greetings.properties文件，并改名为greetings_en.properties即可。最后将greetings.properties、greetings_en.properties和greetings_zh.properties这三个资源文件保存到<TOMCAT_HOME>\webapps\JSTL\WEB-INF\classes\org\it315\目录中。
8.4.2  <fmt:setLocale>标签
<fmt:setLocale>标签用于在JSP页面中显式地设置用户的本地化信息，并将设置的本地化信息以Locale对象的形式保存在某个Web域中，其在Web域中的属性名称为“javax.servlet.jsp.jstl.fmt.locale”。使用<fmt:setLocale>标签设置本地化信息后，国际化标签库中的其他标签将使用该本地化信息，而忽略客户端浏览器传递过来的本地信息。<fmt:setLocale>标签的语法格式如下：
<fmt:setLocale value="locale"
			[variant="variant"]
			[scope="{page|request|session|application}"] />
<fmt:setLocale>标签的属性说明如表8.12所示。
表8.12  <fmt:setLocale>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
value	true	String或java.util.Locale	指定用户的本地化信息，可以是一个字符串或java.util.Locale实例对象。如果是字符串，则必须包含小写形式的语言编码，其后也可以带有大写形式的国家编码，两者中间用“-”或“_”连接
variant	true	String	指定创建Locale实例对象时设置的变量部分，它用于标识开发商或特定浏览器为实现扩展功能而自定义的信息
scope	false	String	指定将构造出的Locale实例对象保存在哪个Web作用域中
如果<fmt:setLocale>标签的value属性值为null，<fmt:setLocale>标签将采用客户端浏览器传递过来的本地信息。例程8-28是一个使用<fmt:setLocale>标签的例子程序。
例程8-28 fmt_setLocale.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
<fmt:setLocale value="${param.locale}" />
<fmt:setBundle basename="org.it315.greetings" var="greetings" />
<head>
	<title><fmt:message bundle="${greetings}" key="org.it315.heading" /></title>
</head>
<jsp:useBean id="now" class="java.util.Date" />
<%
	session.setAttribute("number", new Integer(8888888));
%>
<fmt:message bundle="${greetings}" key="org.it315.welcome" /><br />
<fmt:message bundle="${greetings}" key="org.it315.okKey">
	<fmt:param value="${now}" />
	<fmt:param value="${number}" />
</fmt:message>

例程8-28中的<fmt:setBundle>标签用于根据<fmt:setLocale>标签设置的本地化信息绑定一个资源包，其细节请参看8.4.3节；<fmt:message>标签用于从一个资源包中读取信息并进行格式化输出，其细节请参看8.4.5节；<fmt:param>标签用于为格式化文本串中的占位符设置参数值，其细节请参看8.4.6节。
在浏览器地址栏输入如下地址访问fmt_setLocale.jsp页面：
	http://localhost:8080/JSTL/fmt_setLocale.jsp?locale=en_US
例程8-28的运行结果如图8.22所示。

图8.22
将上面的访问地址中的locale参数设置为zh_CN后访问fmt_setLocale.jsp页面，例程8-28的运行结果如图8.23所示。

图8.23
8.4.3  <fmt:setBundle>标签
<fmt:setBundle>标签用于根据<fmt:setLocale>标签设置的本地化信息创建一个资源包（ResourceBundle）实例对象，并将其绑定到一个Web域的属性上。<fmt:setBundle>标签的语法格式如下：
<fmt:setBundle basename="basename"
			[var="varName"]
			[scope="{page|request|session|application}"] />
<fmt:setBundle>标签的属性说明如表8.13所示。
表8.13  <fmt:setBundle>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
basename	true	String	指定创建ResourceBundle实例对象的基名
var	false	String	指定将创建出的ResourceBundle实例对象保存到Web域中的属性名称
scope	false	String	指定将创建出的ResourceBundle实例对象保存在哪个Web作用域中
<fmt:setBundle>标签有如下一些特性：
（1）如果basename属性的值为null或空字符串，或找不到basename属性指定的资源，<fmt:setBundle>标签保存到Web域中的属性的值为null。
（2）如果指定了var属性，<fmt:setBundle>标签将把ResourceBundle实例对象以var属性的值作为域属性名称保存到Web域中。
（3）如果没有指定var属性，<fmt:setBundle>标签将把ResourceBundle实例对象以域属性名javax.servlet.jsp.jstl.fmt.localizationContext保存到Web域中。所有没有嵌套在<fmt:bundle>标签中且未指定bundle属性的<fmt:formatDate>都将使用该标签创建的资源包。
在前面的例程8-28中已经使用了<fmt:setBundle>标签，这里就不再对<fmt:setBundle>标签进行举例讲解了。
8.4.4  <fmt:bundle>标签
<fmt:bundle>标签与<fmt:setBundle>标签的功能类似，但它创建的ResourceBundle实例对象只在其标签体内有效。<fmt:bundle>标签的语法格式如下：
<fmt:bundle basename="basename"
		[prefix="prefix"]>
	body content
</fmt:bundle>
<fmt:bundle>标签的属性说明如表8.14所示。
表8.14  <fmt:bundle>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
basename	true	String	指定创建ResourceBundle实例对象的基名
prefix	true	String	指定追加到嵌套在<fmt:bundle>标签内的<fmt:message>标签的key属性值前面的前缀
如果设置了<fmt:bundle>标签的prefix属性，则其中嵌套的<fmt:message>标签的key属性值中就可以省略prefix属性设置的前缀部分，这对要使用具有相同前缀的多个关键字的情况提供了一些简便。
例程8-29是一个使用<fmt:bundle>标签的例子程序，其中分别演示了设置和不设置prefix属性的情况。
例程8-29 fmt_bundle.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
没有设置prefix属性的情况:<br />
<fmt:bundle basename="org.it315.greetings">
	<fmt:message key="org.it315.heading" /><br />
	<fmt:message key="org.it315.welcome" /><br /><hr />
</fmt:bundle>
设置prefix属性的情况:<br />
<fmt:bundle basename="org.it315.greetings" prefix="org.it315.">
	<fmt:message key="heading" /><br />
	<fmt:message key="welcome" />
</fmt:bundle>

例程8-29的运行结果如图8.24所示。

图8.24 
8.4.5  <fmt:message>标签
<fmt:message>标签用于从一个资源包中读取信息并进行格式化输出，它有如下一些使用语法格式：
语法1，没有标签体的情况：
<fmt:message key="messageKey"	
			[bundle="resourceBundle"]
			[var="varName"]
			[scope="{page|request|session|application}"] />
语法2，在标签体中指定格式化文本串中的占位符参数的情况：
<fmt:message key="messageKey"
			[bundle="resourceBundle"]
			[var="varName"]
			[scope="{page|request|session|application}"]>
	<fmt:param>subtags
</fmt:message>
语法3，在标签体中指定消息关键字和可选择的占位符参数：
<fmt:message [bundle="resourceBundle"]
			[var="varName"]
			[scope="{page|request|session|application}"]>
	key
	optional <fmt:param>subtags
</fmt:message>
<fmt:message>标签的属性说明如表8.15所示。
表8.15  <fmt:message>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
key	true	String	指定要输出的信息的关键字
bundle	true	LocalizationContext	指定ResourceBundle对象在Web域中的属性名称
var	false	String	用于指定将格式化结果保存到某个Web域中的某个属性的名称
scope	false	String	指定将格式化结果保存到哪个Web域中
<fmt:message>标签有如下一些特性：
如果指定的资源不存在，输出“???<key>???”形式的错误信息。
如果ResouceBundle中不存在key属性指定的信息，输出“???<key>???”形式的错误信息。
如果key属性的值为null或空字符串，输出“??????”形式的错误信息。
如果没有指定var属性，<fmt:message>标签将直接输出格式化的结果；如果指定了var属性，则<fmt:message>标签将格式化的结果保存在scope属性指定的Web域中，保存在Web域中的属性名称为var属性指定的值。如果指定了scope属性，就必须指定var属性。
要输出的消息的关键字可以使用key属性指定，也可以在标签体中指定。如果<fmt:message>标签嵌套在<fmt:bundle>标签内，并且<fmt:bundle>标签设置了prefix属性，则该属性的值追加到<fmt:message>标签指定的关键字的前面。
可以通过在<fmt:message>标签内嵌套<fmt:param>标签来指定格式化文本串中的占位符的参数值，每个<fmt:param>标签分别设置一个参数，各个<fmt:param>标签的顺序与格式化字符串的参数相对应，即第一个<fmt:param>标签对应于格式化字符串中的第一个参数，第二个<fmt:param>对应于格式化字符串中的第二个参数，依次类推。
如果<fmt:message>标签处理的格式化文本串中包含有参数，但其中没有嵌套与该参数对应<fmt:param>标签，则直接输出该参数在格式化文本串中的原始形式。

例程8-30是一个使用<fmt:message>标签的例子程序。
例程8-30  fmt_message.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
<jsp:useBean id="now" class="java.util.Date" />
<%
	session.setAttribute("number", new Integer(8888888));
%>
<fmt:setBundle basename="org.it315.greetings" var="greetings" />
&lt;fmt:message&gt;标签内嵌套&lt;fmt:param&gt;标签的情况：<br />
<fmt:message bundle="${greetings}">
	org.it315.okKey
	<fmt:param value="${now}" />
	<fmt:param value="${number}" />
</fmt:message><br /><hr />
&lt;fmt:message&gt;标签内没有嵌套&lt;fmt:param&gt;标签的情况：<br />
<fmt:bundle basename="org.it315.greetings" prefix="org.it315.">
	<fmt:message key="okKey" />
</fmt:bundle>	

例程8-30的运行结果如图8.25 所示。

图8.25 
8.4.6  <fmt:param>标签
<fmt:param>标签用于为格式化文本串中的占位符设置参数值，它只能嵌套在<fmt:message>标签内使用。<fmt:param>标签有如下两种语法格式：
语法1，用value属性指定参数值：
<fmt:param value="messageParameter" />
语法2，在标签体中指定参数的值的情况：
<fmt:param>
	body content
</fmt:param>
说明：<fmt:param>标签的value属性的类型是java.lang.Object，它支持动态属性值。在前面的例程中已经多次使用了<fmt:param>标签，这里就不再对<fmt:param>标签进行举例讲解了。
8.4.7  <fmt:requestEncoding>标签
<fmt:requestEncoding>标签用于设置请求消息的字符集编码，该标签内部调用request.setCharacterEncoding()方法，以便Web容器将请求消息中的参数值按该字符集编码转换成Unicode字符串返回。<fmt:requestEncoding>标签的语法格式如下：
	<fmt:requestEncoding [value="charsetName" />
其中的value属性用于指定请求消息的字符集编码，其类型为String，支持动态属性值。
关于<fmt:requestEncoding>标签的几点说明：
（1）为了能够正确解码请求参数值中的非ISO-8859-1编码的字符，应该调用这个标签来设置请求消息的字符集编码，并且必须在获取任何请求参数（包括使用EL表达式获取参数）之前进行调用。
（2）因为很多浏览器没有完全遵守HTTP规范，在请求消息中没有包含Content-Type请求头，所以使用这个标签来设置请求消息的字符集编码是很有必要的。
（3）<fmt:requestEncoding>标签的value属性的设置值通常为提交这次请求的页面的字符集编码，如果不能预先确定请求消息的字符集编码，那就不应指定value属性。如果没有设置<fmt:requestEncoding>标签的value属性，<fmt:requestEncoding>标签首先采用请求消息的Content-Type头中定义的字符集编码，如果不能从请求消息的Content-Type头中确定字符集编码，则采用session域中的javax.servlet.jsp.jstl.fmt.request.charset属性的值，否则，采用ISO-8859-1字符集编码。
例程8-31是一个使用<fmt:requestEncoding>标签的例子程序。
例程8-31 fmt_requestEncoding.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
<fmt:requestEncoding value="gb2312" />
	我最喜欢的科目是:${param.favourite}<br />
<form method="POST">
	你最喜欢学习的是什么科目?<br />
	<input type="text" name="favourite" />
	<input type="submit" value="OK" /><br/>
</form>

例程8-31的运行结果如图8.26所示，在文本框中输入“英语”，单击其中的OK按钮后的运行结果如图8.27所示。

图8.26

图8.27 
8.4.8  <fmt:timeZone>标签
<fmt:timeZone>标签用于设置时区，但它的设置值只对其标签体部分有效。<fmt:timeZone>标签标签的语法格式如下：
<fmt:timeZone value="timeZone">
	body content
</fmt:timeZone>
其中的value属性支持动态属性值，它的值可以是一个命名时区的字符串，也可以是java.util.TimeZone类的一个实例对象。如果value属性的值为null或空字符串，标签体中的内容就使用GMT的0基准时区。如果value属性的值是表示时区名称的字符串，这个字符串通过java.util.TimeZone.getTimeZone()静态方法被解析为java.util.TimeZone类的实例对象。
例程8-32是一个使用<fmt:timeZone>标签的例子程序。
例程8-32 fmt_timeZone.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.TimeZone" %>
<jsp:useBean id="now" class="java.util.Date" />
使用“GMT+1:00”时区：<br />
<fmt:timeZone value="GMT+1:00">
	<fmt:formatDate value="${now}" type="both" dateStyle="full" timeStyle="full"/>
</fmt:timeZone><br /><hr />
<%
	TimeZone tz = TimeZone.getDefault();
	pageContext.setAttribute("tz", tz);
%>
使用默认的时区，value为java.util.TimeZone的一个实例：<br />
<fmt:timeZone value="${tz}">
	<fmt:formatDate value="${now}" type="both" dateStyle="full" timeStyle="full"/>
</fmt:timeZone><br /><hr />
使用“America/Los_Angeles”时区：<br />
<fmt:timeZone value="America/Los_Angeles">
	<fmt:formatDate value="${now}" type="both" dateStyle="full" timeStyle="full"/>
</fmt:timeZone>

例程8-32的运行结果如图8.28 所示。

图8.28
8.4.9  <fmt:setTimeZone>
<fmt:setTimeZone>标签用于在JSP页面中显示地设置时区，并将设置的时区信息以TimeZone对象的形式保存在某个Web域中，其在Web域中的属性名称为javax.servlet.jsp.jstl.fmt.timeZone。<fmt:setTimeZone>标签的语法格式如下：
<fmt:setTimeZone value="timeZone"
				[var="varName"]
			 	[scope="{page|request|session|application}"] />
<fmt:setTimeZone>标签的属性说明如表8.16所示。
表8.16  <fmt:setTimeZone>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
value	true	String或java.util.TimeZone	指定表示时区的ID字符串或TimeZone对象
var	false	String	指定将创建出的TimeZone实例对象保存到Web域中的属性名称
scope	false	String	指定将创建出的TimeZone实例对象保存到哪个Web域中
其中，value属性的设置值的细节与<fmt:timeZone>标签的细节相同；<fmt:setTimeZone>标签将创建出的TimeZone实例对象保存在scope属性指定的Web域中，如果指定了var属性，保存在Web域中的属性名称为var属性指定的值，否则，保存在Web域中的属性名称为javax.servlet.jsp.jstl.fmt.timeZone，所有没有嵌套在其他<fmt:timeZone>标签中且未指定timezone属性的<fmt:formatDate>标签都将使用该域属性名关联的时区。
例程8-33是一个使用<fmt:setTimeZone>标签的例子程序。
例程8-33 fmt_setTimeZone.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
<jsp:useBean id="now" class="java.util.Date" />
<fmt:setTimeZone value="America/Los_Angeles"/>
“America/Los_Angeles”时区的现在时间是:<br />
<fmt:formatDate value="${now}" type="both" /><hr />
“GMT+1:00”时区的现在时间是:<br />
<fmt:timeZone value="GMT+1:00">
	<fmt:formatDate value="${now}" type="both" />
</fmt:timeZone>

例程8-33的运行结果如图8.29所示。

图8.29 
8.4.10  <fmt:formatDate>标签
<fmt:formatDate>标签用于对日期和时间按本地化信息进行格式化，或对日期和时间按化为JSP页面作者自定义的格式进行格式化。<fmt:formatDate>标签的语法格式如下：
<fmt:formatDate value="date"	
				[type="{time|date|both}"]
				[dateStyle="{default|short|medium|long|full}"]
				[timeStyle="{default|short|medium|long|full}"]
				[pattern="customPattern"]
				[timeZone="timeZone"]
				[var="varName"]
				[scope="{page|request|session|application}"] />
<fmt:formatDate>标签的属性说明如表8.17所示。
表8.17 <fmt:formatDate>标签的属性
属性名	是否支持EL	属性类型	属 性 描 述
value	true	java.util.Date	指定要格式化的日期或时间
type	true	String	指定是格式化输出日期部分，还是格式化输出时间部分，还是两者都输出 
dateStyle	true	String	指定日期部分的输出格式，其可用的设置值可以参照java.text.DateFormat类的讲解。该属性仅在type属性取值为date或both时才有效
timeStyle	true	String	指定时间部分的输出格式，其可用的设置值请参照java.text.DateFormat类的讲解。该属性仅在type属性取值为time或both时才有效
pattern	true	String	指定一个自定义的日期和时间输出格式
timeZone	true	String或java.util.timeZone	指定当前采用的时区
var	false	String	用于指定将格式化结果保存到某个Web域中的某个属性的名称
scope	false	String	指定将格式化结果保存到哪个Web域中

<fmt:formatDate>标签有如下一些特性：
如果没有指定var属性，<fmt: formatDate>标签将直接输出格式化的结果；如果指定了var属性，则<fmt:formatDate>标签将格式化的结果保存在scope属性指定的Web域中，保存在Web域中的属性名称为var属性指定的值。如果指定了scope属性，就必须指定var属性。
如果value属性的值为null，则不输出任何内容，如果这时候指定了var和scope属性，将scope属性指定的Web域中的var属性指定的域属性删除。
JSP网页作者可以使用pattern属性设置自定义的日期格式，这时候，<fmt:formatDate>标签将忽略type、dateStyle和timeStyle等属性。pattern属性的值必须符合java.text.SimpleDateFormat类的日期模式的语法。
如果timeZone属性的值为null或者空字符串，相当于没有设置这个属性。
如果要格式化一个表示日期或时间的字符串，必须首先用<fmt:parseDate>标签将其解析为java.util.Date类的一个实例对象，再使用<fmt:formatDate >标签对这个Date实例对象进行格式化。<fmt:parseDate>标签的介绍请参看8.4.11节。
如果<fmt:formatDate>标签不能确定格式化的本地化信息，就使用java.util.Date.toString()方法作为输出格式。
例程8-34是一个使用<fmt:formatDate>标签的例子程序。
例程8-34 fmt_formatDate.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.TimeZone" %>
<jsp:useBean id="now" class="java.util.Date" />
格式化当前日期、时间：
<fmt:formatDate value="${now}" type="both" timeStyle="medium" dateStyle="long"/>
<hr/>
<%
	session.setAttribute("tz", TimeZone.getTimeZone("GMT+10"));
%>
指定时区为“GMT+10”：
<fmt:formatDate value="${now}" type="both" timeZone="${tz}" /><hr />
指定自定义的格式，月.日.年:
<fmt:formatDate value="${now}" pattern="MM.dd.yyyy" /><hr />
格式化用字符串表示的日期：
<fmt:parseDate value="7/31/05" pattern="MM/dd/yy" var="parsed" />
<fmt:formatDate value="${parsed}" />

例程8-34的运行结果如图8.30 所示。

图8.30 
8.4.11  <fmt:parseDate>标签
<fmt:parseDate>标签与<fmt: formatDate >标签的作用正好相反，它用于将一个表示日期和时间的字符串解析成java.util.Date实例对象，它有如下两种语法格式：
语法1，没有标签体的情况：
<fmt:parseDate value="dateString"
				[type="time|date|both"]
				[dateStyle="default|short|medium|long|full"]
				[timeStyle="default|short|medium|long|full"]
				[pattern="customPattern"]
				[timeZone="timeZone"]
				[parseLocale="parseLocale"]
				[var="varName"]
				[scope="{page|request|session|application}"] />
语法2， 有标签体的情况，在标签体中指定要被解析的日期和/或时间值：
<fmt:parseDate [type="time|date|both"]
				[dateStyle="default|short|medium|long|full"]
				[timeStyle="default|short|medium|long|full"]
				[pattern="customPattern"]
				[timeZone="timeZone"]
				[parseLocale="parseLocale"]
				[var="varName"]
				[scope="{page|request|session|application}"]>
		date value to be parsed
</fmt:parseDate>
<fmt:parseDate>标签的属性说明如表8.18所示。
表8.18 <fmt:parseDate>标签的属性

<fmt:parseDate>标签有如下一些特性：
value属性的值必须是合法的日期/时间字符串，否则<fmt:parseDate>标签在解析时抛出异常。如果value属性的值为null或空字符串，就删除scope属性指定的域范围中的var属性命名的变量。
根据type属性的值，要解析日期字符串可以包含日期、时间或同时包含日期和时间，并根据指定的格式类型进行解析。
如果timeZone属性的值为null或空字符串，按没有设置这个属性处理。
如果parseLocale属性的值为null或空字符串，按没有设置该属性处理。
如果指定pattern属性，标签就忽略它的type、dateStyle和timeStyle属性。这时，根据pattern属性设置的自定义格式解析value属性指定的日期和/或时间字符串，所以，要解析的日期和/或时间字符串必须严格符合pattern属性设置的自定义格式。pattern属性的值必须符合java.text.SimpleDateFormat类的模式语法。
如果标签不能确定解析的本地环境，就抛出JspException异常，异常信息中包含要解析的字符串。

在前面的例程8-34中已经使用了<fmt:parseDate>标签，这里就不再对<fmt:parseDate>标签进行举例讲解了。
8.4.12  <fmt:formatNumber>标签
<fmt:formatNumber>标签用于将数值、货币或百分数按本地化信息进行格式化，或者按JSP页面作者自定义的格式进行格式化。<fmt:formatNumber>标签有两种语法格式：
语法1，没有标签体的情况：
<fmt:formatNumber value="numericValue"
	 	 	 	 [type="{number|currency|percent}"]
	 	 	 	 [pattern="customPattern"]
	 	 	 	 [currencyCode="currencyCode"]
	 	 	 	 [currencySymbol="currencySymbol"]
	 	 	 	 [groupingUsed="{true|false}"]
	 	 	 	 [maxIntegerDigits="maxIntegerDigits"]
	 	 	 	 [minIntegerDigits="minIntegerDigits"]
	 	 	 	 [maxFractionDigits="maxFractionDigits"]
	 	 	 	 [minFractionDigits="minFractionDigits"]
	 	 	 	 [var="varName"]
	 	 	 	 [scope="{page|request|session|application}"] />
语法2，有标签体的情况，在标签体中指定要被格式化的数值：
<fmt:formatNumber [type="{number|currency|percent}"]
	 	 	 	 [pattern="customPattern"]
	 	 	 	 [currencyCode="currencyCode"]
	 	 	 	 [currencySymbol="currencySymbol"]
	 	 	 	 [groupingUsed="{true|false}"]
	 	 	 	 [maxIntegerDigits="maxIntegerDigits"]
	 	 	 	 [minIntegerDigits="minIntegerDigits"]
	 	 	 	 [maxFractionDigits="maxFractionDigits"]
	 	 	 	 [minFractionDigits="minFractionDigits"]
	 	 	 	 [var="varName"]
	 	 	 	 [scope="{page|request|session|application}"]>
		要被格式化的数值
</fmt:formatNumber>
如果指定scope属性，就必须指定var属性。<fmt:formatNumber>标签的属性说明如表8.19所示。
表8.19 <fmt:formatNumber>标签的属性

<fmt:formatNumber>标签有如下一些特性：
如果value属性的值为null，则不输出任何内容，如果这时候指定了var和scope属性，将scope属性指定的Web域中的var属性指定的域属性删除。
pattern属性优先于type属性，不管是使用哪个属性，格式化的标记（例如十进制小数的整数部分、小数部分的分隔符及组分隔符）通过格式化的Locale特性来决定。
pattern属性指定的模式字符串必须符合java.text.DecimalFormat类的模式语法。如果pattern属性为null或空字符串，就相当于没有设置这个属性的值。
currencyCode属性的值必须是一个合法的ISO 4217货币编码。
groupingUsed属性指定是否要将格式化后的数值的整数部分的数字分组。例如，在英语本地环境中，将比较大的数值按每三个数字分为一组，每组用逗号定界，其它的本地环境可能用点或空格来定界这样的分组。详细信息参考java.text.NumberFormat类的setGroupingUsed()方法。
当type属性的值为currency时，currencyCode属性用来显式地指定要显示的数据的货币符号。currencySymbol属性也可以显式地指定货币符号。当WEB容器的运行环境是JDK1.4或更高版本时，如果同时指定<fmt:formatNumber>标签的currencyCode和currencySymbol属性，前者优先于后者；但当WEB容器的运行环境是JDK1.4以前的版本时，currencySymbol属性优先于currencyCode属性。
如果<fmt:formatNumber>标签不能确定格式化的本地环境，就使用Number.toString()作为输出格式。
例程8-35是一个使用<fmt:formatNumber>标签的例子程序。
例程8-35  fmt_formatNumber.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.Currency,java.util.Locale"%>
将数值格式化为货币格式：
<fmt:formatNumber value="9876543.21" type="currency" /><hr />
将数值格式化为百分数格式：
<fmt:formatNumber value="12.3" type="percent" /><hr />
将数值格式化为自定义的格式：
<fmt:formatNumber value="12.3" pattern=".000" />；
<fmt:formatNumber value="123456.7891" pattern="#,#00.0#" /><hr />
<%
	String code = Currency.getInstance(Locale.CHINA).getCurrencyCode();
	String symbol = Currency.getInstance(Locale.US).getSymbol();
	session.setAttribute("code", code);
	session.setAttribute("symbol", symbol);
%>
同时指定currencyCode和currencySymbol属性，前者优先于后者：
<fmt:formatNumber value="1234567.11" type="currency" currencyCode="${code}" 
	currencySymbol="${symbol}" />

例程8-35的运行结果如图8.31 所示。

图8.31 
8.4.13  <fmt:parseNumber>标签
<fmt:parseDate>标签与<fmt: formatNumber >标签的作用正好相反，它用于将一个按本地化方式被格式化后的数值、货币或百分数解析为数值，它有如下两种语法格式：
语法1，没有标签体的情况：
<fmt:parseNumber value="numericValue"	
				[type="{number|currency|percent}"]
				[pattern="customPattern"]
				[parseLocale="parseLocale"]
				[integerOnly="{true|false}"]
				[var="varName"]
				[scope="{page|request|session|application}"] />
语法2，有标签体的情况，在标签体中指定要被解析的数值：
<fmt:parseNumber [type="{number|currency|percent}"]
				 [pattern="customPattern"]
				 [parseLocale="parseLocale"]
				 [integerOnly="{true|false}"]
				 [var="varName"]
				 [scope="{page|request|session|application}"]>
	numeric value to be parsed
</fmt:parseNumber>
<fmt:parseNumber>标签的属性说明如表8.20所示。
表8.20 <fmt:parseNumber>标签的属性

<fmt:parseNumber>标签有如下一些特性：
如果value属性的值为null或空字符串，则将scope属性指定的Web域中的var属性指定的域属性删除。如果value属性的值不能解析为数值就抛出异常。
pattern属性指定的模式字符串必须符合java.text.DecimalFormat类的模式语法。如果其值为null或空字符串，就相当于没有设置这个属性的值。使用<fmt:parseNumber>解析值时要特别注意，它执行的解析非常严格，要解析的数值字符串必须严格符合特定的本地环境及pattern属性设置的自定义格式。
如果parseLocale属性的值为null或空字符串，就相当于没有指定该属性。
integerOnly属性指定是否只是解析value的整数部分。详细信息请看java.text.NumberFormat接口的setParseIntegerOnly()方法。
如果同时指定type属性和pattern属性，后者优先权高于前者。
如果设置了var属性，将解析的结果保存在某个Web域中的var属性指定的域属性中；否则，<fmt:parseNumber>将使用java.lang.Number.toString()直接输出解析的结果。如果指定scope属性，则必须指定var属性。
如果标签不能确定解析的本地环境，就抛出JspException异常，异常信息中包含要解析的字符串。
例程8-36是一个使用<fmt:parseNumber>标签的例子程序。
例程8-36 fmt_parseNumber.jsp

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<%@ page contentType="text/html;charset=gb2312" %>
本地环境为“en_US”解析字符串“$123,456,789.00”：
<fmt:parseNumber value="$123,456,789.00" type="currency" parseLocale="en_US"/>
<hr/>
解析整个数值字符串“123,456,789%”：
<fmt:parseNumber value="123,456,789%" type="percent" /><hr />
只解析“123,456,789%”的整数部分：
<fmt:parseNumber value="123,456,789%" type="percent" integerOnly="true"/><hr />
同时设置type和pattern属性，后者优先于前者：
<fmt:parseNumber value="12.3" type="currency" pattern=".000" />

例程8-36的运行结果如图8.32 所示。

图8.32

注意：在分层设计的软件架构中，JSP页面通常仅用于实现系统的表示层，数据解析的任务不适合在表示层进行处理，而最好是业务逻辑层进行处理，所以，为了增强软件的易维护性和可扩展性，读者应尽量避免在JSP 页面中使用<fmt:parseDate>和<fmt:parseNumber>标签。

图8.39 
8.7  JSTL函数
为了简化在JSP页面操作字符串，JSTL中提供了一套EL自定义函数，这些函数包含了JSP页面制作者经常要用到的字符串操作。例如，fn:toLowerCase将字符串中的字符变为小写，fn:indexOf返回一个指定字符串在另一个字符串中第一次出现的索引位置。
JSTL中提供的EL自定义函数必须在EL表达式中使用，例如，${fn:toUpperCase("www.it315.org")}。
8.7.1  fn:toLowerCase函数
fn:toLowerCase函数将一个字符串中包含的所有字符转换为小写形式，并返回转换后的字符串，它接收一个字符串类型的参数。
fn:toLowerCase函数的应用举例：
fn:toLowerCase("Www.IT315.org") 的返回值为字符串“www.it315.org”
fn:toLowerCase("")的返回值为空字符串
8.7.2  fn:toUpperCase函数
fn:toUpperCase函数将一个字符串中包含的所有字符转换为大写形式，并返回转换后的字符串，它接收一个字符串类型的参数。
fn:toUpperCase函数的应用举例：
fn:toUpperCase("Www.IT315.org") 的返回值为字符串“WWW.IT315.ORG”
fn:toUpperCase("")的返回值为空字符串
8.7.3  fn:trim函数
fn:trim函数删除一个字符串的首尾的空格，并返回删除空格后的结果字符串，它接收一个字符串类型的参数。需要注意的是，fn:trim函数不能删除字符串中间位置的空格。
例如，fn:trim("   www.it  315.org  ") 的返回值为字符串“www.it  315.org”。
8.7.4  fn:escapeXml函数
fn:escapeXml函数将字符串中的需要进行转义的HTML特殊字符按表8.2进行HTML编码转换，并返回转换后的字符串，这样就可以在浏览器中显示出HTML特殊字符。fn:escapeXml函数接收一个字符串类型的参数。
例如，运行包含如下代码的JSP文件后浏览器将跳转到“http://www.it315.org”页面，这是因为这些代码被浏览器作为HTML标签解释执行：
<meta http-equiv="refresh" content="0;url=http://www.it315.org"/>
如果用fn:escapeXml函数处理上面的代码，运行JSP文件后就在浏览器窗口输出这行代码，例程8-54是使用fn:escapeXml函数处理上面的代码的例子程序。
例程8-54  fn_escapeXml.jsp

<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
${fn:escapeXml('<meta http-equiv="refresh" 
		content="0;url=http://www.it315.org"/>')}

fn_escapeXml.jsp页面的运行结果如图8.46所示。

图8.46
8.7.5  fn:length函数
fn:length函数用于返回一个集合或数组对象中包含的元素的个数，或返回一个字符串中包含的字符的个数，返回值为int类型。fn:length函数接收一个参数，这个参数可以是<c:forEach>标签的items属性支持的任何类型，包括任意类型的数组、java.util.Collection、java.util.Iterator、java.util.Enumeration、java.util.Map等类的实例对象和字符串。
如果fn:length函数的参数为null或者是元素个数为0的集合或数组对象，则函数返回0；如果参数是空字符串，则函数返回0。例程8-55是使用fn:length函数的实例程序。
例程8-55  fn_length.jsp

<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
<%@ page contentType="text/html;charset=gb2312" %>
<%@ page import="java.util.*, org.it315.UserBean" %>
<%
	Collection users = new ArrayList();
	for(int i=0; i<5; i++)
	{
		UserBean user = new UserBean();
		user.setUserName("user" + i);
		user.setPassword("guest" + i);
		users.add(user);
	}
	session.setAttribute("users", users);
%>
There are ${fn:length(users)} users online.<hr />
字符串“www.it315.org”中包含 ${fn:length("www.it315.org")} 个字符

fn_length.jsp页面的运行结果如图8.47所示。

图8.47 
8.7.6  fn:split函数
fn:split函数以指定字符串作为分隔符，将一个字符串分割成字符串数组并返回这个字符串数组。fn:split函数接收两个字符串类型的参数，第一个参数表示要分割的字符串，第二个参数表示作为分隔符的字符串。
fn:split函数实现java.util.StringTokenizer类分割字符串的操作，得到的字符串数组中的各字符串元素不包含分隔符本身，例如，fn:split("www.it315.org", ".")[1]的返回值为字符串“it315”。
如果第一个参数是空字符串，则fn:split函数返回的字符串数组中只包含空字符串这一个元素，例如，fn:split("", ".")[0]的返回值为空字符串。
如果第二个参数是空字符串，则函数返回的字符串数组中只包含源字符串这一个元素，例如，fn:split("www.it315.org", "")[0]的返回值为字符串“www.it315.org”，fn:split("www.it315.org", "")[1]的返回值为空字符串。
8.7.7  fn:join函数
fn:join函数以一个字符串作为分隔符，将一个字符串数组中的所有元素合并为一个字符串并返回合并后的结果字符串。fn:join函数接收两个参数，第一个参数是要操作的字符串数组，第二个参数是作为分隔符的字符串。
如果fn:join函数的第二个参数是空字符串，则fn:join函数的返回值是不使用任何分隔符将字符串数组中的各元素连接起来的结果字符串。
fn:join函数的应用举例：
假设stringArray是保存在Web域中的一个属性，它表示一个值为{"www","it315","org"}的字符串数组，则fn:join(stringArray, ".")返回字符串“www.it315.org”
fn:join(fn:split("www,it315,org", ","), ".") 的返回值为字符串“www.it315.org”
8.7.8  fn:indexOf函数
fn:indexOf函数返回指定字符串在一个字符串中第一次出现的索引值，返回值为int类型。fn:indexOf函数接收两个字符串类型的参数，如果第一个参数字符串中包含第二个参数字符串，那么，不管第二个参数字符串在第一个参数字符串中出现几次，fn:indexOf函数总是返回第一次出现的索引值；如果第一个参数中不包含第二个参数，则fn:indexOf函数返回-1。如果第二个参数为空字符串，则fn:indexOf函数总是返回0。
fn:indexOf函数的应用举例：
fn:indexOf("www.it315.org","t3") 的返回值为5
fn:indexOf("www.it315.org","aaa") 的返回值为 -1
fn:indexOf("www.it315.org","") 的返回值为0
8.7.9  fn:contains函数
fn:contains函数检测一个字符串中是否包含指定的字符串，返回值为布尔类型。fn:contains函数在比较两个字符串是否相等时是大小写敏感的。
fn:contains函数接收两个字符串类型的参数，如果第一个参数字符串中包含第二个参数字符串，则fn:contains函数返回true，否则返回false。如果第二个参数的值为空字符串，则fn:contains函数总是返回true。实际上，fn:contains(string, substring)等价于fn:indexOf(string, substring) != -1。
fn:contains函数的应用举例：
fn:contains("www.it315.org", "org")的返回值为true
fn:contains("www.it315.org", "Org")的返回值为false
fn:contains("", "")的返回值为true
8.7.10  fn:containsIgnoreCase函数
fn:containsIgnoreCase函数检测一个字符串中是否包含指定的字符串，在比较两个字符串是否相等时大小写不敏感。fn:containsIgnoreCase函数的参数和返回值的类型都与fn:contains函数相同，只是前者在比较两个字符串是否相等时不考虑字符的大小写，而后者考虑字符的大小写，fn:containsIgnoreCase(string, substring)等价于fn:contains(fn:toUpperCase(string),fn:toUpperCase(substring))。
fn:containsIgnoreCase函数的应用举例：
fn:containsIgnoreCase("www.it315.org", "Org") 的返回值为 true
fn:containsIgnoreCase (fn:toUpperCase("www.it315.org"), fn:toUpperCase("Org"))的返回值为true
8.7.11  fn:startsWith函数
fn:startsWith函数用于检测一个字符串是否是以指定字符串开始的，返回值为布尔类型。
fn:startsWith函数接收两个字符串类型的参数，如果第一个参数字符串以第二个参数字符串开始，则函数返回true，否则函数返回false。如果第二个参数为空字符串，则fn:startsWith函数总是返回true。实际上，fn:startsWith(string, prefix)等价于表达式fn:indexOf(string, prefix) == 0。 
fn:startsWith函数的应用举例：
fn:startsWith("www.it315.org","it315")的返回值为false
fn:startsWith("www.it315.org","www")的返回值为true
fn:startsWith("www.it315.org","")的返回值为true
8.7.12  fn:endsWith函数
fn:endsWith函数用于检测一个字符串是否是以指定字符串结束的，返回值为布尔类型。
fn:endsWith函数接收两个字符串类型的参数，如果第一个参数字符串以第二个参数字符串结束，则函数返回true，否则函数返回false。如果第二个参数为空字符串，则fn:endsWith函数总是返回true。
fn:endsWith函数的应用举例：
fn:endsWith("www.it315.org","it315")的返回值为false
fn:endsWith("www.it315.org","org")的返回值为true
fn:endsWith("www.it315.org","")的返回值为true
8.7.13  fn:replace函数
fn:replace函数将一个字符串中包含的指定子字符串替换为其它的指定字符串，并返回替换后的结果字符串。fn:replace方法接收三个字符串类型的参数，第一个参数表示要操作的源字符串，第二个参数表示源字符串中要被替换的子字符串，第三个参数表示要被替换成的字符串。
fn:replace函数按照下面的说明执行字符串的替换操作：
（1）源字符串中所有的第二个参数指定的子字符串都被替换成第三个参数指定的字符串，如果替换后的结果字符串中包含第二个参数指定的子字符串，则不再进行替换。例如，
fn:replace("www it315 org", " ", ".")的返回值为字符串“www.it315.org”
fn:replace("ddabccff", "abc", "ab")的返回值为字符串“ddabcff”，这个字符串中还包含字符串“abc”，但不再执行替换操作
（2）如果第一个参数是空字符串，则fn:replace函数返回空字符串，例如，fn:replace("", " ", ".")的返回值为空字符串。
（3）如果第二个参数是空字符串，则fn:replace函数不执行任何替换操作，返回第一个参数指定的字符串。例如，fn:replace("www.it315.org", "", " ") 的返回值为字符串“www.it315.org”。
（4）如果第三个参数是空字符串，则fn:replace函数删除源字符串中包含的第二个参数指定的子字符串。例如，fn:replace("www.it315.org", ".", "")的返回值为字符串“wwwit315org”。
8.7.14  fn:substring函数
fn:substring函数用于截取一个字符串的子字符串并返回截取到的子字符串。fn:substring函数接收三个参数，第一个参数是用于指定要操作的源字符串，第二个参数是用于指定截取子字符串开始的索引值，第三个参数是用于指定截取子字符串结束的索引值，第二个参数和第三个参数都是int类型，其值都从0开始。
fn:substring函数按照下面的说明截取一个字符串的子字符串：
如果第二个参数的值大于或等于源字符串中包含的字符个数，则fn:substring函数返回空字符串；
如果第二个参数的值小于0，则将其值设置为0；
如果第三个参数的值小于0或大于源字符串中包含的字符个数，则截取到源字符串的结尾的字符；
如果第三个参数的值小于第二个参数的值，则fn:substring函数返回空字符串。
fn:substring函数的应用举例（字符串“www.it315.org”中包含13个字符）：
fn:substring("www.it315.org", 4, 9) 的返回值为字符串“it315”
fn:substring("www.it315.org", 13, 14) 返回空字符串
fn:substring("www.it315.org", -1, 9) 的返回值为字符串“www.it315”
fn:substring("www.it315.org", 4, -1) 的返回值为字符串“it315.org”
fn:substring("www.it315.org", 4, 13) 的返回值为字符串“it315.org”
fn:substring("www.it315.org", 4, 3) 返回空字符串
8.7.15  fn:substringAfter函数
fn:substringAfter函数用于截取并返回一个字符串中的指定子字符串第一次出现之后的子字符串。fn:substringAfter函数接收两个字符串类型的参数，第一个参数表示要操作的源字符串，第二个参数表示指定的子字符串，例如，fn:substringAfter("www.it315.org", ".")的返回值为字符串“it315.org”。
fn:substringAfter函数按照下面的说明截取一个字符串的子字符串：
如果第一个参数是空字符串，则fn:substringAfter函数返回空字符串，例如fn:substringAfter("", ".") 的返回值为空字符串；
如果第二个参数是空字符串，则fn:substringAfter函数的返回值为源字符串，例如，fn:substringAfter("www.it315.org", "")的返回值为字符串“www.it315.org”；
如果第二个参数不是第一个参数的子字符串，则substringAfter函数返回空字符串，例如，fn:substringAfter("www.it315.org", "itorg")的返回值为空字符串。
8.7.16  fn:substringBefore函数
fn:substringBefore函数用于截取并返回一个字符串中的指定子字符串第一次出现之前的子字符串。fn:substringBefore函数接收两个字符串类型的参数，第一个参数表示要操作的源字符串，第二个参数表示指定的子字符串，例如，fn:substringBefore("www.it315.org", ".") 的返回值为字符串“www”。
fn:substringBefore函数按照下面的说明截取一个字符串的子字符串：
如果第一个参数是空字符串，则fn:substringBefore函数返回空字符串，例如，fn:substringBefore("", ".") 的返回值为空字符串；
如果第二个参数是空字符串，则fn:substringBefore函数返回空字符串，例如，fn:substringBefore("www.it315.org", "") 的返回值为空字符串
如果第二个参数不是第一个参数的子字符串，则fn:substringBefore函数返回空字符串，例如，fn:substringBefore("www.it315.org", "itorg") 的返回值为空字符串。


思考题：

1、请用<c:forEach>标签在一个table表格中列表显示出一个集合对象中的所有元素，奇偶行用明暗相间的颜色进行分隔。

2、请用<c:forEach>标签将一个整数数组中所有元素用逗号分隔成“1,2,3”的形式进行输出，注意，最后一个元素后面没有逗号。 

3、请嵌套调用<c:forTokens>标签打印出http://www.it315.org/deal.jsp?name=zxx&password=123中的每个参数名和参数值。

4、 请在EL表达式用JSTL函数fn:split和fn:length取出字符串"a/b/c/d.txt"中的最后一个"/"后面的内容。

1、XML指的是？
a、Example Markup Language
b、X-Markup Language
c、eXtensible Markup Language
d、eXtra Modern Link
2、下列定义XML版本的声明中语法正确的是？
a、<?xml version="1.0" />
b、<?xml version="1.0"?>
c、<xml version="1.0" />
3、DTD指的是？
a、Dynamic Type Definition
b、Do The Dance
c、Document Type Definition
d、Direct Type Definition
4、这是一个“形式良好”的文档吗？
<?xml version="1.0"?>
<note>
<to>Tove</to>
<from>Jani</from>
<heading>Reminder</heading>
<body>Do not forget me this weekend!</body>
</note> 
a、是
b、否
5、这是一个“形式良好”的文档吗？
<?xml version="1.0"?>
<to>Tove</to>
<from>Jani</from>
<heading>Reminder</heading>
<body>Do not forget me this weekend!</body>  
a、是
b、否
6、哪条陈述是正确的？
a、所有的XML元素都必须是小写的
b、所有XML元素都必须正确地关闭
c、所有XML文档都必须有DTD
d、以上陈述都是正确的
7、哪条陈述是正确的？
a、XML标签对大小写敏感
b、XML文档必须有根标签
c、XML元素必须被正确地嵌套
d、以上陈述都是正确的
8、XML忽略空白字符
a、错误
b、正确
9、这是一个“形式良好”的文档吗？
<?xml version="1.0"?>
<note>
<to age="29">Tove</to>
<from>Jani</from>
</note>
a、是
b、否
10、这是一个“形式良好”的文档吗？
<?xml version="1.0"?>
<note>
<to age=29>Tove</to>
<from>Jani</from>
</note>
a、是
b、否
11、XML元素不能为空
a、正确
b、错误
12、对于一个XML文档，以下哪个名称是错误的？
a、<Note>
b、<h1>
c、<1dollar>
d、以上三个都不正确
13、对于一个XML文档，以下哪个名称是错误的？
a、<NAME>
b、<age>
c、<first name>
d、以上三个都不正确
14、对于一个XML文档，以下哪个名称是错误的？
a、<7eleven>
b、<phone number>
c、以上两个都不正确
15、必须使用引号包围XML的属性值
a、正确
b、错误
16、以下哪种方法可正确地引用名为“mystyle.css”的样式表？
a、<link type="text/xsl" href="mystyle. css " />
b、<?xml-stylesheet type="text/xsl" href="mystyle. css " ?>
c、<stylesheet type="text/xsl" href="mystyle. css " />
17 . 供XML解析器忽略XML文档的特定部分的正确语法是：
a、<xml:CDATA[ Text to be ignored ]>
b、<PCDATA> Text to be ignored </PCDATA>
c、<![CDATA[ Text to be ignored ]]>
d、<CDATA> Text to be ignored </CDATA>

ajax


二.ajax
1.ajax介绍
AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。
AJAX 是一种用于创建快速动态网页的技术。
通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。
ajax作用:
AJAX不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 
使用Javascript向服务器提出请求并处理响应而不阻塞用户！核心对象XMLHTTPRequest。通过这个对象，您的 JavaScript 可在不重载页面的情况与Web服务器交换数据。
AJAX 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。
AJAX 可使因特网应用程序更小、更快，更友好。

2.ajax入门案例
获取XMLHttpRequest对象
对于不同的浏览器，获取方式有区别(从文档上粘过来)
			function getXMLHttpRequest() {
				var xmlhttp;
if (window.XMLHttpRequest) {// code for all new browsers
					xmlhttp = new XMLHttpRequest();
				} else if (window.ActiveXObject) {// code for IE5 and IE6
					xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
				}
   				return xmlhttp;
			}	
设置回调函数(onreadystatechange)
xmlHttp.onreadystatechange=function(){};
目的是服务器端响应完成后，浏览器端可以知道，并完成后续工作。
open操作
xmlHttp.open(“GET”,”/day/ajax”);
设置访问的资源路径以及请求方式
send操作
xmlhttp.send(null);
发送请求
回调函数编写
在第二步的回调函数内完成操作。
3.XMLHttpRequest之API详解
Ajax 的核心是 JavaScript 对象 XmlHttpRequest。该对象在 Internet Explorer 5 中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest 使您可以使用 JavaScript 向服务器提出请求并处理响应，而不阻塞用户。XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。
onreadystatechange属性
当XMLHttpRequest对象的状态改变时会调用的一个函数.
readyState属性
对于XMLHttpRequest对象，它有一个属性readyState,它有五个状态
0创建XMLHttpRequest对象.
1当open时
2当send时
3响应头已经返回，但响应正文没有完成，也就是响应没有完全完成.
4响应完成了
一般情况下,在回调的函数中，我们都是判断
if(xmlhttp.readyState==4&&xmlhttp.status==200)
来接收服务器端响应的信息.
status属性
由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 "Not Found" 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。
responseText属性
目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。
如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。
如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8。
responseXML属性
对请求的响应，解析为 XML 并作为 Document 对象返回。
open方法
初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求。
		xmlhttp.open(请求方式,url);
请求方式: POST  GET
路径:客户端路径 格式 /工程名/资源路径
如果是GET方式，想要向服务器发送请求，并且携带请求参数，可以直接在url后面连接。
如果是POST方式,想要向服务器发送请求，并且携带请求参数,我们需要在send时传递参数
send方法
发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。
如果请求方式是post,并且要携带参数，可以通过send的参数来传递
setRequestHeader方法
向一个打开但未发送的请求设置或添加一个 HTTP 请求。
如果请求方式是POST,并且要携带参数，需要设置一个请求头.
	setRequestHeader("CONTENT-TYPE","application/x-www-form-urlencoded");
中文乱码问题
get请求需要在发送请求的时候对中文进行编码,如下:

服务器端处理方式和之前request的处理乱码方式一样.


4.json介绍与入门
json介绍
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速度)。
json格式
JSON结构有两种结构 
json简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构 
对象：对象在js中表示为“{}”括起来的内容，数据结构为 {key：value,key：value,...}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。
数组：数组在js中是中括号“[]”括起来的内容，数据结构为 ["java","javascript","vb",...]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。
经过对象、数组2种结构就可以组合成复杂的数据结构了。

5.jsonlib插件介绍
jsonlib介绍
Json-lib 是一个 Java 类库（官网：http://json-lib.sourceforge.net/）可以实现如下功能：
 •转换 javabeans, maps, collections, java arrays 和 XML 成为 json 格式数据
 •转换 json 格式数据成为 javabeans 对象
 
Json-lib 需要的 jar 包
 •commons-beanutils-1.8.3.jar
 •commons-collections-3.2.1.jar
 •commons-lang-2.6.jar
 •commons-logging-1.1.1.jar
 •ezmorph-1.0.6.jar
 •json-lib-2.4-jdk15.jar

jsonlib常用api
数组,Collection集合转换成json数据使用    JsonArray.fromObject(对象);
Map，javaBean转换成json数据使用        JsonObject.fromObject(对象);

如果不想让javaBean中的数据出现在json中.			
	JsonConfig jsonConfig = new JsonConfig();
	jsonConfig.setExcludes(new String[]{"price"});
	
	JSONObject jsonObject = JSONObject.fromObject(p1, jsonConfig);
	System.out.println(jsonObject);

注意：
	如果服务器端返回的数据格式是json格式，那么我们在浏览器端得到数据时
需要使用eval函数将字符串转换成json对象.
var msg=xmlhttp.responseText;
var obj=eval(msg);
有的时候通过eval转换时，得不到一个json对象,这时做以下操作
var obj=eval("("+msg+")");
jquery的ajax

1.load
要求:
jquery对象调用
格式:
load(url,[data],[callback])
参数:
url:请求路径
data:请求参数 格式为json
若有此参数,请求方式为post
若无此参数,请求方式为get
callback:成功之后回调,具有三个参数

2.$.get
发送get请求
格式:
$.get(url,[data],[callback],[type]);
参数:
type:返回内容的格式有如下取值
xml,html,script,json,text,_default

3.$.post
发送post请求
格式:
$.post(url,[data],[callback],[type]);

4.$.ajax
底层是原始的ajax请求方式
格式1:
$.ajax(url,[settings])
格式2:setting可以使用json格式
jQuery.ajax(settings)
参数:
 async 设置是否异步，true：表示异步（ajax）
 type 设置请求方式。例如：get、post
 url 设置请求路径
 data 请求参数
 dataType 设置数据转换类型，例如：xml, html, script, json
 success  成功回调
 error 错误回调
例如:
           $.ajax({
					"async":true,
					"type":"POST",
					"url":url,
					"data":params,
					"success":function(data){
						alert(data);
					},
					"error" : function(){
						alert("错误");
					}
				});


5.表单序列化

serialize() 将表单中所有内容转成字符串。
	所有内容：有name，有值（非空）--文本有数据，单选多选选中，下拉列表选中等
	字符串：key=value&key=value&....
serializeArray()将表单中所有内容转成json数组
Listener & Filter
一.Listener
1.listener介绍 
Javaweb中的监听器是用于监听web常见对象HttpServletRequest,HttpSession,ServletContext
作用:
监听web对象的创建与销毁
监听web对象的属性变化
监听session绑定javaBean操作
监听机制的相关概念
事件----一件事情
事件源---产生这件事情的源头
注册监听---将监听器与事件绑定，当事件产生时，监听器可以知道，并进行处理。
监听器---对某件事情进行处理监听的一个对象

2.web监听器介绍
javaweb监听器介绍
监听web对象创建与销毁的监听器
		ServletContextListener
		HttpSessionListener
		ServletRequestListener	
监听web对象属性变化
		ServletContextAttributeListener
		HttpSessionAttributeListener
		ServletRequestAttributeListener	
监听session绑定javaBean
		HttpSessionBindingListener
		HttpSessionActivationListener(活化或者钝化)
javaweb监听器创建步骤
a.创建一个类，实现指定的监听器接口	
b.重写接口中的方法.
c.在web.xml文件中配置监听
<listener>
		<listener-class>全限定名</listener-class>
</listener>
3.演示监听器的创建与销毁
ServletContext对象的创建与销毁监听
	ServletContext对象的创建与销毁分析
ServletContext对象是服务器开启时创建。服务器关闭时销毁。
	监听ServletContext对象的创建与销毁

HttpSession对象的创建与销毁监听
	HttpSession对象的创建与销毁分析
session对象创建:取决于请求中是否有jsessinid，如果有，可能会获取一个已经存在的session对象。如果没有，会创建一个新的session对象.
session的销毁：
			超时(默认超时30分钟或者通过setMaxInactiveInterval(int)手动设置超时时间)
			关闭服务器
			invalidate()方法
	监听HttpSession对象的创建与销毁

HttpServletRequest对象的创建与销毁监听
	HttpServletRequest对象的创建与销毁分析
request对象是发送请求时创建，当响应产生时，销毁.
	监听HttpServletRequest对象的创建与销毁
4.演示监听属性的变化
javaweb中监听属性变化API介绍
ServletContextAttributeListener

ServletRequestAttributeListener

HttpSessionAttributeListener



演示监听session中属性变化
5.演示监听session绑定javabean对象
HttpSessionBindingListener监听器功能介绍
使javaBean对象在被绑定到会话或从会话中取消对它的绑定时得到通知
HttpSessionActivationListener监听器功能介绍
绑定到会话的对象可以侦听通知它们会话将被钝化和会话将被激活的容器事件
注意事项
这两个监听器比较特殊,它是由javaBean来实现的，并且不需要在web.xml文件中注册监听.
javaBean必须是序列化的.
演示HttpSessionBindingListener功能
javaBean自动感知绑定到session中以及从session中移除.
	public void valueBound(HttpSessionBindingEvent event) {
		System.out.println("绑定了user对象到了session");
	}

	public void valueUnbound(HttpSessionBindingEvent event) {
		System.out.println("从session中移除了user对象");
	}
演示HttpSessionActivationListener功能
钝化:当我们正常关闭服务器时，session对象会被保存到服务器文件中
活化:如果之前进行了钝化操作，当正常启动服务器时会从文件中将session读取出来使用

a.bean1.jsp中向session存储一个user对象
b.bean2.jsp中从session中获取user对象的name属性
c.User类实现接口HttpSessionActivationListener,可以监听到活化与钝化操作
d.做一个配置文件，来设定当活化与钝化操作时文件的位置.代码如下
				
	在meta-inf目录下创建一个context.xml文件
	<Context>
		<Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="1">
			<Store className="org.apache.catalina.session.FileStore" directory="itcast"/>
		</Manager>
	</Context>
通过以上配置会在tomcat的work目录下新建一个名称为itcast的文件夹.
此时需要使用session中的对象的时候,才会活化session


6.案例-定时删除过时订单分析
功能描述
	若一个订单从下单开始超过30分钟未支付,则删除该订单。
分析
为了这个操作我们需要拿到订单的下单时间和支付状态.然后判断订单是否超过30分钟未支付,若未支付则取消该订单,想实现此功能,还需要使用任务调度功能.要求在项目一启动的时候就可以扫描订单.比如每分钟查找一下,将满足条件的删除掉.
在java中有一个Timer定时器类


步骤分析
创建一个ServletContext创建与销毁监听器，在ServletContext对象创建时，启动定时扫描器.
在定时器内部实现查询订单及删除订单操作..
7.案例-定时删除过时订单实现
public void contextInitialized(ServletContextEvent sce) {
		//一旦服务器启动 该定时器就开始扫描
		Timer t=new Timer();
		t.schedule(new TimerTask() {
			@Override
			public void run() {
				//完成订单查询和删除操作即可
				System.out.println(".........");
			}
		}, 1000, 2000);//延迟1秒开始执行,每2秒执行一次
	}

二.Filter
1.filter介绍
filter介绍及其作用介绍
Filter是sun公司中servlet2.3后增加的一个新功能.			
Servlet规范中三个技术  Servlet  Listener  Filter
在javaEE中定义了一个接口 javax.servlet.Filter来描述过滤器
作用:
通过Filter可以拦截访问web资源的请求与响应操作.
WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。
常用api

2.filter入门案例
创建步骤:
编写filter
a.创建一个类实现javax.servlet.Filter接口
b.重写接口方法
编写配置文件
a.注册filter
b.绑定路径

Filter在web.xml文件中配置的目的:
	配置拦截什么样的资源。
	Filter初始化
<filter>
	<filter-name>demo1Filter</filter-name>
	<filter-class>cn.itcast.web.filter.Demo1Filter</filter-class>
</filter>
<filter-mapping>
	<filter-name>demo1Filter</filter-name>
	<url-pattern>/demo1</url-pattern>
</filter-mapping>
拦截分析:

注意:
在Filter的doFilter方法内如果没有执行

那么资源是不会被访问到的。
FilterChain功能介绍
FilterChain 是 servlet 容器为开发人员提供的对象，它提供了对某一资源的已过滤请求调用链的视图。过滤器使用 FilterChain 调用链中的下一个过滤器，如果调用的过滤器是链中的最后一个过滤器，则调用链末尾的资源。


3.filter链与生命周期
filter链介绍
多个Filter对同一个资源进行了拦截，那么当我们在开始的Filter中执行	chain.doFilter(request,response)时，是访问下一下Filter,直到最后一个Filter执行时，它后面没有了Filter,才会访问web资源。

如果有多个Filter形成了Filter链，那么它们的执行顺序是怎样确定的？
它们的执行顺序取决于<filter-mapping>在web.xml文件中配置的先后顺序。
filter生命周期
当服务器启动，会创建Filter对象，并调用init方法，只调用一次.
当访问资源时，路径与Filter的拦截路径匹配，会执行Filter中的doFilter方法，这个方法是真正拦截操作的方法.
当服务器关闭时，会调用Filter的destroy方法来进行销毁操作.
4.FilterConfig介绍
Filter功能介绍
在Filter中的init方法上有一个参数叫FilterConfig	,是Filter的配置对象
作用:
获取初始化参数
获取filter的名称
获取全局管理者(SerlvetContext对象)
常用api

5.filter配置详解
Filter基本配置介绍
<filter>
					<filter-name>filter名称</filter-name>
					<filter-class>filter类全名</filter-class>
				</filter>
				<filter-mapping>
					<filter-name>filter名称</filter-name>
					<url-pattern>映射路径</url-pattern>
				</filter-mapping>
url-pattern配置
			完全匹配 
				要求必须以"/"开始.
			目录匹配
				要求必须以"/"开始，以*结束.						
			扩展名匹配
				不能以"/"开始，以*.xxx结束.例如:*.jsp  *.do
关于servlet-name配置
针对于servlet拦截的配置  <servlet-name>配置
在Filter中它的url-pattern配置项上有一个标签
	<servlet-name>它用于设置当前Filter拦截哪一个servlet。
	是通过servlet的name来确定的。
关于dispatcher配置
可以取的值有  REQUEST  FORWARD  ERROR  INCLUDE					
作用：
当以什么方式去访问web资源时，进行拦截操作.		
			
REQUEST 当是从浏览器直接访问资源，或是重定向到某个资源时进行拦截方式配置的 它也是默认值
FORWARD 它描述的是请求转发的拦截方式配置
ERROR 如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。
INCLUDE 如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用
三.Filter案例
1.案例-自动登录功能分析
之前的登录流程:
login.jsp-->loginServlet-->UserService-->UserDao
现在分析下自动登录的原理
a.当用户登录成功之后,判断一下用户是否勾选了自动登录,若勾选了,将用户名和密码通过cookie持久化到浏览器上.
b.做一个filter,filter的作用为:判断cookie中是否有用户名和密码,若有拿过来调用service完成登录操作
c.filter放行
思考问题:
已经登录成功了是否还需要自动登录.
若访问的登录和注册页面,是否还需要自动登录
2.案例-自动登录功能实现
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		//1.强转
		HttpServletRequest req=(HttpServletRequest) request;
		HttpServletResponse resp=(HttpServletResponse) response;
		
		//2.逻辑
		//首先判断session中是否有user  若没有再继续操作
		User user = (User) req.getSession().getAttribute("user");
		
		if(user==null){//session中没有用户 需要继续操作
			//获取请求路径 若是login和regist的不需要自动登录
			String uri = req.getRequestURI();
			String contextPath = req.getContextPath();
			String path=uri.substring(contextPath.length());
			//System.out.println(path);
			if(!("/login.jsp".equals(path)||"/login".equals(path)||"/regist.jsp".equals(path)||"/regist".equals(path))){
				//查找是否有自动登录的cookie
				Cookie c = CookieUtils.getCookieByName("autoLogin", req.getCookies());
				if(c!=null){
					
					//若有 调用service 自动登录
					//拿到用户名和密码
					String username=c.getValue().split("-")[0];
					String password=c.getValue().split("-")[1];
					
					//调用service登录
					user = new UserService().login(username, password);
					//若登录成功 将user放入session中
					if(user!=null){
						req.getSession().setAttribute("user", user);
						System.out.println("自动登录..........");
					}
				}
			}
			
		}
		
		//3.放行
		chain.doFilter(req, resp);
	}
注意:
cookie中不能存放中文,若出现中文还需编码解决

3.java中对方法进行增强介绍
继承
装饰者模式
动态代理(基础加强讲)

装饰模式实现步骤:
a.装饰类与被装饰类要继承同一个父类或实现同一个接口。
b.在装饰类中重写方法,进行功能增强
c.在装饰类中持有一个被装饰类的对象
4.案例-编码过滤器分析
思路:在Filter中对request进行功能增强，让它处理了乱码问题，再将request传递到servlet中，这样在servlet中获取请求参数就不会乱码。
如何进行功能加强?三种方式(上面刚说过)



在EncodingFilter中已经创建了一个MyReqeust,它是一个HttpServletRequest的装饰类，而我们在chain.doFilter(MyRequest,response);也就是在servlet中使用的request其实是装饰类。

对于我们通过reqeust对象获取请求参数有三种方式:
	getParameter   getParameterValues   getParameterMap

我们不需要将这三个都进行编码处理，只需要对getParameterMap进行乱码处理，而getParameter及getParameteValues可以依赖于getParametreMap的实现

5.案例-编码过滤器实现
class MyRequest extends HttpServletRequestWrapper{
	private HttpServletRequest request;
	private boolean flag=true;
	
	
	public MyRequest(HttpServletRequest request) {
		super(request);
		this.request=request;
	}
	
	@Override
	public String getParameter(String name) {  
		if(name==null || name.trim().length()==0){
			return null;
		}
		String[] values = getParameterValues(name);
		if(values==null || values.length==0){
			return null;
		}
		
		return values[0];
	}
	
	@Override
	/**
	 * hobby=[eat,drink]
	 */
	public String[] getParameterValues(String name) {
		if(name==null || name.trim().length()==0){
			return null;
		}
		Map<String, String[]> map = getParameterMap();
		if(map==null || map.size()==0){
			return null;
		}
		
		return map.get(name);
	}
	
	@Override
	/**
	 * map{ username=[tom],password=[123],hobby=[eat,drink]}
	 */
	public Map<String,String[]> getParameterMap() {  
		
		/**
		 * 首先判断请求方式
		 * 若为post  request.setchar...(utf-8)
		 * 若为get 将map中的值遍历编码就可以了
		 */
		String method = request.getMethod();
		if("post".equalsIgnoreCase(method)){
			try {
				request.setCharacterEncoding("utf-8");
				return request.getParameterMap();
			} catch (UnsupportedEncodingException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}else if("get".equalsIgnoreCase(method)){
			Map<String,String[]> map = request.getParameterMap();
			if(flag){
				for (String key:map.keySet()) {
					String[] arr = map.get(key);
					//继续遍历数组
					for(int i=0;i<arr.length;i++){
						//编码
						try {
							arr[i]=new String(arr[i].getBytes("iso8859-1"),"utf-8");
						} catch (UnsupportedEncodingException e) {
							e.printStackTrace();
						}
					}
				}
				flag=false;
			}
			//需要遍历map 修改value的每一个数据的编码
			
			return map;
		}
		
		return super.getParameterMap();
	}
	
}

文件上传
二.文件上传
1.文件上传介绍
要将客户端（浏览器）大数据存储到服务器端，不将数据直接存储到数据库中，而是要将数据存储到服务器所在的磁盘上，这就要使用文件上传。
作用:减少了数据库服务器的压力，对数据的操作更加灵活
2.文件上传原理分析 
所谓的文件上传就是服务器端通过request对象获取输入流，将浏览器端上传的数据读取出来，保存到服务器端
浏览器端操作
请求方式必须是post
使用<input type=’file’ name=’xxx’>,必须有name属性且有值
表单必须设置encType=”multipart/form-data”
服务器端操作
通过request对象,获取inputStream,就可以将浏览器提交的所有数据读取到.
注意:
这时候,获取其他上传参数的时候,通过request.getParameter(“”)获取不到了.
3.Commons-fileupload介绍与入门案例
commons-fileupload介绍
Apache 开源组织提供了一个用来处理表单文件上传的一个开源组件（ Commons-fileupload ），该组件性能优异，并且其API使用极其简单，可以让开发人员轻松实现web文件上传功能，因此在web开发中实现文件上传功能，通常使用Commons-fileupload组件实现。
使用Commons-fileupload组件实现文件上传，需要导入该组件相应的支撑jar包：
Commons-fileupload和commons-io。
commons-io 不属于文件上传组件的开发jar文件，但Commons-fileupload 组件从1.1 版本开始，它工作时需要commons-io包的支持。
commons-fileupload API简单介绍
DiskFileItemFactory,用于设置缓存大小及临时文件存储位置
ServletFileUpload,真正用于文件上传的核心类
FIleItem,代表的是一个上传项
入门案例分析
在浏览器端创建一个可以上传文件的表单，在服务器端通过commons-fileupload完成文件上传。
	浏览器端注意三件事情:
表单的提交方式为post
在表单上添加属性 encType=”multipart/form-data”
使用<input type=’file’ >,添加name属性且有值
服务器端:
创建DiskFileItemFactory
创建ServletFileUpload
通过ServletFileUpload的parseRequest方法得到所有的FileItem
入门案例实现
浏览器端
<form action="${pageContext.request.contextPath}/upload" method="post"	enctype="multipart/form-data">
		<input type="file" name="f"> 
		<input type="submit" value="上传">
	</form>
服务器端
// 1.创建一个 DiskFileItemFactory
	DiskFileItemFactory factory = new DiskFileItemFactory();

	// 2.创建一个ServletFileUpload
	ServletFileUpload upload = new ServletFileUpload(factory);

	// 3.完成上传操作

	try {
		// 3.1 得到所有上传项
		List<FileItem> items = upload.parseRequest(request);
		// 3.2遍历上传项
		for (FileItem item : items) {
			// 3.3判断是否是上传组件
			if (!item.isFormField()) {
				// 3.4 将文件真正上传
				IOUtils.copy(item.getInputStream(), new FileOutputStream(
						"f:/upload/a.txt"));
			}
		}
	} catch (FileUploadException e) {
		e.printStackTrace();
	}


4.Commons-fileupload详解-DiskFileItemFactory
设置缓存大小
	factory.setSizeThreshold(1024*1024); //设置为1m 默认是10k
设置临时文件存储位置
	File temp=new File(this.getServletContext().getRealPath("/temp"));
	factory.setRepository(temp); //可以指定临时文件存储位置，默认是系统的临时文件存储位置
5.Commons-fileupload详解-ServletFileUpload
parseRequest方法
	List<FileItem> pareRequest(HttpServletRequest request)
		得到所有的上传信息，将每一部分映射成FileItem对象.
isMultipartContent方法
	boolean isMultipartContent(HttpServletRequest request)	
		这个方法返回值是boolean,它是用于判断当前表单是否是一个上传的表单,
		简单说，就判断它的encType的值是否是 multipart/form-data.
setHeaderEncoding方法
		用于解决上传文件名称中文乱码问题
设置上传文件大小
	void setFileSizeMax(long fileSizeMax) 设置单个文件上传大小 
	void  setSizeMax(long sizeMax) 设置总文件上传大小
6.Commons-fileupload详解-FileItem
isFormField方法
	这个方法返回的是boolean类型，
	它是判断当前组件是否是上传组件 简单说，就是判断type="file",
	如果返回true,代表不是上传组件,返回false,代表是上传组件
getName方法
	获取上传组件的上传文件的名称,如果是非上传组件，返回的是null
getFieldName方法
	获取组件名称,简单说，就是表单的元素的name值。
getString方法
	获取非上传组件的value值,
	通过它也可以获取上传的文件内容，但是，使用它获取不合适。如果使用了commons-fileupload进行文件上传，而上传表单中包含了	非上传组件，获取其值，不能使用request获取.getString()有一个重载的方法 getString(String encoding)可以解决乱码问题
getInputStream方法
	通过FileItem.getInputStream();可以获取一个输入流，这个输入流就可以
读取出上传文件内容。
    InputStream is = item.getInputStream(); // 用于读取上传文件内容的输入流.
	FileOutputStream fos = new FileOutputStream("f:/upload/" + filename);
	int len = -1;
	byte[] b = new byte[1024 * 10];
	while ((len = is.read(b)) != -1) {
		fos.write(b, 0, len);
		fos.flush();
	}
	fos.close();
	is.close();

可以使用IOUtils工具完成文件copy操作
IOUtils.copy(is, fos);
delete方法
	它是用于上传完成后，删除临时文件的
7.多文件上传
我们在写邮件中可以添加多个附件，那么我们在文件上传时，是不是也可以上传多个文件哪，答案是一定的，那么怎样实现多个文件上传哪？
	我们可以通过js实现浏览器端的上传文件框的动态添加。服务器端代码不需要改变.
function addFile() {
	//1.得到id叫content的div
	var div=document.getElementById("content");	
	//2.向其中添加一段html代码
div.innerHTML+="<div><input type='file' name='f'><input type='button' value='remove File' onclick='removeFile(this);'></div>";
}
function removeFile(btn){
	document.getElementById("content").removeChild(btn.parentNode);
}


8.文件上传问题-文件重名
每一个客户端都可以进行文件上传操作，那么当我们上传的文件过多，一定会出现同名的文件，那么在服务器端只能保存一个，对于这个问题，我们在上传文件时，就需要考虑文件重名问题.
一般情况下，对于上传文件，为了保证不重名，会给文件起一个随机名.
	一种方案是使用uuid.
	一种方案是使用毫秒值

9.文件上传问题-存储位置
本质就是上传的文件是否允许浏览器端直接访问。			
	例如:商品添加时需要一个图片，这个图片一定是可以直接被浏览器端访问的。

允许被浏览器端访问:放置在WebRoot下，但不能是WEB-INF或META-INF下其及子目录下
	不允许被浏览器端访问:
		若放在工程下则放置在WEB-INF或META-INF及其子目录下.
		也可以不放在工程下

10.文件上传问题-目录分离
当我们上传文件过多，并且保存在同一个目录下时，我们就需要考虑怎样处理它们，因为一个目录下文件过多，不仅降低性能，操作时也不方便。
为了防止同一个目录下方上传文件数量过多 
1) 按照上传时间进行目录分离 （周、月 ）
2) 按照上传用户进行目录分离 ----- 为每个用户建立单独目录 
3) 按照固定数量进行目录分离 ------ 假设每个目录只能存放3000个文件 ，每当一个目录存满3000个文件后，创建一个新的目录
4).按照唯一文件名的hashcode 进行目录分离	

  public static String generateRandomDir(String uuidFileName) {
		// 获得唯一文件名的hashcode
		int hashcode = uuidFileName.hashCode();
		// 获得一级目录
		int d1 = hashcode & 0xf;       
		// 获得二级目录
		int d2 = (hashcode >>> 4) & 0xf;
		return "/" + d2 + "/" + d1;// 共有256目录
	}



一、安装ZIP版本
下载
mysql-5.5.27-win32.zip（根据系统进行相应的下载）
解压
将文件解压在不包含中文、不包含空格的目录下

配置

在my.ini文件中的[mysqld]下面添加下面内容
[mysqld]
basedir=D:\\java\\mysql-5.5.27-win32
datadir=D:\\java\\mysql-5.5.27-win32\\data
注意：mysql5.5.21以后此步不需设置
启动MySQL服务器

启动成功
第一次
第一次启动时，会在/data 目录下创建需要的所需文件

第二次

将MySql设置成window服务
添加

移除

手动操作（了解）
创建
sc create MySQL binpath= "D:\java\mysql-5.5.27-win32\bin\mysqld MySQL" displayname= "MySQLxx" start= auto

删除
sc delete MySQL

启动
net start MySQL

关闭
net stop MySQL







二、安装版本
1、运行mysql-5.5.27-win32.msi
2、进入欢迎界面，点击“下一步”
3、同意使用协议，点击“下一步”
4、选择安装类型


5、选择安装路径
	具体路径自定义

注意：需要单独修改数据库文件所在位置，方便查看和管理。建议放置到mysql安装目录下的data目录

6、确定安装（install）
7、企业版本介绍

8、确定安装成功，并进行数据库初始化操作

选择“配置实例”复选框后，看到以下窗口提示

如果没有勾选，可以在mysql安装目录下,bin目录中执行MySQLInstanceConfig.exe文件
此文件只有安装中存在
9、选择配置类型

10、选择服务类型

11、选择支持的数据库类型

12、设置事务文件位置

13、设置并发连接数

14、网络参数配置

如果勾选了“Add firewall exception for this port”，但是你服务器的Windows的防火墙又没有开启，所以会有如下提示“终结点映射器中没有更多的终结点可用”

15、数据库默认字符集

16、操作系统设置

17、安全设置

18、安装成功




三、安装测试及常用操作
首次登陆
mysql -uroot –p   或  mysql -uroot

查询所有数据库
show databases;

每一个数据库，就是一个数据文件夹

设置密码
查询
用户保存在mysql数据库中的user表中
select host,user,password from user; 【字段太多,只查看user表中3字段：host,user,password】

修改user表


使用mysqladmin
格式：mysqladmin -u用户名 -p旧密码 password 新密码
mysqladmin -uroot -p1234 password 123456
因为开始时root没有密码，所以-p旧密码一项就可以省略了





四、中文乱码
设置数据库编码
mysql> create database test2 character set UTF8;

添加、查询数据

查询当前数据库编码
mysql> show variables like "char%";




五、配置文件介绍
1.my-small.cnf是为了小型数据库而设计的。不应该把这个模型用于含有一些常用项目的数据库。
2.·my-medium.cnf是为中等规模的数据库而设计的。如果你正在企业中使用RHEL,可能会比这个操作系统的最小RAM需求(256MB)明显多得多的物理内存。由此可见，如果有那么多RAM内存可以使用，自然可以在同一台机器上运行其它服务。
3·my-large.cnf是为专用于一个SQL数据库的计算机而设计的。由于它可以为该数据库使用多达512MB的内存，所以在这种类型的系统上将需要至少1GB的RAM,以便它能够同时处理操作系统与数据库应用程序。
4·my-huge.cnf是为企业中的数据库而设计的。这样的数据库要求专用服务器和1GB或1GB以上的RAM。
这些选择高度依赖于内存的数量、计算机的运算速度、数据库的细节大小、访问数据库的用户数量以及在数据库中装入并访问数据的用户数量。随着数据库和用户的不断增加，数据库的性能可能会发生变化。
运行


协议


选择操作


选择路径




安装完成提示


安装完成，是否启动当前程序



运行，第一次填写序列号填写


新建连接





删除服务
.
1.查找要删除的服务名称
.
服务名称分为服务名称和显示名称，我们这里只需要服务名称。
.
选中要删除的服务，右击->属性，弹出服务属性窗口。
.
2删除服务
.
a、打开命令行窗口。win+r弹出“运行”命令框，在“运行”里输入 cmd 后回车。
.
b、sc delete "服务名称" 后，回车，双引号必须为英文符号（如果服务名中间有空格，就需要前后加引号）。

c删除检测:再次服务管理查看删除的服务是否存在。
.







网上商城实战1
今日任务
完成用户模块的功能
网上商城的实战：
演示网上商城的功能：

需求的演示：

数据库分析和设计：

代码实现:
通用的Servlet的编写:
传统的方式：
* 一个请求对应一个Servlet.
* 能不能一个模块对应一个Servlet.

一个模块对应一个Servlet:
<a href=”/UserServlet?method=add”>添加</a>
<a href=”/UserServlet?method=update”>修改</a>
<a href=”/UserServlet?method=delete”>删除</a>

public class UserServlet extends HttpServlet{

   public void service(HttpServletRequest req,HttpServletResponse resp){
           String method = req.getParameter(“method”);
           if(“add”.equals(method)){
               add(req,resp);
           }else if(“update”.equals(method)){
               update(req,resp);
           }
   }

   public void add(HttpServletRequest req,HttpServletResponse resp){
   
   }

   public void update(HttpServletRequest req,HttpServletResponse resp){
   
   }

}

改进以后：
public class BaseServlet extends HttpServlet{
   public void service(HttpServletRequest req,HttpServletResponse resp){
           String methodName = req.getParameter(“method”);
           // 反射:
           Class clazz = this.getClass(); // 指代的是子类的对象.
           Method method = clazz.getMethod(methodName ,HttpServletRequest.class,HttpServletResponse,class);
           method.invoke(this,req,resp);
   }

}


public class UserServlet extends BaseServlet{

   public void add(HttpServletRequest req,HttpServletResponse resp){
   
   }

   public void update(HttpServletRequest req,HttpServletResponse resp){
   
   }

}

public class A{
   public A(){
      System.out.println(this.getClass());
   }
}

public class B extends A{
    Public B(){

    }
}

public class Test{
   Public static void main(String[] args){
       B b = new B();
   }
}
BaseServlet的代码实现：
【创建包结构】

【代码实现】
public class BaseServlet extends HttpServlet{

	@Override
	// http://loacalhost:8080/store/UserServlet?method=add
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// 处理Post请求的乱码
		req.setCharacterEncoding("UTF-8");
		// 接收参数:
		String methodName = req.getParameter("method");
		// 反射获得类的字节码.
		Class clazz = this.getClass();
		// 获得正在执行的类的指定名称的方法
		try {
			Method method = clazz.getMethod(methodName, HttpServletRequest.class,HttpServletResponse.class);
			// 让这个方法执行:
			String path = (String) method.invoke(this, req,resp);
			if(path != null){
				req.getRequestDispatcher(path).forward(req, resp);
			}
		} catch (Exception e) {
			e.printStackTrace();
		} 
	}

}
环境的搭建：
【创建一个WEB工程】
【创建包结构】
【引入相应的jar包】
    * mysql驱动			1
    * dbutils			1
    * c3p0连接池			1
    * beanutils			2
    * JSTL				2
    * 文件上传			2
    * 发送邮件			1
【创建数据库和表】
CREATE TABLE `user` (
  `uid` varchar(32) NOT NULL,
  `username` varchar(20) DEFAULT NULL,
  `password` varchar(20) DEFAULT NULL,
  `name` varchar(20) DEFAULT NULL,
  `email` varchar(30) DEFAULT NULL,
  `telephone` varchar(20) DEFAULT NULL,
  `birthday` varchar(20) DEFAULT NULL,
  `sex` varchar(10) DEFAULT NULL,
  `state` int(11) DEFAULT NULL,
  `code` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
前台用户模块：
注册
异步校验用户名是否存在
5.JS的事件触发一个函数.
6.使用AJAX异步向服务器发送请求.
7.得到返回的数据进行判断.
8.将信息写入到文本框后面span元素中.
完成用户注册
6.在注册页面中输入信息.
7.点击注册,提交到Servlet.
8.接收数据,封装数据.
9.在Servlet调用业务层.
10.页面跳转.
发送激活邮件
2.使用JavaMail的技术-了解.
* 了解邮件相关内容:
    * 术语:
        * 电子邮箱：一个邮箱服务器上的一个账号,通过账号获得到服务器上一块空间.
        * 邮箱服务器：一台电脑安装一个邮箱的服务器.
        * 邮件收发的协议：协议规范双方的数据的格式.
    * 协议:
        * 接收：POP/POP3  IMAP
        * 发送：SMTP
    * 邮件收发过程:
    * 会配置邮箱的客户端:
【配置邮箱服务器：】

安装成功！
第一步：

第二步：

第三步：


【配置邮箱的客户端】
* Foxmail:免费的
    * 输入用户名
    * 输入密码:
    * 修改服务器的地址localhost.
* outlook:微软的收费的.
激活
在邮箱的界面点击激活链接：
提交到Servlet传递一个激活码:
根据激活码进行查询用户：
* 如果查询到该用户：修改用户的状态.
* 如果没有查询到该用户：激活失败.
登录
在登录页面上输入用户名和密码
点击提交：提交到Servlet.
在Servlet中接收参数
调用业务层
页面跳转
记住用户名
使用Cookie记住用户名:
* 自己完成
自动登录
使用Cookie记住用户名和密码：
使用过滤器：
* 自己完成
退出
* 在首页上点击退出的链接:
* 提交到Servlet:
    * 销毁session:













网上商城实战2
今日任务
完成分类模块的功能
完成商品模块的功能
分类模块的功能：
查询分类的功能：

查询分类的代码实现：
创建表：
CREATE TABLE `category` (
  `cid` varchar(32) NOT NULL,
  `cname` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`cid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
功能实现：
1.直接查询所有分类:
CategoryDao categoryDao = new CategoryDaoImpl();
List<Category>	list = categoryDao.findAll();


2.异步加载分类：
$(function() {
	$.post("/store_v2.0/CategoryServlet", {
		"method" : "findAll"
	}, function(data) {
		$.each(data, function(i, n) {
			$("#menu").append("<li><a href='#'>" + n.cname + "</a></li>");
		});
	}, "json");
});

3.使用缓存技术:对程序进行优化.
* 缓存：其实就是内存中的一块空间.可以使用缓存将数据源中的数据拿到,存入到内存中.后期获得数据的话 从缓存中进行获得.
* Memcache	:
* EHCache	:是Hibernate常使用的二级缓存的插件.
* Redis		:
* 使用ehcache:
   * 引入jar包:
   * 引入配置文件:
   	// 业务层查询所有分类的方法:
	public List<Category> findAll() throws SQLException {
		/*
		 * CategoryDao categoryDao = new CategoryDaoImpl(); return
		 * categoryDao.findAll();
		 */
		/**
		 * 从缓存中查询数据：
		 *  * 有数据,直接将缓存的数据返回. 
		 *  * 如果没有,查询数据库,数据存入到缓存中.
		 */
		List<Category> list = null;

		// 从缓存中进行查询:
		CacheManager cacheManager = CacheManager
				.create(CategoryServiceImpl.class.getClassLoader().getResourceAsStream("ehcache.xml"));
		Cache cache = cacheManager.getCache("categoryCache");
		
		Element element = cache.get("list");
		if(element != null){
			// 缓存中有数据:
			System.out.println("缓存中有数据...");
			list = (List<Category>) element.getObjectValue();
		}else{
			// 缓存中没有数据：
			System.out.println("缓存中没有数据...");
			CategoryDao categoryDao = new CategoryDaoImpl();
			list = categoryDao.findAll();
			Element e = new Element("list", list);
			// cache.
			cache.put(e);
		}
		return list;

	}
首页上的商品显示：
商品显示的准备工作:
创建表：
CREATE TABLE `product` (
  `pid` varchar(32) NOT NULL,
  `pname` varchar(50) DEFAULT NULL,
  `market_price` double DEFAULT NULL,
  `shop_price` double DEFAULT NULL,
  `pimage` varchar(200) DEFAULT NULL,
  `pdate` datetime DEFAULT NULL,
  `is_hot` int(11) DEFAULT NULL,
  `pdesc` varchar(255) DEFAULT NULL,
  `pflag` int(11) DEFAULT NULL,
  `cid` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`pid`),
  KEY `sfk_0001` (`cid`),
  CONSTRAINT `sfk_0001` FOREIGN KEY (`cid`) REFERENCES `category` (`cid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
创建类：

首页上的热门商品的显示和最新商品的显示
		ProductService productService = new ProductServiceImpl();
		try {
			// 查询热门商品：
			List<Product> hotList = productService.findByHot();
			// 查询最新商品：
			List<Product> newList = productService.findByNew();
			
			req.setAttribute("hotList",hotList);
			req.setAttribute("newList",newList);
			
		} catch (SQLException e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
商品详情的显示
	public String findById(HttpServletRequest req,HttpServletResponse resp){
		// 接收参数:
		String pid = req.getParameter("pid");
		// 调用业务层：
		ProductService productService = new ProductServiceImpl();
		try {
			Product product = productService.findById(pid);
			req.setAttribute("product",product);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
		// 页面跳转
		return "/jsp/product_info.jsp";
	}
显示某个分类下的商品：
1.在首页上点击分类的链接:
2.提交到Servlet:
    * 接收参数：分类的ID
    * 当前页面：当前页数1
    * 调用业务层：
         * 封装PageBean:
   * 页面跳转：


网上商城实战3
今日任务
完成购物模块的功能
完成订单模块的功能
购物模块：
功能演示：


代码实现：
1.在商品详情的页面中点击【加入购物车】链及.
2.提交到Servlet中：
    * 提交购买的商品的数量.
    * 提交购买的商品的ID.
3.将购物的信息存入到session中.
    * 将购物车的信息存入到session中.
    * 购物项对象的封装（购物车中的每个购买商品的信息）
        * 商品的对象:
        * 数量
        * 小计
    * 购物车对象的封装（购买所有商品的信息）
        * 购物项的集合
        * 总计
4.在页面中将购物车的信息获得到.
    * 在页面中显示出来.

【购物项的实体的封装：CartItem】
public class CartItem {
	private Product product;// 购买的商品的信息
	private int count; // 购买的数量
	private double subtotal; // 购买商品的小计
	
	public Product getProduct() {
		return product;
	}
	public void setProduct(Product product) {
		this.product = product;
	}
	public int getCount() {
		return count;
	}
	public void setCount(int count) {
		this.count = count;
	}
	public double getSubtotal() {
		return count * product.getShop_price();
	}
	/*public void setSubtotal(double subtotal) {
		this.subtotal = subtotal;
	}*/
	
	
}

【购物车的实体：Cart】
public class Cart {
	// 定义一个购物项的集合的属性:集合采用Map集合,因为移除购物项的时候方便.使用商品的id作为Map的key
	// 使用购物项作为Map的value.
	private Map<String,CartItem> map = new LinkedHashMap<String,CartItem>();
	// 定义购物车中的总计:
	private double total;
	
	public Map<String, CartItem> getMap() {
		return map;
	}
	
	public double getTotal() {
		return total;
	}
	
	// 方法：将购物项添加到购物车
	public void addCart(CartItem cartItem){
		// 判断购物车中是否已经存在该购物项.
		String id = cartItem.getProduct().getPid();
		if(map.containsKey(id)){
			// 如果已经存在:在原来的数量的基础上+新买的数量. 总计发生变化.
			// 获得购物车中的原来购物项的信息
			CartItem _cartItem = map.get(id);
			_cartItem.setCount(_cartItem.getCount()+cartItem.getCount());
		}else{
			// 如果不存在:在集合中添加一个新的购物项. 总计发生变化.
			map.put(id, cartItem);
		}
		
		total += cartItem.getSubtotal();
		
	}
	
	// 方法：从购物车中移除购物项
	public void removeCart(String id){
		// 从map中移除选中的元素.
		// CartItem cartItem = map.get(id);
		CartItem cartItem = map.remove(id);
		// 将总计 - 移除购物项的小计
		total -= cartItem.getSubtotal();
		
	}
	
	// 方法：清空购物车
	public void clearCart(){ // 
		//  将map集合清空.
		map.clear();
		// 将总结设置为0.
		total = 0;
	}
}

【在购物详情页面点击加入购物车的链接】
	public String addCart(HttpServletRequest req,HttpServletResponse resp){
		// 接收参数:
		String pid = req.getParameter("pid");
		int count = Integer.parseInt(req.getParameter("count"));
		
		try {
			// 封装购物项:
			CartItem cartItem = new CartItem();
			// 商品对象:通过商品ID查询商品.
			ProductService productService = (ProductService) BeanFactory.getBean("productService");
			Product product = productService.findById(pid);
			cartItem.setProduct(product);
			cartItem.setCount(count);
			// 调用购物车中的添加到购物车的方法：
			// Cart cart = new Cart();
			Cart cart = getCart(req);
			cart.addCart(cartItem);
			
			resp.sendRedirect(req.getContextPath()+"/jsp/cart.jsp");
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
		return null;
	}

【在购物车页面点击清空购物车】
	public String clearCart(HttpServletRequest req,HttpServletResponse resp){
		// 获得购物车对象.
		Cart cart = getCart(req);
		// 调用购物车中的方法:
		cart.clearCart();
		try {
			resp.sendRedirect(req.getContextPath()+"/jsp/cart.jsp");
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
		return null;
	}

【在购物车页面点击删除链接】
	public String removeCart(HttpServletRequest req,HttpServletResponse resp){
		try {
			// 接收参数：
			String pid = req.getParameter("pid");
			// 获得购物车：
			Cart cart = getCart(req);
			cart.removeCart(pid);
			// 页面跳转
			resp.sendRedirect(req.getContextPath()+"/jsp/cart.jsp");
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
		return null;
	}
订单模块：
功能演示：



代码实现：
创建表和实体：
CREATE TABLE `orders` (
  `oid` varchar(32) NOT NULL,
  `ordertime` datetime DEFAULT NULL,
  `total` double DEFAULT NULL,
  `state` int(11) DEFAULT NULL,
  `address` varchar(30) DEFAULT NULL,
  `name` varchar(20) DEFAULT NULL,
  `telephone` varchar(20) DEFAULT NULL,
  `uid` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`oid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `orderitem` (
  `itemid` varchar(32) NOT NULL,
  `count` int(11) DEFAULT NULL,
  `subtotal` double DEFAULT NULL,
  `pid` varchar(32) DEFAULT NULL,
  `oid` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`itemid`),
  KEY `fk_0001` (`pid`),
  KEY `fk_0002` (`oid`),
  CONSTRAINT `fk_0001` FOREIGN KEY (`pid`) REFERENCES `product` (`pid`),
  CONSTRAINT `fk_0002` FOREIGN KEY (`oid`) REFERENCES `orders` (`oid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
生成订单：
【在购物车的页面点击提交订单】
提交到Servlet：
    * 封装订单和订单项.
    * 调用业务层
    * 清空购物车
    * 页面跳转
网上商城实战4
今日任务
完成订单模块的功能
订单 模块的功能
我的订单：
【我的订单的查询】
* 在header.jsp中点击我的订单.
* 提交到Servlet:
    * 获得用户的信息:
    * 调用业务层：分页查询.
        * 查询该用户的所有的订单:
            * 查询每个订单的时候,需要将其订单项一起查询出来.
    * 页面跳转
查询某个订单详情:
【查询某个订单】
在订单列表页面中点击付款的链接
提交到Servlet：
    * 接收数据：
    * 调用业务层：
    * 页面跳转：
为订单付款：
【为订单付款】
在订单详情页面中点击确认订单：
提交到Servlet：
    * 接收数据：（姓名，电话，地址，选择银行，订单号，金额）
    * 为订单付款: 重定向到易宝的网站.
    
网上商城实战5
今日任务
完成后台的功能模块
网上商城的后台功能的实现:
后台的功能的需求:

分类管理:
【查询所有分类】
* 在左侧菜单页面中点击分类管理:
* 提交到Servlet:
* 查询所有的分类:
* 显示到页面中:

【添加分类】
* 在分类列表页面中点击【添加】按钮.
* 提交到Servlet跳转到添加页面.
* 输入信息点击【确定】按钮.
* 提交到Servlet完成保存分类的功能.

【修改分类】
* 在分类列表页面中点击【编辑】链接:
* 提交到Servlet进行查询.
* 显示到修改页面中.
* 修改分类的信息.点击【确定】按钮.
* 提交到Servlet完成修改分类的功能.
【删除分类】
* 在分类的列表页面中点击【删除】链接:
* 提交到Servlet中.
* 页面跳转.
商品管理
【查询商品】
* 在左侧菜单页面中点击【商品管理】
* 提交到Servlet进行查询.
* 显示到页面.
【添加商品】
* 在商品列表页面中点击【添加】按钮.
* 提交到Servlet:查询所有分类.
* 页面跳转到添加页面.
* 在添加页面中输入信息（包括图片）
* 点击【确定】
* 提交到Servlet:文件上传,数据插入到数据库.
***** 文件的上传:
     * 三个要素:
         * 提交的方式是POST：
         * 表单中需要有<input type=”file” name=”upload”>
         * enctype=”multipart/form-data”

     * 文件上传的技术：
         * Servlet3.0
         * JSPSmartUpload
         * FileUpload:
             * commons-fileupload-1.2.1.jar
             * commons-io-1.4.jar
         * Struts2

     * 使用FileUpload的时候:
         * 获得磁盘文件工厂对象:
         * 通过工厂获得核心解析类：
         * 解析request对象 , 返回集合,集合中的内容是分割线分成的每个部分.
         * 遍历每个部分:

【下架商品】
* 在商品的列表页面上点击【下架】链接.
* 提交到Servlet:
* 修改商品的状态:
* 页面跳转:

【上架商品】
* 在左侧菜单中添加一个上架商品:
* 选择某个商品上架.
订单管理
【订单管理】
在左侧菜单中点击【订单管理】链接:
查询订单(按状态查询订单)
页面跳转:
Linux
教学导航
教学目标	了解Linux系统
安装Linux虚拟机
学习Linux的常用命令
多用户以及权限学习
Linux实战
教学方法	案例驱动法
Linux的概述：
什么是Linux：
学习Linux之前先了解Unix
Unix是一个强大的多用户、多任务操作系统。
于1969年在AT&T的贝尔实验室开发。
UNIX的商标权由国际开放标准组织（The Open Group）所拥有。
UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。
Linux的概述：
Linux是基于Unix的
Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机


诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成

             
Linux的历史：
Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统.
Linux系统的应用：
服务器系统
Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 
嵌入式系统
路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，
高性能运算、计算密集型应用
Linux有强大的运算能力。
桌面应用系统
移动手持系统
Linux的版本
Linux的版本分为两种：内核版本和发行版本；
内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；
发行版本是一些组织和公司根据自己发行版的不同而自定的 ；
Linux的主流版本

Linux的安装：
虚拟机安装：
什么是虚拟机
虚拟机：一台虚拟的电脑.
虚拟机软件:
* VmWare		:收费的.
* VirtualBox	:免费的.
安装VmWare
参考《虚拟软件vmware安装.doc》
CentOS的安装
参考《CentOS6详细安装文档.doc》
Linux的目录结构：


root管理员的home目录root
其他用户的home目录home目录中
Linux的常用命令

切换目录命令cd：
使用
cd app	切换到app目录
cd ..	切换到上一层目录
cd /		切换到系统根目录
cd ~		切换到用户主目录
cd -		切换到上一个所在目录
列出文件列表：ls ll dir(*****)
ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。
    格式：ls[参数] [路径或文件名]

常用：
在linux中以 . 开头的文件都是隐藏的文件

* ls
* ls -a  显示所有文件或目录（包含隐藏的文件）
* ls -l  缩写成ll
创建目录和移除目录：mkdir rmdir
mkdir(make directory)命令可用来创建子目录。
mkdir app    在当前目录下创建app目录
mkdir –p app2/test   级联创建aap2以及test目

rmdir(remove directory)命令可用来删除“空”的子目录：
rmdir app    删除app目录

浏览文件
【cat、more、less】
cat
用于显示文件的内容。
格式：cat[参数]<文件名>

    * cat yum.conf

more
一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。
回车显示下一行内容。
按 q 键退出查看。
* more yum.conf
   * 空格显示下一页数据  回车显示下一行的数据

less
用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。
    * less yum.conf
        * PgUp 和 PgDn 进行上下翻页.

【tail】
tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。
用法:
tail -10 /etc/passwd    查看后10行数据
tail -f catalina.log   动态查看日志(*****)


ctrl+c 结束查看
文件操作：
【rm】
rm  删除文件
用法：rm [选项]... 文件...
rm a.txt    删除a.txt文件
删除需要用户确认，y/n
rm 删除不询问
rm -f a.txt    不询问，直接删除
rm 删除目录
rm -r a    递归删除
不询问递归删除（慎用）
rm -rf  a    不询问递归删除
rm -rf *      删除所有文件
rm -rf /*      自杀
【cp、mv】
cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。
cp a.txt b.txt    将a.txt复制为b.txt文件
cp a.txt ../    将a.txt文件复制到上一层目录中


mv 移动或者重命名
mv a.txt ../    将a.txt文件移动到上一层目录中
mv a.txt b.txt    将a.txt文件重命名为b.txt

【tar】命令:(***** 打包或解压)
tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。

常用参数：
-c：创建一个新tar文件
-v：显示运行过程的信息
-f：指定文件名
-z：调用gzip压缩命令进行压缩
-t：查看压缩文件的内容
-x：解开tar文件



打包：
tar –cvf xxx.tar ./*
打包并且压缩：
tar –zcvf xxx.tar.gz ./* 

解压 
     tar –xvf xxx.tar
tar -xvf xxx.tar.gz -C /usr/aaa

【grep】命令
查找符合条件的字符串。
用法: grep [选项]... PATTERN [FILE]...
示例：
grep lang anaconda-ks.cfg  在文件中查找lang
grep lang anaconda-ks.cfg –color 高亮显示






其他常用命令
【pwd】
显示当前所在目录
【touch】
创建一个空文件
* touch a.txt
【ll -h】
友好显示文件大小
【wget】
下载资料
* wget http://nginx.org/download/nginx-1.9.12.tar.gz
Vi和Vim编辑器
Vim编辑器：
在Linux下一般使用vi编辑器来编辑文件。
vi既可以查看文件也可以编辑文件。
三种模式：命令行、插入、底行模式。
切换到命令行模式：按Esc键；
切换到插入模式：按 i 、o、a键；
    i 在当前位置生前插入
    I 在当前行首插入
    a 在当前位置后插入
    A 在当前行尾插入
    o 在当前行之后插入一行
    O 在当前行之前插入一行

切换到底行模式：按 :（冒号）；
更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》


打开文件：vim file
退出：esc  :q
修改文件：输入i进入插入模式
保存并退出：esc:wq

不保存退出：esc:q!

3中进入插入模式：
i:在当前的光标所在处插入
o:在当前光标所在的行的下一行插入
a:在光标所在的下一个字符插入

快捷键：
dd – 快速删除一行
R – 替换
重定向输出>和>>
> 重定向输出，覆盖原有内容；
>> 重定向输出，又追加功能；
示例：
cat /etc/passwd > a.txt  将输出定向到a.txt中
cat /etc/passwd >> a.txt  输出并且追加

ifconfig > ifconfig.txt
管道 |
管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。
示例
ls --help | more  分页查询帮助信息
ps –ef | grep java  查询名称中包含java的进程

ifconfig | more
cat index.html | more
ps –ef | grep aio
&&命令执行控制：
命令之间使用 && 连接，实现逻辑与的功能。 

只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行。 

只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。

mkdir test && cd test
网络通讯命令
ifconfig  显示或设置网络设备。
ifconfig  显示网络设备
ifconfig eth0 up 启用eth0网卡
ifconfig eth0 down  停用eth0网卡
ping   探测网络是否通畅。
ping 192.168.0.1
netstat 查看网络端口。
netstat -an | grep 3306 查询3306端口占用情况
系统管理命令
date 显示或设置系统时间
date  显示当前系统时间
date -s “2014-01-01 10:10:10“  设置系统时间
df 显示磁盘信息
df –h  友好显示大小
free 显示内存状态
free –m 以mb单位显示内存组昂头
top 显示，管理执行中的程序

clear 清屏幕

ps 正在运行的某个进程的状态
ps –ef  查看所有进程
ps –ef | grep ssh 查找某一进程
kill 杀掉某一进程
kill 2868  杀掉2868编号的进程
kill -9 2868  强制杀死进程

du 显示目录或文件的大小。
du –h 显示当前目录的大小

who 显示目前登入系统的用户信息。

hostname 查看当前主机名
修改：vi /etc/sysconfig/network

uname 显示系统信息。
uname -a 显示本机详细信息。
依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称
Linux的用户和组
用户的管理
useradd 添加一个用户
useradd test 添加test用户
useradd test -d /home/t1  指定用户home目录

passwd  设置、修改密码
passwd test  为test用户设置密码

切换登录：
ssh -l test -p 22 192.168.19.128

su – 用户名

userdel 删除一个用户
userdel test 删除test用户(不会删除home目录)
userdel –r test  删除用户以及home目录
组管理：
当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组

创建用户时也可以指定所在组

groupadd  创建组
groupadd public  创建一个名为public的组
useradd u1 –g public  创建用户指定组
groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。
groupdel public

id，su命令
【id命令】
功能：查看一个用户的UID和GID
用法：id [选项]... [用户名]


直接使用id
直接使用id 用户名
【su命令】
功能：切换用户。
用法：su [选项]... [-] [用户 [参数]... ]
示例：
su u1  切换到u1用户
su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用）

【账户文件】
/etc/passwd  用户文件
/etc/shadow  密码文件
/etc/group  组信息文件
【用户文件】
root:x:0:0:root:/root:/bin/bash
账号名称：		在系统中是唯一的
用户密码：		此字段存放加密口令
用户标识码(User ID)：  系统内部用它来标示用户
组标识码(Group ID)：   系统内部用它来标识用户属性
用户相关信息：		例如用户全名等
用户目录：		用户登录系统后所进入的目录
用户环境:		用户工作的环境
【密码文件】
shadow文件中每条记录用冒号间隔的9个字段组成.
用户名：用户登录到系统时使用的名字，而且是惟一的
口令：  存放加密的口令
最后一次修改时间:  标识从某一时刻起到用户最后一次修改时间
最大时间间隔:  口令保持有效的最大天数，即多少天后必须修改口令
最小时间间隔：	再次修改口令之间的最小天数
警告时间：从系统开始警告到口令正式失效的天数
不活动时间：	口令过期少天后，该账号被禁用
失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算)
标志：未使用

【组文件】
root:x:0:
组名：用户所属组
组口令：一般不用
GID：组ID
用户列表：属于该组的所有用户
Linux的权限命令
文件权限

属主（user）	属组（group）	其他用户
r	w	x	r	w	x	r	w	x
4	2	1	4	2	1	4	2	1

Linux三种文件类型：
普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 

目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。  

设备文件： Linux系统把每一个设备都看成是一个文件
文件类型标识
普通文件（-）
目录（d）
符号链接（l）
* 进入etc可以查看，相当于快捷方式
字符设备文件（c）
块设备文件（s）
套接字（s）
命名管道（p）
文件权限管理：
chmod 变更文件或目录的权限。
chmod 755 a.txt 
chmod u=rwx,g=rx,o=rx a.txt
chmod 000 a.txt  / chmod 777 a.txt
chown 变更文件或目录改文件所属用户和组
chown u1:public a.txt	：变更当前的目录或文件的所属用户和组
chown -R u1:public dir	：变更目录中的所有的子目录及文件的所属用户和组
vi使用方法详细介绍


vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 

1、vi的基本概念 
　　基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下： 
    1) 命令行模式command mode） 
　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 
    2) 插入模式（Insert mode） 
　　只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 
    3) 底行模式（last line mode） 
　　将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 

    不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 
2、vi的基本操作 
a) 进入vi 
   　在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：
　　　$ vi myfile 
　　不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ 

b) 切换至插入模式（Insert mode）编辑文件 
　　在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 

c) Insert 的切换 
　　您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 

d) 退出vi及保存文件 
　　在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： 
: w filename （输入 「w filename」将文章以指定的文件名filename保存） 
: wq (输入「wq」，存盘并退出vi) 
: q! (输入q!， 不存盘强制退出vi) 

3、命令行模式（command mode）功能键 
1）. 插入模式 
       按「i」切换进入插入模式「insert mode」，按"i"进入插入模式后是从光标当前位置开始输入文件； 
　　按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 
　　按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 

2）. 从插入模式切换为命令行模式 
      按「ESC」键。 

3）. 移动光标 
　　vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 
　　按「ctrl」+「b」：屏幕往"后"移动一页。 
　　按「ctrl」+「f」：屏幕往"前"移动一页。 
　　按「ctrl」+「u」：屏幕往"后"移动半页。 
　　按「ctrl」+「d」：屏幕往"前"移动半页。 
　　按数字「0」：移到文章的开头。 
　　按「G」：移动到文章的最后。 
　　按「$」：移动到光标所在行的"行尾"。 
　　按「^」：移动到光标所在行的"行首" 
　　按「w」：光标跳到下个字的开头 
　　按「e」：光标跳到下个字的字尾 
　　按「b」：光标回到上个字的开头 
　　按「#l」：光标移到该行的第#个位置，如：5l,56l。 

4）. 删除文字 
　　「x」：每按一次，删除光标所在位置的"后面"一个字符。 
　　「#x」：例如，「6x」表示删除光标所在位置的"后面"6个字符。 
　　「X」：大写的X，每按一次，删除光标所在位置的"前面"一个字符。 
　　「#X」：例如，「20X」表示删除光标所在位置的"前面"20个字符。 
　　「dd」：删除光标所在行。 
　　「#dd」：从光标所在行开始删除#行 

5）. 复制 
　　「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 
　　「#yw」：复制#个字到缓冲区 
　　「yy」：复制光标所在行到缓冲区。 
　　「#yy」：例如，「6yy」表示拷贝从光标所在的该行"往下数"6行文字。 
　　「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与"y"有关的复制命令都必须与"p"配合才能完成复制与粘贴功能。 

6）. 替换 
　　「r」：替换光标所在处的字符。 
　　「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 

7）. 回复上一次操作 
　　「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次"u"可以执行多次回复。 

8）. 更改 
　　「cw」：更改光标所在处的字到字尾处 
　　「c#w」：例如，「c3w」表示更改3个字 

9）. 跳至指定的行 
　　「ctrl」+「g」列出光标所在行的行号。 
　　「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 
4、Last line mode下命令简介 
　　在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 

A) 列出行号 

　「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 

B) 跳到文件中的某一行 

　「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 

C) 查找字符 

　「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 

　「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 

D) 保存文件 

　「w」：在冒号输入字母「w」就可以将文件保存起来。 

E) 离开vi 

　「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 

　「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 

5、vi命令列表 
1、下表列出命令模式下的一些键的功能： 

h 
左移光标一个字符 

l 
右移光标一个字符 

k 
光标上移一行 

j 
光标下移一行 

^ 
光标移动至行首 

0 
数字"0"，光标移至文章的开头 

G 
光标移至文章的最后 

$ 
光标移动至行尾 

Ctrl+f 
向前翻屏 

Ctrl+b 
向后翻屏 

Ctrl+d 
向前翻半屏 

Ctrl+u 
向后翻半屏 

i 
在光标位置前插入字符 

a 
在光标所在位置的后一个字符开始增加 

o 
插入新的一行，从行首开始输入 

ESC 
从输入状态退至命令状态 

x 
删除光标后面的字符 

#x 
删除光标后的＃个字符 

X 
(大写X)，删除光标前面的字符 

#X 
删除光标前面的#个字符 

dd 
删除光标所在的行 

#dd 
删除从光标所在行数的#行 

yw 
复制光标所在位置的一个字 

#yw 
复制光标所在位置的#个字 

yy 
复制光标所在位置的一行 

#yy 
复制从光标所在行数的#行 

p 
粘贴 

u 
取消操作 

cw 
更改光标所在位置的一个字 

#cw 
更改光标所在位置的#个字 


2、下表列出行命令模式下的一些指令 
w filename 
储存正在编辑的文件为filename 

wq filename 
储存正在编辑的文件为filename，并退出vi 

q! 
放弃所有修改，退出vi 

set nu 
显示行号 

/或? 
查找，在/后输入要查找的内容 

n 
与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。 


对于第一次用vi，有几点注意要提醒一下： 
1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。切换方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 
2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键。 
3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的）
 
vi使用手册
VI是unix上最常用的文本编辑工具，作为unix软件测试人员，有必要熟练掌握它。

进入vi的命令
vi filename :打开或新建文件，并将光标置于第一行首
vi +n filename ：打开文件，并将光标置于第n行首
vi + filename ：打开文件，并将光标置于最后一行首
vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处
vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename
vi filename....filename ：打开多个文件，依次编辑

移动光标类命令
h ：光标左移一个字符
l ：光标右移一个字符
space：光标右移一个字符
Backspace：光标左移一个字符
k或Ctrl+p：光标上移一行
j或Ctrl+n ：光标下移一行
Enter ：光标下移一行
w或W ：光标右移一个字至字首
b或B ：光标左移一个字至字首
e或E ：光标右移一个字j至字尾
) ：光标移至句尾
( ：光标移至句首
}：光标移至段落开头
{：光标移至段落结尾
nG：光标移至第n行首
n+：光标下移n行
n-：光标上移n行
n$：光标移至第n行尾
H ：光标移至屏幕顶行
M ：光标移至屏幕中间行
L ：光标移至屏幕最后行
0：（注意是数字零）光标移至当前行首
$：光标移至当前行尾

屏幕翻滚类命令
Ctrl+u：向文件首翻半屏
Ctrl+d：向文件尾翻半屏
Ctrl+f：向文件尾翻一屏
Ctrl＋b；向文件首翻一屏
nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。

插入文本类命令
i ：在光标前
I ：在当前行首
a：光标后
A：在当前行尾
o：在当前行之下新开一行
O：在当前行之上新开一行
r：替换当前字符
R：替换当前字符及其后的字符，直至按ESC键
s：从当前光标位置处开始，以输入的文本替代指定数目的字符
S：删除指定数目的行，并以所输入文本代替之
ncw或nCW：修改指定数目的字
nCC：修改指定数目的行

删除命令
ndw或ndW：删除光标处开始及其后的n-1个字
do：删至行首
d$：删至行尾
ndd：删除当前行及其后n-1行
x或X：删除一个字符，x删除光标后的，而X删除光标前的
Ctrl+u：删除输入方式下所输入的文本

搜索及替换命令 :
/pattern：从光标开始处向文件尾搜索pattern
?pattern：从光标开始处向文件首搜索pattern
n：在同一方向重复上一次搜索命令
N：在反方向上重复上一次搜索命令
：s/p1/p2/g：将当前行中所有p1均用p2替代
：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代
：g/p1/s//p2/g：将文件中所有p1均用p2替换

选项设置
all：列出所有选项设置情况
term：设置终端类型
ignorance：在搜索中忽略大小写
list：显示制表位(Ctrl+I)和行尾标志（$)
number：显示行号
report：显示由面向行的命令修改过的数目
terse：显示简短的警告信息
warn：在转到别的文件时若没保存当前文件则显示NO write信息
nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符
nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始
mesg：允许vi显示其他用户用write写到自己终端上的信息

最后行方式命令
：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下
：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下
：n1,n2 d ：将n1行到n2行之间的内容删除
：w ：保存当前文件
：e filename：打开文件filename进行编辑
：x：保存当前文件并退出
：q：退出vi
：q!：不保存文件并退出vi
：!command：执行shell命令command
：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指
定n1，n2，则表示将整个文件内容作为command的输入
：r!command：将命令command的输出结果放到当前行 。




Vim命令合集
命令历史
以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。
启动vim
在命令行窗口中输入以下命令即可
vim 直接启动vim
vim filename 打开vim并创建名为filename的文件
文件命令
打开单个文件
vim file
同时打开多个文件
vim file1 file2 file3 ...
在vim窗口中打开一个新文件
:open file
在新窗口中打开文件
:split file
切换到下一个文件
:bn
切换到上一个文件
:bp
查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。
:args
打开远程文件，比如ftp或者share folder
:e ftp://192.168.10.76/abc.txt
:e \\qadrive\test\1.txt
vim的模式
正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空
插入模式（按i键进入） 左下角显示--INSERT--
可视模式（不知道如何进入） 左下角显示--VISUAL--
导航命令
% 括号匹配
插入命令
i 在当前位置生前插入
I 在当前行首插入
a 在当前位置后插入
A 在当前行尾插入
o 在当前行之后插入一行
O 在当前行之前插入一行
查找命令
/text　　查找text，按n健查找下一个，按N健查找前一个。
?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。
vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$
:set ignorecase　　忽略大小写的查找
:set noignorecase　　不忽略大小写的查找
查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。
:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。
:set nohlsearch　　关闭高亮搜索显示
:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。
:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。
:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。
替换命令
ra 将当前字符替换为a，当期字符即光标所在字符。
s/old/new/ 用old替换new，替换当前行的第一个匹配
s/old/new/g 用old替换new，替换当前行的所有匹配
%s/old/new/ 用old替换new，替换所有行的第一个匹配
%s/old/new/g 用old替换new，替换整个文件的所有匹配
:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。
ddp 交换光标所在行和其下紧邻的一行。
移动命令
h 左移一个字符
l 右移一个字符，这个命令很少用，一般用w代替。
k 上移一个字符
j 下移一个字符
以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。
w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。
b 向后移动一个单词 2b 向后移动2个单词
e，同w，只不过是光标停在单词尾部
ge，同b，光标停在单词尾部。
^ 移动到本行第一个非空白字符上。
0（数字0）移动到本行第一个字符上，
<HOME> 移动到本行第一个字符。同0健。
$ 移动到行尾 3$ 移动到下面3行的行尾
gg 移动到文件头。 = [[
G（shift + g） 移动到文件尾。 = ]]
f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。
F 同f，反向查找。
跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。
Ctrl + e 向下滚动一行
Ctrl + y 向上滚动一行
Ctrl + d 向下滚动半屏
Ctrl + u 向上滚动半屏
Ctrl + f 向下滚动一屏
Ctrl + b 向上滚动一屏
撤销和重做
u 撤销（Undo）
U 撤销对整行的操作
Ctrl + r 重做（Redo），即撤销的撤销。
删除命令
x 删除当前字符
3x 删除当前光标开始向后三个字符
X 删除当前字符的前一个字符。X=dh
dl 删除当前字符， dl=x
dh 删除前一个字符
dd 删除当前行
dj 删除上一行
dk 删除下一行
10d 删除当前行开始的10行。
D 删除当前字符至行尾。D=d$
d$ 删除当前字符之后的所有字符（本行）
kdgg 删除当前行之前所有行（不包括当前行）
jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）
:1,10d 删除1-10行
:11,$d 删除11行及以后所有的行
:1,$d 删除所有行
J(shift + j)　　删除两行之间的空行，实际上是合并两行。
拷贝和粘贴
yy 拷贝当前行
nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。
p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。
shift+p 在当前行前粘贴
:1,10 co 20 将1-10行插入到第20行之后。
:1,$ co $ 将整个文件复制一份并添加到文件尾部。
正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制
ddp交换当前行和其下一行
xp交换当前字符和其后一个字符
剪切命令
正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切
ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴
:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。
:1, 10 m 20 将第1-10行移动到第20行之后。
退出命令
:wq 保存并退出
ZZ 保存并退出
:q! 强制退出并忽略所有更改
:e! 放弃所有修改，并打开原来文件。
窗口命令
:split或new 打开一个新窗口，光标停在顶层的窗口上
:split file或:new file 用新窗口打开文件
split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。
Ctrl+ww 移动到下一个窗口
Ctrl+wj 移动到下方的窗口
Ctrl+wk 移动到上方的窗口
关闭窗口
:close 最后一个窗口不能使用此命令，可以防止意外退出vim。
:q 如果是最后一个被关闭的窗口，那么将退出vim。
ZZ 保存并退出。
关闭所有窗口，只保留当前窗口
:only
录制宏
按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。
执行shell命令
:!command
:!ls 列出当前目录下文件
:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。
:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。
:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。
注释命令
perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#
3,5 s/^/#/g 注释第3-5行
3,5 s/^#//g 解除3-5行的注释
1,$ s/^/#/g 注释整个文档。
:%s/^/#/g 注释整个文档，此法更快。
帮助命令
:help or F1 显示整个帮助
:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。
:help 'number' Vim选项的帮助用单引号括起
:help <Esc> 特殊键的帮助用<>扩起
:help -t Vim启动参数的帮助用-
：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式
帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回
其他非编辑命令
. 重复前一次命令
:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看
:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。
:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:>-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。
Vim教程
在Unix系统上
$ vimtutor
在Windows系统上
:help tutor

:syntax 列出已经定义的语法项
:syntax clear 清除已定义的语法规则
:syntax case match 大小写敏感，int和Int将视为不同的语法元素
:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案

Linux各目录及每个目录的详细介绍

【常见目录说明】
目录	
/bin	存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。
/etc	存放系统管理和配置文件
/home	存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示

/usr	用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。
/usr/x11r6 存放x window的目录
/usr/bin 众多的应用程序  
/usr/sbin 超级用户的一些管理程序  
/usr/doc linux文档  
/usr/include linux下开发和编译应用程序所需要的头文件  
/usr/lib 常用的动态链接库和软件包的配置文件  
/usr/man 帮助文档  
/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里  
/usr/local/bin 本地增加的命令  
/usr/local/lib 本地增加的库
/opt	额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。
/proc	虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
/root	超级用户（系统管理员）的主目录（特权阶级^o^）
/sbin	存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。
/dev	用于存放设备文件。
/mnt	系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。
/boot	存放用于系统引导时使用的各种文件
/lib	存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。
/tmp	用于存放各种临时文件，是公用的临时文件存储点。
/var	用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。
/lost+found	这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里




Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图：

/bin 二进制可执行命令
/dev 设备特殊文件
/etc 系统管理和配置文件
/etc/rc.d 启动的配置文件和脚本
/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件
/sbin 超级管理命令，这里存放的是系统管理员使用的管理程序
/tmp 公共的临时文件存储点
/root 系统管理员的主目录
/mnt 系统提供这个目录是让用户临时挂载其他的文件系统
/lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
/var 某些大文件的溢出区，比方说各种服务的日志文件
/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：
/usr/x11R6 存放x window的目录
/usr/bin 众多的应用程序
/usr/sbin 超级用户的一些管理程序
/usr/doc linux文档
/usr/include linux下开发和编译应用程序所需要的头文件
/usr/lib 常用的动态链接库和软件包的配置文件
/usr/man 帮助文档
/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里
/usr/local/bin 本地增加的命令
/usr/local/lib 本地增加的库根文件系统

通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的不经常改变的文件系统不容易损坏。
除了可能的一个叫/ vmlinuz标准的系统引导映像之外，根目录一般不含任何文件。所有其他文件在根文件系统的子目录中。
1. /bin目录
/ b i n目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命令都是二进制文件的可执行程序( b i n是b i n a r y - -二进制的简称)，多是系统中重要的系统文件。
2. /sbin目录
/ s b i n目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用。
3. /etc目录
/ e t c目录存放着各种系统配置文件，其中包括了用户信息文件/ e t c / p a s s w d，系统初始化文件/ e t c / r c等。l i n u x正是*这些文件才得以正常地运行。
4. /root目录
/root 目录是超级用户的目录。
5. /lib目录
/ l i b目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。
6. /lib/modules 目录
/lib/modules 目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引导系统所需的模块(例如网络和文件系统驱动)。
7. /dev目录
/ d e v目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可以通过访问/ d e v / m o u s e来访问鼠标的输入，就像访问其他文件一样。
8. /tmp目录
/tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/ v a r / t m p来代替/tmp ，因为前者可能拥有一个更大的磁盘空间。
9. /boot目录
/ b o o t目录存放引导加载器(bootstrap loader)使用的文件，如l i lo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在i d e硬盘的前1 0 2 4柱面内。
10. /mnt目录
/ m n t目录是系统管理员临时安装( m o u n t )文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用m s d o s文件系统的软驱，而/mnt/exta 可能是使用e x t 2文件系统的软驱，/mnt/cdrom 光驱等等。
11. /proc, /usr,/var,/home目录
其他文件系统的安装点。

下面详细介绍；
/etc文件系统
/etc 目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的m a n页。许多网络配置文件也在/etc 中。
1. /etc/rc或/etc/rc.d或/etc/rc?.d
启动、或改变运行级时运行的脚本或脚本的目录。
2. /etc/passwd
用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其
他信息。
3. /etc/fdprm
软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见s e t f d p r m
的帮助页。
4. /etc/fstab
指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的s w a p区的信息。
5. /etc/group
类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。
6. /etc/inittab
init 的配置文件。
7. /etc/issue
包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。
8. /etc/magic
“f i l e”的配置文件。包含不同文件格式的说明，“f i l e”基于它猜测文件类型。
9. /etc/motd
m o t d是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。
10. /etc/mtab
当前安装的文件系统列表。由脚本( s c r i t p )初始化，并由mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df 命令)。
11. /etc/shadow
在安装了影子( s h a d o w )口令软件的系统上的影子口令文件。影子口令文件将/ e t c / p a s s wd文件中的加密口令移动到/ e t c / s h a d o w中，而后者只对超级用户( r o o t)可读。这使破译口令更困难，以此增加系统的安全性。
12. /etc/login.defs
l o g i n命令的配置文件。
13. /etc/printcap
类似/etc/termcap ，但针对打印机。语法不同。
14. /etc/profile 、/ e t c / c s h . l o g i n、/etc/csh.cshrc
登录或启动时b o u r n e或c shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。
15. /etc/securetty
确认安全终端，即哪个终端允许超级用户( r o o t )登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器( m o d e m )或网络闯入系统并得到超级用户特权。
16. /etc/shells
列出可以使用的s h e l l。chsh 命令允许用户在本文件指定范围内改变登录的s h e l l。提供一台机器f t p服务的服务进程ftpd 检查用户s h e l l是否列在/etc/shells 文件中，如果不是，将不允许该用户登录。
17. /etc/termcap
终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。
这样，多数的程序可以在多数终端上运行。

/dev文件系统
/dev 目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。
设备文件在安装时由系统产生，以后可以用/dev/makedev 描述。/ d e v / m a k e d e v.local是
系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准
makedev 的一部分)。下面简要介绍/ d e v下一些常用文件。
1. /dev/console
系统控制台，也就是直接和系统连接的监视器。
2. /dev/hd
i d e硬盘驱动程序接口。如： / d e v / h d a指的是第一个硬盘， h a d 1则是指/ d e v / h da的第一个
分区。如系统中有其他的硬盘，则依次为/ d e v / h d b、/ d e v / h d c、. . . . ..；如有多个分区则依次为
h d a 1、h d a 2 . . . . . .
3. /dev/sd
s c s i磁盘驱动程序接口。如有系统有s c s i硬盘，就不会访问/ d e v / h a d，而会访问/ d e v / sd a。
4. /dev/fd
软驱设备驱动程序。如： / d e v / f d 0指系统的第一个软盘，也就是通常所说的a：盘，
/ d e v / f d 1指第二个软盘，. . . . . .而/ d e v / f d 1 h 1 4 40则表示访问驱动器1中的4 . 5高密盘。
5. /dev/st
s c s i磁带驱动器驱动程序。
6. /dev/tty
提供虚拟控制台支持。如： / d e v / t t y 1指的是系统的第一个虚拟控制台， / d e v / t t y2则是系统
的第二个虚拟控制台。
7. /dev/pty
提供远程登陆伪终端支持。在进行te l n e t登录时就要用到/ d e v / p t y设备。
8. /dev/ttys
计算机串行接口，对于d o s来说就是“ c o m 1”口。
9. /dev/cua
计算机串行接口，与调制解调器一起使用的设备。
10. /dev/null
“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输入到/ d e v / n u l l中即可。

/usr文件系统
/usr 是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的
所有文件一般来自l i n u x发行版( d i s t r i b u t i o n)；本地安装的程序和其他东西在/usr/local 下，因为这样可以在升级新版系统或新发行版时无须重新安装全部程序。/usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/ u s r可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。
1. /usr/x11r6
包含x wi n d o w系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x wi n d o w系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft wi n d o w s或m a c h i n t o s h比较熟悉的话，就不会对x win d o w系统感到束手无策了。
2. /usr/x386
类似/ u s r / x 11r6 ，但是是专门给x 11 release 5的。
3. /usr/bin
集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin 或/usr/local/bin 中。
4. /usr/sbin
包括了根文件系统不必要的系统管理命令，例如多数服务程序。
5. /usr/man、/ u s r / i n f o、/ u s r / d o c
这些目录包含所有手册页、g n u信息文档和各种其他文档文件。每个联机手册的“节”都有两个子目录。例如： / u s r / m a n / m a n 1中包含联机手册第一节的源码(没有格式化的原始文件)，/ u s r / m a n / c a t 1包含第一节已格式化的内容。l联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、系统管理和核心程序。
6. /usr/include
包含了c语言的头文件，这些文件多以. h结尾，用来描述c语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib 下，但习惯上一直沿用了这个名字。
7. /usr/lib
包含了程序或子系统的不变的数据文件，包括一些s i t e - w i d e配置文件。名字l i b来源于库(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。
8. /usr/local
本地安装的软件和其他文件放在这里。这与/ u s r很相似。用户可能会在这发现一些比较大的软件包，如t e x、e m a c s等。

/var文件系统
/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来/ v a r目录中有些内容是在/ u s r中的，但为了保持/ u s r目录的相对稳定，就把那些需要经常改变的目录放到/ v a r中了。每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。
1. /var/catman
包括了格式化过的帮助( m a n )页。帮助页的源文件一般存在/ u s r / m a n / m a n中；有些m an页可能有预格式化的版本，存在/ u s r / m a n / c a t中。而其他的m a n页在第一次看时都需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman 经常被清除，就像清除临时目录一样。)
2. /var/lib
存放系统正常运行时要改变的文件。
3. /var/local
存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。
4. /var/lock
锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件。
5. /var/log
各种程序的日志( l o g )文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log里的文件经常不确定地增长，应该定期清除。
6. /var/run
保存在下一次系统引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。
7. /var/spool
放置“假脱机( s p o o l )”程序的目录，如m a i l、n e w s、打印队列和其他队列工作的目录。每个不同的s p o o l在/var/spool 下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail中。
8. /var/tmp
比/tmp 允许更大的或需要存在较长时间的临时文件。注意系统管理员可能不允许/var/tmp 有很旧的文件。

/proc文件系统
/proc 文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一
个非常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提
供关于系统的信息。下面说明一些最重要的文件和目录(/proc 文件系统在proc man页中有更详
细的说明)。
1. /proc/x
关于进程x的信息目录，这一x是这一进程的标识号。每个进程在/proc 下有一个名为自
己进程号的目录。
2. /proc/cpuinfo
存放处理器( c p u )的信息，如c p u的类型、制造商、型号和性能等。
3. /proc/devices
当前运行的核心配置的设备驱动的列表。
4. /proc/dma
显示当前使用的d m a通道。
5. /proc/filesystems
核心配置的文件系统信息。
6. /proc/interrupts
显示被占用的中断信息和占用者的信息，以及被占用的数量。
7. /proc/ioports
当前使用的i / o端口。
8. /proc/kcore
系统物理内存映像。与物理内存大小完全一样，然而实际上没有占用这么多内存；它仅仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc 下没有任何东西占用任何磁盘空间。)
9. /proc/kmsg
核心输出的消息。也会被送到s y s l o g。
10. /proc/ksyms
核心符号表。
11. /proc/loadavg
系统“平均负载”； 3个没有意义的指示器指出系统当前的工作量。
12. /proc/meminfo
各种存储器使用信息，包括物理内存和交换分区( s w a p )。
13. /proc/modules
存放当前加载了哪些核心模块信息。
14. /proc/net
网络协议状态信息。
15. /proc/self
存放到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，这将会是不同的连接。这主要便于程序得到它自己的进程目录。
16. /proc/stat
系统的不同状态，例如，系统启动后页面发生错误的次数。
17. /proc/uptime
系统启动的时间长度。
18. /proc/version
核心版本












什么是虚拟软件：
虚拟原件是一个可以使你在一台机器上同时运行二个或更多Windows、LINUX等系统。它可以模拟一个标准PC环境。这个环境和真实的计算机一样，都有芯片组、CPU、内存、显卡、声卡、网卡、软驱、硬盘、光驱、串口、并口、USB控制器等


常用的虚拟原件：
1.VMware workstation
2.VirtualBox


VMware workstation安装：

1双击VMware-workstation-full-9.0.0-812388.exe

2点击next进行安装









3.选择安装方式

Typical：典型安装
Custom：自定义安装

4.选择程序安装位置

点击change选择程序安装位置，然后点击next
5.选择是否自动检测更新

如勾选，有新版时会提示你跟新版本，点next进行下一步

6.创建快捷方式

选择后点击next

7.配置完成，开始安装程序

点击continue

8.开始安装虚拟原件



8.完成

点击finish完成安装

注意：

虚拟软件安装完成后会在 \控制面板\网络和Internet\网络连接 下多出来两个虚拟网卡VMware Network Adapter VMnet1和VMware Network Adapter VMnet8
需要将这两个网卡禁用，不然就无法收到视频了

选中VMnet1或VMnet8，右键，选中禁用

rpm 执行安装包
二进制包（Binary）以及源代码包（Source）两种。二进制包可以直接安装在计算机中，而源代码包将会由 RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。
常用命令组合：
－ivh：安装显示安装进度--install--verbose--hash
－Uvh：升级软件包--Update；
－qpl： 列出RPM软件包内的文件信息[Query Package list]；
－qpi：列出RPM软件包的描述信息[Query Package install package(s)]；
－qf：查找指定文件属于哪个RPM软件包[Query File]；
－Va：校验所有的 RPM软件包，查找丢失的文件[View Lost]；
－e：删除包
rpm -q samba //查询程序是否安装
rpm -ivh /media/cdrom/RedHat/RPMS/samba-3.0.10-1.4E.i386.rpm //按路径安装并显示进度
rpm -ivh --relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm    //指定安装目录
rpm -ivh --test gaim-1.3.0-1.fc4.i386.rpm　　　 //用来检查依赖关系；并不是真正的安装；
rpm -Uvh --oldpackage gaim-1.3.0-1.fc4.i386.rpm //新版本降级为旧版本
rpm -qa | grep httpd　　　　　 ＃[搜索指定rpm包是否安装]--all搜索*httpd*
rpm -ql httpd　　　　　　　　　＃[搜索rpm包]--list所有文件安装目录
rpm -qpi Linux-1.4-6.i368.rpm　＃[查看rpm包]--query--package--install package信息
rpm -qpf Linux-1.4-6.i368.rpm　＃[查看rpm包]--file
rpm -qpR file.rpm　　　　　　　＃[查看包]依赖关系
rpm2cpio file.rpm |cpio -div    ＃[抽出文件]
rpm -ivh file.rpm 　＃[安装新的rpm]--install--verbose--hash
rpm -ivh [url]http://mirrors.kernel.org/fedora/core/4/i386/os/Fedora/RPMS/gaim-1.3.0-1.fc4.i386.rpm[/url] 
rpm -Uvh file.rpm    ＃[升级一个rpm]--upgrade
rpm -e file.rpm      ＃[删除一个rpm包]--erase
常用参数：
Install/Upgrade/Erase options:
-i, --install                     install package(s)
-v, --verbose                     provide more detailed output
-h, --hash                        print hash marks as package installs (good with -v)
-e, --erase                       erase (uninstall) package
-U, --upgrade=<packagefile>+      upgrade package(s)
－-replacepkge                    无论软件包是否已被安装，都强行安装软件包
--test                            安装测试，并不实际安装
--nodeps                          忽略软件包的依赖关系强行安装
--force                           忽略软件包及文件的冲突
Query options (with -q or --query):
-a, --all                         query/verify all packages
-p, --package                     query/verify a package file
-l, --list                        list files in package
-d, --docfiles                    list all documentation files
-f, --file                        query/verify package(s) owning file
RPM源代码包装安装
.src.rpm结尾的文件，这些文件是由软件的源代码包装而成的，用户要安装这类RPM软件包，必须使用命令：
rpm　--recompile　vim-4.6-4.src.rpm   ＃这个命令会把源代码解包并编译、安装它，如果用户使用命令：
rpm　--rebuild　vim-4.6-4.src.rpm　　＃在安装完成后，还会把编译生成的可执行文件重新包装成i386.rpm 的RPM软件包。

[root@localhost src]# rpm -ivh awstats-6.8-1.noarch.rpm
error: Failed dependencies:
perl(LWP::UserAgent) is needed by awstats-6.8-1.noarch
[root@localhost src]#

使用rpm 属性相依套件的档案

[root@localhost src]# rpm -qpR awstats-6.8-1.noarch.rpm
/bin/sh
/usr/bin/perl
config(awstats) = 6.8-1
perl >= 0:5.005
perl(LWP::UserAgent)
perl(POSIX)
perl(Socket)
perl(Time::Local)
perl(strict)
perl(vars)
rpmlib(CompressedFileNames) <= 3.0.4-1
rpmlib(PayloadFilesHavePrefix) <= 4.0-1





另外：# rpm -ivh --aid samba*.rpm (一定要安装rpmdb后才可以用这种方式安装排除依赖关系)

Linux的Top命令解析
整理：张波


Top命令是什么
TOP命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。
TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.



一. 统计信息区 
统计信息区前五行是系统整体的统计信息。

1. 第一行是任务队列信息
同 uptime  命令的执行结果:
[root@localhost ~]# uptime
 13:22:30 up 8 min,  4 users,  load average: 0.14, 0.38, 0.25
其内容如下：
12:38:33	当前时间
up 50days	系统运行时间，格式为时:分
1 user	当前登录用户数
load average: 0.06, 0.60, 0.48	系统负载，即任务队列的平均长度。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。
2. 第二、三行为进程和CPU的信息
当有多个CPU时，这些内容可能会超过两行。内容如下：
Tasks: 29 total	进程总数
1 running	正在运行的进程数
28 sleeping	睡眠的进程数
0 stopped	停止的进程数
0 zombie	僵尸进程数
Cpu(s): 0.3% us	用户空间占用CPU百分比
1.0% sy	内核空间占用CPU百分比
0.0% ni	用户进程空间内改变过优先级的进程占用CPU百分比
98.7% id	空闲CPU百分比
0.0% wa	等待输入输出的CPU时间百分比
0.0% hi	
0.0% si	
3. 第四五行为内存信息。
内容如下：
Mem: 191272k total	物理内存总量
173656k used	使用的物理内存总量
17616k free	空闲内存总量
22052k buffers	用作内核缓存的内存量
Swap: 192772k total	交换区总量
0k used	使用的交换区总量
192772k free	空闲交换区总量
123988k cached	缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。
二.  进程信息区
统计信息区域的下方显示了各个进程的详细信息。我们来认识一下各列的含义：

1.列信息
列名	含义
PID	进程id
PPID	父进程id
RUSER	Real user name
UID	进程所有者的用户id
USER	进程所有者的用户名
GROUP	进程所有者的组名
TTY	启动进程的终端名。不是从终端启动的进程则显示为 ?
PR	优先级
NI	nice值。负值表示高优先级，正值表示低优先级
P	最后使用的CPU，仅在多CPU环境下有意义
%CPU	上次更新到现在的CPU时间占用百分比
TIME	进程使用的CPU时间总计，单位秒
TIME+	进程使用的CPU时间总计，单位1/100秒
%MEM	进程使用的物理内存百分比
VIRT	进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
SWAP	进程使用的虚拟内存中，被换出的大小，单位kb。
RES	进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
CODE	可执行代码占用的物理内存大小，单位kb
DATA	可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
SHR	共享内存大小，单位kb
nFLT	页面错误次数
nDRT	最后一次写入到现在，被修改过的页面数。
S	进程状态。
            D=不可中断的睡眠状态
            R=运行
            S=睡眠
            T=跟踪/停止
            Z=僵尸进程
COMMAND	命令名/命令行
WCHAN	若该进程在睡眠，则显示睡眠中的系统函数名
Flags	任务标志，参考 sched.h


2.用快捷键更改显示内容
h或者?  : 显示帮助画面，给出一些简短的命令总结说明。
k  ：终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。
i：忽略闲置和僵死进程。这是一个开关式命令。
q：  退出程序。
r：  重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。
S：切换到累计模式。
s :  改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。
f或者F :从当前显示中添加或者删除项目。
o或者O  :改变显示项目的顺序。
l: 切换显示平均负载和启动时间信息。即显示影藏第一行
m： 切换显示内存信息。即显示影藏内存行
t ： 切换显示进程和CPU状态信息。即显示影藏CPU行
c：  切换显示命令名称和完整命令行。 显示完整的命令。 这个功能很有用。
M ： 根据驻留内存大小进行排序。
P：根据CPU使用百分比大小进行排序。
T： 根据时间/累计时间进行排序。
W：  将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。
z：改变显示的颜色







先卸载open-jdk

java –version
rpm -qa | grep java

rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64
rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64

开始安装：
mkdir /usr/local/src/java
rz 上传jdk tar包
tar -xvf jdk-7u71-linux-i586.tar.gz

yum install glibc.i686

配置环境变量：
① vi /etc/profile

② 在末尾行添加
	#set java environment
	JAVA_HOME=/usr/local/src/java/jdk1.7.0_71
	CLASSPATH=.:$JAVA_HOME/lib.tools.jar
	PATH=$JAVA_HOME/bin:$PATH
	export JAVA_HOME CLASSPATH PATH
保存退出
③source /etc/profile  使更改的配置立即生效
④java -version  查看JDK版本信息，如果显示出1.7.0证明成功

Nginx


1什么是Nginx
Nginx ("engine x") 是一个高性能的 HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。

正向代理：













反向代理：



















很多大网站都是使用nginx做反向代理，应用非常广泛。
Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。

2应用场景
1、http服务器，可以做静态网页的http服务器。
2、配置虚拟机。
一个域名可以被多个ip绑定。可以根据域名的不同吧请求转发给运行在不同端口的服务器。
3、反向代理，负载均衡。把请求转发给不同的服务器。

3安装及配置
3.1下载
官方网站：http://nginx.org/
最后的一个稳定版本：1.8.0版本。有两个版本windows版本和linux版本。生产环境都是使用linux版本。

3.2安装
3.2.1环境要求
nginx是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。
gcc
	安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ 
PCRE
	PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。
yum install -y pcre pcre-devel
注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。
zlib
	zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。
yum install -y zlib zlib-devel

openssl
	OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。
	nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。
yum install -y openssl openssl-devel

3.2.2编译及安装
第一步：把nginx的源码包上传至linux服务器
第二步：解压源码包。 tar -zxf nginx-1.8.0.tar.gz 
第三步：进入nginx-1.8.0文件夹。使用configure命令创建makefile。
第四步：参数设置如下：
./configure \
--prefix=/usr/local/nginx \
--pid-path=/var/run/nginx/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi

注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录
第五步：make
第六步 make install


3.3Nginx的启动及关闭
3.3.1启动
在nginx目录下有一个sbin目录，sbin目录下有一个nginx可执行程序。
./nginx



3.3.2关闭nginx
关闭命令：相当于找到nginx进程kill。
./nginx -s stop

退出命令：
./nginx -s quit
等程序执行完毕后关闭，建议使用此命令。

3.3.3动态加载配置文件
./nginx -s reload
可以不关闭nginx的情况下更新配置文件。

创建ucenter用户
一般情况下，发布应用程序都不是使用root用户的，需要创建一个普通用户来发布程序；

创建ucenter用户：
useradd -d /ucenter ucenter

设置密码：
passwd ucenter （密码 ucenter）

切换用户：
su - ucenter

安装Tomcat
tomcat只要解压就可以使用。

1、创建web目录
mkdir /ucenter/web
2、上传apache-tomcat-7.0.57.tar.gz
3、解压：tar -xvf apache-tomcat-7.0.57.tar.gz
4、重命名：mv apache-tomcat-7.0.57 itcast-usermanage
5、启动tomcat：
cd itcast-usermanage/bin/
./startup.sh 或者 sh startup.sh
6、查看日志：
tail -f ../logs/catalina.out
7、查看效果 http://192.168.0.160:8080/
发现无法访问：

8、防火墙打开 8080 端口
/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT
/etc/rc.d/init.d/iptables save
9、安装成功

部署用户管理项目
上传usermanage.sql和ROOT.war到/ucenter/web
执行数据库脚本
cat usermanage.sql | mysql -uroot -p123456
部署web程序
删除webapps下的所有文件
cd /ucenter/web/itcast-usermanage/webapps
rm -rf *
拷贝ROOT.war到webapps
cp /ucenter/web/ROOT.war .
重新启动tomcat
cd ../bin/
sh startup.sh && tail -f ../logs/catalina.out
启动浏览器测试
http://192.168.0.160:8080/user/page/query


手动编译安装
1、下载安装包，wget https://ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz  或者是  上传已经下载好的安装包
2、cd /usr/local/src/
3、mkdir lrzsz
4、cd lrzsz/
5、解压：tar -xvf lrzsz-0.12.20.tar.gz
6、cd lrzsz-0.12.20
7、执行配置：./configure 
a)会提示 configure: error: no acceptable cc found in $PATH，意思是缺少gcc命令，需要安装gcc
b)手动安装gcc比较麻烦，所有选择使用yum安装
c)yum install gcc
8、编译：make
9、安装：make install
10、cd /usr/bin
11、ln -s /usr/local/bin/lrz rz
12、ln -s /usr/local/bin/lsz sz
13、输入命令：rz
a)
b)安装成功！

使用yum安装
yum -y install lrzsz

下载
http://dev.mysql.com/downloads/mysql/





或者使用wget下载：

wget http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar

安装
检测是否已经安装了mysql
rpm -qa | grep mysql   

如果已经安装了，将其卸载，如：

rpm -e --nodeps  mysql-libs-5.1.71-1.el6.x86_64
安装mysql
1、mkdir /usr/local/src/mysql
2、cd /usr/local/src/mysql
3、tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar

4、安装server
rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm
出错：

安装依赖：yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 



需要升级libstdc++-4.4.7-4.el6.x86_64
yum  update libstdc++-4.4.7-4.el6.x86_64
5、安装中：

6、安装client

安装依赖：yum -y install libncurses.so.5 libtinfo.so.5
7、查询mysq服务运行状态

服务未启动。
8、启动mysql服务
service mysql start
9、使用root账号登录mysql
提示：


在安装mysql server时有句提示：

注意：这个密码是不安全的，所有需要修改初始密码。
10、使用密码登录mysql账号：mysql -uroot -p
11、修改root密码：SET PASSWORD = PASSWORD('123456');
系统启动时自动启动mysql服务
加入到系统服务：
chkconfig --add mysql
自动启动：
chkconfig mysql on
查询列表：
chkconfig

说明：都没关闭（off）时是没有自动启动。

开启远程访问
登录：
mysql -uroot –p123456

设置远程访问（使用root密码）：
grant all privileges on *.* to 'root' @'%' identified by '123456'; 
flush privileges;

防火墙打开3306端口
/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT
/etc/rc.d/init.d/iptables save
/etc/init.d/iptables status





使用VMware安装CentOS 6.4
环境：Windows7 , VMware Workstation10, CentOS6.4
为什么选择CentOS ?
1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS
2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本
3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！

安装步骤
第1步：首先安装VMware Workstation，只需点下一步即可，安装过程略
第2步：文件 → 新建虚拟机 或 直接点击 创建新的虚拟机 图标

第3步：选择 典型（推荐）→ 下一步 

第4步：稍后安装操作系统

第5步：选择操作系统和版本


第6步：输入虚拟机名称和安装路径


第7步：设置磁盘大小

第8步：自定义硬件

第9步：选择CentOS安装镜像文件

第10步：点击完成

第11步：启动虚拟机

第12步：选择第一项，安装全新操作系统或升级现有操作系统

第13步：Tab键进行选择，选择Skip，退出检测

第14步：点击Next




第15步：选择语言，这里选择的是中文简体

第16步：选择键盘样式

第17步：选择存储设备

如果以前安装过虚拟机，会出现这个警告，选择是，忽略所有数据

第18步：输入主机名

第19步：配置网络

第20步：设置时区，勾选使用UTC时间

第21步：输入根用户（root）的密码

如果密码过于简单会出现提示，点击无论如何都使用

第22步：根据此Linux具体功能，选择不同的方式

第23步：选择现在自定义，自定义安装需要的软件，如桌面配置

可以根据具体的情况来配置，如可安Eclipse

还可以安装Java平台、Perl支持等

选择语言支持

第24步：点击下一步，开始安装

第25步：安装完成后，点击重新导引

第26步：点击前进按钮

第27步：点击是，同意许可，再点击前进按钮





第28步：创建用户

第29步：设置日期和时间，如果可以上网，勾选在网上同步日期和时间

最后点击前进，完成安装！








Linux
教学导航
教学目标	了解Linux系统
安装Linux虚拟机
学习Linux的常用命令
多用户以及权限学习
Linux实战
教学方法	案例驱动法
Linux的概述：
什么是Linux：
学习Linux之前先了解Unix
Unix是一个强大的多用户、多任务操作系统。
于1969年在AT&T的贝尔实验室开发。
UNIX的商标权由国际开放标准组织（The Open Group）所拥有。
UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。
Linux的概述：
Linux是基于Unix的
Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机


诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成

             
Linux的历史：
Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统.
Linux系统的应用：
服务器系统
Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 
嵌入式系统
路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，
高性能运算、计算密集型应用
Linux有强大的运算能力。
桌面应用系统
移动手持系统
Linux的版本
Linux的版本分为两种：内核版本和发行版本；
内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；
发行版本是一些组织和公司根据自己发行版的不同而自定的 ；
Linux的主流版本

Linux的安装：
虚拟机安装：
什么是虚拟机
虚拟机：一台虚拟的电脑.
虚拟机软件:
* VmWare		:收费的.
* VirtualBox	:免费的.
安装VmWare
参考《虚拟软件vmware安装.doc》
CentOS的安装
参考《CentOS6详细安装文档.doc》
Linux的目录结构：


root管理员的home目录root
其他用户的home目录home目录中
Linux的常用命令

切换目录命令cd：
使用
cd app	切换到app目录
cd ..	切换到上一层目录
cd /		切换到系统根目录
cd ~		切换到用户主目录
cd -		切换到上一个所在目录
列出文件列表：ls ll dir(*****)
ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。
    格式：ls[参数] [路径或文件名]

常用：
在linux中以 . 开头的文件都是隐藏的文件

* ls
* ls -a  显示所有文件或目录（包含隐藏的文件）
* ls -l  缩写成ll
创建目录和移除目录：mkdir rmdir
mkdir(make directory)命令可用来创建子目录。
mkdir app    在当前目录下创建app目录
mkdir –p app2/test   级联创建aap2以及test目

rmdir(remove directory)命令可用来删除“空”的子目录：
rmdir app    删除app目录

浏览文件
【cat、more、less】
cat
用于显示文件的内容。
格式：cat[参数]<文件名>

    * cat yum.conf

more
一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。
回车显示下一行内容。
按 q 键退出查看。
* more yum.conf
   * 空格显示下一页数据  回车显示下一行的数据

less
用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。
    * less yum.conf
        * PgUp 和 PgDn 进行上下翻页.

【tail】
tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。
用法:
tail -10 /etc/passwd    查看后10行数据
tail -f catalina.log   动态查看日志(*****)


ctrl+c 结束查看
文件操作：
【rm】
rm  删除文件
用法：rm [选项]... 文件...
rm a.txt    删除a.txt文件
删除需要用户确认，y/n
rm 删除不询问
rm -f a.txt    不询问，直接删除
rm 删除目录
rm -r a    递归删除
不询问递归删除（慎用）
rm -rf  a    不询问递归删除
rm -rf *      删除所有文件
rm -rf /*      自杀
【cp、mv】
cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。
cp a.txt b.txt    将a.txt复制为b.txt文件
cp a.txt ../    将a.txt文件复制到上一层目录中


mv 移动或者重命名
mv a.txt ../    将a.txt文件移动到上一层目录中
mv a.txt b.txt    将a.txt文件重命名为b.txt

【tar】命令:(***** 打包或解压)
tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。

常用参数：
-c：创建一个新tar文件
-v：显示运行过程的信息
-f：指定文件名
-z：调用gzip压缩命令进行压缩
-t：查看压缩文件的内容
-x：解开tar文件



打包：
tar –cvf xxx.tar ./*
打包并且压缩：
tar –zcvf xxx.tar.gz ./* 

解压 
     tar –xvf xxx.tar
tar -xvf xxx.tar.gz -C /usr/aaa

【grep】命令
查找符合条件的字符串。
用法: grep [选项]... PATTERN [FILE]...
示例：
grep lang anaconda-ks.cfg  在文件中查找lang
grep lang anaconda-ks.cfg –color 高亮显示






其他常用命令
【pwd】
显示当前所在目录
【touch】
创建一个空文件
* touch a.txt
【ll -h】
友好显示文件大小
【wget】
下载资料
* wget http://nginx.org/download/nginx-1.9.12.tar.gz
Vi和Vim编辑器
Vim编辑器：
在Linux下一般使用vi编辑器来编辑文件。
vi既可以查看文件也可以编辑文件。
三种模式：命令行、插入、底行模式。
切换到命令行模式：按Esc键；
切换到插入模式：按 i 、o、a键；
    i 在当前位置生前插入
    I 在当前行首插入
    a 在当前位置后插入
    A 在当前行尾插入
    o 在当前行之后插入一行
    O 在当前行之前插入一行

切换到底行模式：按 :（冒号）；
更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》


打开文件：vim file
退出：esc  :q
修改文件：输入i进入插入模式
保存并退出：esc:wq

不保存退出：esc:q!

3中进入插入模式：
i:在当前的光标所在处插入
o:在当前光标所在的行的下一行插入
a:在光标所在的下一个字符插入

快捷键：
dd – 快速删除一行
R – 替换
重定向输出>和>>
> 重定向输出，覆盖原有内容；
>> 重定向输出，又追加功能；
示例：
cat /etc/passwd > a.txt  将输出定向到a.txt中
cat /etc/passwd >> a.txt  输出并且追加

ifconfig > ifconfig.txt
管道 |
管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。
示例
ls --help | more  分页查询帮助信息
ps –ef | grep java  查询名称中包含java的进程

ifconfig | more
cat index.html | more
ps –ef | grep aio
&&命令执行控制：
命令之间使用 && 连接，实现逻辑与的功能。 

只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行。 

只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。

mkdir test && cd test
网络通讯命令
ifconfig  显示或设置网络设备。
ifconfig  显示网络设备
ifconfig eth0 up 启用eth0网卡
ifconfig eth0 down  停用eth0网卡
ping   探测网络是否通畅。
ping 192.168.0.1
netstat 查看网络端口。
netstat -an | grep 3306 查询3306端口占用情况
系统管理命令
date 显示或设置系统时间
date  显示当前系统时间
date -s “2014-01-01 10:10:10“  设置系统时间
df 显示磁盘信息
df –h  友好显示大小
free 显示内存状态
free –m 以mb单位显示内存组昂头
top 显示，管理执行中的程序

clear 清屏幕

ps 正在运行的某个进程的状态
ps –ef  查看所有进程
ps –ef | grep ssh 查找某一进程
kill 杀掉某一进程
kill 2868  杀掉2868编号的进程
kill -9 2868  强制杀死进程

du 显示目录或文件的大小。
du –h 显示当前目录的大小

who 显示目前登入系统的用户信息。

hostname 查看当前主机名
修改：vi /etc/sysconfig/network

uname 显示系统信息。
uname -a 显示本机详细信息。
依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称
Linux的用户和组
用户的管理
useradd 添加一个用户
useradd test 添加test用户
useradd test -d /home/t1  指定用户home目录

passwd  设置、修改密码
passwd test  为test用户设置密码

切换登录：
ssh -l test -p 22 192.168.19.128

su – 用户名

userdel 删除一个用户
userdel test 删除test用户(不会删除home目录)
userdel –r test  删除用户以及home目录
组管理：
当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组

创建用户时也可以指定所在组

groupadd  创建组
groupadd public  创建一个名为public的组
useradd u1 –g public  创建用户指定组
groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。
groupdel public

id，su命令
【id命令】
功能：查看一个用户的UID和GID
用法：id [选项]... [用户名]


直接使用id
直接使用id 用户名
【su命令】
功能：切换用户。
用法：su [选项]... [-] [用户 [参数]... ]
示例：
su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用）

【账户文件】
/etc/passwd  用户文件
/etc/shadow  密码文件
/etc/group  组信息文件
【用户文件】
root:x:0:0:root:/root:/bin/bash
账号名称：		在系统中是唯一的
用户密码：		此字段存放加密口令
用户标识码(User ID)：  系统内部用它来标示用户
组标识码(Group ID)：   系统内部用它来标识用户属性
用户相关信息：		例如用户全名等
用户目录：		用户登录系统后所进入的目录
用户环境:		用户工作的环境
【密码文件】
shadow文件中每条记录用冒号间隔的9个字段组成.
用户名：用户登录到系统时使用的名字，而且是惟一的
口令：  存放加密的口令
最后一次修改时间:  标识从某一时刻起到用户最后一次修改时间
最大时间间隔:  口令保持有效的最大天数，即多少天后必须修改口令
最小时间间隔：	再次修改口令之间的最小天数
警告时间：从系统开始警告到口令正式失效的天数
不活动时间：	口令过期少天后，该账号被禁用
失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算)
标志：未使用

【组文件】
root:x:0:
组名：用户所属组
组口令：一般不用
GID：组ID
用户列表：属于该组的所有用户
Linux的权限命令
文件权限

属主（user）	属组（group）	其他用户
r	w	x	r	w	x	r	w	x
4	2	1	4	2	1	4	2	1

Linux三种文件类型：
普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 

目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。  

设备文件： Linux系统把每一个设备都看成是一个文件
文件类型标识
普通文件（-）
目录（d）
符号链接（l）
* 进入etc可以查看，相当于快捷方式
字符设备文件（c）
块设备文件（s）
套接字（s）
命名管道（p）
文件权限管理：
chmod 变更文件或目录的权限。
chmod 755 a.txt 
chmod u=rwx,g=rx,o=rx a.txt
chmod 000 a.txt  / chmod 777 a.txt
chown 变更文件或目录改文件所属用户和组
chown u1:public a.txt	：变更当前的目录或文件的所属用户和组
chown -R u1:public dir	：变更目录中的所有的子目录及文件的所属用户和组
Nginx
今日任务
在Linux系统上安装JDK.
在Linux系统上安装Tomcat.
在Linux系统上安装MySQL
教学导航
教学目标	了解Linux系统
安装Linux虚拟机
学习Linux的常用命令
多用户以及权限学习
Linux实战
教学方法	案例驱动法
Linux系统上安装JDK：
安装步骤：
卸载OpenJDK
执行命令查看:
rpm –qa | grep java   查看和java相关的包

卸载OPENJDK

创建JDK的安装路径：
在/usr/local/  创建文件夹java
mkdir java
上传安装文件到linux:

cd ~
ll

解压tar.gz
首先需要安装依赖：
yum install glibc.i686
tar –xvf xxx.tar.gz –C /usr/local/java
配置环境变量：
vim /etc/profile

	#set java environment
	JAVA_HOME=/usr/local/src/java/jdk1.7.0_71
	CLASSPATH=.:$JAVA_HOME/lib.tools.jar
	PATH=$JAVA_HOME/bin:$PATH
	export JAVA_HOME CLASSPATH PATH

重新加载配置文件：
source /etc/profile
Linux系统上安装MySQL:
安装MySQL:
上传mysql到Linux:

卸载自带mysql:

创建mysql的安装路径：
Mkdir mysql
解压mysql：
tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql
安装依赖：
yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6
yum  update libstdc++-4.4.7-4.el6.x86_64
安装mysql的服务端：
rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm
安装mysql的客户端：
rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm
启动mysql的服务：
service mysql status

service mysql start
登录mysql:

产生一个随机的密码存放在/root/.mysql_secret

查看密码进行登录:
msyql –u root -p

修改密码：
set password = password('123456');
设置开机自动启动mysql:
加入到系统服务：
chkconfig --add mysql
自动启动：
chkconfig mysql on
开启远程服务：
登录mysql授权可以远程访问:
grant all privileges on *.* to 'root' @'%' identified by '123456';
flush privileges;
设置Linux的防火墙:
3306端口放行 且将该设置添加到防火墙的规则中
/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT
/etc/rc.d/init.d/iptables save

Linux系统上安装tomcat：
安装tomcat:
上传tomcat的安装文件：

创建tomcat的安装路径：
在/usr/local 下mkdir tomcat
解压tomcat
tar –xvf xxx.tar.gz –C /usr/local/tomcat
设置防火墙：
/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT
/etc/rc.d/init.d/iptables save
启动tomcat：
进入到tomcat/bin
执行 ./startup.sh
关闭tomcat
执行 ./shutdown.sh
发布项目到Linux：
将数据库还原到Linux上：
备份Window上的数据库：
使用命令备份：
mysqldump –u root -p store_v2.0 > c:/store_v2.0.sql

使用可视化工具：
在Linux上还原数据库：

将程序的代码发布到Linux上：
将工程制作为war包：

将war包上传到linux服务器：

将war包copy到linux下的tomcat的webapps中：

修改配置文件就可以：

Nginx
Nginx的概述：

什么是代理和反向代理：

Nginx+Tomcat的集群配置:
在一台电脑上安装两个tomcat
需要在一台电脑模拟：在E盘解压两个tomcat,分别命名为tomcat1，tomcat2.
修改tomcat的配置文件，将端口进行修改:
修改tomcat2中的端口:



将项目分别发布到两个tomcat中：

安装Nginx：
解压
双击nginx.exe
启动完以后访问http://localhost


配置Nginx：
修改nginx/conf/nginx.conf文件：

Tomcat集群的session共享：
1.一种解决办法：一个用户进来以后只在tomcat1上进行操作，另一个用户进行只在tomcat2上进行操作.

2.session的共享
一种使用tomcat广播机制完成session的共享（不推荐的方式）
一种使用redis服务器的方式完成session的共享（推荐的方式）
使用tomcat的广播机制完成session的共享。
修改两个tomcat中的server.xml:


在项目中web.xml中添加一个配置:
<distributable/>
Linux上搭建Nginx+Tomcat集群：
在Linux上安装多个Tomcat:
解压tomcat
分别解压tomcat到/usr/local/tomcat1 和 tomcat2
修改tomcat2中server.xml:

***** 将修改后的端口添加到防火墙中.
Linux上安装Nginx:

一、正向代理(Forward Proxy)

一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下： 正 向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代 理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。如下图1.1
 
（图1.1）
从上面的概念中，我们看出，文中所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】
这就是正向代理的意义所在。而为什么要用代理服务器去代替访问方【用户A】去访问服务器B呢？这就要从代理服务器使用的意义说起。

使用正向代理服务器作用主要有以下几点：
1、访问本无法访问的服务器B，如下图1.2
（图1.2） 我们抛除复杂的网络路由情节来看图1.2，假设图中路由器从左到右命名为R1,R2假 设最初用户A要访问服务器B需要经过R1和R2路由器这样一个路由节点，如果路由器R1或者路由器R2发生故障，那么就无法访问服务器B了。但是如果用户 A让代理服务器Z去代替自己访问服务器B，由于代理服务器Z没有在路由器R1或R2节点中，而是通过其它的路由节点访问服务器B，那么用户A就可以得到服 务器B的数据了。现实中的例子就是“翻墙”。不过自从VPN技术被广泛应用外，“翻墙”不但使用了传统的正向代理技术，有的还使用了VPN技术。

2、加速访问服务器B

这种说法目前不像以前那么流行了，主要是带宽流量的飞速发展。早期的正向代理中，很多人使用正向代理就是提速。还是如图1.2 假设用户A到服务器B，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。而用户A到代理服务器Z，从代理服务器Z到服务器B都是高带宽链路。那么很显然就可以加速访问服务器B了。

3、Cache作用
Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术。还如上图所示，如果在用户A访问服务器B某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。这一技术在Cache中术语就叫Cache命中。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。
4、客户端访问授权
这方面的内容现今使用的还是比较多的，例如一些公司采用ISA SERVER做为正向代理服务器来授权用户是否有权限访问互联网，挼下图1.3 （图1.3）图 1.3防火墙作为网关，用来过滤外网对其的访问。假设用户A和用户B都设置了代理服务器，用户A允许访问互联网，而用户B不允许访问互联网（这个在代理服 务器Z上做限制）这样用户A因为授权，可以通过代理服务器访问到服务器B，而用户B因为没有被代理服务器Z授权，所以访问服务器B时，数据包会被直接丢 弃。

5、隐藏访问者的行踪

如下图1.4 我们可以看出服务器B并不知道访问自己的实际是用户A，因为代理服务器Z代替用户A去直接与服务器B进行交互。如果代理服务器Z被用户A完全控制（或不完全控制），会惯以“肉鸡”术语称呼。 
（图1.4） 我 们总结一下 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内 容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。

二、反向代理（reverse proxy）
反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 使用反向代理服务器的作用如下：
1、保护和隐藏原始资源服务器如下图2.1 

（图2.1）

用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。

2、负载均衡如下图2.2 

（图2.2）
当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。
当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。如下图2.3

（图2.3）
我们并不是讲解CDN，所以去掉了CDN最关键的核心技术智能DNS。只是展示CDN技术实际上利用的正是反向代理原理这块。

反向代理结论与正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。

基本上，网上做正反向代理的程序很多，能做正向代理的软件大部分也可以做反向代理。开源软件中最流行的就是squid，既可以做正向代理，也有很多人用来做反向代理的前端服务器。另外MS ISA也可以用来在WINDOWS平台下做正向代理。反向代理中最主要的实践就是WEB服务，近些年来最火的就是Nginx了。网上有人说NGINX不能做正向代理，其实是不对的。NGINX也可以做正向代理，不过用的人比较少了。

三、透明代理

   如果把正向代理、反向代理和透明代理按照人类血缘关系来划分的话。那么正向代理和透明代理是很明显堂亲关系，而正向代理和反向代理就是表亲关系了 。
   透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。 透明代理实践的例子就是时下很多公司使用的行为管理软件。如下图3.1
（图3.1）
用户A和用户B并不知道行为管理设备充当透明代理行为，当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。		

Nginx在Windows平台的配置
1.1Nginx在Windows平台的配置:
1.1.1课程目标:
课程目标:
能够使用Nginx搭建Tomcat集群,并完成负载均衡.
1.1.2Nginx的概述:
什么是Nginx:

为什么使用Nginx:
背景:
互联网飞速发展的今天,大用户量高并发已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢？这是一些中小网站急需解决的问题。用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的，为了解决这个问题引入了负载均衡方法。负载均衡就是一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。
负载均衡服务器分为两种一种是通过硬件实现的负载均衡服务器，简称硬负载例如：f5。另一种是通过软件来实现的负载均衡，简称软负载:例如apache和nginx。硬负载和软负载相比前者作用的网络层次比较多可以作用到socket接口的数据链路层对发出的请求进行分组转发但是价格成本比较贵，而软负载作用的层次在http协议层之上可以对http请求进行分组转发并且因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。
1.1.3使用Nginx完成负载均衡:
完成Nginx负载均衡,那么需要先来介绍Tomcat的安装和配置,我们首先要来配置Tomcat完成集群的配置.因为我们没有多台服务器运行Tomcat.那么我们可以模拟在一台服务器上运行多个Tomcat程序.
使用Tomcat配置Tomcat集群:
步骤一:下载Tomcat:
http://tomcat.apache.org/download-70.cgi

步骤二:安装和配置Tomcat:
直接将下载后的Tomcat解压在本地磁盘:解压两个分别命名为tomcat1和tomcat2.

分别完成如下配置:(需要将tomcat带有端口号的地方改成不同的端口即可.)分别打开两个tomcat的conf下的server.xml
tomcat1/conf/server.xml




tomcat2/conf/server.xml





1.1.4Nginx的安装和部署:
Nginx的安装:
将nginx-1.8.0.zip解压包某个盘符下运行:目录结构如下:

双击nginx.exe即可运行:打开浏览器http://localhost:80显示如下页面:

说明安装成功!!!
关闭nginx需要使用:
相当于找到nginx进程kill。
nginx -s stop
重新加载配置文件:
nginx -s reload
可以不关闭nginx的情况下更新配置文件.

Nginx的负载均衡的配置:
打开C:\nginx-1.8.0\conf\nginx.conf这个文件:


***** 通过以上的配置我们已经可以通过访问www.taoge.com访问到不同的tomcat来分担服务器端的压力.请求负载过程中会话信息不能丢失.那么需要在多个tomcat中session需要共享.
* 配置Tomcat的session共享可以有三种解决方案:
第一种是以负载均衡服务器本身提供的session共享策略，每种服务期的配置是不一样的并且nginx本身是没有的。

第二种是利用web容器本身的session共享策略来配置共享。针对于weblogic这种方式还是靠普的。但是针对于tomcat这种方式存在很大的缺陷，主要因为是依靠广播方式来实现的session复制，会浪费很多带宽导致整个网络反映缓慢。官网也建议这种方式最好不要超过4台tomcat,具体的内容可参考/webapps/docs/cluster-howto.html里面有详细的说明。下面是具体的配置过程
第三种是Tomcat集群+redis的Session共享配置方法.
在这里我们以第二种方式为例:
配置Tomcat中session的共享:
步骤一:修改server.xml文件，最简单的集群配置只需要将节点中注释掉的下面这句取消注释即可：
Xml代码：
    <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>  
使用这样方法配置的集群会将Session同步到所在网段上的所有配置了集群属性的实例上(此处讲所在网段可能不准确，是使用Membership 的address和port来区分的。tomcat集群的实例如果在Membership配置中有相同的address和port值的tomcat被分到同一个集群里边。他们的session是相互共享的，同一个session的集群被称为一个cluster。可以配置多个cluster，但是cluster和cluster之间的session是不共享的)。也就是说如果该广播地址下的所有Tomcat实例都会共享Session，那么假如有几个互不相关的集群，就可能造成Session复制浪费，所以为了避免浪费就需要对节点多做点设置了，如下：
Xml代码
    <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster">    
        <Channel className="org.apache.catalina.tribes.group.GroupChannel">    
            <Membership className="org.apache.catalina.tribes.membership.McastService"    
                address="228.0.0.4"    
                port="45564"    
                frequency="500"    
                dropTime="3000"/>    
        </Channel>    
    </Cluster>  
加了一个Channel，里面包了个Membership，咱们要关注的就是membership的port属性和address属性，不同的集群设置不同的port值或address值，从目前的使用来看，基本上是隔离开了。

步骤二:修改项目的web.xml文件：
web.xml文件的修改很简单：只需要在节点中添加这个节点<distributable/>就可以了。
OK，有了这二步就实现了Tomcat的集群和Session的共享了。





Nginx
今日任务
在Linux系统上安装JDK.
在Linux系统上安装Tomcat.
在Linux系统上安装MySQL
教学导航
教学目标	了解Linux系统
安装Linux虚拟机
学习Linux的常用命令
多用户以及权限学习
Linux实战
教学方法	案例驱动法
Linux系统上安装JDK：
安装步骤：
卸载OpenJDK
执行命令查看:
rpm –qa | grep java   查看和java相关的包

卸载OPENJDK

创建JDK的安装路径：
在/usr/local/  创建文件夹java
mkdir java
上传安装文件到linux:

cd ~
ll

解压tar.gz
首先需要安装依赖：
yum install glibc.i686
tar –xvf xxx.tar.gz –C /usr/local/java
配置环境变量：
vim /etc/profile

	#set java environment
	JAVA_HOME=/usr/local/src/java/jdk1.7.0_71
	CLASSPATH=.:$JAVA_HOME/lib.tools.jar
	PATH=$JAVA_HOME/bin:$PATH
	export JAVA_HOME CLASSPATH PATH

重新加载配置文件：
source /etc/profile
Linux系统上安装MySQL:
安装MySQL:
上传mysql到Linux:

卸载自带mysql:

创建mysql的安装路径：
Mkdir mysql
解压mysql：
tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql
安装依赖(可选)：
yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6
yum  update libstdc++-4.4.7-4.el6.x86_64
安装mysql的服务端：
rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm
安装mysql的客户端：
rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm
启动mysql的服务：
service mysql status

service mysql start
登录mysql:

产生一个随机的密码存放在/root/.mysql_secret

查看密码进行登录:
msyql –u root -p

修改密码：
set password = password('123456');
设置开机自动启动mysql:
加入到系统服务：
chkconfig --add mysql
自动启动：
chkconfig mysql on
开启远程服务：
登录mysql授权可以远程访问:
grant all privileges on *.* to 'root' @'%' identified by '123456';
flush privileges;
设置Linux的防火墙:
3306端口放行 且将该设置添加到防火墙的规则中
/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT
/etc/rc.d/init.d/iptables save

Linux系统上安装tomcat：
安装tomcat:
上传tomcat的安装文件：

创建tomcat的安装路径：
在/usr/local 下mkdir tomcat
解压tomcat
tar –xvf xxx.tar.gz –C /usr/local/tomcat
设置防火墙：
/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT
/etc/rc.d/init.d/iptables save
启动tomcat：
进入到tomcat/bin
执行 ./startup.sh
关闭tomcat
执行 ./shutdown.sh
发布项目到Linux：
将数据库还原到Linux上：
备份Window上的数据库：
使用命令备份：
mysqldump –u root -p store_v2.0 > c:/store_v2.0.sql

使用可视化工具：
在Linux上还原数据库：

将程序的代码发布到Linux上：
将工程制作为war包：

将war包上传到linux服务器：

将war包copy到linux下的tomcat的webapps中：

修改配置文件就可以：

Nginx
Nginx的概述：

什么是代理和反向代理：

Nginx+Tomcat的集群配置:
在一台电脑上安装两个tomcat
需要在一台电脑模拟：在E盘解压两个tomcat,分别命名为tomcat1，tomcat2.
修改tomcat的配置文件，将端口进行修改:
修改tomcat2中的端口:



将项目分别发布到两个tomcat中：

安装Nginx：
解压
双击nginx.exe
启动完以后访问http://localhost


配置Nginx：
修改nginx/conf/nginx.conf文件：

Tomcat集群的session共享：
2.一种解决办法：一个用户进来以后只在tomcat1上进行操作，另一个用户进行只在tomcat2上进行操作.

2.session的共享
一种使用tomcat广播机制完成session的共享（不推荐的方式）
一种使用redis服务器的方式完成session的共享（推荐的方式）
使用tomcat的广播机制完成session的共享。
修改两个tomcat中的server.xml:


在项目中web.xml中添加一个配置:
<distributable/>
Linux上搭建Nginx+Tomcat集群：
在Linux上安装多个Tomcat:
解压tomcat
分别解压tomcat到/usr/local/tomcat1 和 tomcat2
修改tomcat2中server.xml:

***** 将修改后的端口添加到防火墙中.
Linux上安装Nginx:
可以通过在upstream下设置一个ip_hash解决session共享问题
ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上
启动
在nginx目录下有一个sbin目录，sbin目录下有一个nginx可执行程序。
./nginx



关闭nginx
关闭命令：相当于找到nginx进程kill。
./nginx -s stop

退出命令：
./nginx -s quit
等程序执行完毕后关闭，建议使用此命令。

动态加载配置文件
./nginx -s reload
可以不关闭nginx的情况下更新配置文件。

Nginx在Windows平台的配置
1.2Nginx在Windows平台的配置:
1.2.1课程目标:
课程目标:
能够使用Nginx搭建Tomcat集群,并完成负载均衡.
1.2.2Nginx的概述:
什么是Nginx:

为什么使用Nginx:
背景:
互联网飞速发展的今天,大用户量高并发已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢？这是一些中小网站急需解决的问题。用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的，为了解决这个问题引入了负载均衡方法。负载均衡就是一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。
负载均衡服务器分为两种一种是通过硬件实现的负载均衡服务器，简称硬负载例如：f5。另一种是通过软件来实现的负载均衡，简称软负载:例如apache和nginx。硬负载和软负载相比前者作用的网络层次比较多可以作用到socket接口的数据链路层对发出的请求进行分组转发但是价格成本比较贵，而软负载作用的层次在http协议层之上可以对http请求进行分组转发并且因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。
1.2.3使用Nginx完成负载均衡:
完成Nginx负载均衡,那么需要先来介绍Tomcat的安装和配置,我们首先要来配置Tomcat完成集群的配置.因为我们没有多台服务器运行Tomcat.那么我们可以模拟在一台服务器上运行多个Tomcat程序.
使用Tomcat配置Tomcat集群:
步骤一:下载Tomcat:
http://tomcat.apache.org/download-70.cgi

步骤二:安装和配置Tomcat:
直接将下载后的Tomcat解压在本地磁盘:解压两个分别命名为tomcat1和tomcat2.

分别完成如下配置:(需要将tomcat带有端口号的地方改成不同的端口即可.)分别打开两个tomcat的conf下的server.xml
tomcat1/conf/server.xml




tomcat2/conf/server.xml





1.2.4Nginx的安装和部署:
Nginx的安装:
将nginx-1.8.0.zip解压包某个盘符下运行:目录结构如下:

双击nginx.exe即可运行:打开浏览器http://localhost:80显示如下页面:

说明安装成功!!!
关闭nginx需要使用:
相当于找到nginx进程kill。
nginx -s stop
重新加载配置文件:
nginx -s reload
可以不关闭nginx的情况下更新配置文件.

Nginx的负载均衡的配置:
打开C:\nginx-1.8.0\conf\nginx.conf这个文件:


***** 通过以上的配置我们已经可以通过访问www.taoge.com访问到不同的tomcat来分担服务器端的压力.请求负载过程中会话信息不能丢失.那么需要在多个tomcat中session需要共享.
* 配置Tomcat的session共享可以有三种解决方案:
第一种是以负载均衡服务器本身提供的session共享策略，每种服务期的配置是不一样的并且nginx本身是没有的。

第二种是利用web容器本身的session共享策略来配置共享。针对于weblogic这种方式还是靠普的。但是针对于tomcat这种方式存在很大的缺陷，主要因为是依靠广播方式来实现的session复制，会浪费很多带宽导致整个网络反映缓慢。官网也建议这种方式最好不要超过4台tomcat,具体的内容可参考/webapps/docs/cluster-howto.html里面有详细的说明。下面是具体的配置过程
第三种是Tomcat集群+redis的Session共享配置方法.
在这里我们以第二种方式为例:
配置Tomcat中session的共享:
步骤一:修改server.xml文件，最简单的集群配置只需要将节点中注释掉的下面这句取消注释即可：
Xml代码：
    <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>  
使用这样方法配置的集群会将Session同步到所在网段上的所有配置了集群属性的实例上(此处讲所在网段可能不准确，是使用Membership 的address和port来区分的。tomcat集群的实例如果在Membership配置中有相同的address和port值的tomcat被分到同一个集群里边。他们的session是相互共享的，同一个session的集群被称为一个cluster。可以配置多个cluster，但是cluster和cluster之间的session是不共享的)。也就是说如果该广播地址下的所有Tomcat实例都会共享Session，那么假如有几个互不相关的集群，就可能造成Session复制浪费，所以为了避免浪费就需要对节点多做点设置了，如下：
Xml代码
    <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster">    
        <Channel className="org.apache.catalina.tribes.group.GroupChannel">    
            <Membership className="org.apache.catalina.tribes.membership.McastService"    
                address="228.0.0.4"    
                port="45564"    
                frequency="500"    
                dropTime="3000"/>    
        </Channel>    
    </Cluster>  
加了一个Channel，里面包了个Membership，咱们要关注的就是membership的port属性和address属性，不同的集群设置不同的port值或address值，从目前的使用来看，基本上是隔离开了。

步骤二:修改项目的web.xml文件：
web.xml文件的修改很简单：只需要在节点中添加这个节点<distributable/>就可以了。
OK，有了这二步就实现了Tomcat的集群和Session的共享了。





1.1.反向代理
反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。

1.2.负载均衡
负载均衡，英文名称为Load Balance，是指建立在现有网络结构之上，并提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。其原理就是数据流量分摊到多个服务器上执行，减轻每台服务器的压力，多台服务器共同完成工作任务，从而提高了数据的吞吐量。

大型互联网架构演变历程
2.淘宝技术这10年
2.1.淘宝现状
高并发已经成为当前互联网企业面临的巨大挑战！例如2015年“双十一”全球狂欢节正式落下帷幕，天猫最终交易额也达到了创纪录的912.17亿元！参与交易国家和地区达到232个，双十一支付宝最高峰每秒处理的交易笔数是8.59万笔，在线人数峰值达到4500万。

淘宝的核心技术（国内乃至国际的Top，这还是2011年的数据）
拥有全国最大的分布式Hadoop集群（云梯，2000左右节点，24000核CPU，48000GB内存，40PB存储容量）
全国分布80+CDN节点，能够自动找寻最近的节点提供服务，支持流量超过800Gbps
不逊于百度的搜索引擎，对数十亿商品进行搜索，全球最大的电商平台
顶尖的负载均衡系统，顶尖的分布式系统，顶尖的互联网思想，功能多样运行极其稳定
丰富的生态产业以及先进的数据挖掘技术
……很多很多
2.2.淘宝技术演变，摘自《淘宝技术这十年》
马总在2003年4月7日秘密叫来阿里巴巴的十位员工，来到杭州一个隐秘的毛坯房，要求他们在一个月左右的时间内做出一个C2C网站。结果当然还是直接买的快，一个基于LAMP架构的网站，原名是PHPAuction，老美开发的一个拍卖网站。当然必须要做修改才能用。
2003年底，淘宝注册用户23万，PV 31万/day，半年成交额3371万
很显然MySQL无法撑得起如此大的访问量，数据库瓶颈出现了。幸好阿里的DBA队伍足够强大，他们使用Oracle替代了MySQL。Oracle那时就已经有了强大的并发性访问设计——连接池，从连接池取连接的耗费比单独建立连接少很多。但是PHP当时并没有官方提供支持语言连接池特性，于是多隆前辈用Google（不会是Baidu）搜到了一个开源的SQL Relay，于是数据库软件方面的瓶颈暂时解决了。
随之而来的是面临硬件性能瓶颈，阿里买了EMC的SAN存储设备，加上Oracle高性能RAC，硬件容量也暂时没问题了。
因为SQL Relay的问题实在过于严重，2004年于是淘宝终于做出了跨时代的决策——使用Java重写网站。
淘宝请了Sun的高级工程师来帮忙做Java架构。那么他们是如何做到修改编程语言而不改变网站使用呢——模块化替换，今天写好了A模块，另开一个新域名，将连接指向该模块，同时别的模块不变，等到全部模块完成的时候，原域名放弃。Sun公司坚持使用EJB作为控制层，加上使用iBatis作为持久层，一个可扩展且高效的Java EE应用诞生了。
送走Sun的大牛们之后，阿里的数据存储又遇到了瓶颈，于是忍痛买了一台IBM小型机，也就有了IOE（IBM + Oracle + EMC）这样的传说
2004年底，淘宝注册用户400万，PV 4000万/day，全网成交额10个亿。
2005年Spring诞生了，早闻Spring框架在Web应用不可或缺，而在淘宝网，Spring也达到了Rod Johnson设计它的目的——替代EJB。
2005年底，淘宝注册用户1390万，PV 8931万/day，商品数目1663万个。
考虑到未来的发展，这样的设施架构只是勉强可以应付现在的要求。于是，CDN技术派上用场了，一开始使用商用的ChinaCache，后来使用章文嵩博士搭建低耗能CDN网络，淘宝网的性能越来越好了。
2006年底，淘宝注册用户3000万，PV 15000万/day，商品数目5000万，全网成交额169亿元。
淘宝在2007年之前，使用NetApp的商用存储系统，但是仍然不够应付迅速增长的趋势。同年Google公布了GFS的设计思想，参照它的思想，淘宝也开发了自己的文件系统——TFS每个用户在TFS上拥有1GB的图片存储空间，这些都得益于TFS集群的文件存储系统以及大量的图片服务器。淘宝使用实时生成缩率图，全局负载均衡以及一级和二级缓存来保证图片的访问优化与高效访问。
淘宝的服务器软件使用Tengine，一个被优化过的nginx模块。
淘宝分离出了UIC（User Information Center），供所有模块调用。多隆前辈再次为其编写出了TDBM，完全是基于内存的数据缓存（参考了memcached）。再然后，淘宝将TBstore和TDBM合并，写出了Tair，一个基于Key-Value的分布式缓存数据系统。然后升级了自己的iSearch系统。
2007年底，淘宝注册用户5000万，PV 25000万/day，商品数目1个亿，全网成交额433亿元。
...
Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，每天为2000+ 个服务提供3,000,000,000+ 次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。Dubbo自2011年开源后，已被许多非阿里系公司使用。
3.技术发展历程总结
3.1.单节点架构

3.2.集群架构

3.3.集群+分布式架构




一、正向代理(Forward Proxy)

一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下： 正 向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代 理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。如下图1.1
 
（图1.1）
从上面的概念中，我们看出，文中所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】
这就是正向代理的意义所在。而为什么要用代理服务器去代替访问方【用户A】去访问服务器B呢？这就要从代理服务器使用的意义说起。

使用正向代理服务器作用主要有以下几点：
1、访问本无法访问的服务器B，如下图1.2
（图1.2） 我们抛除复杂的网络路由情节来看图1.2，假设图中路由器从左到右命名为R1,R2假 设最初用户A要访问服务器B需要经过R1和R2路由器这样一个路由节点，如果路由器R1或者路由器R2发生故障，那么就无法访问服务器B了。但是如果用户 A让代理服务器Z去代替自己访问服务器B，由于代理服务器Z没有在路由器R1或R2节点中，而是通过其它的路由节点访问服务器B，那么用户A就可以得到服 务器B的数据了。现实中的例子就是“翻墙”。不过自从VPN技术被广泛应用外，“翻墙”不但使用了传统的正向代理技术，有的还使用了VPN技术。

2、加速访问服务器B

这种说法目前不像以前那么流行了，主要是带宽流量的飞速发展。早期的正向代理中，很多人使用正向代理就是提速。还是如图1.2 假设用户A到服务器B，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。而用户A到代理服务器Z，从代理服务器Z到服务器B都是高带宽链路。那么很显然就可以加速访问服务器B了。

3、Cache作用
Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术。还如上图所示，如果在用户A访问服务器B某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。这一技术在Cache中术语就叫Cache命中。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。
4、客户端访问授权
这方面的内容现今使用的还是比较多的，例如一些公司采用ISA SERVER做为正向代理服务器来授权用户是否有权限访问互联网，挼下图1.3 （图1.3）图 1.3防火墙作为网关，用来过滤外网对其的访问。假设用户A和用户B都设置了代理服务器，用户A允许访问互联网，而用户B不允许访问互联网（这个在代理服 务器Z上做限制）这样用户A因为授权，可以通过代理服务器访问到服务器B，而用户B因为没有被代理服务器Z授权，所以访问服务器B时，数据包会被直接丢 弃。

5、隐藏访问者的行踪

如下图1.4 我们可以看出服务器B并不知道访问自己的实际是用户A，因为代理服务器Z代替用户A去直接与服务器B进行交互。如果代理服务器Z被用户A完全控制（或不完全控制），会惯以“肉鸡”术语称呼。 
（图1.4） 我 们总结一下 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内 容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。

二、反向代理（reverse proxy）
反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 使用反向代理服务器的作用如下：
1、保护和隐藏原始资源服务器如下图2.1 

（图2.1）

用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。

2、负载均衡如下图2.2 

（图2.2）
当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。
当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。如下图2.3

（图2.3）
我们并不是讲解CDN，所以去掉了CDN最关键的核心技术智能DNS。只是展示CDN技术实际上利用的正是反向代理原理这块。

反向代理结论与正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。

基本上，网上做正反向代理的程序很多，能做正向代理的软件大部分也可以做反向代理。开源软件中最流行的就是squid，既可以做正向代理，也有很多人用来做反向代理的前端服务器。另外MS ISA也可以用来在WINDOWS平台下做正向代理。反向代理中最主要的实践就是WEB服务，近些年来最火的就是Nginx了。网上有人说NGINX不能做正向代理，其实是不对的。NGINX也可以做正向代理，不过用的人比较少了。

三、透明代理

   如果把正向代理、反向代理和透明代理按照人类血缘关系来划分的话。那么正向代理和透明代理是很明显堂亲关系，而正向代理和反向代理就是表亲关系了 。
   透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。 透明代理实践的例子就是时下很多公司使用的行为管理软件。如下图3.1
（图3.1）
用户A和用户B并不知道行为管理设备充当透明代理行为，当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。		

下载
http://dev.mysql.com/downloads/mysql/





或者使用wget下载：

wget http://dev.mysql.com/get/Downloads/MySQL-5.6/MySQL-5.6.22-1.el6.i686.rpm-bundle.tar

安装
检测是否已经安装了mysql
rpm -qa | grep mysql   

如果已经安装了，将其卸载，如：

rpm -e --nodeps  mysql-libs-5.1.71-1.el6.x86_64
安装mysql
12、mkdir /usr/local/src/mysql
13、cd /usr/local/src/mysql
14、tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar

15、安装server
rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm
出错：

安装依赖：yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6 



需要升级libstdc++-4.4.7-4.el6.x86_64
yum  update libstdc++-4.4.7-4.el6.x86_64
16、安装中：

17、安装client

安装依赖：yum -y install libncurses.so.5 libtinfo.so.5
18、查询mysq服务运行状态

服务未启动。
19、启动mysql服务
service mysql start
20、使用root账号登录mysql
提示：


在安装mysql server时有句提示：

注意：这个密码是不安全的，所有需要修改初始密码。
21、使用密码登录mysql账号：mysql -uroot -p
22、修改root密码：SET PASSWORD = PASSWORD('123456');
系统启动时自动启动mysql服务
加入到系统服务：
chkconfig --add mysql
自动启动：
chkconfig mysql on
查询列表：
chkconfig

说明：都没关闭（off）时是没有自动启动。

开启远程访问
登录：
mysql -uroot –p123456

设置远程访问（使用root密码）：
grant all privileges on *.* to 'root' @'%' identified by '123456'; 
flush privileges;

防火墙打开3306端口
/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT
/etc/rc.d/init.d/iptables save
/etc/init.d/iptables status





创建ucenter用户
一般情况下，发布应用程序都不是使用root用户的，需要创建一个普通用户来发布程序；

创建ucenter用户：
useradd -d /ucenter ucenter

设置密码：
passwd ucenter （密码 ucenter）

切换用户：
su - ucenter

安装Tomcat
tomcat只要解压就可以使用。

10、创建web目录
mkdir /ucenter/web
11、上传apache-tomcat-7.0.57.tar.gz
12、解压：tar -xvf apache-tomcat-7.0.57.tar.gz
13、重命名：mv apache-tomcat-7.0.57 itcast-usermanage
14、启动tomcat：
cd itcast-usermanage/bin/
./startup.sh 或者 sh startup.sh
15、查看日志：
tail -f ../logs/catalina.out
16、查看效果 http://192.168.0.160:8080/
发现无法访问：

17、防火墙打开 8080 端口
/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT
/etc/rc.d/init.d/iptables save
18、安装成功

部署用户管理项目
上传usermanage.sql和ROOT.war到/ucenter/web
执行数据库脚本
cat usermanage.sql | mysql -uroot -p123456
部署web程序
删除webapps下的所有文件
cd /ucenter/web/itcast-usermanage/webapps
rm -rf *
拷贝ROOT.war到webapps
cp /ucenter/web/ROOT.war .
重新启动tomcat
cd ../bin/
sh startup.sh && tail -f ../logs/catalina.out
启动浏览器测试
http://192.168.0.160:8080/user/page/query


Nginx


4什么是Nginx
Nginx ("engine x") 是一个高性能的 HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。

正向代理：













反向代理：



















很多大网站都是使用nginx做反向代理，应用非常广泛。
Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。

5应用场景
4、http服务器，可以做静态网页的http服务器。
5、配置虚拟机。
一个域名可以被多个ip绑定。可以根据域名的不同吧请求转发给运行在不同端口的服务器。
6、反向代理，负载均衡。把请求转发给不同的服务器。

6安装及配置
6.1下载
官方网站：http://nginx.org/
最后的一个稳定版本：1.8.0版本。有两个版本windows版本和linux版本。生产环境都是使用linux版本。

6.2安装
6.2.1环境要求
nginx是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。
gcc
	安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ 
PCRE
	PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。
yum install -y pcre pcre-devel
注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。
zlib
	zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。
yum install -y zlib zlib-devel

openssl
	OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。
	nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。
yum install -y openssl openssl-devel

6.2.2编译及安装
第一步：把nginx的源码包上传至linux服务器
第二步：解压源码包。 tar -zxf nginx-1.8.0.tar.gz 
第三步：进入nginx-1.8.0文件夹。使用configure命令创建makefile。
第四步：参数设置如下：
./configure \
--prefix=/usr/local/nginx \
--pid-path=/var/run/nginx/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi

注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录
第五步：make
第六步 make install


6.3Nginx的启动及关闭
6.3.1启动
在nginx目录下有一个sbin目录，sbin目录下有一个nginx可执行程序。
./nginx



6.3.2关闭nginx
关闭命令：相当于找到nginx进程kill。
./nginx -s stop

退出命令：
./nginx -s quit
等程序执行完毕后关闭，建议使用此命令。

6.3.3动态加载配置文件
./nginx -s reload
可以不关闭nginx的情况下更新配置文件。

先卸载open-jdk

java –version
rpm -qa | grep java

rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64
rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64

开始安装：
mkdir /usr/local/src/java
rz 上传jdk tar包
tar -xvf jdk-7u71-linux-i586.tar.gz

yum install glibc.i686

配置环境变量：
① vi /etc/profile

② 在末尾行添加
	#set java environment
	JAVA_HOME=/usr/local/src/java/jdk1.7.0_71
	CLASSPATH=.:$JAVA_HOME/lib.tools.jar
	PATH=$JAVA_HOME/bin:$PATH
	export JAVA_HOME CLASSPATH PATH
保存退出
③source /etc/profile  使更改的配置立即生效
④java -version  查看JDK版本信息，如果显示出1.7.0证明成功


第一天练习

1.查询工资大于12000的员工姓名和工资
select last_name, salary
from employees
where salary > 12000
2.查询员工号为176的员工的姓名和部门号
select last_name, department_id
from employees
where employee_id = 176
3.选择工资不在5000到12000的员工的姓名和工资
select last_name, salary
from employees
where salary not between 5000 and 12000
4.选择雇用时间在1998-02-01到1998-05-01之间的员工姓名，job_id和雇用时间
select last_name, job_id, hire_date
from employees
where hire_date between '1-2月 -1998' and '1-5月 -1998'
5.选择在20或50号部门工作的员工姓名和部门号
select last_name, department_id
from employees
where department_id in (20, 50)
6.选择在1994年雇用的员工的姓名和雇用时间
select last_name, hire_date
from employees
where hire_date like '% -94'
7.选择公司中没有管理者的员工姓名及job_id
select last_name, job_id
from employees
where manager_id is null
8.选择公司中有奖金的员工姓名，工资和奖金级别
select last_name, salary, commission_pct
from employees
where commission_pct is not null
9.选择员工姓名的第三个字母是a的员工姓名
select last_name
from employees
where last_name like '__a%'
10.选择姓名中有字母a和e的员工姓名
select last_name
from employees
where last_name like '%a%' and last_name like '%e%'

11.显示系统时间
select to_char(sysdate, 'yyyy-mm-dd hh:mi:ss') from dual;
12.查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）
select employee_id, last_name, salary, salary * 1.2 "new salary"
from employees;
13.将员工的姓名按首字母排序，并写出姓名的长度（length）
   select last_name, length(last_name)
from employees
order by last_name
14.查询各员工的姓名，并显示出各员工在公司工作的月份数（worked_month）。
   select last_name, months_between(sysdate, hire_date) worked_month
from employees
15.查询员工的姓名，以及在公司工作的月份数（worked_month），并按月份数降序排列
   
select last_name, months_between(sysdate, hire_date) worked_month
from employees
order by worked_month desc
16.做一个查询，产生下面的结果
<last_name> earns <salary> monthly but wants <salary*3>
Dream Salary
King earns $24000 monthly but wants $72000
select last_name || ' earns ' || salary || ' monthly but wants ' || salary * 3
from employees
17.使用decode函数，按照下面的条件：
job                  grade
AD_PRES            A
ST_MAN             B
IT_PROG             C
SA_REP              D
ST_CLERK           E
Others                     F
产生下面的结果
Last_name	Job_id	Grade
king	AD_PRES	A
select last_name, job_id, decode(job_id, 'AD_PRES', 'A',
                                         'ST_MAN', 'B',
                                         'IT_PROG', 'C',
                                         'SA_REP', 'D',
                                         'ST_CLERK', 'E',
                                         'F') GRADE
from employees
18.将第7题的查询用case函数再写一遍。
select last_name, job_id, case job_id when 'AD_PRES' then 'A'
                                      when 'ST_MAN' then 'B'
                                      when 'IT_PROG' then 'C'
                                      when 'SA_REP' then 'D'
                                      when 'ST_CLERK' then 'E'
                                      else 'F'
                           end            
from employees

19.查询公司员工工资的最大值，最小值，平均值，总和
Select max(salary), min(salary), avg(salary), sum(salary)
From employees
20.查询各job_id的员工工资的最大值，最小值，平均值，总和
Select job_id, max(salary), min(salary), avg(salary), sum(salary)
From employees
Group by job_id
21.选择具有各个job_id的员工人数
Select job_id, count(employee_id)
From employees
Group by job_id;
22.查询员工最高工资和最低工资的差距（DIFFERENCE）
Select max(salary) – min(salary) difference
From employees
23.查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内
Select manager_id, min(salary)
From employees
Where manager_id is not null
Group by manager_id
Having min(salary) >= 6000
24.查询所有部门的名字，location_id，员工数量和工资平均值
Select department_name, location_id, count(employee_id), avg(salary)
From employees e join departments d
On e.department_id = d.department_id
Group by department_name, location_id

第二天练习
1.查询和smith相同部门的员工姓名和雇用日期

select t1.ename, t1.hiredate
  from emp t1
 where t1.deptno = (select t.deptno from emp t where t.ename = 'SMITH')
2.查询工资比公司平均工资高的员工的员工号，姓名和工资。

select t.empno, t.ename, t.sal
  from emp t
 where t.sal > (select avg(sal) from emp)
3.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资

select e.empno, e.ename, e.sal
  from (select t.deptno, avg(t.sal) avgsal from emp t group by t.deptno) a,
       emp e
 where a.deptno = e.deptno
   and e.sal > a.avgsal
4.查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名

select *
  from emp e
 where e.deptno in (select t.deptno from emp t where t.ename like '%U%')
   and e.ename not in (select t.ename from emp t where t.ename like '%U%')
5. 查询管理者是King的员工姓名和工资

select *
  from emp e
 where e.mgr in (select t.empno from emp t where t.ename = 'KING')




第二天练习
5.查询和smith相同部门的员工姓名和雇用日期

6.查询工资比公司平均工资高的员工的员工号，姓名和工资。

7.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资

8.查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名

5. 查询管理者是King的员工姓名和工资




第二天练习
9.查询和Zlotkey相同部门的员工姓名和雇用日期

select last_name, hire_date
from employees
where department_id = (
      select department_id
      from employees
      where last_name = 'Zlotkey'
)

10.查询工资比公司平均工资高的员工的员工号，姓名和工资。

select employee_id, last_name, salary
from employees
where salary > (
      select avg(salary)
      from employees
)

11.查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资

select employee_id, last_name, salary
from employees e
where salary > (
      select avg(salary)
      from employees
      where department_id = e.department_id
)

12.查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名
select employee_id, last_name
from employees
where department_id in (
      select department_id
      from employees
      where last_name like '%u%'
)

5. 查询在部门的location_id为1700的部门工作的员工的员工号，
select employee_id
from employees
where department_id in (
      select department_id
      from departments
      where location_id = 1700
)
6. 查询管理者是King的员工姓名和工资
select last_name, salary
from employees
where manager_id in (
      select employee_id
      from employees
      where last_name = 'King'
)






PL/SQL安装详情
1.双击图标

提示信息：

2.会进入下面的界面

3.进一步到下面的界面，注意修改路径（不要有中文和空格），我的路径改为D:\plsql

4.修改后的路径如下

5.点”Next”后，进入如下界面

6.直接点击”Next”，进入如下界面

7.直接点击”Finish”，完成安装

8.点击”Close”结束，可以看到桌面的小图标

9.双击该图标，在弹出的窗口中点击取消。如下图所示

10.此时会进入到PL/SQL主页面，并要求进行激活。如下界面

11.打开plsql安装路径下的另一个文件,如下图

解压后

12.进入解压后的keygen文件夹下，可以看到

双击上面这个图标
13.可以看到如下界面

14.将上面的内容，对应的复制到第10步操作中的界面中

15.点”Register”后，会提示注册成功。

16.点击”OK”后，完成注册操作
17.在PL/SQL中，点击菜单Tools->>Preferences

18.在上面的图中，找到你的D:\instantclient_12_1(32位)文件夹所在的位置

要使用32位的软件

19.将tnsnames.ora拷贝至D盘根目录（或其它位置），编辑此文件。
此文件在下图目录中查找。因为你oracle安装在虚拟机中，所以这个路径是虚拟机winxp上的路径


先将这个文件放到共享文件夹中
在winxp中:  “我的电脑”双击---工具--映射网络驱动器，进入下面界面

进入下面界面，将文件复制到此处，再到win7系统中找到这个文件，复制到D:\根目录下

打开文件，可以看到

修改后：

20.在win7系统中进行操作
设置环境变量  TNS_ADMIN  为D盘根目录( tnsnames.ora所在目录 )

21.再次双击PL/SQL图标，进入系统  

22.进入主页面说明成功，如下图


23.打开sql视图，输入sql语句，按”F8”运行，可以看到结果





Oracle 第三天
1.游标Cursor
在写java程序中有集合的概念，那么在pl/sql中也会用到多条记录，这时候我们就要用到游标，游标可以存储查询返回的多条数据。
语法：
	CURSOR  游标名  [ (参数名  数据类型,参数名 数据类型,...)]  IS  SELECT   语句;
例如：cursor c1 is select ename from emp;
游标的使用步骤：
打开游标：      open c1;    (打开游标执行查询)
取一行游标的值：fetch c1 into pjob; (取一行到变量中)
关闭游标：       close  c1;(关闭游标释放资源)
游标的结束方式   exit when c1%notfound
注意： 上面的pjob必须与emp表中的job列类型一致： 
		定义：pjob emp.empjob%type;
范例1：使用游标方式输出emp表中的员工编号和姓名
declare
  cursor pc is
    select * from emp;
  pemp emp%rowtype;
begin
  open pc;
  loop
    fetch pc
      into pemp;
    exit when pc%notfound;
    dbms_output.put_line(pemp.empno || ' ' || pemp.ename);
  end loop;
  close pc;
end;
范例2：写一段PL/SQL程序，为部门号为10的员工涨工资。
declare
  cursor pc(dno myemp.deptno%type) is
    select empno from myemp where deptno = dno;
  pno myemp.empno%type;
begin
  open pc(20);
  loop
    fetch pc
      into pno;
    exit when pc%notfound;
    update myemp t set t.sal = t.sal + 1000 where t.empno = pno;
  end loop;
  close pc;
end;

2.异常
异常是程序设计语言提供的一种功能，用来增强程序的健壮性和容错性。
系统定义异常 
no_data_found    (没有找到数据)
too_many_rows   (select …into语句匹配多个行) 
zero_divide   ( 被零除)
value_error   (算术或转换错误)
timeout_on_resource  (在等待资源时发生超时)
范例1：写出被0除的异常的plsql程序
declare
  pnum number;
begin
  pnum := 1 / 0;
exception
  when zero_divide then
    dbms_output.put_line('被0除');
  when value_error then
    dbms_output.put_line('数值转换错误');
  when others then
    dbms_output.put_line('其他错误');
end;
	
用户也可以自定义异常，在声明中来定义异常
DECLARE
My_job   char(10);
v_sal   emp.sal%type;
No_data    exception;
cursor c1 is select distinct job from emp    order by job;
如果遇到异常我们要抛出raise no_data;
范例2：查询部门编号是50的员工
declare
  no_emp_found exception;
  cursor pemp is
    select t.ename from emp t where t.deptno = 50;
  pename emp.ename%type;
begin
  open pemp;
  fetch pemp
    into pename;
  if pemp%notfound then
    raise no_emp_found;
  end if;
  close pemp;
exception
  when no_emp_found then
    dbms_output.put_line('没有找到员工');
  when others then
    dbms_output.put_line('其他错误');
end;

3.存储过程
存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。

创建存储过程语法：
create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]  
AS 
begin
        PLSQL子程序体；
End;

或者

create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]  
is
begin
        PLSQL子程序体；
End  过程名;

范例1：给指定的员工涨100工资，并打印出涨前和涨后的工资
分析：我们需要使用带有参数的存储过程
create or replace procedure addSal1(eno in number) is
  pemp myemp%rowtype;
begin
  select * into pemp from myemp where empno = eno;
  update myemp set sal = sal + 100 where empno = eno;
  dbms_output.put_line('涨工资前' || pemp.sal || '涨工资后' || (pemp.sal + 100));
end addSal1;

调用
begin
  -- Call the procedure
  addsal1(eno => 7902);     
  commit;
end;
4.存储函数
create or replace function 函数名(Name in type, Name out type, ...) return 数据类型 is
  结果变量 数据类型;
begin
  
  return(结果变量);
end[函数名];

存储过程和存储函数的区别
一般来讲，过程和函数的区别在于函数可以有一个返回值；而过程没有返回值。 
但过程和函数都可以通过out指定一个或多个输出参数。我们可以利用out参数，在过程和函数中实现返回多个值。

范例：使用存储函数来查询指定员工的年薪
create or replace function empincome(eno in emp.empno%type) return number is
  psal  emp.sal%type;
  pcomm emp.comm%type;
begin
  select t.sal into psal from emp t where t.empno = eno;
  return psal * 12 + nvl(pcomm, 0);
end;
使用存储过程来替换上面的例子
create or replace procedure empincomep(eno in emp.empno%type, income out number) is
  psal emp.sal%type;
  pcomm emp.comm%type;
begin
  select t.sal, t.comm into psal, pcomm from emp t where t.empno = eno;
  income := psal*12+nvl(pcomm,0);
end empincomep;

调用：
declare
  income number;
begin
  empincomep(7369, income);
  dbms_output.put_line(income);
end;

5.触发器
数据库触发器是一个与表相关联的、存储的PL/SQL程序。每当一个特定的数据操作语句(Insert,update,delete)在指定的表上发出时，Oracle自动地执行触发器中定义的语句序列。 

1.触发器作用
数据确认  
实施复杂的安全性检查
做审计，跟踪表上所做的数据操作等 
数据的备份和同步 

2.触发器的类型 
语句级触发器 ：在指定的操作语句操作之前或之后执行一次，不管这条语句影响		     了多少行 。 
行级触发器（FOR EACH ROW） ：触发语句作用的每一条记录都被触发。在行级触		  发器中使用old和new伪记录变量, 识别值的状态。 
语法：
CREATE  [or REPLACE] TRIGGER  触发器名
   {BEFORE | AFTER}
   {DELETE | INSERT | UPDATE [OF 列名]}
   ON  表名
   [FOR EACH ROW [WHEN(条件) ] ]
declare
    ……
begin
   PLSQL 块 
End 触发器名
范例：插入员工后打印一句话“一个新员工插入成功”
create or replace trigger testTrigger
  after insert on person  
declare
  -- local variables here
begin
  dbms_output.put_line('一个员工被插入');
end testTrigger;

范例：不能在休息时间插入员工
create or replace trigger validInsertPerson
  before insert on person

declare
  weekend varchar2(10);
begin
  select to_char(sysdate, 'day') into weekend from dual;
  if weekend in ('星期一') then
    raise_application_error(-20001, '不能在非法时间插入员工');
  end if;
end validInsertPerson;
当执行插入时会报错



在触发器中触发语句与伪记录变量的值
触发语句	:old	:new
Insert	所有字段都是空(null)	将要插入的数据
Update	更新以前该行的值	更新后的值
delete	删除以前该行的值	所有字段都是空(null)
范例：判断员工涨工资之后的工资的值一定要大于涨工资之前的工资
create or replace trigger addsal4p
  before update of sal on myemp
  for each row
begin
  if :old.sal >= :new.sal then
    raise_application_error(-20002, '涨前的工资不能大于涨后的工资');
  end if;
end;

调用
update myemp t set t.sal = t.sal - 1;


3.触发器实际应用
需求：使用序列，触发器来模拟mysql中自增效果
1.创建序列
1、建立表
复制代码 代码如下:create table user  
(   
    id   number(6) not null,   
    name   varchar2(30)   not null primary key  
)  
2、建立序列SEQUENCE
代码如下:
create sequence user_seq increment by 1 start with 1 minvalue 1 maxvalue 9999999999999 nocache order;
2.创建自增的触发器
分析：创建一个基于该表的before insert 触发器，在触发器中使用刚创建的SEQUENCE。
代码如下:
create or replace trigger user_trigger   
before insert on user  
for each row   
begin  
      select   user_seq.nextval  into:new.id from sys.dual ;   
end;  
3.测试效果
 insert into itcastuser(name) values('aa');
commit;
insert into itcastuser(name) values('bb');
commit;

5.Java代码访问Oracle对象
1.java连接oracle的jar包
可以在虚拟机中xp的oracle安装目录下找到jar包 :ojdbc14.jar

2.数据库连接字符串
String driver="oracle.jdbc.OracleDriver";
String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
String username="scott";
String password="tiger";

测试代码：

3.实现过程与函数的调用
1.调用过程
1.过程定义
--统计年薪的过程
create or replace procedure proc_countyearsal(eno in number,esal out number)
as
begin
   select sal*12+nvl(comm,0) into esal from emp where empno=eno;
end;


--调用
declare
   esal number;
begin
   proc_countyearsal(7839,esal);
   dbms_output.put_line(esal);
end;


2.过程调用
@Test
	public void testProcedure01(){
		String driver="oracle.jdbc.OracleDriver";
		String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
		String username="scott";
		String password="tiger";
		
		try {
			Class.forName(driver);
			Connection con  = DriverManager.getConnection(url, username, password);
			
			CallableStatement callSt = con.prepareCall("{call proc_countyearsal(?,?)}");
			
			callSt.setInt(1, 7839);
			callSt.registerOutParameter(2, OracleTypes.NUMBER);
			
			callSt.execute();
			
			System.out.println(callSt.getObject(2));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

2.调用函数
1.函数定义
--统计年薪的函数
create or replace function fun_countyearsal(eno in number) 
return number
as
   esal number:=0;
begin
  select sal*12+nvl(comm,0) into esal from emp where empno=eno;
  return esal;
end;


--调用
declare
   esal number;
begin
   esal:=fun_countyearsal(7839);
   dbms_output.put_line(esal);
end;


2.函数调用
@Test
	public void testFunction01(){
		String driver="oracle.jdbc.OracleDriver";
		String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
		String username="scott";
		String password="tiger";
		
		try {
			Class.forName(driver);
			Connection con  = DriverManager.getConnection(url, username, password);
			
			CallableStatement callSt = con.prepareCall("{?= call fun_countyearsal(?)}");
			
			callSt.registerOutParameter(1, OracleTypes.NUMBER);
			callSt.setInt(2, 7839);
			
			
			callSt.execute();
			
			System.out.println(callSt.getObject(1));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

4.游标引用的java测试
1.定义过程，并返回引用型游标
--定义过程
create or replace procedure proc_cursor_ref(dno in number,empList out sys_refcursor)
as
begin
  open empList for select * from emp where deptno = dno;
end;

--pl/sql中调用
declare
  mycursor_c sys_refcursor;
  myempc emp%rowtype;
begin
  proc_cursor_ref(20,mycursor_c);
  
  loop
    fetch mycursor_c into myempc;
    exit when mycursor_c%notfound;
    dbms_output.put_line(myempc.empno||','||myempc.ename);
  end loop;
  close mycursor_c;
end;

2.java代码调用游标类型的out参数
@Test
	public void testFunction(){
		String driver="oracle.jdbc.OracleDriver";
		String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
		String username="scott";
		String password="tiger";
		
		try {
			Class.forName(driver);
			Connection con  = DriverManager.getConnection(url, username, password);
			
			CallableStatement callSt = con.prepareCall("{call proc_cursor_ref (?,?)}");
			
			callSt.setInt(1, 20);
			callSt.registerOutParameter(2, OracleTypes.CURSOR);
			
			callSt.execute();
			
			ResultSet rs = ((OracleCallableStatement)callSt).getCursor(2);
			while(rs.next()){
				System.out.println(rs.getObject(1)+","+rs.getObject(2));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}



Oracle 第三天
1.游标(光标)Cursor
在写java程序中有集合的概念，那么在pl/sql中也会用到多条记录，这时候我们就要用到游标，游标可以存储查询返回的多条数据。
语法：
	CURSOR  游标名  [ (参数名  数据类型,参数名 数据类型,...)]  IS  SELECT   语句;
例如：cursor c1 is select ename from emp;
游标的使用步骤：
打开游标：      open c1;    (打开游标执行查询)
取一行游标的值：fetch c1 into pjob; (取一行到变量中)
关闭游标：       close  c1;(关闭游标释放资源)
游标的结束方式   exit when c1%notfound
注意： 上面的pjob必须与emp表中的job列类型一致： 
		定义：pjob emp.empjob%type;
光标属性:%isopen %rowcount(影响的行数)  %found  %notfound
范例1：使用游标方式输出emp表中的员工编号和姓名
declare
  cursor pc is
    select * from emp;
  pemp emp%rowtype;
begin
  open pc;
  loop
    fetch pc
      into pemp;
    exit when pc%notfound;
    dbms_output.put_line(pemp.empno || ' ' || pemp.ename);
  end loop;
  close pc;
end;
范例2：写一段PL/SQL程序，为部门号为10的员工涨工资。
declare
  cursor pc(dno myemp.deptno%type) is
    select empno from myemp where deptno = dno;
  pno myemp.empno%type;
begin
  open pc(20);
  loop
    fetch pc
      into pno;
    exit when pc%notfound;
    update myemp t set t.sal = t.sal + 1000 where t.empno = pno;
  end loop;
  close pc;
end;

2.异常
异常是程序设计语言提供的一种功能，用来增强程序的健壮性和容错性。
系统定义异常 
no_data_found    (没有找到数据)
too_many_rows   (select …into语句匹配多个行) 
zero_divide   ( 被零除)
value_error   (算术或转换错误)
timeout_on_resource  (在等待资源时发生超时)
范例1：写出被0除的异常的plsql程序
declare
  pnum number;
begin
  pnum := 1 / 0;
exception
  when zero_divide then
    dbms_output.put_line('被0除');
  when value_error then
    dbms_output.put_line('数值转换错误');
  when others then
    dbms_output.put_line('其他错误');
end;
	
用户也可以自定义异常，在声明中来定义异常
DECLARE
My_job   char(10);
v_sal   emp.sal%type;
No_data    exception;
cursor c1 is select distinct job from emp    order by job;
如果遇到异常我们要抛出raise no_data;
范例2：查询部门编号是50的员工
declare
  no_emp_found exception;
  cursor pemp is
    select t.ename from emp t where t.deptno = 50;
  pename emp.ename%type;
begin
  open pemp;
  fetch pemp
    into pename;
  if pemp%notfound then
    raise no_emp_found;
  end if;
  close pemp;
exception
  when no_emp_found then
    dbms_output.put_line('没有找到员工');
  when others then
    dbms_output.put_line('其他错误');
end;

3.存储过程
存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。

创建存储过程语法：
create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]  
AS 
begin
        PLSQL子程序体；
End;

或者

create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]  
is
begin
        PLSQL子程序体；
End  过程名;

范例1：给指定的员工涨100工资，并打印出涨前和涨后的工资
分析：我们需要使用带有参数的存储过程
create or replace procedure addSal1(eno in number) is
  pemp myemp%rowtype;
begin
  select * into pemp from myemp where empno = eno;
  update myemp set sal = sal + 100 where empno = eno;
  dbms_output.put_line('涨工资前' || pemp.sal || '涨工资后' || (pemp.sal + 100));
end addSal1;

调用
begin
  -- Call the procedure
  addsal1(eno => 7902);     
  commit;
end;
4.存储函数
create or replace function 函数名(Name in type, Name out type, ...) return 数据类型 is
  结果变量 数据类型;
begin
  
  return(结果变量);
end[函数名];

存储过程和存储函数的区别
一般来讲，过程和函数的区别在于函数可以有一个返回值；而过程没有返回值。 
但过程和函数都可以通过out指定一个或多个输出参数。我们可以利用out参数，在过程和函数中实现返回多个值。

范例：使用存储函数来查询指定员工的年薪
create or replace function empincome(eno in emp.empno%type) return number is
  psal  emp.sal%type;
  pcomm emp.comm%type;
begin
  select t.sal into psal from emp t where t.empno = eno;
  return psal * 12 + nvl(pcomm, 0);
end;
使用存储过程来替换上面的例子
create or replace procedure empincomep(eno in emp.empno%type, income out number) is
  psal emp.sal%type;
  pcomm emp.comm%type;
begin
  select t.sal, t.comm into psal, pcomm from emp t where t.empno = eno;
  income := psal*12+nvl(pcomm,0);
end empincomep;

调用：
declare
  income number;
begin
  empincomep(7369, income);
  dbms_output.put_line(income);
end;

5.触发器
数据库触发器是一个与表相关联的、存储的PL/SQL程序。每当一个特定的数据操作语句(Insert,update,delete)在指定的表上发出时，Oracle自动地执行触发器中定义的语句序列。 

1.触发器作用
数据确认  
实施复杂的安全性检查
做审计，跟踪表上所做的数据操作等 
数据的备份和同步 

2.触发器的类型 
语句级触发器 ：在指定的操作语句操作之前或之后执行一次，不管这条语句影响		     了多少行 。 
行级触发器（FOR EACH ROW） ：触发语句作用的每一条记录都被触发。在行级触		  发器中使用old和new伪记录变量, 识别值的状态。 
语法：
CREATE  [or REPLACE] TRIGGER  触发器名
   {BEFORE | AFTER}
   {DELETE | INSERT | UPDATE [OF 列名]}
   ON  表名
   [FOR EACH ROW [WHEN(条件) ] ]
declare
    ……
begin
   PLSQL 块 
End 触发器名
范例：插入员工后打印一句话“一个新员工插入成功”
create or replace trigger testTrigger
  after insert on person  
declare
  -- local variables here
begin
  dbms_output.put_line('一个员工被插入');
end testTrigger;

范例：不能在休息时间插入员工
create or replace trigger validInsertPerson
  before insert on person

declare
  weekend varchar2(10);
begin
  select to_char(sysdate, 'day') into weekend from dual;
  if weekend in ('星期一') then
    raise_application_error(-20001, '不能在非法时间插入员工');
  end if;
end validInsertPerson;
当执行插入时会报错



在触发器中触发语句与伪记录变量的值
触发语句	:old	:new
Insert	所有字段都是空(null)	将要插入的数据
Update	更新以前该行的值	更新后的值
delete	删除以前该行的值	所有字段都是空(null)
范例：判断员工涨工资之后的工资的值一定要大于涨工资之前的工资
create or replace trigger addsal4p
  before update of sal on myemp
  for each row
begin
  if :old.sal >= :new.sal then
    raise_application_error(-20002, '涨前的工资不能大于涨后的工资');
  end if;
end;

调用
update myemp t set t.sal = t.sal - 1;


3.触发器实际应用
需求：使用序列，触发器来模拟mysql中自增效果
2.创建序列
1、建立表
复制代码 代码如下:create table user  
(   
    id   number(6) not null,   
    name   varchar2(30)   not null primary key  
)  
2、建立序列SEQUENCE
代码如下:
create sequence user_seq increment by 1 start with 1 minvalue 1 maxvalue 9999999999999 nocache order;
2.创建自增的触发器
分析：创建一个基于该表的before insert 触发器，在触发器中使用刚创建的SEQUENCE。
代码如下:
create or replace trigger user_trigger   
before insert on user  
for each row   
begin  
      select   user_seq.nextval  into:new.id from sys.dual ;   
end;  
3.测试效果
 insert into itcastuser(name) values('aa');
commit;
insert into itcastuser(name) values('bb');
commit;

5.Java代码访问Oracle对象
1.java连接oracle的jar包
可以在虚拟机中xp的oracle安装目录下找到jar包 :ojdbc14.jar

2.数据库连接字符串
String driver="oracle.jdbc.OracleDriver";
String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
String username="scott";
String password="tiger";

测试代码：

3.实现过程与函数的调用
1.调用过程
1.过程定义
--统计年薪的过程
create or replace procedure proc_countyearsal(eno in number,esal out number)
as
begin
   select sal*12+nvl(comm,0) into esal from emp where empno=eno;
end;


--调用
declare
   esal number;
begin
   proc_countyearsal(7839,esal);
   dbms_output.put_line(esal);
end;


2.过程调用
@Test
	public void testProcedure01(){
		String driver="oracle.jdbc.OracleDriver";
		String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
		String username="scott";
		String password="tiger";
		
		try {
			Class.forName(driver);
			Connection con  = DriverManager.getConnection(url, username, password);
			
			CallableStatement callSt = con.prepareCall("{call proc_countyearsal(?,?)}");
			
			callSt.setInt(1, 7839);
			callSt.registerOutParameter(2, OracleTypes.NUMBER);
			
			callSt.execute();
			
			System.out.println(callSt.getObject(2));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

2.调用函数
1.函数定义
--统计年薪的函数
create or replace function fun_countyearsal(eno in number) 
return number
as
   esal number:=0;
begin
  select sal*12+nvl(comm,0) into esal from emp where empno=eno;
  return esal;
end;


--调用
declare
   esal number;
begin
   esal:=fun_countyearsal(7839);
   dbms_output.put_line(esal);
end;


2.函数调用
@Test
	public void testFunction01(){
		String driver="oracle.jdbc.OracleDriver";
		String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
		String username="scott";
		String password="tiger";
		
		try {
			Class.forName(driver);
			Connection con  = DriverManager.getConnection(url, username, password);
			
			CallableStatement callSt = con.prepareCall("{?= call fun_countyearsal(?)}");
			
			callSt.registerOutParameter(1, OracleTypes.NUMBER);
			callSt.setInt(2, 7839);
			
			
			callSt.execute();
			
			System.out.println(callSt.getObject(1));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

4.游标引用的java测试
1.定义过程，并返回引用型游标
--定义过程
create or replace procedure proc_cursor_ref(dno in number,empList out sys_refcursor)
as
begin
  open empList for select * from emp where deptno = dno;
end;

--pl/sql中调用
declare
  mycursor_c sys_refcursor;
  myempc emp%rowtype;
begin
  proc_cursor_ref(20,mycursor_c);
  
  loop
    fetch mycursor_c into myempc;
    exit when mycursor_c%notfound;
    dbms_output.put_line(myempc.empno||','||myempc.ename);
  end loop;
  close mycursor_c;
end;

2.java代码调用游标类型的out参数
@Test
	public void testFunction(){
		String driver="oracle.jdbc.OracleDriver";
		String url="jdbc:oracle:thin:@192.168.56.10:1521:orcl";
		String username="scott";
		String password="tiger";
		
		try {
			Class.forName(driver);
			Connection con  = DriverManager.getConnection(url, username, password);
			
			CallableStatement callSt = con.prepareCall("{call proc_cursor_ref (?,?)}");
			
			callSt.setInt(1, 20);
			callSt.registerOutParameter(2, OracleTypes.CURSOR);
			
			callSt.execute();
			
			ResultSet rs = ((OracleCallableStatement)callSt).getCursor(2);
			while(rs.next()){
				System.out.println(rs.getObject(1)+","+rs.getObject(2));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}



Oracle第二天
1.回顾


2.多表查询
1.多表连接基本查询
使用一张以上的表做查询就是多表查询
语法：	SELECT {DISTINCT} *|列名.. FROM 表名 别名，表名1 别名
			{WHERE 限制条件	ORDER BY 排序字段 ASC|DESC...}
范例：查询员工表和部门表

我们发现产生的记录数是56条，我们还会发现emp表是14条，dept表是4条，56正是emp表和dept表的记录数的乘积，我们称其为笛卡尔积。
如果多张表进行一起查询而且每张表的数据很大的话笛卡尔积就会变得非常大，对性能造成影响，想要去掉笛卡尔积我们需要关联查询。
在两张表中我们发现有一个共同的字段是depno，depno就是两张表的关联的字段，我们可以使用这个字段来做限制条件，两张表的关联查询字段一般是其中一张表的主键，另一张表的外键。

关联之后我们发现数据条数是14条，不在是56条。
多表查询我们可以为每一张表起一个别名

范例：查询出雇员的编号，姓名，部门的编号和名称，地址

范例：查询出每个员工的上级领导
分析：emp表中的mgr字段是当前雇员的上级领导的编号，所以该字段对emp表产生了自身关联，可以使用mgr字段和empno来关联

范例:在上一个例子的基础上查询该员工的部门名称
分析：只要在上一个例子基础上再加一张表的关联，使用deptno来做关联字段即可

范例：查询出每个员工编号，姓名，部门名称，工资等级和他的上级领导的姓名，工资等级
select e.empno,
       e.ename,
       decode(s.grade,
              1,'一级',
              2,'二级',
              3,'三级',
              4,'四级',
              5,'五级') grade,
       d.dname,
       e1.empno,
       e1.ename,
       decode(s1.grade,
              1,'一级',
              2,'二级',
              3,'三级',
              4,'四级',
              5,'五级') grade
  from emp e, emp e1, dept d, salgrade s, salgrade s1
 where e.mgr = e1.empno
   and e.deptno = d.deptno
   and e.sal between s.losal and s.hisal
   and e1.sal between s1.losal and s1.hisal

2.外连接（左右连接）
1.右连接
当我们在做基本连接查询的时候，查询出所有的部门下的员工，我们发现编号为40的部门下没有员工，但是要求把该部门也展示出来，我们发现上面的基本查询是办不到的

使用(+)表示左连接或者右连接，当(+)在左边表的关联条件字段上时是左连接，如果是在右边表的关联条件字段上就是右连接。

范例：查询出所有员工的上级领导
分析：我们发现使用我们以前的做法发现KING的上级领导没有被展示，我们需要使用左右连接把他查询出来

3.sql1999对SQL的支持
1.ON子句，自己编写连接条件（重要）
On相当于where

2.左连接和右连接LEFT JOIN和RIGHT JOIN（重要）



3. 分组统计
分组统计需要使用GROUP BY来分组
语法：语法：SELECT * |列名 FROM 表名 {WEHRE 查询条件}   {GROUP BY 分组字段} ORDER BY 列名1 ASC|DESC，列名2...ASC|DESC

范例：查询每个部门的人数

范例：查询出每个部门的平均工资


如果我们想查询出来部门编号，和部门下的人数

我们发现报了一个ORA-00937的错误
注意：
1.如果使用分组函数，SQL只可以把GOURP BY分组条件字段和分组函数查询出来，不能有其他字段。
2.如果使用分组函数，不使用GROUP BY 只可以查询出来分组函数的值


范例：按部门分组，查询出部门名称和部门的员工数量


范例：查询出部门人数大于5人的部门
分析：需要给count(ename)加条件，此时在本查询中不能使用where，可以使用HAVING

范例：查询出部门平均工资大于2000的部门



注意：现在可以做学员练习题了



4. 子查询
1.子查询
在一个查询的内部还包括另一个查询，则此查询称为子查询。
Sql的任何位置都可以加入子查询。

范例：查询比7654工资高的雇员
分析：查询出7654员工的工资是多少，把它作为条件


所有的子查询必须在“（）”中编写
子查询在操作中有三类：
单列子查询：返回的结果是一列的一个内容
单行子查询：返回多个列，有可能是一个完整的记录
多行子查询：返回多条记录

范例：查询出比雇员7654的工资高，同时从事和7788的工作一样的员工

范例：要求查询每个部门的最低工资和最低工资的雇员和部门名称

在返回多条记录的子查询可以把它的结果集当做一张表，给起个别名， 如图中的a。

范例：查询出每个部门最低工资的员工

2. exists和not exists关键字
exists （sql 返回结果集为真） 
not exists (sql 不返回结果集为真）

范例：查询出有员工的部门有哪些？


范例：查询出没有员工的部门


3.Insert中加入子查询
语法：
Insert into 表名(列1,列2，列3,….)
Select 列1,列2，列3,….
From 表名
Where条件

注意:
1.此时不要写values
2.插入的列名与查询的列名要一致

4.Update与子查询

5.Delete与子查询

5. Rownum与分页查询
ROWNUM:表示行号，实际上此是一个列,但是这个列是一个伪列,此列可以在每张表中出现。
范例：查询emp表带有rownum列
select rownum, t.* from emp t

我们可以根据rownum来取结果集的前几行，比如前5行

但是我们不能取到中间几行，因为rownum不支持大于号，只支持小于号，如果想		实现我们的需求怎么办呢？答案是使用子查询，也正是oracle分页的做法。
第一种写法：
select *
  from (select rownum rm, a.* from (select * from emp) a where rownum < 11) b where b.rm > 5
第二种写法：
select * 
from (select rownum r ,emp.* from emp) b
where b.r >5 and b.r <11
6.视图
视图就是封装了一条复杂查询的语句。
语法1.：CREATE VIEW 视图名称 AS 子查询
范例：建立一个视图，此视图包括了20部门的全部员工信息
create view empvd20 as select * from emp t where t.deptno = 20
视图创建完毕就可以使用视图来查询，查询出来的都是20部门的员工

语法2：CREATE OR REPLACE VIEW 视图名称 AS 子查询
如果视图已经存在我们可以使用语法2来创建视图，这样已有的视图会被覆盖。
create or replace view empvd20 as select * from emp t where t.deptno = 20

那么视图可以修改吗？


我们尝试着修改视图但是发现是视图所查询的表的字段值被修改了。所以我们一般不会去修改视图。
我们可以设置视图为只读。
语法3：CREATE OR REPLACE VIEW 视图名称 AS 子查询 WITH READ ONLY
create or replace view empvd20 as select * from emp t where t.deptno = 20 with read only


7.索引
索引是用于加速数据存取的数据对象。合理的使用索引可以大大降低i/o 次数,从而
提高数据访问性能。索引有很多种我们主要介绍常用的几种:
为什么添加了索引之后，会加快查询速度呢？
图书馆：如果杂乱地放书的话检索起来就非常困难,所以将书分类，然后再建一个箱子，箱
子里面放卡片，卡片里面可以按类查询,按书名查或者类别查,这样的话速度会快很多很多，
这个就有点像索引。索引的好处就是提高你找到书的速度，但是正是因为你建了索引，就应该有人专门来维护索引，维护索引是要有时间精力的开销的，也就是说索引是不能乱建的，所以建索引有个原则：如果有一个字段如果不经常查询，就不要去建索引。现在把书变成我们的表，把卡片变成我们的索引，就知道为什么索引会快，为什么会有开销。
创建索引的语法：
创建索引：
1． 单列索引
单列索引是基于单个列所建立的索引，比如:
CREATE index 索引名  on 表名(列名)
2． 复合索引
复合索引是基于两个列或多个列的索引。在同一张表上可以有多个索引，但是
要求列的组合必须不同,比如：
Create index emp_idx1 on emp(ename,job);
Create index emp_idx1 on emp(job,ename);

范例：给person表的name建立索引
create index pname_index on person(name);
范例：给person表创建一个name和gender的索引
	create index pname_gender_index on person(name, gender);
3.  索引重建
   1.索引重建的必要性

   2.索引重建的语法

索引的使用原则：
在大表上建立索引才有意义
在where子句后面或者是连接条件上的字段建立索引(经常使用的列才建索引)
索引的层次不要超过4层

原理参考：二叉树  BTree  B+树
参考网址：http://blog.csdn.net/kennyrose/article/details/7532032

8.PL/SQL
procedure [prə'siːdʒə] n. 程序，手续；步骤
language ['læŋgwɪdʒ] n. 语言；语言文字；表达能力
declare [dɪ'kleə] vt. 宣布，声明；断言，宣称vi. 声明，宣布
begin [bɪ'gɪn] vt. 开始

什么是PL/SQL?
PL/SQL（Procedure Language/SQL）
PLSQL是Oracle对sql语言的过程化扩展，指在SQL命令语言中增加了过程处理语句（如分支、循环等），使SQL语言具有过程处理能力。把SQL语言的数据操纵能力与过程语言的数据处理能力结合起来，使得PLSQL面向过程但比过程语言简单、高效、灵活和实用。
范例1：为职工涨工资，每人涨10％的工资。
update emp set sal=sal*1.1
范例2：例2: 按职工的职称长工资,总裁涨1000元,经理涨800元，其他人员涨400元。
这样的需求我们就无法使用一条SQL来实现，需要借助其他程序来帮助完成，也可以使用pl/sql。
1.pl/sql程序语法
程序语法：
declare
      说明部分    （变量说明，游标申明，例外说明 〕 
begin
      语句序列   （DML语句〕… 
exception
      例外处理语句   
End;
2.常量和变量定义
在程序的声明阶段可以来定义常量和变量。
变量的基本类型就是ORACLE中的建表时字段的变量如char, varchar2, date, number, boolean, long
定义语法：varl  char(15); 
		Psal  number(9,2);
说明变量名、数据类型和长度后用分号结束说明语句。
常量定义：married   constant boolean:=true
引用变量
Myname  emp.ename%type;
引用型变量，即my_name的类型与emp表中ename列的类型一样
在sql中使用into来赋值
declare emprec emp.ename%type;
begin
  select t.ename into emprec from emp t where t.empno = 7369;
  dbms_output.put_line(emprec);
end;
将查询到的语句赋值给emprec
记录型变量
Emprec  emp%rowtype 代表一行
记录变量分量的引用
emp_rec.ename:='ADAMS'; 
declare
  p emp%rowtype;
begin
  select * into p from emp t where t.empno = 7369;
  dbms_output.put_line(p.ename || ' ' || p.sal);
end;
注意   := 赋值符号等价于java中的=号;
	= 逻辑等,判断两个值是否相等,等价于java中的==号
3. if分支
语法1：
IF   条件  THEN
 语句1;
       语句2; 
       END IF;
语法2：
IF  条件  THEN
  语句序列1；   
       ELSE   
语句序列 2；
       END   IF； 
语法3：
IF   条件  THEN 语句;
ELSIF  条件  THEN  语句;
ELSIF  条件  THEN  语句;
…
ELSE  语句;
END  IF; 
范例1：如果从控制台输入1则输出我是1
accept num prompt ‘请输入一个数字’;
declare
  pnum number := &num;
begin
  if pnum = 1 then
    dbms_output.put_line('我是1');
  end if;
end;
&代表地址符,意思是指向num的值
接收的是字符串类型,此处会发生类型转换

范例3:判断人的不同年龄段18岁以下是未成年人，18岁以上40以下是成年人，40以上是老年人
accept num prompt ‘请输入一个年龄’;
declare
  mynum number := &num;
begin
  if mynum < 18 then
    dbms_output.put_line('未成年人');
  elsif mynum >= 18 and mynum < 40 then
    dbms_output.put_line('中年人');
  elsif mynum >= 40 then
    dbms_output.put_line('老年人');
  end if;
end;

4.LOOP [luːp]循环语句
其中语法2比较常用
语法1：
WHILE  条件  LOOP
.. .
total : = total + salary;
END  LOOP; 
语法2：
Loop
EXIT  when   条件;
……
End loop
语法3：
FOR   I   IN   1 . . 3    LOOP
语句序列 ;
END    LOOP ; 
范例:使用语法1输出1到10的数字
declare
  step number := 1;
begin
  while step <= 10 loop
    dbms_output.put_line(step);
    step := step + 1;
  end loop;
end;


Oracle应用开发实战
1.oracle介绍
	ORACLE数据库系统是美国ORACLE公司（甲骨文）提供的以分布式数据库为核心的一组软件产品，是目前最流行的客户/服务器(CLIENT/SERVER)或B/S体系结构的数据库之一。比如SilverStream就是基于数据库的一种中间件。ORACLE数据库是目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系数据库，它是一个完备关系的产品；作为分布式数据库它实现了分布式处理功能。但它的所有知识，只要在一种机型上学习了ORACLE知识，便能在各种类型的机器上使用它。
2.oracle10g安装
参考：下的安装说明书。
1.解压oracle数据库安装包，如果是win7或者win8系统右键点击setup.exe选择兼容性，以xp方式，并且以管理员方式运行，以及其他所有用户都按着此规则如图


2.并双击解压目录下的setup.exe，出现安装界面，如下：


3.输入口令和确认口令，如：password，点击下一步，出现如下进度条，
注：此口令即是管理员密码。

4.检查先决条件，选中红框所示的选择框，如下图：


5.点击“下一步”，出现“概要”界面，点击“安装”。

6.出现安装进度条，等待安装完成，如下图：


7.安装完成后，自动运行配置向导，如下图，等待其完成：


8.完成后，出现“口令管理”界面，点击“口令管理”，如下图：


9.将SCOTT和HR用户的沟去掉（解锁这两个账户），如下图所示，点击“确定”：

10.回到“口令管理”界面，点击“确定”，如下图：



11.安装结束，点击“退出”。


1.登录
运行cmd进入命令行
Sqlplus 用户名/密码@ip地址:1521/orcl [as sysdba]

如果是超级管理员需要在用户名/密码后面加上 as sysdba,是以系统管理员的身份来登录的，如图。

如果是普通用户不需要as sysdba

2.查看当前连接数据库的用户
		使用show user查看当前的用户
        
3.用户的切换
在登录的状态下输入：conn 用户名/密码 [as sysdba]
如图：
切换为超级管理员
          
切换为普通的用户

4.查看用户下的表
	为了防止命令行中数据展示表格错乱的情况可以设计行宽和列宽
	set  linesize 300;	每行展示300个字符
	Col 列名	 for  a[数字]，某一列占几个字符
在用户登录的情况下输入：select * from tab;

查看表中的数据
Col ename for a8
Col mgr for 9999
Col sal for 9999
Select * from emp;

如果使用dba用户登录查询该表无法查看到，因为sys用户下没有这个emp表

由于超级管理员的权限很大可以查看Scott用户下的表
可以使用select * from [用户名].[表名] 来查看某用户下的表的数据

5.查看表的结构
Desc 表名

Number(4)	最大长度为4为的数值类型
Varchar2(10)	最大长度为10的字符串，varchar2用于存储可变长度的字符串，.varchar2把所有字符都占两字节处理(一般情况下)，varchar只对汉字和全角等字符占两字节，数字，英文字符等都是一个字节，VARCHAR2把空串等同于null处理，而varchar仍按照空串处理；建议在oracle中使用varchar2
Number(7,2)	数值类型整数位占5位，小数位占2位，一共7位。
Date			时间类型

3.PLSQL Developer安装
傻瓜式安装即可，不建议汉化，最后会提示输入序列号，打开plsql-sn.txt复制序列号，输入即可。重要提示：不要把plsql developer安装在有括号的目录下，否则会出现连不上数据库的情况，安装目录也不要出现中文。

Plsql developer是最好用也是公司里面大量使用的数据库图形化工具，功能十分强大，在开发人员中广受欢迎，基本上是使用oracle数据库的必备神器。Oracle支持命令行方式操作，在实际的开发中很少使用命令行，绝大多数使用图形化的工具Plsql developer




4.Oracle体系结构
数据库：
Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。
实例：  
一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构（Memory Structures)组成。一个数据库可以有n个实例。
用户：
用户是在实例下建立的。不同实例可以建相同名字的用户。
表空间：
        
	表空间是Oracle对物理数据库上相关数据文件（ORA或者DBF文件）的逻辑映射。一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构。每个数据库至少有一个表空间(称之为system表空间)。

每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件(datafile)。一个数据文件只能属于一个表空间。

数据文件（dbf、ora）:
        数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。

注：     表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。

由于oracle的数据库不是普通的概念，oracle是有用户和表空间对数据进行管理和存放的。但是表不是有表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！




5.创建表空间
表空间？  ORACLE数据库的逻辑单元。  数据库---表空间   一个表空间可以与多个数据文件（物理结构）关联
一个数据库下可以建立多个表空间，一个表空间可以建立多个用户、一个用户下可以建立多个表。



create tablespace itcast001
datafile 'c:\itcast001.dbf'
size 100m
autoextend on
next 10m

itcast 为表空间名称
datafile  指定表空间对应的数据文件  
size  后定义的是表空间的初始大小
autoextend on  自动增长 ，当表空间存储都占满时，自动增长
next 后指定的是一次自动增长的大小。
6.用户
1创建用户
create user itcastuser
identified by itcast
default tablespace itcast001
identified by  后边是用户的密码  
default tablespace 后边是表空间名称
oracle数据库与其它数据库产品的区别在于，表和其它的数据库对象都是存储在用户下的。
2用户赋权限
新创建的用户没有任何权限，登陆后会提示

Oracle中已存在三个重要的角色：connect角色，resource角色，dba角色。
CONNECT角色： --是授予最终用户的典型权利，最基本的
        ALTER SESSION --修改会话
        CREATE CLUSTER --建立聚簇
        CREATE DATABASE LINK --建立数据库链接
        CREATE SEQUENCE --建立序列
        CREATE SESSION --建立会话
        CREATE SYNONYM --建立同义词
        CREATE VIEW --建立视图
  RESOURCE角色： --是授予开发人员的
        CREATE CLUSTER --建立聚簇
        CREATE PROCEDURE --建立过程
        CREATE SEQUENCE --建立序列
        CREATE TABLE --建表
        CREATE TRIGGER --建立触发器
        CREATE TYPE --建立类型

DBA角色：拥有全部特权，是系统最高权限，只有DBA才可以创建数据库结构，并且系统权限也需要DBA授出，且DBA用户可以操作全体用户的任意基表，包括删除

grant dba to itcastuser

进入system用户下给用户赋予dba权限，否则无法正常登陆
3中文乱码问题解决
1.查看服务器端编码
select userenv('language') from dual;
我实际查到的结果为:AMERICAN_AMERICA.ZHS16GBK
2.执行语句 select * from V$NLS_PARAMETERS 
查看第一行中PARAMETER项中为NLS_LANGUAGE 对应的VALUE项中是否和第一步得到的值一样。
如果不是，需要设置环境变量.
否则PLSQL客户端使用的编码和服务器端编码不一致,插入中文时就会出现乱码.
3.设置环境变量
计算机->属性->高级系统设置->环境变量->新建
设置变量名:NLS_LANG,变量值:第1步查到的值， 我的是
	SIMPLIFIED CHINESE_CHINA.ZHS16GBK

4.重新启动PLSQL,插入数据正常

7.Oracle数据类型
1.oracle 数据类型 




2.常用的数据类型
No	数据类型	描述
1	Varchar， varchar2	表示一个字符串
2	NUMBER	NUMBER(n)表示一个整数，长度是n
		NUMBER(m,n):表示一个小数，总长度是m，小数是n，整数是m-n
Number(10,2):整数部分占 8 位，小数部分占2份
3	DATE	表示日期类型   
4	CLOB	大对象，表示大文本数据类型，可存4G
5	BLOB	大对象，表示二进制数据，可存4G
8.表的管理
1建表
语法：

Create table 表名（
字段1	数据类型	[default 默认值],
字段2	数据类型	[default 默认值],
...
字段n	数据类型	[default 默认值]
）;
范例：创建person表
create table person(
       pid      number(10),
       name     varchar2(10),
       gender   number(1)  default 1,
       birthday date
);

insert into person(pid, name, gender, birthday)
values(1, '张三', 1, to_date('1999-12-22', 'yyyy-MM-dd'));
2.表删除
语法：DROP TABLE 表名
3.表的修改
在sql中使用alter可以修改表
添加语法：ALTER TABLE 表名称 ADD(列名1 类型 [DEFAULT 默认值]，列名1 类型 [DEFAULT 默认值]...)
修改语法：ALTER TABLE 表名称 MODIFY(列名1 类型 [DEFAULT 默认值]，列名1 类型 [DEFAULT 默认值]...)
修改列名: ALTER TABLE 表名称 RENAME COLUMN 列名1 TO 列名2
范例：在person表中增加列address
alter table person add(address varchar2(10));
范例：把person表的address列的长度修改成20长度
alter table person modify(address varchar2(20));
4.截断表
在person表中使用delete语句删除数据，则可以使用rollback来回滚，如果想要清空一张表的数据，同时不想回滚可以立即释放资源需要使用截断表的语法
语法：TRUNCATE TABLE 表名
范例：截断person表
truncate table person;

5.数据库表数据的更新
1.INSERT（增加）
语法：
INSERT  INTO表名[(列名1，列名2，...)]VALUES(值1，值2，...)
标准写法

简单写法（不建议）
INSERT  INTO 表名VALUES(值1，值2，...)
insert into person
values(1,'张三',1,'9-5月-1981','北京北七家');
注意：使用简单的写法必须按照表中的字段的顺序来插入值，而且如果有为空的字段使用null
insert into person
values(2,'李四',1,null,'北京育新');
2.事务
这是因为oracle的事务对数据库的变更的处理，我们必须做提交事务才能让数据真正的插入到数据库中，在同样在执行完数据库变更的操作后还可以把事务进行回滚，这样就不会插入到数据库。如果事务提交后则不可以再回滚。
提交：commit
回滚：rollback

1.事务保存点与回滚：
语法：
savepoint  保存点名字
示例：
savepoint a1;    --设置一个保存点 a1;
update person set name='张三' where pid='101'  --修改一条数据
savepoint a2;   --设置一个保存点 a1;
update tmp set name='李四' where id='102  --再修改一条数据
 
rollback to a2;   --回滚到a2 保存点。 此时在 a2 保存点之后的所有数据修改视为无效。
rollback to a1;   --这里可以再从a2保存点再回滚到a1 保存点。 此时在 a1 保存点之后的所有数据修改视为无效。
rollback;           --回滚全部。即撤消至上一次提交事务后的所有数据修改。
commit;  --提交事务 将回滚后的事务提交，并会删除所有保存点。
注意：我们可以从a2向前再回滚到a1 ，但无法从a1回滚到a2。也就是只能向前回滚，不能从前面的点再向后回滚！ 

2．事务的隔离级别：
事务的隔离性是什么？
事务隔离级别有哪些？
Oracle支持的隔离级别是什么？
3.UPDATE（修改）
全部修改：UPDATE 表名 SET 列名1=值1，列名2=值2，....
局部修改：UPDATE 表名 SET 列名1=值1，列名2=值2，....WHERE 修改条件；
全部更新

局部更新

4.DELETE（删除）
语法 : DELETE FROM 表名	WHERE	删除条件;


在删除语句中如果不指定删除条件的话就会删除所有的数据

Truncate table实现数据删除

比较truncat与delete实现数据删除？
1.delete删除的数据可以rollback,也可以闪回
2.delete删除可能产生碎片，并且不释放空间
3.truncate是先摧毁表结构，再重构表结构

4.通过闪回实现数据恢复
1.闪回的原理

2.闪回的实现方式
3.闪回的注意事项

5. 碎片问题的思考
1.什么是碎片

2.碎片的产生
3.碎片问题的避免与解决

9.序列
在很多数据库中都存在一个自动增长的列,如果现在要想在oracle 中完成自动增长的功能, 则只能依靠序列完成,所有的自动增长操作,需要用户手工完成处理。
语法：CREATE SEQUENCE 序列名 
[INCREMENT BY n] 
[START WITH n] 
[{MAXVALUE/ MINVALUE n|NOMAXVALUE}] 
[{CYCLE|NOCYCLE}] 
[{CACHE n|NOCACHE}];
范例:创建一个seqpersonid的序列,验证自动增长的操作
CREATE SEQUENCE seqpersonid;
序列创建完成之后,所有的自动增长应该由用户自己处理,所以在序列中提供了以下的两种操作：
nextval :取得序列的下一个内容
currval :取得序列的当前内容
select seqpersonid.nextval from dual;
select seqpersonid.currval from dual;
在插入数据时需要自增的主键中可以这样使用

在实际项目中每一张表会配一个序列，但是表和序列是没有必然的联系的，一个序列被哪一张表使用都可以，但是我们一般都是一张表用一个序列。
序列的管理一般使用工具来管理。

10.约束
在数据库开发中，约束是必不可少，使用约束可以更好的保证数据的完整性。
1.主键约束
主键约束都是在id上使用，而且本身已经默认了内容不能为空，可以在建表的时候指定。
创建一张表，把pid作为主键
create table person(
       pid      number(10) primary key,
       name     varchar2(10),
       gender   number(1)  default 1,
       birthday date
);
主键不可重复， SCOTT.SYS_C0017981是系统自动分配的约束的名字

主键不可为空

我们可以自己来指定主键约束的名字
create table person(
       pid      number(10),
       name     varchar2(10),
       gender   number(1)  default 1,
       birthday date,
       constraint person_pk_pid primary key(pid)
);

2.非空约束
使用非空约束，可以使指定的字段不可以为空。
范例：建立一张pid和name不可以为空的表
create table person(
       pid      number(10) not null,
       name     varchar2(10) not null,
       gender   number(1)  ,
       birthday date,
);

3.唯一约束（unique）
表中的一个字段的内容是唯一的
范例：建表一个name是唯一的表
create table person(
       pid      number(10) ,
       name     varchar2(10) unique,
       gender   number(1)  ,
       birthday date
);

唯一约束的名字也可以自定义
create table person(
       pid      number(10) ,
       name     varchar2(10),
       gender   number(1)  ,
       birthday date,
       constraint person_name_uk unique(name)
);

4.检查约束
使用检查约束可以来约束字段值的合法范围。
范例：创建一张表性别只能是1或2
create table person(
       pid      number(10) ,
       name     varchar2(10),
       gender   number(1)  check(gender in (1, 2)),
       birthday date
);

检查约束也可以自定义
create table person(
       pid      number(10) ,
       name     varchar2(10),
       gender   number(1),
       birthday date,
       constraint person_gender_ck check(gender in (1,2))
);

5.外键约束
之前所讲的都是单表的约束，外键是两张表的约束，可以保证关联数据的完整性。
范例：创建两张表，一张订单表，一张是订单明细表，订单和明细是一对多的关系
create table orders(
       order_id      number(10) ,
       total_price   number(10,2),
       order_time date,
      constraint orders_order_id_pk primary key(order_id)
);

create table order_detail(
       detail_id      number(10) ,
       order_id   number(10),
       item_name  varchar2(10),
       quantity   number(10),
      constraint order_detail_detail_id_pk primary key(detail_id)
);

insert into orders values(1, 200, to_date('2015-12-12','yyyy-MM-dd'));
insert into order_detail values(1, 2, 'java',1);
我们在两张表中插入如上两条数据，我们发现在order_detail表中插入的order_id在order表中并不存在，这样在数据库中就产生了脏数据。此时需要外键来约束它。

我们再次建表
create table orders(
       order_id      number(10) ,
       total_price   number(10,2),
       order_time date,
      constraint orders_order_id_pk primary key(order_id)
);

create table order_detail(
       detail_id      number(10) ,
       order_id   number(10),
       item_name  varchar2(10),
       quantity   number(10),
      constraint order_detail_detail_id_pk primary key(detail_id),
      constraint order_detail_order_id_fk foreign key(order_id) references orders(order_id)
);



外键关联一定注意：
外键一定是主表的主键
删表时一定先删子表再删主表，如果直接删主表会出现由于约束存在无法删除的问题

但是可以强制删除drop table orders cascade constraint;(不建议)
删除主表的数据可以先删除子表的关联数据，再删主表，也可以使用级联删除。
级联删除在外键约束上要加上on delete cascade 如
constraint order_detail_order_id_fk foreign key(order_id) 
      references orders(order_id) on delete cascade
这样删除主表数据的时候会把字表的关联数据一同删除



11.Scott用户下的表结构






12. sql
1.sql简介
	结构化查询语言(Structured Query Language)简称SQL(发音：/ˈɛs kjuː ˈɛl/ "S-Q-L")，结构化查询语言是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。

DML(数据库操作语言): 其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。
DDL(数据库定义语言): 其语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。
DCL(数据库控制语言):它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户    	组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。
2.简单查询
1.查询语法
Select * |列名 from 表名



2.别名用法
在查询的结果列中可以使用别名
Select  列名 别名，列名别名，... from emp;

3.消除重复的数据
Select distinct *|列名, ... from emp; 

使用distinct可以消除重复的行，如果查询多列的必须保证多列都重复才能去掉重复
4.字符串连接查询
Mysql中实现方法：



查询雇员编号，姓名，工作
编号是：7369的雇员， 姓名是：smith，工作是：clerk

字符串的连接使用‘||’
5.查询中四则运算
查询每个雇员的年薪
select ename, sal*12 from emp;
select ename, sal*12 income from emp;

Sql中支持四则运算“+，-，*，/”

3. 条件查询
在查询绝大多数都会有条件的限制
语法：select *|列名 from 表名 where 条件
例如：查询工资大于1500的所有雇员

1.非空和空的限制
示例：查询每月能得到奖金的雇员
分析：只要字段中存在内容表示不为空，如果不存在内容就是null，
语法：列名 IS NOT NULL
为空  列名 IS NULL


范例：查询工资大于1500并且有奖金领取的雇员
分析：多个查询条件同时满足之间使用‘AND’

范例:查询工资大于1500或者有奖金的雇员
分析：多个查询条件或满足，条件之间使用“OR”

范例：查询工资不大于1500和没有奖金的人
语法：NOT(查询条件)

2.范围限制
范例：基本工资大于1500但是小于3000的全部雇员
分析：sal>1500, sal<3000

Between  and等于 sal > =1500 and sal <= 3000

范例：查询1981-1-1到1981-12-31号入职的雇员
分析：between and 不仅可以使用在数值之间，也可以用在日期的区间

范例：查询雇员名字叫smith的雇员
在oracle中的查询条件中查询条件的值是区分大小写的


范例:查询雇员编号是7369,7499,7521的雇员编号的具体信息
如果使用之前的做法可以使用OR关键字

实际上，此时指定了查询范围，那么sql可以使用IN关键字
语法: 列名 IN (值1，值2，....)
	 列名 NOT IN (值1， 值2，...)
其中的值不仅可以是数值类型也可以是字符串


范例:查询雇员姓名是’SMITH’,’ALLEN’,’WARD’的雇员具体信息

3．模糊查询
在常用的站点中经常会有模糊查询，即：输入一个关键字，把符合的内容全部的查询出来，在sql中使用LIKE语句完成。
在LIKE中主要使用以下两种通配符
“%”：可以匹配任意长度的内容
“_”:可以匹配一个长度的内容
范例：查询出所有雇员姓名中第二个字符包含“M”的雇员

在LIKE中如果没有关键字表示查询全部

查询名字中带有“M”的雇员

在oracle中不等号的用法可以有两种形式“<>”和“!=”
范例：查询雇员编号不是7369的雇员信息


6.对结果集排序
1.排序的语法
在sql中可以使用ORDER BY对查询结果进行排序
语法：SELECT * |列名 FROM 表名 {WEHRE 查询条件} ORDER BY 列名1 ASC|DESC，列名2...ASC|DESC
范例：查询雇员的工资从低到高
分析：ORDER BY 列名 默认的排序规则是升序排列，可以不指定ASC，如果按着降序排列必须指定DESC



如果存在多个排序字段可以用逗号分隔

注意ORDER BY语句要放在sql的最后执行。

2.排序中的空值问题

排序  order by  经验：当排序时存在null时就会产生问题  nulls first ,  nulls last
--查询雇员的工资从低到高
select * from emp order by sal nulls first;

select * from emp order by sal desc nulls last ;

13.函数
1.字符函数
接收字符输入返回字符或者数值，dual是伪表
1.把小写的字符转换成大小的字符
upper('smith')

2.把大写字符变成小写字符
lower('SMITH')

3.把首字符大写
initcap('smith')

4.字符串的连接可以使用concat可以使用“||”建议使用“||”
concat('hello', 'world')

5.字符串的截取，使用substr，第一个参数是源字符串，第二个参数是开始索引，第三个参数长度，开始的索引使用1和0效果相同
substr('hello', 1,3)

6.获取字符串的长度
length('hello')

7.字符串替换，第一个参数是源字符串，第二个参数被替换的字符串，第三个是替换字符串
replace('hello', 'l','x')

2.数值函数
1.四舍五入函数：ROUND()
默认情况下ROUND四舍五入取整，可以自己指定保留的位数。


2.取整：TRUNC()，默认全部去掉小数，也可以指定保留的位数


3.取余数MOD()

3.日期函数
Oracle中提供了很多和日期相关的函数，包括日期的加减，在日期加减时有一些规律
日期 – 数字 = 日期
日期 + 数字 = 日期
日期 – 日期 = 数字
1.范例：查询雇员的进入公司的周数。
分析：查询雇员进入公司的天数(sysdate – 入职日期)/7就是周数

2.获得两个时间段中的月数：MONTHS_BETWEEN()
范例：查询所有雇员进入公司的月数

3.获得几个月后的日期：ADD_MONTHS()
范例：求出三个月后的日期

4.转换函数
1.	TO_CHAR:字符串转换函数
	范例：查询所有的雇员将将年月日分开，此时可以使用TO_CHAR函数来拆分
	拆分时需要使用通配符
	年：y, 年是四位使用yyyy
	月：m, 月是两位使用mm
	日：d,	日是两位使用dd

在结果中10以下的月前面被被补了前导零，可以使用fm去掉前导零

TO_CHAR还可以给数字做格式化
范例：把雇员的工资按三位用“,”分隔，在oracle中“9”代表一位数字

如果在钱的前面加上国家的符号可以使用“$”代表是美元，如果要使用本地的钱的单位使用“L”


2.	TO_NUMBER:数值转换函数
	TO_NUMBER可以把字符串转换成数值
	
3.   TO_DATE:日期转换函数
	TO_DATE可以把字符串的数据转换成日期类型
	
5.通用函数
1．空值处理nvl
范例：查询所有的雇员的年薪

我们发现很多员工的年薪是空的，原因是很多员工的奖金是null，null和任何数值计算都是null，这时我们可以使用nvl来处理。

2.Decode函数
该函数类似if....else if...esle
语法：DECODE(col/expression, [search1,result1],[search2, result2]....[default])
Col/expression:列名或表达式
Search1，search2...:用于比较的条件
Result1, result2...:返回值
如果col/expression和Searchi匹配就返回resulti,否则返回default的默认值

范例：查询出所有雇员的职位的中文名

3.case when
CASE expr WHEN comparison_expr1 THEN return_expr1
         [WHEN comparison_expr2 THEN return_expr2
          WHEN comparison_exprn THEN return_exprn 
          ELSE else_expr]
END
select t.empno,
       t.ename,
       case
         when t.job = 'CLERK' then
          '业务员'
         when t.job = 'MANAGER' then
          '经理'
         when t.job = 'ANALYST' then
          '分析员'
         when t.job = 'PRESIDENT' then
          '总裁'
         when t.job = 'SALESMAN' then
          '销售'
          else 
            '无业'
       end
  from emp t



6.聚合函数
1.统计记录数count()
范例：查询出所有员工的记录数

不建议使用count(*)，可以使用一个具体的列以免影响性能。

2.最小值查询min()
范例：查询出来员工最低工资


3.最大值查询max()
范例：查询出员工的最高工资

4.查询平均值avg()
范例：查询出员工的平均工资

5.求和函数sum()
范例：查询出20号部门的员工的工资总和


14.集合操作
1.并集
UNION
UNION ALL

2.交集
INTERSECT

3.差集
MINUS

4.集合操作的注意事项总结



一、将文件win32_11gR2_database_1of2.zip和win32_11gR2_database_2of2.zip解压。
注意：这两个文件解压到同一个目录下，即：将Components目录合并到一起

二、双击“setup.exe”，弹出以下安装向导。去掉“I wish to receive security updates via My Oracle Support”复选框，点击“Next”


三、在如下对话框中，点解“Yes”


四、选择“Create and configure a database”，点击“Next”

五、选择“Desktop Class”，点击“Next”


六、在配置页面上，输入管理员密码，比如“password”，点击“Next”

七、验证先决条件

八、出现概要界面，点击“Finish”


九、安装Oracle，等待完成。

十、安装完成，创建数据库实例，等待完成。


十一、安装完成，点击“Password Management”


十二、找到HR和SCOTT用户，去掉“Lock Account”的勾，并赋予新的密码，点击“OK”

	



十三、点击“Yes”


十四、点击“OK”


十五、点击“Close”，完成安装

十六、Oracle SQL Developer

Oracle 10G安装指导

1、解压文件10201_database_win32.zip，并双击解压目录下的setup.exe，出现安装界面，如下：


2、输入口令和确认口令，如：password，点击下一步，出现如下进度条，
注：此口令即是管理员密码。

3、检查先决条件，选中红框所示的选择框，如下图：


4、点击“下一步”，出现“概要”界面，点击“安装”。

5、出现安装进度条，等待安装完成，如下图：


6、安装完成后，自动运行配置向导，如下图，等待其完成：


7、完成后，出现“口令管理”界面，点击“口令管理”，如下图：


8、将SCOTT和HR用户的沟去掉（解锁这两个账户），如下图所示，点击“确定”：

9、回到“口令管理”界面，点击“确定”，如下图：



10、安装结束，点击“退出”。




第1章Hibernate_day01
今日任务
使用Hibernate完成对客户的CRUD的操作
教学导航
教学目标	掌握Hibernate的执行流程
独立使用Hibernate的完成对客户的CRUD的操作
教学方法	案例驱动法
案例一：完成客户的CRUD的操作
案例需求:
需求描述
CRM系统中客户信息管理模块功能包括：
新增客户信息
客户信息查询
修改客户信息
删除客户信息

本功能要实现新增客户，页面如下：

相关知识点：
CRM的概述
什么是CRM
CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程。其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理。
CRM的功能模块
	CRM系统实现了对企业销售、营销、服务等各阶段的客户信息、客户活动进行统一管理。
CRM系统功能涵盖企业销售、营销、用户服务等各各业务流程，业务流程中与客户相关活动都会在CRM系统统一管理，下边列出一些基本的功能模块，包括：客户信息管理、联系人管理、商机管理、统计分析等。


客户信息管理
对客户信息统一维护，客户是指存量客户或拟营销的客户，通过员工录入形成公司的“客户库”是公司最重要的数据资源。
联系人管理
对客户的联系人信息统一管理，联系人是指客户企业的联系人，即企业的业务人员和客户的哪些人在打交道。
客户拜访管理：
业务员（用户）要开发客户需要去拜访客户，客户拜访信息记录了业务员与客户沟通交流方面的不足、采取的策略不当、有待改进的地方或值得分享的沟通技巧等方面的信息。
综合查询
客户相关信息查询，包括：客户信息查询、联系人信息查询、商机信息查询等。
统计分析
按分类统计客户信息，包括：客户信息来源统计、按行业统计客户、客户发展数量统计等。
系统管理
系统管理属于crm系统基础功能模块，包括：数据字典、账户管理、角色管理、权限管理、操作日志管理等。
EE开发三层结构

Hibernate的概述
什么是框架
框架是软件的半成品,已经完成了相应部分的内容了.只需要实现自己业务即可.
什么是Hibernate

Hibernate就是一个持久层的ORM的框架.
ORM	:Object Relational Mapping.对象关系映射.
Hibernate的优点
简化JDBC的编程.
修改了实体类，不需要修改源代码.
轻量级的框架.
Hibernate的入门:
下载Hibernate5
http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download
创建表
Create database hibernate_day01;
Use hibernate_day01;
CREATE TABLE `cst_customer` (
  `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)',
  `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)',
  `cust_user_id` bigint(32) DEFAULT NULL COMMENT '负责人id',
  `cust_create_id` bigint(32) DEFAULT NULL COMMENT '创建人id',
  `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源',
  `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业',
  `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别',
  `cust_linkman` varchar(64) DEFAULT NULL COMMENT '联系人',
  `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话',
  `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话',
  PRIMARY KEY (`cust_id`)
) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8;
引入Hibernate的开发包
数据库驱动包:
Hibernate/lib/required/*
引入日志记录的包:
 
创建实体
public class Customer {
	private Long cust_id;
	private String cust_name;
	private Long cust_user_id;
	private Long cust_create_id;
	private String cust_source;
	private String cust_industry;
	private String cust_level;
	private String cust_linkman;
	private String cust_phone;
	private String cust_mobile;
...
}

创建映射
<hibernate-mapping>
	<!-- class标签用来创建 实体类和表的映射 -->
	<class name="com.itheima.domain.Customer" table="cst_customer">
		<!-- 设置表中的主键与类中的某个属性的映射 name是类中的属性名  column表中字段名 -->
		<id name="cust_id" column="cust_id">
			<!-- 只要是主键 需要有一个主键的生成策略： -->
			<generator class="native"/>
		</id>
		
		<!-- 非主键的属性都使用property标签配置映射  name是类中的属性名  column表中字段名 -->
		<property name="cust_name" column="cust_name"></property>
		<property name="cust_user_id" column="cust_user_id"></property>
		<property name="cust_create_id" column="cust_create_id"></property>
		<property name="cust_source" column="cust_source"></property>
		<property name="cust_industry" column="cust_industry"></property>
		<property name="cust_level" column="cust_level"></property>
		<property name="cust_linkman" column="cust_linkman"></property>
		<property name="cust_phone" column="cust_phone"></property>
		<property name="cust_mobile" column="cust_mobile"></property>
	</class>
</hibernate-mapping>
创建Hibernate的核心配置文件
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	
	<session-factory>
		<!-- 必须的配置 -->
		<!-- 配置连接数据库的基本的信息: -->
		<property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
		<property name="hibernate.connection.url">jdbc:mysql:///hibernate_day01</property>
		<property name="hibernate.connection.username">root</property>
		<property name="hibernate.connection.password">123</property>
		
		<!-- 数据库的方言: -->
		<property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
		
		<!-- Hibernate的可选项 -->
		
		<!-- 加载映射 -->
		<mapping resource="com/itheima/domain/Customer.hbm.xml"/>
	</session-factory>

</hibernate-configuration>
编写代码
public class HibernateDemo1 {

	@Test
	/**
	 * 使用Hibernate保存数据
	 */
	public void demo1(){
		// 1.加载配置文件:
		Configuration cfg = new Configuration().configure();
		// 2.创建一个SessionFactory:
		SessionFactory sessionFactory = cfg.buildSessionFactory();
		// 3.创建Session对象.Session对象 类似Connection.
		Session session = sessionFactory.openSession();
		// 4.开启事务:
		Transaction tx = session.beginTransaction();
		// 5.执行相关操作
		Customer customer = new Customer();
		customer.setCust_name("小王");
		customer.setCust_source("小广告");
		
		session.save(customer);
		// 6.事务提交
		tx.commit();
		// 7.释放资源
		session.close();
	}
}
Hibernate的常见配置:
映射文件的配置
是一个XML文件即可,通常命名 类名.hbm.xml
<class>标签

<id>标签:

<property>标签

核心配置
* 扩展：Hibernate的核心配置有两种方式:
    * 1.属性文件的方式:hibernate.properties
        * 属性文件的方式不能配置映射:
        * 通过手动编写代码方式加载映射:

    * 2.XML文件的方式:hibernate.cfg.xml
        * 一块:必须的配置:
            * 数据库连接信息:
            * 数据库方言:
        * 二块:可选的配置:
            * 显示SQL
            * 格式化SQL
            * hbm2ddl.auto
                * none				
                * create			:数据库有表,每次都会创建一个新的表.(测试时候)
                * create-drop		:每次都会创建一个新的表，用完之后就删除掉.(测试时候)
                * update			:如果数据库没有表，创建一个新表，如果有表，使用原有表.更新表结构
                * validate		:使用原有表，进行校验.
       * 三块:加载映射:
             <mapping resource="com/itheima/domain/Customer.hbm.xml"/>
Hibernate的相关API：
Configuration:加载配置文件.

SessionFactory

工具类:
public class HibernateUtils {

	private static final Configuration cfg;
	private static final SessionFactory sessionFactory;
	static{
		cfg = new Configuration().configure();
		sessionFactory = cfg.buildSessionFactory();
	}
	
	// 提供一个静态的方法获得session对象.
	public static Session openSession(){
		return sessionFactory.openSession();
	}
}

Session：

Session不是线程安全的.
是与数据库交互的桥梁:完成CRUD的操作:常用的方法:
* save(Object obj);
* update(Object obj);
* delete(Object obj);
* T get(Class c,Serializable s); 
* T load(Class c,Serializable s);
* saveOrUpdate(Object obj);
Transaction

* commit();
* rollback();
* wasCommitted(); // Hibernate3中提供了该方法.判断事务是否已经提交了.

代码实现:
引入页面:
* 引入页面
* 引入jstl的标签库
建包和类:

保存客户:



第1章Hibernate_day02
今日任务
案例一:使用Hibernate完成客户列表的显示
教学导航
教学目标	
教学方法	案例驱动法
案例一：使用Hibernate完成客户的列表显示.
案例需求:
需求描述
CRM系统中客户信息管理模块功能包括：
新增客户信息
客户信息查询
修改客户信息
删除客户信息

本功能要实现查询客户，页面如下：


相关知识点:
持久化类的编写规则
主键生成策略
持久化对象的三种状态
Hibernate管理对象包括三种状态：瞬时状态（Transient）、持久状态（Persistent）、托管状态（Detached），如下图：


1、transient 瞬时状态
new一个新的对象即为瞬时状态，瞬时状态和session没有关联，一个瞬时对象和数据库记录不对应。
瞬时对象--->save或saveOrUpadate---->持久对象。

2、persistent 持久状态
持久状态对象和session有关联，持久对象和数据库记录存在对应，持久对象属性值变更可以持久到数据库中。
执行Get查询可以得到一个持久对象。
持久对象--->delete删除--->瞬时对象
持久对象-->session.close（session关闭）--->托管对象 

3、detached 托管状态
托管对象和session没有关联，它和瞬时对象的区别在于托管对象可能会和数据库记录存在对应。
托管对象------>update或saveOrUpdate --->持久对象
一级缓存
什么是一级缓存
Hibernate框架中共有两级缓存. Session级别的缓存是属于一级缓存,SessionFactory级别的缓存是二级缓存.
缓存:将数据库或硬盘中的数据,存入到内存中.当下次使用的时候可以从内存中获得,减少数据库访问次数.(优化)

一级缓存：生命周期与session一致.
在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存. 只要 Session 实例没有结束生命周期, 存放在它缓存中的对象也不会结束生命周期.
当session的save()方法持久化一个对象时，该对象被载入缓存，以后即使程序中不再引用该对象，只要缓存不清空，该对象仍然处于生命周期中。当试图get()、 load()对象时，会判断缓存中是否存在该对象，有则返回，此时不查询数据库。没有再查询数据库
测试一级缓存:
	@Test
	// 证明一级缓存的存在.
	public void demo2() {
		// 创建session
		Session session = HibernateUtils.openSession();
		// 开启事务
		Transaction tx = session.beginTransaction();
		
		
		// 调用get方法的时候,查询.将查询的结果放入到一级缓存中.
		Customer c1 = (Customer) session.get(Customer.class, 1); // 发出sql语句,数据翻入一级缓存
		
		// 
		Customer c2 = (Customer)session.get(Customer.class, 1); // 不会发出sql,从一级缓存中获得对象.

		// session缓存对象的时候,缓存对象的地址.
		System.out.println(c1 == c2);
		
		tx.commit();
		session.close();
	}

一级缓存的深入:
持久化对象的更新会同步到数据库.

事务控制
什么是事务（了解）

什么是事务？ 
    当多个操作有这样的要求时：要么都成功要么都失败，这说明这多个操作必须在一个事务中，事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。
	
事务的四个特性？ 
A:原子性(Atomicity)  
事务中包括的诸操作要么全成功，要么全失败。
B:一致性(Consistency)      
事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
也就是说事务执行之前数据库数据处于正确状态，执行之后也处理正确状态，如果有些事务运行中发生故障，这些事务对数据库所做的修改有一部分已写入数据库，这时数据库就处于不正确的状态即不一致的状态。
一致性与原子性是密切相关的，如果事务没有原子性的保证，那么在发生系统故障的情况下，数据库就有可能处于不一致状态。
C:隔离性(Isolation)     
 一个事务的执行不能被其他事务干扰。解决多个线程并发操作事务情况，每个事务互相不影响
D:持续性/永久性(Durability) 
一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。

隔离级别（了解）

	ANSI SQL 标准定义了隔离级别,但并不是SQL数据库独有.JTA也定义了同样的隔离级别.级别越高,成本越高。

由事务隔离性引发几种问题 ？ 
	脏读、 不可重复读 、虚读 、 丢失更新 
脏读： 一个事务读取到另一个事务 未提交数据 
不可重复读： 一个事务中，先后读取两次，两次读取结果不同，读取到了另一个事务已经提交的数据，此问题针对update更新来说。
虚读： 一个事务，先后读取两次，结果不同，读取到了另一个事务已经提交的数据 ，此问题针对insert插入来说。
丢失更新： 两个事务 同时修改一条数据，后提交事务，覆盖了之前提交事务结果 


隔离级别	含义
READ_UNCOMMITTED	允许你读取还未提交的改变了的数据。可能导致脏、幻、不可重复读 
READ_COMMITTED	允许在并发事务已经提交后读取。可防止脏读，但幻读和 不可重复读仍可发生 
REPEATABLE_READ	对相同字段的多次读取是一致的，除非数据被事务本身改变。可防止脏、不可重复读，但幻读仍可能发生。 
SERIALIZABLE	完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。 

事务的隔离级别 ，是由数据库提供的 ，并不是所有数据库都支持四种隔离级别 
	MySQL : READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ、SERIALIZABLE （默认 REPEATABLE_READ）
	Oracle ： READ_UNCOMMITTED、READ_COMMITTED、 SERIALIZABLE
（默认 READ_COMMITTED ）


在使用数据库时候，隔离级别越高，安全性越高 ，性能越低 
	实际开发中，不会选择最高或者最低隔离级别，选择 READ_COMMITTED（oracle 默认）、REPEATABLE_READ (mysql默认)


Hibernate 如何设置隔离级别 ？ 
每个数据库连接都有默认的隔离级别,通常是读已提交或可重复读.可以通过数据库配置设置,也可在应用程序中设置.例如Hibernate:
hibernate.connection.isolation = 4 
1—Read uncommitted isolation
2—Read committed isolation
4—Repeatable read isolation
8—Serializable isolation

在hibernate.cfg.xml中设置隔离级别：

<!-- 事务隔离级别 -->
<property name="hibernate.connection.isolation">4</property>
事务处理的场合
企业级项目采用三层结构， 在业务层进行事务管理，一个service方法的模型如下：

service(){
	session.beginTransaction;//开启事务
	try{
	调用dao方法1
	调用dao方法2
	.....
    session.getTransaction().commit();//提交事务
	}catch(Exception ex){
		session.getTransaction().rollback();//回滚事务
	}
}
hibernate对 session的管理
Hibernate 5 自身提供了三种管理 Session 对象的方法
		Session 对象的生命周期与本地线程绑定
		Session 对象的生命周期与 JTA 事务绑定
		Hibernate 委托程序管理 Session 对象的生命周期

在 Hibernate 的配置文件中, hibernate.current_session_context_class 属性用于指定 Session 管理方式, 可选值包括
	thread: Session 对象的生命周期与本地线程绑定
	jta*: Session 对象的生命周期与 JTA 事务绑定
	managed: Hibernate 委托程序来管理 Session 对象的生命周期

在hibernate.cfg.xml中配置：
<!-- 配置session绑定本地线程 -->
		<property name="hibernate.current_session_context_class">thread</property>

hibernate提供sessionFactory.getCurrentSession()创建一个session和threadLocal绑定方法。

在HibernateUtil工具类中更改getCurrentSession方法：
	//获取当前线程绑定的会话
	public static Session getCurrentSession(){
		return sessionFactory.getCurrentSession();
	}
Hibernate的其他API
Query
Query执行HQL语句:
// 1.查询所有记录
		/*Query query = session.createQuery("from Customer");
		List<Customer> list = query.list();
		System.out.println(list);*/
		
		// 2.条件查询:
		/*Query query = session.createQuery("from Customer where name = ?");
		query.setString(0, "李健");
		List<Customer> list = query.list();
		System.out.println(list);*/
		
		// 3.条件查询:
		/*Query query = session.createQuery("from Customer where name = :aaa and age = :bbb");
		query.setString("aaa", "李健");
		query.setInteger("bbb", 38);
		List<Customer> list = query.list();
		System.out.println(list);*/
		
		// 4.分页查询:
		Query query = session.createQuery("from Customer");
		query.setFirstResult(3);
		query.setMaxResults(3);
		List<Customer> list = query.list();
		System.out.println(list);
Criteria
Criteria:用来执行条件查询
// 1.查询所有记录
		/*Criteria criteria = session.createCriteria(Customer.class);
		List<Customer> list = criteria.list();
		System.out.println(list);*/
		
		// 2.条件查询
		/*Criteria criteria = session.createCriteria(Customer.class);
		criteria.add(Restrictions.eq("name", "李健"));
		List<Customer> list = criteria.list();
		System.out.println(list);*/
		
		// 3.条件查询
		/*Criteria criteria = session.createCriteria(Customer.class);
		criteria.add(Restrictions.eq("name", "李健"));
		criteria.add(Restrictions.eq("age", 38));
		List<Customer> list = criteria.list();
		System.out.println(list);*/
		
		// 4.分页查询
		Criteria criteria = session.createCriteria(Customer.class);
		criteria.setFirstResult(3);
		criteria.setMaxResults(3);
		List<Customer> list = criteria.list();
		System.out.println(list);

SQLQuery
		//　基本查询
		/*SQLQuery sqlQuery = session.createSQLQuery("select * from cst_customer");
		List<Object[]> list = sqlQuery.list();
		
		for (Object[] objects : list) {
			System.out.println(Arrays.toString(objects));
		}*/
		
		SQLQuery sqlQuery = session.createSQLQuery("select * from cst_customer");
		// 封装到对象中
		sqlQuery.addEntity(Customer.class);
		List<Customer> list = sqlQuery.list();
		
		for(Customer customer:list){
			System.out.println(customer);
		}
案例实现:
环境搭建:
代码实现:

第1章Hibernate_day03
今日任务
案例一:使用Hibernate完成CRM的联系人的保存
操作
案例二:使用Hibernate完成CRM用户分配角色的操作
教学导航
教学目标	
教学方法	案例驱动法
案例一：完成CRM的联系人的保存操作
案例需求:
需求描述
一个客户对应多个联系人，单独在联系人管理模块中对联系人信息进行维护，功能包括：
添加联系人、修改联系人、删除联系人。
添加联系人：添加联系人时指定所属客户，添加信息包括联系人名称、联系电话等
修改联系人：允许修改联系人所属客户、联系人名称、联系人电话等信息
删除联系人：删除客户的同时删除下属的联系人，可以单独删除客户的某个联系人

相关知识点

Hibernate的一对多关联映射
创建表：
创建联系人表cst_linkman。
导入crm/sql/ crm_cst_linkman.sql

联系人表中存在外键（lkm_cust_id 即所属客户id），外键指向客户表：

ALTER TABLE cst_linkman 
ADD CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
创建类:
客户的实体：
public class Customer {
	private Long cust_id;  // OID
	private String cust_name;
	private Long cust_user_id;
	private Long cust_create_id;
	private String cust_source;
	private String cust_industry;
	private String cust_level;
	private String cust_linkman;
	private String cust_phone;
	private String cust_mobile;
	
	// 一个客户对应多个联系人:放的是联系人的集合.(Hibernate默认使用的集合是Set集合.)
	private Set<LinkMan> linkMans = new HashSet<LinkMan>();
}

联系人的实体：
public class LinkMan {
	private Long lkm_id;
	private String lkm_name;
	private String lkm_gender;
	private String lkm_phone;
	private String lkm_mobile;
	private String lkm_email;
	private String lkm_qq;
	private String lkm_position;
	private String lkm_memo;
	
	// 联系人关联的客户对象:
	private Customer customer;// ORM框架 Object 
}
创建映射:
【客户的映射】
<hibernate-mapping>
	<class name="cn.itcast.hibernate.domain.Customer" table="cst_customer">
		<id name="cust_id">
			<generator class="native"/>
		</id>
		
		<property name="cust_name" length="32"/>
		<property name="cust_user_id" column="cust_user_id"/>
		<property name="cust_create_id" column="cust_create_id"/>
		<property name="cust_source" column="cust_source"/>
		<property name="cust_industry" column="cust_industry"/>
		<property name="cust_level" column="cust_level"/>
		<property name="cust_linkman" column="cust_linkman"/>
		<property name="cust_phone" column="cust_phone"/>
		<property name="cust_mobile" column="cust_mobile"/>
		
		<!-- 配置关联对象 -->
		<!-- 
			set标签:
			    * name属性:多的一方的集合的属性名称.
		 -->
		<set name="linkMans">
			<!-- 
				key标签 :
				    * column属性:多的一方的外键的名称.
			-->
			<key column="lkm_cust_id"></key>
			<!-- 
				one-to-many标签:
				    * class属性:多的一方的类全路径
			 -->
			 <one-to-many class="cn.itcast.hibernate.domain.LinkMan"/>
		</set>
	</class>
</hibernate-mapping>

【联系人映射】
<hibernate-mapping>
	<class name="cn.itcast.hibernate.domain.LinkMan" table="cst_linkman">
		<id name="lkm_id" column="lkm_id">
			<generator class="native"/>
		</id>
		
		<property name="lkm_name"/>
		<property name="lkm_gender"/>
		<property name="lkm_phone"/>
		<property name="lkm_mobile"/>
		<property name="lkm_email"/>
		<property name="lkm_qq"/>
		<property name="lkm_position"/>
		<property name="lkm_memo"/>
		
		<!-- 配置关联对象: -->
		<!-- 
			many-to-one:标签.代表多对一.
			    * name		:一的一方的对象的名称.
			    * class		:一的一方的类的全路径.
			    * column	:表中的外键的名称.
		 -->
		<many-to-one name="customer" class="cn.itcast.hibernate.domain.Customer" column="lkm_cust_id"/>
	</class>
</hibernate-mapping>
将映射添加到配置文件
<mapping resource="com/itheima/domain/LinkMan.hbm.xml"/>
编写测试代码：
	@Test
	// 向客户 和 联系人中同时保存数据：
	public void demo1(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 创建一个客户
		Customer customer = new Customer();
		customer.setCust_name("张总");
		
		// 创建两个联系人:
		LinkMan linkMan1 = new LinkMan();
		linkMan1.setLkm_name("秦助理");
		
		LinkMan linkMan2 = new LinkMan();
		linkMan2.setLkm_name("胡助理");
		
		// 建立关系:
		customer.getLinkMans().add(linkMan1);
		customer.getLinkMans().add(linkMan2);
		
		linkMan1.setCustomer(customer);
		linkMan2.setCustomer(customer);
		
		session.save(customer);
		session.save(linkMan1);
		session.save(linkMan2);
		
		tx.commit();
	}
一对多的相关操作:
级联保存
【操作一个对象的时候，将关联对象一并操作.】
级联是有方向性:
* 保存客户的时候级联保存联系人.
	@Test
	/**
	 * 测试级联保存:
	 * * 保存客户 同时 级联保存联系人.
      * 在set集合上配置cascade=”save-update”
	 */
	public void demo3(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 保存客户:
		Customer customer = new Customer();
		customer.setCust_name("陈总");
		// 保存联系人:
		LinkMan man1 = new LinkMan();
		man1.setLkm_name("小花");

		// 建立关系:
		customer.getLinkMans().add(man1);
		man1.setCustomer(customer);
		
		// 执行保存操作:
		session.save(customer); // TransientObjectException:customer变为持久态对象,man 还是瞬时态对象.
		// session.save(man1);
		
		tx.commit();
	}


【保存联系人的时候级联保存客户.】
	@Test
	/**
	 * 测试级联保存:
	 * * 保存联系人 级联 保存客户.
      * 在many-to-one上配置cascade=”save-update”
	 */
	public void demo4(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 保存客户:
		Customer customer = new Customer();
		customer.setCust_name("肖总");
		// 保存联系人:
		LinkMan man1 = new LinkMan();
		man1.setLkm_name("小娇");

		// 建立关系:
		customer.getLinkMans().add(man1);
		man1.setCustomer(customer);
		
		// 执行保存操作:
		// session.save(customer); // TransientObjectException:customer变为持久态对象,man 还是瞬时态对象.
		session.save(man1);
		
		tx.commit();
	}

测试对象的导航的问题
	@Test
	/**
	 * 测试关联对象的导航:
	 * * 保存一个客户 和 3个联系人. 双方都配置了cascade="save-update"
	 */
	public void demo5(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 保存客户:
		Customer customer = new Customer();
		customer.setCust_name("肖老板");
		
		LinkMan linkMan1 = new LinkMan();
		linkMan1.setLkm_name("大娇");
		LinkMan linkMan2 = new LinkMan();
		linkMan2.setLkm_name("中娇");
		LinkMan linkMan3 = new LinkMan();
		linkMan3.setLkm_name("小娇");
		
		// 设置关系：
		linkMan1.setCustomer(customer);
		
		customer.getLinkMans().add(linkMan2);
		customer.getLinkMans().add(linkMan3);
		
		// 执行如下的操作:
		// session.save(linkMan1);  // 执行几条  insert 语句. 4条.
		
		// session.save(customer); // 执行几条 insert 语句. 3条
		
		session.save(linkMan2); // 执行几条 insert语句  1条.
		tx.commit();
	}
Hibernate的级联删除
【删除客户的时候同时删除客户的联系人】
	@Test
	/**
	 * 测试级联删除
	 * 删除客户的时候 删除联系人：
	 * 需要在Customer.hbm.xml中set标签上配置cascade="delete"
	 */
	public void demo6(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		Customer customer = session.get(Customer.class, 1l);
		session.delete(customer);
		
		// 不能级联删除的.
		/*Customer customer = new Customer();
		customer.setCust_id(1l);
		
		session.delete(customer);*/
		tx.commit();
	}

【删除联系人的时候同时删除客户.】
	@Test
	/**
	 * 测试级联删除
	 * 删除联系人 同时删除 客户：
	 * 需要在LinkMan.hbm.xml中many-to-one标签上配置cascade="delete"
	 */
	public void demo7(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		LinkMan linkman = session.get(LinkMan.class, 1l);
		
		session.delete(linkman);
		
		tx.commit();
	}
双向关联产生多余的SQL语句
	@Test
	/**
	 * 更改联系人所属的客户
	 * * 双向关联 会产生多余的SQL：
	 */
	public void demo8(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		LinkMan linkman = session.get(LinkMan.class, 5l);
		
		Customer customer = session.get(Customer.class, 4l);
		// 双向关联:
		linkman.setCustomer(customer);
		customer.getLinkMans().add(linkman);
		
		tx.commit();
	}

原理:


一的一方放弃外键的维护权:

案例二：完成CRM的用户分配角色的操作
案例需求
需求描述
用户即使用系统的用户，包括业务员、总经理等角色，不同类型的用户使用系统不同的功能，本功能要完成给用户分配角色，功能包括：给用户分配权限、取消用户分配的角色

相关知识点
Hibernate的多对多关联关系映射
创建表:
创建sys_user、sys_role、sys_user_role三张表。

数据模型如下：

先后导入下边的sql：
crm_sys_user.sql
crm_sys_role.sql
crm_sys_user_role.sql
创建实体
【用户实体】
public class User {

	private Long uid;
	private String username;
	private String password;
	
	// 一个用户有多个角色:
	private Set<Role> roles = new HashSet<Role>();
...
}
【角色实体】
public class Role {
	private Long rid;
	private String rname;
	
	// 一个角色中有多个所属的用户:
	private Set<User> users = new HashSet<User>();
...
}
创建映射
【用户的映射:】
<hibernate-mapping>
	<class name="com.itheima.domain.User">
		<id name="uid" column="uid">
			<generator class="native"/>
		</id>
		
		<property name="username" length="20"></property>
		<property name="password" length="20"></property>
		
		<!-- 配置关联关系 -->
		<!-- name:角色集合的属性名称   table:-->
		<set name="roles" table="user_role">
			<!-- 当前类中在中间表的外键的名称 -->
			<key column="uno"></key>
			<!-- class:关联的另一方的多的类全路径.column:另一方在中间表中的外键名称: -->
			<many-to-many class="com.itheima.domain.Role" column="rno"></many-to-many>
		</set>
	</class>
</hibernate-mapping>

【角色的映射:】
<hibernate-mapping>
	<class name="com.itheima.domain.Role">
		<id name="rid">
			<generator class="native"/>
		</id>
		
		<property name="rname" length="20"/>
		
		<!-- 配置角色的关联的映射 -->
		<set name="users" table="user_role">
			<key column="rno"></key>
			<many-to-many class="com.itheima.domain.User" column="uno"></many-to-many>
		</set>
	</class>
</hibernate-mapping>
在核心配置中加入映射文件
		<!-- 加载映射 -->
		<mapping resource="com/itheima/domain/User.hbm.xml"/>
		<mapping resource="com/itheima/domain/Role.hbm.xml"/>
编写测试类
@Test
	/**
	 * 保存操作:
	 */
	public void demo1(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 保存两个用户:
		User user1 = new User();
		user1.setUsername("张三");
		User user2 = new User();
		user2.setUsername("李四");
		
		// 保存三个角色
		Role role1 = new Role();
		role1.setRname("经理");
		Role role2 = new Role();
		role2.setRname("助理");
		Role role3 = new Role();
		role3.setRname("前台");
		
		// 设置关系：
		user1.getRoles().add(role2);
		user1.getRoles().add(role3);
		
		user2.getRoles().add(role1);
		user2.getRoles().add(role2);
		
		role1.getUsers().add(user2);
		role2.getUsers().add(user1);
		role2.getUsers().add(user2);
		role3.getUsers().add(user1);
		
		session.save(user1);
		session.save(user2);
		session.save(role1);
		session.save(role2);
		session.save(role3);
		
		tx.commit();
	}
多对多的相关操作
级联保存
【保存用户级联角色】
	@Test
	/**
	 * 多对多只保存一边 也是不可以的.
	 * 配置级联:保存用户级联角色.在User.hbm.xml中<set>上配置 cascade="save-update"
	 */
	public void demo2(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 创建两个两个用户:
		User user1 = new User();
		user1.setUser_name("张勇");
		
		User user2 = new User();
		user2.setUser_name("王强");
		// 创建三个角色:
		Role role1 = new Role();
		role1.setRole_name("行政管理");
		Role role2 = new Role();
		role2.setRole_name("人事管理");
		Role role3 = new Role();
		role3.setRole_name("财务管理");
		
		// 建立关系：如果建立了双向的关系 一定要有一方放弃外键维护权.
		user1.getRoles().add(role1);
		user1.getRoles().add(role3);
		
		user2.getRoles().add(role2);
		user2.getRoles().add(role3);
		
		role1.getUsers().add(user1);
		role2.getUsers().add(user2);
		
		role3.getUsers().add(user1);
		role3.getUsers().add(user2);
		
		session.save(user1);
		session.save(user2);
		/*session.save(role1);
		session.save(role2);
		session.save(role3);
		*/
		tx.commit();
	}

【保存角色级联用户】
	@Test
	/**
	 * 多对多只保存一边 也是不可以的.
	 * 配置级联:保存角色 级联用户 在Role.hbm.xml中配置cascade="save-update"
	 */
	public void demo3(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 创建两个两个用户:
		User user1 = new User();
		user1.setUser_name("张勇");
		
		User user2 = new User();
		user2.setUser_name("王强");
		// 创建三个角色:
		Role role1 = new Role();
		role1.setRole_name("行政管理");
		Role role2 = new Role();
		role2.setRole_name("人事管理");
		Role role3 = new Role();
		role3.setRole_name("财务管理");
		
		// 建立关系：如果建立了双向的关系 一定要有一方放弃外键维护权.
		user1.getRoles().add(role1);
		user1.getRoles().add(role3);
		
		user2.getRoles().add(role2);
		user2.getRoles().add(role3);
		
		role1.getUsers().add(user1);
		role2.getUsers().add(user2);
		
		role3.getUsers().add(user1);
		role3.getUsers().add(user2);
		
		/*session.save(user1);
		session.save(user2);*/
		session.save(role1);
		session.save(role2);
		session.save(role3);
		
		tx.commit();
	}
级联删除:（了解）
【删除用户级联角色】
@Test
	// 级联删除: 删除用户 级联删除 角色.
	public void demo4(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		User user = session.get(User.class, 1l);
		session.delete(user);
		
		tx.commit();
	}
【删除角色级联删除用户】
	@Test
	// 级联删除: 删除角色 级联删除 用户.
	public void demo5(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		Role role = session.get(Role.class, 3l);	
		session.delete(role);
		
		tx.commit();
	}
多对多的其他操作：
【删除某个用户的角色】
	@Test
	// 将2号用户中的1号角色去掉.
	public void demo6(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 查询2号用户：
		User user = session.get(User.class, 2l);
		// 查询1号角色
		Role role = session.get(Role.class, 1l);
		
		// 操作集合 相当于 操作中间表.
		user.getRoles().remove(role);
		
		tx.commit();
	}
【将某个用户的角色改选】
	@Test
	// 将2号用户中的1号角色去掉 改为3号角色
	public void demo7(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 查询2号用户：
		User user = session.get(User.class, 2l);
		// 查询1号角色
		Role role1 = session.get(Role.class, 1l);
		// 查询3号角色
		Role role3 = session.get(Role.class, 3l);
		
		user.getRoles().remove(role1);
		user.getRoles().add(role3);
		
		tx.commit();
	}
【给某个用户添加新角色】
	@Test
	// 给1号用户添加2号角色
	public void demo8(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 查询1号用户：
		User user = session.get(User.class, 1l);
		// 查询2号角色:
		Role role = session.get(Role.class, 2l);
		
		user.getRoles().add(role);
		tx.commit();
	}
第1章Hibernate_day04
今日任务
案例一:使用Hibernate完成对客户的条件查询
案例二:使用Hibernate完成对客户查询的优化
教学导航
教学目标	
教学方法	案例驱动法
案例一：完成CRM的客户的条件查询
案例需求:
需求描述
要对客户进行条件查询,效果如下:

相关知识点
Hibernate的检索方式:
Hibernate检索方式的分类:
Hibernate中提供了5种检索方式：
1.OID检索	
2.对象导航检索	
3.HQL检索
4.QBC检索
5.SQL检索
HQL检索
基本检索
	@Test
	/**
	 * HQL：基本检索
	 */
	public void demo2(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 基本查询
		/*Query query = session.createQuery("from Customer");
		List<Customer> list = query.list();*/
		// 起别名
		//Query query = session.createQuery("from Customer c");
		Query query = session.createQuery("select c from Customer c");
		List<Customer> list = query.list();
		
		for (Customer customer : list) {
			System.out.println(customer);
		}
		
		tx.commit();
	}
排序检索
	@Test
	/**
	 * HQL：排序检索
	 */
	public void demo3(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 基本查询
		Query query = session.createQuery("from Customer order by cust_id desc");
		List<Customer> list = query.list();
		
		for (Customer customer : list) {
			System.out.println(customer);
		}
		
		tx.commit();
	}
条件检索
	@Test
	/**
	 * HQL：条件查询
	 */
	public void demo4(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 按位置绑定参数
		/*Query query = session.createQuery("from Customer where cust_name = ?");
		// query.setString(0, "小军军");
		query.setParameter(0, "小军军");
		List<Customer> list = query.list();*/
		
		// 按名称绑定参数
		Query query = session.createQuery("from Customer where cust_name = :name");
		query.setParameter("name", "小添添");
		/*List<Customer> list = query.list();
		for (Customer customer : list) {
			System.out.println(customer);
		}*/
		Customer customer = (Customer) query.uniqueResult();
		System.out.println(customer);
		
		tx.commit();
	}
分页检索
	@Test
	/**
	 *  分页查询
	 */
	public void demo5(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		Query query = session.createQuery("from LinkMan order by lkm_id desc");
		query.setFirstResult(5);
		query.setMaxResults(5);
		List<LinkMan> list = query.list();
		for (LinkMan linkMan : list) {
			System.out.println(linkMan);
		}
		
		tx.commit();
	}
统计检索
	@Test
	/**
	 *  统计查询
	 */
	public void demo6(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		Query query = session.createQuery("select count(*) from Customer");
		Long num = (Long) query.uniqueResult();
		System.out.println(num);
		
		tx.commit();
	}
投影检索
	@Test
	/**
	 * 投影查询
	 */
	public void demo7(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		// 投影查询一列
		/*List<String> list = session.createQuery("select cust_name from Customer").list();
		for (String string : list) {
			System.out.println(string);
		}*/
		// 投影查询多列:
		/*List<Object[]> list = session.createQuery("select cust_id,cust_name from Customer").list();
		for (Object[] objects : list) {
			System.out.println(Arrays.toString(objects));
		}*/
		
		// 投影的构造的方式查询:
		List<Customer> list = session.createQuery("select new Customer(cust_id,cust_name) from Customer").list();
		for (Customer customer : list) {
			System.out.println(customer);
		}
		tx.commit();
	}

QBC检索
基本检索
@Test
	/**
	 * 简单的查询
	 */
	public void demo1(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		// 简单查询:
		Criteria criteria = session.createCriteria(Customer.class);
		List<Customer> list = criteria.list();
		
		for (Customer customer : list) {
			System.out.println(customer);
		}
		tx.commit();
	}
条件检索
	@Test
	/**
	 * 条件查询
	 */
	public void demo2(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		// 条件查询:
		Criteria criteria = session.createCriteria(Customer.class);
		// 设置条件:
		// criteria.add(Restrictions.eq("cust_name", "小军军"));
		criteria.add(Restrictions.like("cust_name", "%小%"));
		criteria.add(Restrictions.gt("cust_id", 1l));
		
		List<Customer> list = criteria.list();
		
		for (Customer customer : list) {
			System.out.println(customer);
		}
		tx.commit();
	}
分页检索
	@Test
	/**
	 * 分页查询
	 */
	public void demo3(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		// 条件查询:
		Criteria criteria = session.createCriteria(LinkMan.class);
		// 设置分页查询:
		criteria.setFirstResult(5);
		criteria.setMaxResults(5);
		
		List<LinkMan> list = criteria.list();
		
		for (LinkMan linkMan : list) {
			System.out.println(linkMan);
		}
		tx.commit();
	}
排序检索
	@Test
	/**
	 * 排序查询
	 */
	public void demo4(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		// 排序查询:
		Criteria criteria = session.createCriteria(LinkMan.class);
		criteria.addOrder(Order.desc("lkm_id"));
		
		List<LinkMan> list = criteria.list();
		
		for (LinkMan linkMan : list) {
			System.out.println(linkMan);
		}
		
		tx.commit();		
	}
统计检索
	@Test
	// 统计查询:
	public void demo4(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		Criteria criteria = session.createCriteria(LinkMan.class);
		criteria.setProjection(Projections.rowCount());
		Long count = (Long) criteria.uniqueResult();
		
		System.out.println(count);
		tx.commit();
	}
离线条件检索
	@Test
	/**
	 * 离线条件查询:DetachedCriteria(SSH整合经常使用.).
	 * * 可以脱离session设置参数.
	 */
	public void demo6(){
		// 获得一个离线条件查询的对象
		DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class);
		detachedCriteria.add(Restrictions.eq("cust_name","小童童"));
		
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		
		List<Customer> list = detachedCriteria.getExecutableCriteria(session).list();// 离线条件查询对象与session绑定.
		for (Customer customer : list) {
			System.out.println(customer);
		}
		tx.commit();
	}
多表查询
多表查询:
【SQL多表查询】
SQL中分成:
* 连接查询:
    * 交叉连接:
        * select * from A,B;
    * 内连接
        * 隐式内连接
            * select * from A ,B where A.id = B.id;
        * 显示内连接
            * select * from A inner join B on A.id = B.id;
            * select * from A join B on A.id = B.id;
    * 外连接
        * 左外连接
            * select * from A left outer join B on A.id = B.id;
            * select * from A left join B on A.id = B.id;

        * 右外连接
            * select * from A right outer join B on A.id = B.id;
            * select * from A right join B on A.id = B.id;
【HQL的多表查询】
HQL中分成:
* 连接查询:
     * 交叉连接:

     * 内连接:
        * 隐式内连接
        * 显示内连接
        * 迫切内连接 

     * 外连接：
        * 左外连接
        * 迫切左外连接
        * 右外连接
HQL连接查询
SQL连接查询:
* 隐式内连接:
SELECT * FROM cst_customer c,cst_linkman l WHERE c.cust_id = l.lkm_cust_id;
* 显示内连接:
SELECT * FROM cst_customer c INNER JOIN cst_linkman l ON c.cust_id = l.lkm_cust_id;

HQL连接的查询:
* 内连接：
List<Object[]> list = session.createQuery("from Customer c inner join c.linkMans").list();
// session.createQuery("from LinkMan l inner join l.customer");

* 迫切内连接:
	@Test
	/**
	 * 迫切内连接查询
	 */
	public void demo9(){
		Session session = HibernateUtils.getCurrentSession();
		Transaction tx = session.beginTransaction();
		// 迫切内连接:
		// 迫切内连接和内连接所发送的SQL语句是一样的.fetch告诉Hibernate 封装的时候 要往对象中去封装.将客户封装到Customer中将Customer对应的联系人封装到Customer的LinMan的集合中.
		//List<Customer> list = session.createQuery("from Customer c inner join fetch c.linkMans").list();
		List<Customer> list = session.createQuery("select distinct c from Customer c inner join fetch c.linkMans").list();
		// System.out.println(list.size());
		for (Customer customer : list) {
			System.out.println(customer);
		}
		tx.commit();
	}

* 内连接和迫切内连接的区别:
    * 内连接:发送就是内连接的语句,封装的时候将每条记录封装到一个Object[]数组中,最后得到一个List<Object[]>.
    * 迫切内连接：发送的也是内连接的语句,在join后添加一个fetch关键字,Hibernate会将每条数据封装到对象中,最后List<Customer>. 需要去掉重复值.

案例二:完成CRM的查询优化
案例需求
需求描述
在CRM的案例中有很多地方需要用到查询操作，但是Hibernate本身的查询的效率不是很好，需要对查询语句进行一些优化操作
相关知识点
Hibernate的抓取策略:
延迟加载的分类:
【类级别的延迟加载】:类级别的延迟一般不修改.采用默认值即可.lazy=”true”
Customer customer = session.load(Customer.class,1l); // 通过一些延迟加载的方法load方法检索某个对象.这个对象是否采用延迟.
// 默认情况下类上的延迟是 lazy=”true”

***** 如何使延迟加载失效:
      * 在<class>标签上配置lazy=”false”
      * 定义类的时候采用final修饰.
      * Hibernate.initialize(Object proxy);

【关联级别的延迟加载】
Customer customer = session.get(Customer.class,1l); 
Set<LinkMan> linkMans = customer.getLinkMans(); // 通过客户关联其联系人的对象.联系人是否采用延迟.

<set>上的lazy			:
<many-to-one>上的lazy	:

抓取策略:抓取其关联对象.
<set>和<many-to-one>标签上有一个fetch=””

<set>集合上的fetch和lazy:
fetch:	控制的是查询其关联对象的时候采用的SQL语句的格式.
    * select		:默认值.  发送一条select语句查询其关联对象.
    * join		:发送 一条迫切左外连接查询关联对象.
    * subselect	:发送 一条子查询查询其关联对象.

lazy:	控制的是查询其关联对象的时候是否采用延迟加载的策略.
    * true		:默认值. 默认查询联系人的时候采用延迟加载.
    * false		:查询关联对象的时候 不采用延迟加载.
    * extra		:及其懒惰. 查询关联对象的时候 采用比延迟加载更懒惰的方式进行查询.
<many-to-one>上的fetch和lazy:
fetch:	控制查询其关联对象的SQL语句的格式
    * select		:默认值,发送普通的select语句查询
    * join		:发送一条迫切左外连接查询.

lazy:	查询其关联对象的时候是否采用延迟加载.
    * proxy		:默认值.是否采用延迟 取决于 一的一方的class上的lazy的值.
    * false		:不采用延迟加载其关联对象.
    * no-proxy	:不用研究



参数	说明	例子
%c 	列出logger名字空间的全称，如果加上{<层数>}表示列出从最内层算起的指定层数的名字空间	log4j配置文件参数举例 	输出显示媒介 
		假设当前logger名字空间是“a.b.c”
		%c	a.b.c
		%c{2}	b.c
		%20c	（若名字空间长度小于20，则左边用空格填充）
		%-20c	（若名字空间长度小于20，则右边用空格填充）
		%.30c	（若名字空间长度超过30，截去多余字符）
		%20.30c	（若名字空间长度小于20，则左边用空格填充；若名字空间长度超过30，截去多余字符）
		%-20.30c	（若名字空间长度小于20，则右边用空格填充；若名字空间长度超过30，截去多余字符）
%C 	列出调用logger的类的全名（包含包路径）	假设当前类是“org.apache.xyz.SomeClass”
		%C	org.apache.xyz.SomeClass
		%C{2}	xyz.SomeClass
%d 	显示日志记录时间，{<日期格式>}使用ISO8601定义的日期格式	%d{yyyy/MM/dd HH:mm:ss,SSS}	2005/10/12 22:23:30,117
		%d{ABSOLUTE}	22:23:30,117
		%d{DATE}	12 Oct 2005 22:23:30,117
		%d{ISO8601}	2005-10-12 22:23:30,117
%F 	显示调用logger的源文件名	%F	MyClass.java
%l 	输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数	%l	MyClass.main(MyClass.java:129)
%L 	显示调用logger的代码行	%L	129
%m 	显示输出消息	%m	This is a message for debug.
%M 	显示调用logger的方法名	%M	main
%n 	当前平台下的换行符	%n	Windows平台下表示rn
UNIX平台下表示n
%p 	显示该条日志的优先级	%p	INFO
%r 	显示从程序启动时到记录该条日志时已经经过的毫秒数	%r	1215
%t 	输出产生该日志事件的线程名	%t	MyClass
%x 	按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志	假设某程序调用顺序是MyApp调用com.foo.Bar
		%c %x - %m%n	MyApp - Call com.foo.Bar.
com.foo.Bar - Log in Bar
MyApp - Return to MyApp.
%X 	按MDC（Mapped Diagnostic Context，线程映射表）输出日志。通常用于多个客户端连接同一台服务器，方便服务器区分是那个客户端访问留下来的日志。	%X{5}	（记录代号为5的客户端的日志）
%% 	显示一个百分号	%%	%        


SSH框架学习环境配置



1、java环境

安装
安装jdk7，根据自己的操作系统选择32位或64位安装。




配置

安装后需要配置环境变量，如下所示：


配置classpath，如下：




并在path中添加java6安装目录中的bin目录路径，如下所示：



检验是否安装成功，cmd进入命令行模式，输入java，出现如下画面表示安装java完成：




2、web容器
安装
本教程开发环境使用tomcat7，“开发工具”目录提供了apache-tomcat-7.0.52.zip。

解压安装包到自己的电脑上，建议不要解压到中文目录下，老师的tomcat8放在了F盘根目录F:\ apache-tomcat-7.0.52。

配置
网上有些安装教程提到需要配置CATALINA_HOME环境变量，此变量指向了tomcat 的目录，主要是为了方便tomcat运行使用，如果配置了，你的电脑上有多个tomcat目录时只能成功运行那个和CATALINA_HOME一致的tomcat，如果不配置，在你启动tomcat时它会自己确定tomcat目录，这里我们就不配置了。


运行

运行 tomcat目录中的bin/startup.bat，启动tomcat，如果启动不起来就到logs查看错误日志，启动后有浏览器输入http://localhost:8080/，进入如下画面表示tomcat安装成功。




3、STS环境
STS安装
STS（spring-tool-suite）是Spring在Eclipse的基础上定制的开发工具，目前spring使用广泛，为了方便Spring项目的开发本课程使用STS开发工具。
在“开发工具”目录中有STS的安装包，提供32位和64位两种：



解压安装包到固定位置，建议不要解压到中文目录，运行：STS.exe，初次运行会让你确定自己的工作区，工作区是你创建project工程的地方，选择一个容易到的目录作为你的工作区，建议工作区目录不要设在中文目录中。

Java环境配置：





编译版本：


选择java运行环境：







Tomcat配置
配置web Server
配置web Server，本系统使用tomcat7作为web容器，需要配置tomcat Server，配置步骤如下：











点击完成

添加Tomcat Server
新建：


新建一个server






打开Tomcat视图











配置tomcat


Timeouts：延迟时间设置加大，设置为100以上
Server location：默认工程部署目录在STS的工作区
下.metadata\.plugins\org.eclipse.wst.server.core目录中。



如果出现tomcat启动工程时内存溢出，可通过下边的方法加大虚拟机内存。 






在VM ageuments中配置（根据自己电脑情况设置）：
-Xms128m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=512m



默认编码
工作区默认字符编码
更改工作区默认字符集更改为utf-8






jsp文件编码：





Web工程测试
在STS中创建一个web工程，测试web工程创建过程。

创建动态web工程





















创建成功：





新建一个jsp：
在WebRoot下创建jsp：






在tomcat中部署运行







添加成功后需要修改tomcat配置，取消自动部署，这样做的原因是取消后采用debug方式启动工程可以打断点调试。



保存配置信息：




清理部署：
运行工程需要将工程代码发布到tomcat目录，先整理再发布：



发布成功查看发布目录，前边配置tomcat Server指定的发布工程目录，默认在STS工作区目录下.metadata\.plugins\org.eclipse.wst.server.core目录中。


启动工程，一般采用debug方式：
右键点击“Debug”




插件安装
propedit插件
	eclipse中默认的properties文件编辑工具不好用，默认用unicode编码表示，输入中文后将自动转为unicode编码，安装此插件后，properties文件中可以直接输入中文，方便文件内容编写。

	在STS中此插件采用在线安装：





出现提示，选择继续安装：


安装成功：



STS内存设置
为防止STS在启动运行时内存溢出，修改STS安装目录下的sts.ini文件添加如下：
-Xms128m
-Xmx768m
-XX：permSize=64M
-XX：MaxPermSize=128M

字体修改





添加代码提示



在上边红色框内输入：.abcdefghijklmnopqrstuvwxyz


第1章Struts2_day01
今日任务
使用Struts2完成登录功能
教学导航
教学目标	
教学方法	案例驱动法
案例一:使用Struts2完成登录功能.
案例需求
需求概述
CRM系统中需要有登录的功能：
本功能要实现用户的登录，页面如下：


需求分析
	Crm系统使用struts2架构实现web层，web层实现的功能是控制逻辑和视图。
	整体调用流程如下：
	1、用户请求至struts2
	2、struts2调用service
	3、service调用dao
	4、dao持久化数据

相关知识点
Struts2框架的概述
什么是Struts2


Struts2是一个基于MVC设计模式的WEB层框架。
Struts2和Struts1区别:
Struts2和Struts1没有任何联系.Struts2内核是webwork的内核.
WEB层的框架都会基于前端控制器的模式:

Struts2快速入门：
下载Struts2的开发包:
官网: https://struts.apache.org/
解压Struts2的开发包：

* apps	:Struts2提供一些案例
* docs	:Struts2开发文档.
* lib	:Struts2的开发的jar包
* src	:Struts2的源码
创建一个web工程引入相应jar包：
D:\struts2\struts-2.3.24\apps\struts2-blank\WEB-INF\lib\*.jar
创建一个页面:放置一个链接.
<h1>Struts2的入门案例</h1>
<a href="${pageContext.request.contextPath }/strutsDemo1.action">访问Struts2的Action.</a>
编写一个Action:
public class StrutsDemo1 {

	/**
	 * 提供一个默认的执行的方法:execute
	 */
	public String execute(){
		System.out.println("StrutsDemo1中的execute执行了...");
		return null;
	}
}
完成Action的配置:
在src下引入一个struts.xml

<struts>
	<!-- 配置一个包:package -->
	<package name="demo1" extends="struts-default" namespace="/">
		<!-- 配置Action -->
		<action name="strutsDemo1" class="cn.itcast.struts2.action.StrutsDemo1">
			
		</action>
	</package>
</struts>
配置核心过滤器:
  <!-- 配置Struts2的核心过滤器：前端控制器 -->
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>struts2</filter-name>
  	<url-pattern>/*</url-pattern>
  </filter-mapping>
修改Action，将方法设置一个返回值:
public class StrutsDemo1 {

	/**
	 * 提供一个默认的执行的方法:execute
	 */
	public String execute(){
		System.out.println("StrutsDemo1中的execute执行了...");
		return "success";
	}
}
修改struts.xml
<struts>
	<!-- 配置一个包:package -->
	<package name="demo1" extends="struts-default" namespace="/">
		<!-- 配置Action -->
		<action name="strutsDemo1" class="cn.itcast.struts2.action.StrutsDemo1">
			<!-- 配置结果页面的跳转 -->
			<result name="success">/demo1/demo2.jsp</result>
		</action>
	</package>
</struts>
Struts2开发流程分析
Struts2的执行流程:
从客户端发送请求过来 先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter）过滤器中执行一组拦截器（一组拦截器 就会完成部分功能代码）执行目标Action，在Action中返回一个结果视图,根据Result的配置进行页面的跳转.


配置struts.xml中的提示(在不联网情况下)
DTD存放的路径:src\core\src\main\resources\struts-2.3.dtd
Window--->Preferences--->在左侧搜索xml catalog--->add添加.
* 选择URI
* 文件系统 选择dtd路径



Struts2的常见配置
Struts2的配置文件的加载顺序:
查看StrutsPrepareAndExecuteFilter:(核心过滤器)两个功能 ：预处理 和 执行 
在预处理功能中 init 方法中会有加载配置文件的代码:
dispatcher.init();
            init_DefaultProperties(); // [1]					---- 加载org.apache.struts.default.properties.配置的是struts2的所有常量.
            init_TraditionalXmlConfigurations(); // [2]		---- 加载struts-default.xml、struts-plugin.xml、struts.xml
            init_LegacyStrutsProperties(); // [3]				---- 加载用户自定义struts.properties
            init_CustomConfigurationProviders(); // [5]		---- 加载Struts2定义Bean.
            init_FilterInitParameters() ; // [6]				---- 加载web.xml
            init_AliasStandardObjects() ; // [7]				---- 用户自定义Bean

结论:
* default.properties
* struts-default.xml
* struts-plugin.xml
* struts.xml				---- 配置Action以及常量.(******)
* struts.properties		---- 配置常量
* web.xml				---- 配置核心过滤器及常量.

***** 后配置的常量 会 覆盖先配置的常量.
Action的配置:
<package>的配置:
* package:包. 不是java中说那个包. Struts2中的包 管理<action>.
* 属性:
* name		:包名.包名是唯一的不能重复的.
* extends	:继承.继承struts-default.（struts-default包中定义结果类型和拦截器.）
* namespace	:名称空间.与<action>标签中的name属性共同决定Action的访问路径.
* 写法:
* namespace有名称:	namespace=”/aa”
* namespace只是一个/:	 namespance=”/”
* namespace默认的:	namespace没写.
    * 例子:
	<package name="demo1" extends="struts-default" namespace="/aaa/bbb/ccc">
		<!-- 配置Action -->
		<action name="strutsDemo1" class="cn.itcast.struts2.action.StrutsDemo1">
			<!-- 配置结果页面的跳转 -->
			<result name="success">/demo1/demo2.jsp</result>
		</action>
		
	</package>

	<package name="demo2" extends="struts-default" namespace="/aaa/bbb">
		<!-- 配置Action -->
		<action name="ccc/strutsDemo1" class="cn.itcast.struts2.action.StrutsDemo1">
			<!-- 配置结果页面的跳转 -->
			<result name="success">/demo1/demo2.jsp</result>
		</action>
		
	</package>

	<package name="demo3" extends="struts-default" namespace="/aaa">
		<!-- 配置Action -->
		<action name="bbb/ccc/strutsDemo1" class="cn.itcast.struts2.action.StrutsDemo1">
			<!-- 配置结果页面的跳转 -->
			<result name="success">/demo1/demo2.jsp</result>
		</action>
		
	</package>

在页面中<a href=”/aa/bb/cc/demo1.action”>访问</a>
***** 名称空间最大化:访问路径中:/aa/bb/cc/demo1.action 首先将/aa/bb/cc都作为名称空间.demo1作为action的name去查询.
* abstract	:抽象的.用于使其他的包可以继承的.
* <package name="struts-default" abstract="true"> . 所以可以继承struts-default.

<action>的配置:
* action:配置Action类的访问路径.
* 属性:
* name	:名称.与<package>中的namespace属性共同决定访问路径.
* class	:类的全路径.要执行的Action类的全路径.
* method	:方法.用来指定Action中执行那个方法的方法名.(默认的值execute)

<result>的配置:
* result:配置Action执行后的页面跳转.
* 属性:
* name	:逻辑视图名称.（不是真实的视图，为真实的视图起了一个别名,在Action中返回这个字符串的别名,从而找到具体页面.）
* type	:跳转的类型.
默认的Action和Action的默认处理类:
默认的Action:
<!-- 配置默认的Action:Action的访问路径不存在的时候,执行一个默认的Action -->
<default-action-ref name="strutsDemo1"/>


Action的默认处理类：
<!-- Action的默认处理类:Action的访问路径配置正确了，但是没有配置class属性. -->
<default-class-ref class="com.opensymphony.xwork2.ActionSupport"/>

Struts2常量的配置:
修改常量:
* struts.xml中修改常量（推荐使用）
	<!-- 修改Struts2的常量的值 -->
	<constant name="struts.action.extension" value="abc"/>

* struts.properties修改常量
	struts.action.extension=xxx

* web.xml中修改常量
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  	<init-param>
  		<param-name>struts.action.extension</param-name>
  		<param-value>xyz</param-value>
  	</init-param>
  </filter>

分模块开发的时候
<include file="cn/itcast/struts2/demo1/struts_demo1.xml"/>  整合其他的struts的配置文件.
Struts2的Action的访问:
Action的编写的方式:
【Action的是一个POJO的类】
Action是简单的Java对象没有实现任何借口 和 继承任何类.
public class ActionDemo1 {

	public String execute(){
		System.out.println("ActionDemo1执行了...");
		return null;
	}
}
【Action类实现一个Action的接口】
public class ActionDemo2 implements Action{

	@Override
	public String execute() throws Exception {
		System.out.println("ActionDemo2执行了...");
		return null;
	}

}

Action接口中提供了5个已经定义好的视图名称:
    * SUCCESS		:success，代表成功.
    * NONE			:none，代表页面不跳转
    * ERROR			:error，代表跳转到错误页面.
    * INPUT			:input，数据校验的时候跳转的路径.
    * LOGIN			:login，用来跳转到登录页面.
【Action类继承ActionSupport类】
public class ActionDemo3 extends ActionSupport{

	@Override
	public String execute() throws Exception {
		System.out.println("ActionDemo3执行了...");
		return NONE;
	}
}

ActionSupport中提供了一些功能，比如数据校验，比如国际化… 如果Action继承了ActionSupport，那么Action就会有这些功能.
Action的访问:
Action的访问不是难题，因为之前已经访问过了，但是出现一个问题一次请求现在对应一个Action，那么如果请求很多对应很多个Action.现在要处理的问题就是要让一个模块的操作提交到一个Action中。
【解决Action的访问的问题的方式一：通过配置method属性完成】
页面：
<h3>客户的管理</h3>
<a href="${ pageContext.request.contextPath }/saveCustomerAction.action">添加客户</a> <br/>
<a href="${ pageContext.request.contextPath }/updateCustomerAction.action">修改客户</a> <br/>
<a href="${ pageContext.request.contextPath }/deleteCustomerAction.action">删除客户</a> <br/>
<a href="${ pageContext.request.contextPath }/findCustomerAction.action">查询客户</a> <br/>


编写Action:
public class CustomerAction extends ActionSupport{

	public String save(){
		System.out.println("CustomerAction中save方法执行了...");
		return NONE;
	}
	public String update(){
		System.out.println("CustomerAction中update方法执行了...");
		return NONE;
	}
	public String delete(){
		System.out.println("CustomerAction中delete方法执行了...");
		return NONE;
	}
	public String find(){
		System.out.println("CustomerAction中find方法执行了...");
		return NONE;
	}
}

配置Action:
	<package name="demo3" extends="struts-default" namespace="/">
		<action name="saveCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="save"></action>
		<action name="updateCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="update"></action>
		<action name="deleteCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="delete"></action>
		<action name="findCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="find"></action>
	
	</package>

【解决Action的访问的问题的方式二：通过通配符的配置完成】
第一种解决方案不是很优秀，因为在Action的配置中配置多条.能不能一个Class类只对应一个配置?

页面:
<h3>联系人的管理</h3>
<a href="${ pageContext.request.contextPath }/linkman_save.action">添加联系人</a> <br/>
<a href="${ pageContext.request.contextPath }/linkman_update.action">修改联系人</a> <br/>
<a href="${ pageContext.request.contextPath }/linkman_delete.action">删除联系人</a> <br/>
<a href="${ pageContext.request.contextPath }/linkman_find.action">查询联系人</a> <br/>

编写Action:
public class LinkManAction extends ActionSupport{

	public String save(){
		System.out.println("保存联系人...");
		return NONE;
	}
	public String update(){
		System.out.println("修改联系人...");
		return NONE;
	}
	public String delete(){
		System.out.println("删除联系人...");
		return NONE;
	}
	public String find(){
		System.out.println("查询联系人...");
		return NONE;
	}
}

配置Action:
	<!-- 通配符的配置 -->
	<action name="linkman_*" class="cn.itcast.struts2.demo3.LinkManAction" method="{1}"></action>

【解决Action的访问的问题的方式三：动态方法访问】
开启一个常量:动态方法访问.
<constant name="struts.enable.DynamicMethodInvocation" value="true"></constant>

编写Action:
public class UserAction extends ActionSupport{

	public String save(){
		System.out.println("保存用户...");
		return NONE;
	}
	public String update(){
		System.out.println("修改用户...");
		return NONE;
	}
	public String delete(){
		System.out.println("删除用户...");
		return NONE;
	}
	public String find(){
		System.out.println("查询用户...");
		return NONE;
	}
}

配置Action:
<!-- 动态方法访问的配置 -->
<action name="userAction" class="cn.itcast.struts2.demo3.UserAction"></action>

页面路径写法:
<h3>用户的管理</h3>
<a href="${ pageContext.request.contextPath }/userAction!save.action">添加用户</a> <br/>
<a href="${ pageContext.request.contextPath }/userAction!update.action">修改用户</a> <br/>
<a href="${ pageContext.request.contextPath }/userAction!delete.action">删除用户</a> <br/>
<a href="${ pageContext.request.contextPath }/userAction!find.action">查询用户</a> <br/>



第1章Struts2_day01
今日任务
使用Struts2完成登录功能
教学导航
教学目标	
教学方法	案例驱动法
案例一:使用Struts2完成登录功能.
案例需求
需求概述
CRM系统中需要有登录的功能：
本功能要实现用户的登录，页面如下：


需求分析
	Crm系统使用struts2架构实现web层，web层实现的功能是控制逻辑和视图。
	整体调用流程如下：
	1、用户请求至struts2
	2、struts2调用service
	3、service调用dao
	4、dao持久化数据

相关知识点
Struts2框架的概述
什么是Struts2


Struts2是一个基于MVC设计模式的WEB层框架。
Struts2和Struts1区别:
Struts2和Struts1没有任何联系.Struts2内核是webwork的内核.
WEB层的框架都会基于前端控制器的模式:

Struts2快速入门：
下载Struts2的开发包:
官网: https://struts.apache.org/
解压Struts2的开发包：

* apps	:Struts2提供一些案例
* docs	:Struts2开发文档.
* lib	:Struts2的开发的jar包
* src	:Struts2的源码
创建一个web工程引入相应jar包：
D:\struts2\struts-2.3.24\apps\struts2-blank\WEB-INF\lib\*.jar
创建一个页面:放置一个链接.
<h1>Struts2的入门案例</h1>
<a href="${pageContext.request.contextPath }/strutsDemo1.action">访问Struts2的Action.</a>
编写一个Action:
public class StrutsDemo1 {

	/**
	 * 提供一个默认的执行的方法:execute
	 */
	public String execute(){
		System.out.println("StrutsDemo1中的execute执行了...");
		return null;
	}
}
完成Action的配置:
在src下引入一个struts.xml

<struts>
	<!-- 配置一个包:package -->
	<package name="demo1" extends="struts-default" namespace="/">
		<!-- 配置Action -->
		<action name="strutsDemo1" class="cn.itcast.struts2.action.StrutsDemo1">
			
		</action>
	</package>
</struts>
配置核心过滤器:
  <!-- 配置Struts2的核心过滤器：前端控制器 -->
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>struts2</filter-name>
  	<url-pattern>/*</url-pattern>
  </filter-mapping>
修改Action，将方法设置一个返回值:
public class StrutsDemo1 {

	/**
	 * 提供一个默认的执行的方法:execute
	 */
	public String execute(){
		System.out.println("StrutsDemo1中的execute执行了...");
		return "success";
	}
}
修改struts.xml
<struts>
	<!-- 配置一个包:package -->
	<package name="demo1" extends="struts-default" namespace="/">
		<!-- 配置Action -->
		<action name="strutsDemo1" class="cn.itcast.struts2.action.StrutsDemo1">
			<!-- 配置结果页面的跳转 -->
			<result name="success">/demo1/demo2.jsp</result>
		</action>
	</package>
</struts>
Struts2开发流程分析
Struts2的执行流程:
从客户端发送请求过来 先经过前端控制器（核心过滤器StrutsPrepareAndExecuteFilter）过滤器中执行一组拦截器（一组拦截器 就会完成部分功能代码）执行目标Action，在Action中返回一个结果视图,根据Result的配置进行页面的跳转.


配置struts.xml中的提示(在不联网情况下)
DTD存放的路径:src\core\src\main\resources\struts-2.3.dtd
Window--->Preferences--->在左侧搜索xml catalog--->add添加.
* 选择URI
* 文件系统 选择dtd路径



Struts2的常见配置
Struts2的配置文件的加载顺序:
查看StrutsPrepareAndExecuteFilter:(核心过滤器)两个功能 ：预处理 和 执行 
在预处理功能中 init 方法中会有加载配置文件的代码:
dispatcher.init();
            init_DefaultProperties(); // [1]					---- 加载org.apache.struts.default.properties.配置的是struts2的所有常量.
            init_TraditionalXmlConfigurations(); // [2]		---- 加载struts-default.xml、struts-plugin.xml、struts.xml
            init_LegacyStrutsProperties(); // [3]				---- 加载用户自定义struts.properties
            init_CustomConfigurationProviders(); // [5]		---- 加载Struts2定义Bean.
            init_FilterInitParameters() ; // [6]				---- 加载web.xml
            init_AliasStandardObjects() ; // [7]				---- 用户自定义Bean

结论:
* default.properties
* struts-default.xml
* struts-plugin.xml
* struts.xml				---- 配置Action以及常量.(******)
* struts.properties		---- 配置常量
* web.xml				---- 配置核心过滤器及常量.

***** 后配置的常量 会 覆盖先配置的常量.
Action的配置:
<package>的配置:
* package:包. 不是java中说那个包. Struts2中的包 管理<action>.
* 属性:
* name		:包名.包名是唯一的不能重复的.
* extends	:继承.继承struts-default.（struts-default包中定义结果类型和拦截器.）
* namespace	:名称空间.与<action>标签中的name属性共同决定Action的访问路径.
* 写法:
* namespace有名称:	namespace=”/aa”
* namespace只是一个/:	 namespance=”/”
* namespace默认的:	namespace没写.
    
* abstract	:抽象的.用于使其他的包可以继承的.
* <package name="struts-default" abstract="true"> . 所以可以继承struts-default.

<action>的配置:
* action:配置Action类的访问路径.
* 属性:
* name	:名称.与<package>中的namespace属性共同决定访问路径.
* class	:类的全路径.要执行的Action类的全路径.
* method	:方法.用来指定Action中执行那个方法的方法名.(默认的值execute)

<result>的配置:
* result:配置Action执行后的页面跳转.
* 属性:
* name	:逻辑视图名称.（不是真实的视图，为真实的视图起了一个别名,在Action中返回这个字符串的别名,从而找到具体页面.）
* type	:跳转的类型.
默认的Action和Action的默认处理类:
默认的Action:
<!-- 配置默认的Action:Action的访问路径不存在的时候,执行一个默认的Action -->
<default-action-ref name="strutsDemo1"/>


Action的默认处理类：
<!-- Action的默认处理类:Action的访问路径配置正确了，但是没有配置class属性. -->
<default-class-ref class="com.opensymphony.xwork2.ActionSupport"/>

Struts2常量的配置:
修改常量:
* struts.xml中修改常量（推荐使用）
	<!-- 修改Struts2的常量的值 -->
	<constant name="struts.action.extension" value="abc"/>

* struts.properties修改常量
	struts.action.extension=xxx

* web.xml中修改常量
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  	<init-param>
  		<param-name>struts.action.extension</param-name>
  		<param-value>xyz</param-value>
  	</init-param>
  </filter>

分模块开发的时候
<include file="cn/itcast/struts2/demo1/struts_demo1.xml"/>  整合其他的struts的配置文件.
Struts2的Action的访问:
Action的编写的方式:
【Action的是一个POJO的类】
Action是简单的Java对象没有实现任何借口 和 继承任何类.
public class ActionDemo1 {

	public String execute(){
		System.out.println("ActionDemo1执行了...");
		return null;
	}
}
【Action类实现一个Action的接口】
public class ActionDemo2 implements Action{

	@Override
	public String execute() throws Exception {
		System.out.println("ActionDemo2执行了...");
		return null;
	}

}

Action接口中提供了5个已经定义好的视图名称:
    * SUCCESS		:success，代表成功.
    * NONE			:none，代表页面不跳转
    * ERROR			:error，代表跳转到错误页面.
    * INPUT			:input，数据校验的时候跳转的路径.
    * LOGIN			:login，用来跳转到登录页面.
【Action类继承ActionSupport类】
public class ActionDemo3 extends ActionSupport{

	@Override
	public String execute() throws Exception {
		System.out.println("ActionDemo3执行了...");
		return NONE;
	}
}

ActionSupport中提供了一些功能，比如数据校验，比如国际化… 如果Action继承了ActionSupport，那么Action就会有这些功能.
Action的访问:
Action的访问不是难题，因为之前已经访问过了，但是出现一个问题一次请求现在对应一个Action，那么如果请求很多对应很多个Action.现在要处理的问题就是要让一个模块的操作提交到一个Action中。
【解决Action的访问的问题的方式一：通过配置method属性完成】
页面：
<h3>客户的管理</h3>
<a href="${ pageContext.request.contextPath }/saveCustomerAction.action">添加客户</a> <br/>
<a href="${ pageContext.request.contextPath }/updateCustomerAction.action">修改客户</a> <br/>
<a href="${ pageContext.request.contextPath }/deleteCustomerAction.action">删除客户</a> <br/>
<a href="${ pageContext.request.contextPath }/findCustomerAction.action">查询客户</a> <br/>


编写Action:
public class CustomerAction extends ActionSupport{

	public String save(){
		System.out.println("CustomerAction中save方法执行了...");
		return NONE;
	}
	public String update(){
		System.out.println("CustomerAction中update方法执行了...");
		return NONE;
	}
	public String delete(){
		System.out.println("CustomerAction中delete方法执行了...");
		return NONE;
	}
	public String find(){
		System.out.println("CustomerAction中find方法执行了...");
		return NONE;
	}
}

配置Action:
	<package name="demo3" extends="struts-default" namespace="/">
		<action name="saveCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="save"></action>
		<action name="updateCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="update"></action>
		<action name="deleteCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="delete"></action>
		<action name="findCustomerAction" class="cn.itcast.struts2.demo3.CustomerAction" method="find"></action>
	
	</package>

【解决Action的访问的问题的方式二：通过通配符的配置完成】
第一种解决方案不是很优秀，因为在Action的配置中配置多条.能不能一个Class类只对应一个配置?

页面:
<h3>联系人的管理</h3>
<a href="${ pageContext.request.contextPath }/linkman_save.action">添加联系人</a> <br/>
<a href="${ pageContext.request.contextPath }/linkman_update.action">修改联系人</a> <br/>
<a href="${ pageContext.request.contextPath }/linkman_delete.action">删除联系人</a> <br/>
<a href="${ pageContext.request.contextPath }/linkman_find.action">查询联系人</a> <br/>

编写Action:
public class LinkManAction extends ActionSupport{

	public String save(){
		System.out.println("保存联系人...");
		return NONE;
	}
	public String update(){
		System.out.println("修改联系人...");
		return NONE;
	}
	public String delete(){
		System.out.println("删除联系人...");
		return NONE;
	}
	public String find(){
		System.out.println("查询联系人...");
		return NONE;
	}
}

配置Action:
	<!-- 通配符的配置 -->
	<action name="linkman_*" class="cn.itcast.struts2.demo3.LinkManAction" method="{1}"></action>

【解决Action的访问的问题的方式三：动态方法访问】
开启一个常量:动态方法访问.
<constant name="struts.enable.DynamicMethodInvocation" value="true"></constant>

编写Action:
public class UserAction extends ActionSupport{

	public String save(){
		System.out.println("保存用户...");
		return NONE;
	}
	public String update(){
		System.out.println("修改用户...");
		return NONE;
	}
	public String delete(){
		System.out.println("删除用户...");
		return NONE;
	}
	public String find(){
		System.out.println("查询用户...");
		return NONE;
	}
}

配置Action:
<!-- 动态方法访问的配置 -->
<action name="userAction" class="cn.itcast.struts2.demo3.UserAction"></action>

页面路径写法:
<h3>用户的管理</h3>
<a href="${ pageContext.request.contextPath }/userAction!save.action">添加用户</a> <br/>
<a href="${ pageContext.request.contextPath }/userAction!update.action">修改用户</a> <br/>
<a href="${ pageContext.request.contextPath }/userAction!delete.action">删除用户</a> <br/>
<a href="${ pageContext.request.contextPath }/userAction!find.action">查询用户</a> <br/>


第1章Struts2_day02
今日任务
使用Struts2完成对客户的新增操作
教学导航
教学目标	
教学方法	案例驱动法
案例一: 使用Struts2完成对客户的新增的优化操作
案例需求
需求概述
CRM系统中客户信息管理模块功能包括：
新增客户信息
客户信息查询
修改客户信息
删除客户信息

本功能要实现新增客户，页面如下：

相关知识点
Struts2访问Servlet的API:
可以使用完全解耦合的方式.
public class RequestActionDemo1 extends ActionSupport{

	@Override
	public String execute() throws Exception {
		// 接收表单的参数:
		// 使用的是Struts2中的一个对象ActionContext对象.
		ActionContext actionContext = ActionContext.getContext();
		// 接收参数:
		Map<String,Object> paramsMap = actionContext.getParameters();
		for (String key : paramsMap.keySet()) {
			String[] value = (String[]) paramsMap.get(key);
			System.out.println(key+"    "+value[0]);
		}
		
		// 向request中存入数据  request.setAttribute(String name,Object value);
		actionContext.put("requestName", "张三");
		// 向session中存入数据 request.getSession().setAttribute(String name,Object value);
		actionContext.getSession().put("sessionName", "李四");
		// 向application中存入数据 this.getServletContext().setAttribute(String name,Object value);
		actionContext.getApplication().put("applicationName", "王五");
		
		return SUCCESS;
	}
}
使用原生的Servlet的API
public class RequestActionDemo2 extends ActionSupport{

	@Override
	public String execute() throws Exception {
		// 接收参数:
		HttpServletRequest req = ServletActionContext.getRequest();
		Map<String,String[]> map = req.getParameterMap();
		for (String key : map.keySet()) {
			String[] value = map.get(key);
			System.out.println(key+"   "+value[0]);
		}
		
		// 向域中存入数据:
		req.setAttribute("requestName", "张三");
		// 向session中存入数据:
		req.getSession().setAttribute("sessionName", "李四");
		// 向application中保存:
		ServletActionContext.getServletContext().setAttribute("applicationName", "王五");
		return SUCCESS;
	}
}
结果页面的配置:
全局结果页面
<global-results>
	<result name="success">/demo3/demo2.jsp</result>
</global-results>
局部结果页面
		<action name="requestActionDemo2" class="cn.itcast.struts2.demo4.RequestActionDemo2">
			<result name="success">/demo3/demo3.jsp</result>
		</action>

<result>标签:
    * name		：返回一个逻辑视图名称.
    * type		: 跳转的采用的方式.
        * dispatcher			:默认值，转发. 转发到一个JSP页面	
        * redirect			:重定向. 重定向到一个JSP页面
        * chain				:转发,转发到一个Action.
        * redirectAction		:重定向到另一个Action

Struts的数据封装
实际开发的场景:页面提交参数,在Action中接收参数,需要进行数据的封装,封装到JavaBean中,将JavaBean传递给业务层.
属性驱动
【一、编写属性的set方法的方式进行参数的封装】使用比较少.
页面：
<h1>Struts2的属性驱动中:set方法的方式</h1>
<form action="${ pageContext.request.contextPath }/strutsDemo1.action" method="post">
	名称:<input type="text" name="name"><br/>
	年龄:<input type="text" name="age"><br/>
	生日:<input type="text" name="birthday"><br/>
	<input type="submit" value="提交">
</form>

Action:
public class StrutsDemo1 extends ActionSupport{
	// 接收参数:
	private String name;
	private Integer age;
	private Date birthday;
	public void setName(String name) {
		this.name = name;
	}

	public void setAge(Integer age) {
		this.age = age;
	}

	public void setBirthday(Date birthday) {
		this.birthday = birthday;
	}
…
}

***** 这种方式还需要手动封装对象。
【二、页面中使用表达式的方式进行参数的封装】
页面:
<h1>Struts2的属性驱动中:OGNL表达式的方式</h1>
<form action="${ pageContext.request.contextPath }/strutsDemo2.action" method="post">
	名称:<input type="text" name="user.name"><br/>
	年龄:<input type="text" name="user.age"><br/>
	生日:<input type="text" name="user.birthday"><br/>
	<input type="submit" value="提交">
</form>

Action:
public class StrutsDemo2 extends ActionSupport{

	private User user;
	// 必须提供get方法.
	public User getUser() { 
		return user;
	}

	public void setUser(User user) {
		this.user = user;
	}
…
}
模型驱动
【三、使用模型驱动的方式进行参数的封装】（优先）
页面:
<h1>Struts2的模型驱动驱动中:模型驱动的方式</h1>
<form action="${ pageContext.request.contextPath }/strutsDemo3.action" method="post">
	名称:<input type="text" name="name"><br/>
	年龄:<input type="text" name="age"><br/>
	生日:<input type="text" name="birthday"><br/>
	<input type="submit" value="提交">
</form>

Action：
public class StrutsDemo3 extends ActionSupport implements ModelDriven<User>{
	// 模型驱动使用的对象.
	private User user = new User();// 必须手动new
	@Override
	public User getModel() {
		return user;
	}
…
}
Struts2中封装复杂类型的数据:
封装到List集合中:
页面:
<form action="${ pageContext.request.contextPath }/strutsDemo4.action" method="post">
	名称:<input type="text" name="list[0].name"><br/>
	年龄:<input type="text" name="list[0].age"><br/>
	生日:<input type="text" name="list[0].birthday"><br/>
	名称:<input type="text" name="list[1].name"><br/>
	年龄:<input type="text" name="list[1].age"><br/>
	生日:<input type="text" name="list[1].birthday"><br/>
	<input type="submit" value="提交">
</form>

Action：
public class StrutsDemo4 extends ActionSupport{
	private List<User> list;
	
	public List<User> getList() {
		return list;
	}

	public void setList(List<User> list) {
		this.list = list;
	}

	@Override
	public String execute() throws Exception {
		for (User user : list) {
			System.out.println(user);
		}
		return NONE;
	}
}
封装数据到Map集合:
页面:
<h1>批量插入用户:封装到Map集合</h1>
<form action="${ pageContext.request.contextPath }/strutsDemo5.action" method="post">
	名称:<input type="text" name="map['one'].name"><br/>
	年龄:<input type="text" name="map['one'].age"><br/>
	生日:<input type="text" name="map['one'].birthday"><br/>
	名称:<input type="text" name="map['two'].name"><br/>
	年龄:<input type="text" name="map['two'].age"><br/>
	生日:<input type="text" name="map['two'].birthday"><br/>
	<input type="submit" value="提交">
</form>

Action:
public class StrutsDemo5 extends ActionSupport {
	private Map<String,User> map;
	
	public Map<String, User> getMap() {
		return map;
	}

	public void setMap(Map<String, User> map) {
		this.map = map;
	}

	@Override
	public String execute() throws Exception {
		for (String key : map.keySet()) {
			User user = map.get(key);
			System.out.println(key+"    "+user);
		}
		return NONE;
	}
}
案例代码：
环境准备
代码实现
总结:
Struts2的拦截器:
拦截器的概述
拦截器，在AOP（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。
在Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。
谈到拦截器，还有一个词大家应该知道——拦截器链 （Interceptor Chain，在Struts 2中称为拦截器栈Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。
拦截器的实现原理:
大部分时候，拦截器方法都是通过代理的方式来调用的。Struts 2的拦截器实现相对简单。当请求到达Struts 2的ServletDispatcher时，Struts 2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表，最后一个一个地调用列表中的拦截器。
Struts2拦截器是可插拔的，拦截器是AOP的一种实现。Struts2拦截器栈就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，Struts2拦截器链中的拦截器就会按其之前定义的顺序被调用。
Struts2的执行流程:

自定义拦截器及配置:
第一步: 自定义一个实现Interceptor接口（或者继承自AbstractInterceptor）的类。
第二步：在strutx.xml中注册上一步中定义的拦截器。
第三步：在需要使用的Action中引用上述定义的拦截器，为了方便也可将拦截器定义为默认的拦截器，这样在不加特殊声明的情况下所有的Action都被这个拦截器拦截。
第1章Struts2_day03
今日任务
使用Struts2完成对客户的查询操作
教学导航
教学目标	
教学方法	案例驱动法
案例一: 使用Struts2完成对客户的查询操作
案例需求
需求概述
CRM系统中客户信息管理模块功能包括：
新增客户信息
客户信息查询
修改客户信息
删除客户信息

本功能要实现查询客户，页面如下：


相关知识点
OGNL的概述
什么是OGNL

OGNL的作用
   1、支持对象方法调用，如xxx.doSomeSpecial()； 
   2、支持类静态的方法调用和值访问，表达式的格式:
      @[类全名（包括包路径）]@[方法名 |  值名]，例如：
             @java.lang.String@format('foo %s', 'bar')
             或@tutorial.MyConstant@APP_NAME；
      设置 struts.ognl.allowStaticMethodAccess=true
   3、访问OGNL上下文（OGNL context）和ActionContext；访问值栈
   4、支持赋值操作和表达式串联，如price=100, discount=0.8,
        calculatePrice()，这个表达式会返回80； 
   5、操作集合对象。
OGNL的入门:
	@Test
	// OGNL调用对象的方法:
	public void demo1() throws OgnlException{
		OgnlContext context = new OgnlContext();
		Object obj = Ognl.getValue("'helloworld'.length()", context, context.getRoot());
		System.out.println(obj);
	}
	
	@Test
	// OGNL获取数据:
	public void demo3() throws OgnlException{
		OgnlContext context = new OgnlContext();
		
		// 获取OgnlContext中的数据:
		/*context.put("name", "张三");
		String name = (String) Ognl.getValue("#name", context, context.getRoot());
		System.out.println(name);*/
		
		// 获得Root中的数据
		User user = new User();
		user.setName("李四");
		context.setRoot(user);
		
		String name = (String) Ognl.getValue("name", context, context.getRoot());
		System.out.println(name);
	}
值栈的概述
什么是值栈？ 
	ValueStack是Struts的一个接口，字面意义为值栈，OgnlValueStack是ValueStack的实现类，客户端发起一个请求struts2架构会创建一个action实例同时创建一个OgnlValueStack值栈实例，OgnlValueStack贯穿整个 Action 的生命周期，struts2中使用OGNL将请求Action的参数封装为对象存储到值栈中，并通过OGNL表达式读取值栈中的对象属性值。
值栈的内部结构:

在 OnglValueStack 中包括两部分，值栈和map（即ognl上下文）


Context: 即OgnlContext上下文，它是一个map结构，上下文中存储了一些引用，parameters、request、session、application等，上下文的Root为CompoundRoot。
OgnlContext中的一些引用：
		parameters: 该 Map 中包含当前请求的请求参数
		request: 该 Map 中包含当前 request 对象中的所有属性
		session: 该 Map 中包含当前 session 对象中的所有属性
		application:该 Map 中包含当前 application  对象中的所有属性
		attr: 该 Map 按如下顺序来检索某个属性: request, session, application

CompoundRoot：存储了action实例，它作为OgnlContext 的Root对象。
		CompoundRoot 继承ArrayList实现压栈和出栈功能，拥有栈的特点，先进后出，后进先出，最后压进栈的数据在栈顶。我们把它称为对象栈。
	
	struts2对原OGNL作出的改进就是Root使用CompoundRoot(自定义栈)，使用OnglValueStack的findValue方法可以在CompoundRoot中从栈顶向栈底找查找的对象的属性值。

	CompoundRoot作为OgnlContext 的Root对象，并且在CompoundRoot中action实例位于栈顶，当读取action的属性值时会先从栈顶对象中找对应的属性，如果找不到则继续找栈中的其它对象，如果找到则停止查找。

ActionContext和ValueStack的关系:
通过源码查询:
    public ActionContext createActionContext(HttpServletRequest request, HttpServletResponse response) {
        ActionContext ctx;
        Integer counter = 1;
        Integer oldCounter = (Integer) request.getAttribute(CLEANUP_RECURSION_COUNTER);
        if (oldCounter != null) {
            counter = oldCounter + 1;
        }
        
        ActionContext oldContext = ActionContext.getContext();
        if (oldContext != null) {
            // detected existing context, so we are probably in a forward
            ctx = new ActionContext(new HashMap<String, Object>(oldContext.getContextMap()));
        } else {
            ValueStack stack = dispatcher.getContainer().getInstance(ValueStackFactory.class).createValueStack();
            stack.getContext().putAll(dispatcher.createContextMap(request, response, null));
            ctx = new ActionContext(stack.getContext());
        }
        request.setAttribute(CLEANUP_RECURSION_COUNTER, counter);
        ActionContext.setContext(ctx);
        return ctx;
    }
* 在创建ActionContext的时候 创建ValueStack的对象，将ValueStack对象给ActionContext.
* ActionContext中有一个ValueStack的引用.  ValueStack中也有一个ActionContext的引用.
* ActionContext获取ServletAPI的时候,依赖值栈了.
获取值栈对象:
【通过ActionContext对象获取值栈.】
ValueStack stack1 =ActionContext.getContext().getValueStack();

【通过request域获取值栈.】
ValueStack stack2 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);
操作值栈:
【对Action中的属性提供get方法的方式】
因为Action本身在值栈中，Action中的属性也就默认在值栈中了，所以我们可以通过对Action的属性提供get方法的方式来操作值栈。
【手动操作值栈】
调用值栈的push和set方法对值栈进行操作
从值栈中获取数据

EL能够访问值栈
底层对Request对象的getAttribute方法进行增强:
public class StrutsRequestWrapper extends HttpServletRequestWrapper {

    private static final String REQUEST_WRAPPER_GET_ATTRIBUTE = "__requestWrapper.getAttribute";
    private final boolean disableRequestAttributeValueStackLookup;

    /**
     * The constructor
     * @param req The request
     */
    public StrutsRequestWrapper(HttpServletRequest req) {
        this(req, false);
    }

    /**
     * The constructor
     * @param req The request
     * @param disableRequestAttributeValueStackLookup flag for disabling request attribute value stack lookup (JSTL accessibility)
     */
    public StrutsRequestWrapper(HttpServletRequest req, boolean disableRequestAttributeValueStackLookup) {
        super(req);
        this.disableRequestAttributeValueStackLookup = disableRequestAttributeValueStackLookup;
    }

    /**
     * Gets the object, looking in the value stack if not found
     *
     * @param key The attribute key
     */
    public Object getAttribute(String key) {
        if (key == null) {
            throw new NullPointerException("You must specify a key value");
        }

        if (disableRequestAttributeValueStackLookup || key.startsWith("javax.servlet")) {
            // don't bother with the standard javax.servlet attributes, we can short-circuit this
            // see WW-953 and the forums post linked in that issue for more info
            return super.getAttribute(key);
        }

        ActionContext ctx = ActionContext.getContext();
        Object attribute = super.getAttribute(key);

        if (ctx != null && attribute == null) {
            boolean alreadyIn = isTrue((Boolean) ctx.get(REQUEST_WRAPPER_GET_ATTRIBUTE));

            // note: we don't let # come through or else a request for
            // #attr.foo or #request.foo could cause an endless loop
            if (!alreadyIn && !key.contains("#")) {
                try {
                    // If not found, then try the ValueStack
                    ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.TRUE);
                    ValueStack stack = ctx.getValueStack();
                    if (stack != null) {
                        attribute = stack.findValue(key);
                    }
                } finally {
                    ctx.put(REQUEST_WRAPPER_GET_ATTRIBUTE, Boolean.FALSE);
                }
            }
        }
        return attribute;
    }
}
EL的特殊字符的使用:
#号的使用：
【获取context的数据】
<s:property value=”#request.name”/>
【用于构建一个Map集合】：使用struts的UI标签的时候.
<s:iterator value="#{'aaa':'111','bbb':'222','ccc':'333' }" var="entry">
	<s:property value="key"/>---<s:property value="value"/><br/>
	<s:property value="#entry.key"/>---<s:property value="#entry.value"/><br/>
</s:iterator>

<s:radio list="#{'1':'男','2':'女' }" name="sex"></s:radio>
%号的使用:
【%强制解析OGNL表达式】
<s:textfield name="name" value="%{#request.name}"/>
【%强制不解析OGNL表达式】
<s:property value="%{'#request.name'}"/>
$号的使用:
【在配置文件中使用OGNL表达式】
在struts的配置文件中使用.XML文件 或者 是属性文件.
案例实现
环境准备

代码实现


Spring_day01总结
今日任务
使用Spring完成对客户的保存操作
教学导航
教学目标	
教学方法	案例驱动法
案例一使用Spring的IOC完成保存客户的操作:
案例需求
需求概述
CRM系统中客户信息管理模块功能包括：
新增客户信息
客户信息查询
修改客户信息
删除客户信息

本功能要实现新增客户，页面如下：



相关知识点
1.2.5Spring的概述:
什么是Spring :

Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。

EE开发分成三层结构:
* WEB层:Spring MVC.
* 业务层:Bean管理:(IOC)
* 持久层:Spring的JDBC模板.ORM模板用于整合其他的持久层框架.

Expert One-to-One J2EE Design and Development		:J2EE的设计和开发:(2002.EJB)
Expert One-to-One J2EE Development without EJB		:J2EE不使用EJB的开发.
为什么学习Spring:
方便解耦，简化开发
Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理
AOP编程的支持
Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能
声明式事务的支持
只需要通过配置就可以完成对事务的管理，而无需手动编程
方便程序的测试
Spring对Junit4支持，可以通过注解方便的测试Spring程序
方便集成各种优秀框架
Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持
降低JavaEE API的使用难度
Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低
Spring的版本:
Spring 3.X 和 Spring4.X
Spring的入门案例:(IOC)
IOC的底层实现原理

IOC：Inversion of Control 控制反转. 指的是 对象的创建权反转(交给)给Spring.
作用是实现了程序的解耦合.
步骤一:下载Spring的开发包:
官网：http://spring.io/ 
下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:)
* docs		:API和开发规范.
* libs		:jar包和源码.
* schema		:约束.
步骤二:创建web项目,引入Spring的开发包:


步骤三:引入相关配置文件:
log4j.properties
applicationContext.xml
引入约束:
spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.html

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

</beans>
步骤四:编写相关的类:
public interface UserDao {
	
	public void sayHello();
}

public class UserDaoImpl implements UserDao {

	@Override
	public void sayHello() {
		System.out.println("Hello Spring...");
	}

}
步骤五:完成配置：
    <!-- Spring的入门案例================ -->
	<bean id="userDao" class="cn.itcast.spring.demo1.UserDaoImpl"></bean>

步骤六:编写测试程序:
	@Test
	// Spring的方式：
	public void demo2(){
		// 创建Spring的工厂类：
		ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
		// 通过工厂解析XML获取Bean的实例.
		UserDao userDao = (UserDao) applicationContext.getBean("userDao");
		userDao.sayHello();
	}
IOC和DI:
IOC	:控制反转,将对象的创建权交给了Spring.
DI	:Dependency Injection 依赖注入.需要有IOC的环境,Spring创建这个类的过程中,Spring将类的依赖的属性设置进去.

Spring中的工厂:
ApplicationContext:
ApplicatioContext接口有两个实现类:


ClassPathXmlApplicationContext		:加载类路径下Spring的配置文件.
FileSystemXmlApplicationContext		:加载本地磁盘下Spring的配置文件.
BeanFactory:

BeanFactory和ApplicationContext的区别:
BeanFactory		:是在getBean的时候才会生成类的实例.
ApplicationContext	:在加载applicationContext.xml时候就会创建.
配置STS的XML的提示:
Spring配置文件中提示的配置
复制路径:
* http://www.springframework.org/schema/beans/spring-beans.xsd
查找XML Catalog:

点击Add..

Spring的相关配置:
id属性和name属性标签的配置
id	:Bean起个名字.	在约束中采用ID的约束:唯一.	必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号	id:不能出现特殊字符.
<bean id=”bookAction”>
name:Bean起个名字.	没有采用ID的约束.	 name:出现特殊字符.如果<bean>没有id的话 , name可以当做id使用.
* 整合struts1的时候:
<bean name=”/loginAction” >

scope属性：Bean的作用范围.
* singleton		:默认值，单例的.
* prototype		:多例的.
* request		:WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中.
* session		:WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中.
* globalSession	:WEB项目中,应用在Porlet环境.如果没有Porlet环境那么globalSession相当于session.

Bean的生命周期的配置:
通过配置<bean>标签上的init-method作为Bean的初始化的时候执行的方法，配置destroy-method作为Bean的销毁的时候执行的方法。
销毁方法想要执行，需要是单例创建的Bean而且在工厂关闭的时候，Bean才会被销毁.
Spring的Bean的管理XML的方式：
Spring的Bean的属性注入:
【构造方法的方式注入属性】
	<!-- 第一种：构造方法的方式 -->
	<bean id="car" class="cn.itcast.spring.demo4.Car">
		<constructor-arg name="name" value="保时捷"/>
		<constructor-arg name="price" value="1000000"/>
	</bean>

【set方法的方式注入属性】
	<!-- 第二种：set方法的方式 -->
	<bean id="car2" class="cn.itcast.spring.demo4.Car2">
		<property name="name" value="奇瑞QQ"/>
		<property name="price" value="40000"/>
	</bean>
Spring的属性注入：对象类型的注入:
	<!-- 注入对象类型的属性 -->
	<bean id="person" class="cn.itcast.spring.demo4.Person">
		<property name="name" value="会希"/>
		<!-- ref属性：引用另一个bean的id或name -->
		<property name="car2" ref="car2"/>
	</bean>

名称空间p的属性注入的方式:Spring2.x版本后提供的方式.
第一步:引入p名称空间
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

第二步:使用p名称空间.
    * 普通属性:    		p:属性名称=””
    * 对象类型属性:	p:属性名称-ref=””

<!-- p名称空间的属性注入的方式 -->
	<bean id="car2" class="cn.itcast.spring.demo4.Car2" p:name="宝马7" p:price="1200000"/>
<bean id="person" class="cn.itcast.spring.demo4.Person" p:name="思聪" p:car2-ref="car2"/>
SpEL的方式的属性注入:Spring3.x版本后提供的方式.
SpEL：Spring Expression Language.
语法:#{ SpEL }

	<!-- SpEL的注入的方式 -->
	<bean id="car2" class="cn.itcast.spring.demo4.Car2">
		<property name="name" value="#{'奔驰'}"/>
		<property name="price" value="#{800000}"/>
	</bean>

    <bean id="person" class="cn.itcast.spring.demo4.Person">
    	<property name="name" value="#{'冠希'}"/>
    	<property name="car2" value="#{car2}"/>
    </bean>

	<bean id="carInfo" class="cn.itcast.spring.demo4.CarInfo"></bean>
	
 	引用了另一个类的属性
	<bean id="car2" class="cn.itcast.spring.demo4.Car2">
<!-- 		<property name="name" value="#{'奔驰'}"/> -->
		<property name="name" value="#{carInfo.carName}"/>
		<property name="price" value="#{carInfo.calculatePrice()}"/>
	</bean>
注入复杂类型:
<!-- Spring的复杂类型的注入===================== -->
	<bean id="collectionBean" class="cn.itcast.spring.demo5.CollectionBean">
		<!-- 数组类型的属性 -->
		<property name="arrs">
			<list>
				<value>会希</value>
				<value>冠希</value>
				<value>天一</value>
			</list>
		</property>
		
		<!-- 注入List集合的数据 -->
		<property name="list">
			<list>
				<value>芙蓉</value>
				<value>如花</value>
				<value>凤姐</value>
			</list>
		</property>
		
		<!-- 注入Map集合 -->
		<property name="map">
			<map>
				<entry key="aaa" value="111"/>
				<entry key="bbb" value="222"/>
				<entry key="ccc" value="333"/>
			</map>
		</property>
		
		<!-- Properties的注入 -->
		<property name="properties">
			<props>
				<prop key="username">root</prop>
				<prop key="password">123</prop>
			</props>
		</property>
	</bean>
Spring的分配置文件的开发
一种:创建工厂的时候加载多个配置文件:
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml","applicationContext2.xml");

二种:在一个配置文件中包含另一个配置文件：
<import resource="applicationContext2.xml"></import>

案例代码
搭建环境:
创建web项目，引入jar包.
WEB层使用Struts2:
	* Struts2开发的基本的包
Spring进行Bean管理:
     * Spring开发的基本的包
引入配置文件:
Struts2:
    * web.xml
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>struts2</filter-name>
  	<url-pattern>/*</url-pattern>
  </filter-mapping>
    * struts.xml

Spring:
    * applicationContext.xml
    * log4j.properties

引入页面:

创建包结构和类：

在添加页面提交内容到Action:

改写Action类并配置Action：
<struts>
	<package name="crm" extends="struts-default" namespace="/">
		<action name="customer_*" class="cn.itcast.crm.web.action.CustomerAction" method="{1}">
			
		</action>
	</package>
</struts>
在Action调用业务层:
将业务层类配置到Spring中:
	<bean id="customerService" class="cn.itcast.crm.service.impl.CustomerServiceImpl">
		
	</bean>

在Action中获取业务层类:
	public String save(){
		System.out.println("Action中的save方法执行了...");
		System.out.println(customer);
		
		// 传统方式:
		/*CustomerService customerService = new CustomerServiceImpl();
		customerService.save(customer);*/
		
		// Spring的方式进行操作:
		ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
		CustomerService customerService = (CustomerService) applicationContext.getBean("customerService");
		customerService.save(customer);
		return NONE;
	}

**** 每次请求都会创建一个工厂类,服务器端的资源就浪费了,一般情况下一个工程只有一个Spring的工厂类就OK了.
    * 将工厂在服务器启动的时候创建好,将这个工厂放入到ServletContext域中.每次获取工厂从ServletContext域中进行获取.
    * ServletContextLinstener	:监听ServletContext对象的创建和销毁.
Spring整合WEB项目
引入spring-web.jar包:
配置监听器:
  <listener>
  	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  
  <context-param>
  	<param-name>contextConfigLocation</param-name>
  	<param-value>classpath:applicationContext.xml</param-value>
  </context-param>


改写Action:
	/**
	 * 保存客户的执行的方法：save
	 */
	public String save(){
		// 传统方式:
		/*CustomerService customerService = new CustomerServiceImpl();
		customerService.save(customer);*/
		
		// Spring的方式进行操作:
		/*ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
		CustomerService customerService = (CustomerService) applicationContext.getBean("customerService");*/
		
		WebApplicationContext applicationContext =WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext());
		CustomerService customerService = (CustomerService) applicationContext.getBean("customerService");
		
		System.out.println("Action中的save方法执行了...");
		System.out.println(customer);
		customerService.save(customer);
		return NONE;
	}


编写Dao并配置:
	<bean id="customerDao" class="cn.itcast.crm.dao.impl.CustomerDaoImpl">
	
	</bean>

业务层调用DAO：
public class CustomerServiceImpl implements CustomerService {

	private CustomerDao customerDao;
	
	public void setCustomerDao(CustomerDao customerDao) {
		this.customerDao = customerDao;
	}

…
}

	<bean id="customerService" class="cn.itcast.crm.service.impl.CustomerServiceImpl">
		<property name="customerDao" ref="customerDao"/>
	</bean>


Spring_day02总结
今日任务
使用Spring的AOP对客户管理的DAO进行增强
教学导航
教学目标	

教学方法	案例驱动法
案例一使用Spring的AOP对客户管理的DAO进行增强
案例需求
需求描述
对于CRM的系统而言，现在有很多的DAO类，比如客户的DAO，联系人DAO等等。客户提出一个需求要开发人员实现一个功能对所有的DAO的类中以save开头的方法实现权限的校验，需要时管理员的身份才可以进行保存操作。
相关知识点
	Spring的Bean管理:(注解方式)
步骤一:下载Spring的开发包:
官网：http://spring.io/ 
下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:)
* docs		:API和开发规范.
* libs		:jar包和源码.
* schema		:约束.
步骤二:创建web项目,引入Spring的开发包:


在Spring的注解的AOP中需要引入spring-aop的jar包。
步骤三:引入相关配置文件:
log4j.properties
applicationContext.xml
引入约束:
spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.html

* 引入约束:(引入context的约束):
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

</beans>
步骤四:编写相关的类:
public interface UserDao {
	
	public void sayHello();
}

public class UserDaoImpl implements UserDao {

	@Override
	public void sayHello() {
		System.out.println("Hello Spring...");
	}

}
步骤五:配置注解扫描
<!-- Spring的注解开发:组件扫描(类上注解: 可以直接使用属性注入的注解) -->
	<context:component-scan base-package="com.itheima.spring.demo1"/>
在相关的类上添加注解:
@Component(value="userDao")
public class UserDaoImpl implements UserDao {

	@Override
	public void sayHello() {
		System.out.println("Hello Spring Annotation...");
	}

}
编写测试类:
	@Test
	public void demo2() {
		ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
				"applicationContext.xml");
		UserDao userDao = (UserDao) applicationContext.getBean("userDao");
		userDao.sayHello();
	}


Spring的Bean管理的中常用的注解:
@Component:组件.(作用在类上)
Spring中提供@Component的三个衍生注解:(功能目前来讲是一致的)
* @Controller	:WEB层
* @Service		:业务层
* @Repository	:持久层

这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强
属性注入的注解:(使用注解注入的方式,可以不用提供set方法.)
@Value		:用于注入普通类型.
@Autowired	:自动装配:
* 默认按类型进行装配.
* 按名称注入:
* @Qualifier:强制使用名称注入.
@Resource相当于:
* @Autowired和@Qualifier一起使用.
Bean的作用范围的注解:
@Scope:
* singleton:单例
* prototype:多例
Bean的生命周期的配置:
@PostConstruct	:相当于init-method
@PreDestroy		:相当于destroy-method
Spring的Bean管理的方式的比较:


XML和注解:
* XML	:结构清晰.
* 注解	:开发方便.(属性注入.)

实际开发中还有一种XML和注解整合开发:
* Bean有XML配置.但是使用的属性使用注解注入.

AOP的概述
什么是AOP

Spring是解决实际开发中的一些问题:
* AOP解决OOP中遇到的一些问题.是OOP的延续和扩展.
为什么学习AOP
对程序进行增强:不修改源码的情况下.
* AOP可以进行权限校验,日志记录,性能监控,事务控制.
Spring的AOP的由来:
AOP最早由AOP联盟的组织提出的,制定了一套规范.Spring将AOP思想引入到框架中,必须遵守AOP联盟的规范.
底层实现:
代理机制:
* Spring的AOP的底层用到两种代理机制：
    * JDK的动态代理	:针对实现了接口的类产生代理.
    * Cglib的动态代理	:针对没有实现接口的类产生代理. 应用的是底层的字节码增强的技术 生成当前类的子类对象.

Spring底层AOP的实现原理:（了解）
JDK动态代理增强一个类中方法:
public class MyJDKProxy implements InvocationHandler {

	private UserDao userDao;

	public MyJDKProxy(UserDao userDao) {
		this.userDao = userDao;
	}

	// 编写工具方法：生成代理：
	public UserDao createProxy(){
		UserDao userDaoProxy = (UserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(),
				userDao.getClass().getInterfaces(), this);

		return userDaoProxy;
	}
	
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		if("save".equals(method.getName())){
			System.out.println("权限校验================");
		}
		return method.invoke(userDao, args);
	}
}
Cglib动态代理增强一个类中的方法:
public class MyCglibProxy implements MethodInterceptor{

	private CustomerDao customerDao;

	public MyCglibProxy(CustomerDao customerDao){
		this.customerDao = customerDao;
	}
	
	// 生成代理的方法:
	public CustomerDao createProxy(){
		// 创建Cglib的核心类:
		Enhancer enhancer = new Enhancer();
		// 设置父类:
		enhancer.setSuperclass(CustomerDao.class);
		// 设置回调:
		enhancer.setCallback(this);
		// 生成代理：
		CustomerDao customerDaoProxy = (CustomerDao) enhancer.create();
		return customerDaoProxy;
	}

	@Override
	public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
		if("delete".equals(method.getName())){
			Object obj = methodProxy.invokeSuper(proxy, args);
			System.out.println("日志记录================");
			return obj;
		}
		
		return methodProxy.invokeSuper(proxy, args);
	}
}
Spring的基于AspectJ的AOP开发
AOP的开发中的相关术语:
Joinpoint(连接点):所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点.
Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义.
Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)
Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.
Target(目标对象):代理的目标对象
Weaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程.
	spring采用动态代理织入，而AspectJ采用编译期织入和类装在期织入
Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类
Aspect(切面): 是切入点和通知（引介）的结合
Spring使用AspectJ进行AOP的开发：XML的方式（*****）
引入相应的jar包
* spring的传统AOP的开发的包
spring-aop-4.2.4.RELEASE.jar
com.springsource.org.aopalliance-1.0.0.jar
* aspectJ的开发包:
com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar
spring-aspects-4.2.4.RELEASE.jar

引入Spring的配置文件
引入AOP约束:
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
	
</beans>
编写目标类
创建接口和类:
public interface OrderDao {
	public void save();
	public void update();
	public void delete();
	public void find();
}

public class OrderDaoImpl implements OrderDao {

	@Override
	public void save() {
		System.out.println("保存订单...");
	}

	@Override
	public void update() {
		System.out.println("修改订单...");
	}

	@Override
	public void delete() {
		System.out.println("删除订单...");
	}

	@Override
	public void find() {
		System.out.println("查询订单...");
	}

}
目标类的配置
	<!-- 目标类================ -->
	<bean id="orderDao" class="cn.itcast.spring.demo3.OrderDaoImpl">
	
	</bean>
整合Junit单元测试
引入spring-test.jar

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class SpringDemo3 {
	@Resource(name="orderDao")
	private OrderDao orderDao;
	
	@Test
	public void demo1(){
		orderDao.save();
		orderDao.update();
		orderDao.delete();
		orderDao.find();
	}
}
通知类型
前置通知	：在目标方法执行之前执行.
后置通知	：在目标方法执行之后执行
环绕通知	：在目标方法执行前和执行后执行
异常抛出通知：在目标方法执行出现 异常的时候 执行
最终通知	：无论目标方法是否出现异常 最终通知都会 执行.
切入点表达式
execution(表达式)
表达式:
[方法访问修饰符] 方法返回值 包名.类名.方法名(方法的参数)
public * cn.itcast.spring.dao.*.*(..)
* cn.itcast.spring.dao.*.*(..)
* cn.itcast.spring.dao.UserDao+.*(..)
* cn.itcast.spring.dao..*.*(..)

编写一个切面类
public class MyAspectXml {
	// 前置增强
	public void before(){
		System.out.println("前置增强===========");
	}
}
配置完成增强
	<!-- 配置切面类 -->
	<bean id="myAspectXml" class="cn.itcast.spring.demo3.MyAspectXml"></bean>
	
	<!-- 进行aop的配置 -->
	<aop:config>
		<!-- 配置切入点表达式:哪些类的哪些方法需要进行增强 -->
		<aop:pointcut expression="execution(* cn.itcast.spring.demo3.OrderDao.save(..))" id="pointcut1"/>
		<!-- 配置切面 -->
		<aop:aspect ref="myAspectXml">
			<aop:before method="before" pointcut-ref="pointcut1"/>
		</aop:aspect>
	</aop:config>

其他的增强的配置：
	<!-- 配置切面类 -->
	<bean id="myAspectXml" class="cn.itcast.spring.demo3.MyAspectXml"></bean>
	
	<!-- 进行aop的配置 -->
	<aop:config>
		<!-- 配置切入点表达式:哪些类的哪些方法需要进行增强 -->
		<aop:pointcut expression="execution(* cn.itcast.spring.demo3.*Dao.save(..))" id="pointcut1"/>
		<aop:pointcut expression="execution(* cn.itcast.spring.demo3.*Dao.delete(..))" id="pointcut2"/>
		<aop:pointcut expression="execution(* cn.itcast.spring.demo3.*Dao.update(..))" id="pointcut3"/>
		<aop:pointcut expression="execution(* cn.itcast.spring.demo3.*Dao.find(..))" id="pointcut4"/>
		<!-- 配置切面 -->
		<aop:aspect ref="myAspectXml">
			<aop:before method="before" pointcut-ref="pointcut1"/>
			<aop:after-returning method="afterReturing" pointcut-ref="pointcut2"/>
			<aop:around method="around" pointcut-ref="pointcut3"/>
			<aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4"/>
			<aop:after method="after" pointcut-ref="pointcut4"/>
		</aop:aspect>
	</aop:config>
Spring_day03总结
今日任务
使用Spring的AOP对客户管理的DAO进行增强
使用Spring完成转账的事务管理
教学导航
教学目标	掌握Spring的声明式事务
掌握SSH的整合

教学方法	案例驱动法
案例一：使用Spring的AOP对客户管理的DAO进行增强
案例需求
需求描述
对于CRM的系统而言，现在有很多的DAO类，比如客户的DAO，联系人DAO等等。客户提出一个需求要开发人员实现一个功能对所有的DAO的类中以save开头的方法实现权限的校验，需要时管理员的身份才可以进行保存操作。
相关知识点
Spring使用AspectJ进行AOP的开发:注解的方式
引入相关的jar包:
* spring的传统AOP的开发的包
spring-aop-4.2.4.RELEASE.jar
com.springsource.org.aopalliance-1.0.0.jar
* aspectJ的开发包:
com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar
spring-aspects-4.2.4.RELEASE.jar

引入Spring的配置文件
引入AOP约束:
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
	
</beans>
编写目标类:
public class ProductDao {
	public void save(){
		System.out.println("保存商品...");
	}
	public void update(){
		System.out.println("修改商品...");
	}
	public void delete(){
		System.out.println("删除商品...");
	}
	public void find(){
		System.out.println("查询商品...");
	}
}
配置目标类：
     <!-- 目标类============ -->
     <bean id="productDao" class="cn.itcast.spring.demo4.ProductDao"></bean>   
开启aop注解的自动代理:
<aop:aspectj-autoproxy/>
AspectJ的AOP的注解:
@Aspect:定义切面类的注解

通知类型:
    * @Before			:前置通知
    * @AfterReturing		:后置通知
    * @Around			:环绕通知
    * @After				:最终通知
    * @AfterThrowing		:异常抛出通知.

@Pointcut:定义切入点的注解
编写切面类:
@Aspect
public class MyAspectAnno {

	@Before("MyAspectAnno.pointcut1()")
	public void before(){
		System.out.println("前置通知===========");
	}
	
	@Pointcut("execution(* cn.itcast.spring.demo4.ProductDao.save(..))")
	private void pointcut1(){}
}
配置切面:
     <!-- 配置切面类 -->
     <bean id="myAspectAnno" class="cn.itcast.spring.demo4.MyAspectAnno"></bean>  
其他通知的注解:
@Aspect
public class MyAspectAnno {

	@Before("MyAspectAnno.pointcut1()")
	public void before(){
		System.out.println("前置通知===========");
	}
	
	@AfterReturning("MyAspectAnno.pointcut2()")
	public void afterReturning(){
		System.out.println("后置通知===========");
	}
	
	@Around("MyAspectAnno.pointcut3()")
	public Object around(ProceedingJoinPoint joinPoint) throws Throwable{
		System.out.println("环绕前通知==========");
		Object obj = joinPoint.proceed();
		System.out.println("环绕后通知==========");
		return obj;
	}
	
	@AfterThrowing("MyAspectAnno.pointcut4()")
	public void afterThrowing(){
		System.out.println("异常抛出通知========");
	}
	
	@After("MyAspectAnno.pointcut4()")
	public void after(){
		System.out.println("最终通知==========");
	}
	
	@Pointcut("execution(* cn.itcast.spring.demo4.ProductDao.save(..))")
	private void pointcut1(){}
	@Pointcut("execution(* cn.itcast.spring.demo4.ProductDao.update(..))")
	private void pointcut2(){}
	@Pointcut("execution(* cn.itcast.spring.demo4.ProductDao.delete(..))")
	private void pointcut3(){}
	@Pointcut("execution(* cn.itcast.spring.demo4.ProductDao.find(..))")
	private void pointcut4(){}
}

案例二：Spring的事务管理完成转账的案例
案例需求:
需求描述:
完成一个转账的功能,需要进行事务的管理，使用Spring的事务管理的方式完成.
相关知识点
Spring的JDBC的模板:
Spring提供了很多持久层技术的模板类简化编程:

创建数据库和表:

引入相关开发包:
Spring的基本的开发包需要引入的:6个.

创建一个测试类:
	@Test
	// JDBC模板的基本使用：
	public void demo1(){
		DriverManagerDataSource dataSource = new DriverManagerDataSource();
		dataSource.setDriverClassName("com.mysql.jdbc.Driver");
		dataSource.setUrl("jdbc:mysql:///spring_day03");
		dataSource.setUsername("root");
		dataSource.setPassword("123");
		
		JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
		jdbcTemplate.update("insert into account values (null,?,?)", "会希",10000d);
	}
将连接池的配置交给Spring管理:
Spring内置的连接池的配置：
【引入Spring的配置文件】

【配置内置连接池】
    <!-- 配置Spring的内置连接池 -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    	<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    	<property name="url" value="jdbc:mysql:///spring_day02"/>
    	<property name="username" value="root"/>
    	<property name="password" value="123"/>
    </bean>
【将模板配置到Spring中】
    <!-- 配置JDBC模板 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    	<property name="dataSource" ref="dataSource"/>
    </bean>
【编写测试类】
**** 引入spring-aop.jar

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class SpringDemo2 {
	
	@Resource(name="jdbcTemplate")
	private JdbcTemplate jdbcTemplate;
	
	@Test
	public void demo1(){
		jdbcTemplate.update("insert into account values (null,?,?)", "凤姐",10000d);
	}

}
Spring中配置DBCP连接池:
【引入dbcp连接池的jar包】

【配置连接池】
    <!-- 配置DBCP连接池 -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    	<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    	<property name="url" value="jdbc:mysql:///spring_day02"/>
    	<property name="username" value="root"/>
    	<property name="password" value="123"/>
    </bean>
配置c3p0连接池:
【引入相应的jar包】
com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar

【配置连接池】
    <!-- 配置C3P0连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    	<property name="driverClass" value="com.mysql.jdbc.Driver"/>
    	<property name="jdbcUrl" value="jdbc:mysql:///spring_day02"/>
    	<property name="user" value="root"/>
    	<property name="password" value="123"/>
    </bean>
JDBC模板的CRUD的操作：
JDBC模板CRUD的操作:
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class SpringDemo3 {

	@Resource(name="jdbcTemplate")
	private JdbcTemplate jdbcTemplate;
	
	@Test
	// 插入操作
	public void demo1(){
		jdbcTemplate.update("insert into account values (null,?,?)", "冠希",10000d);
	}
	
	@Test
	// 修改操作
	public void demo2(){
		jdbcTemplate.update("update account set name=?,money =? where id = ?", "思雨",10000d,5);
	}
	
	@Test
	// 删除操作
	public void demo3(){
		jdbcTemplate.update("delete from account where id = ?", 5);
	}
	
	@Test
	// 查询一条记录
	public void demo4(){
		Account account = jdbcTemplate.queryForObject("select * from account where id = ?", new MyRowMapper(), 1);
		System.out.println(account);
	}
	
	@Test
	// 查询所有记录
	public void demo5(){
		List<Account> list = jdbcTemplate.query("select * from account", new MyRowMapper());
		for (Account account : list) {
			System.out.println(account);
		}
	}
	
	class MyRowMapper implements RowMapper<Account>{

		@Override
		public Account mapRow(ResultSet rs, int rowNum) throws SQLException {
			Account account = new Account();
			account.setId(rs.getInt("id"));
			account.setName(rs.getString("name"));
			account.setMoney(rs.getDouble("money"));
			return account;
		}
		
	}
}

事务的回顾:
什么是事务:
事务逻辑上的一组操作,组成这组操作的各个逻辑单元,要么一起成功,要么一起失败.
事务特性:
原子性	:强调事务的不可分割.
一致性	:事务的执行的前后数据的完整性保持一致.
隔离性	:一个事务执行的过程中,不应该受到其他事务的干扰
持久性	:事务一旦结束,数据就持久到数据库
如果不考虑隔离性引发安全性问题:
脏读		:一个事务读到了另一个事务的未提交的数据
不可重复读	:一个事务读到了另一个事务已经提交的update的数据导致多次查询结果不一致.
虚读		:一个事务读到了另一个事务已经提交的insert的数据导致多次查询结果不一致.
解决读问题:设置事务隔离级别
未提交读	:脏读，不可重复读，虚读都有可能发生
已提交读	:避免脏读。但是不可重复读和虚读有可能发生
可重复读	:避免脏读和不可重复读.但是虚读有可能发生.
串行化的	:避免以上所有读问题.
Spring进行事务管理一组API
PlatformTransactionManager:平台事务管理器.
***** 真正管理事务的对象
org.springframework.jdbc.datasource.DataSourceTransactionManager	使用Spring JDBC或iBatis 进行持久化数据时使用
org.springframework.orm.hibernate3.HibernateTransactionManager		使用Hibernate版本进行持久化数据时使用

TransactionDefinition:事务定义信息
事务定义信息:
* 隔离级别
* 传播行为
* 超时信息
* 是否只读
TransactionStatus:事务的状态
记录事务的状态
Spring的这组接口是如何进行事务管理：
平台事务管理根据事务定义的信息进行事务的管理,事务管理的过程中产生一些状态,将这些状态记录到TransactionStatus里面
事务的传播行为
PROPAGION_XXX		:事务的传播行为
     * 保证同一个事务中
PROPAGATION_REQUIRED		支持当前事务，如果不存在 就新建一个(默认)
PROPAGATION_SUPPORTS		支持当前事务，如果不存在，就不使用事务
PROPAGATION_MANDATORY	支持当前事务，如果不存在，抛出异常

* 保证没有在同一个事务中
PROPAGATION_REQUIRES_NEW	如果有事务存在，挂起当前事务，创建一个新的事务
PROPAGATION_NOT_SUPPORTED	以非事务方式运行，如果有事务存在，挂起当前事务
PROPAGATION_NEVER 	以非事务方式运行，如果有事务存在，抛出异常

PROPAGATION_NESTED	如果当前事务存在，则嵌套事务执行
案例代码
搭建转账的环境:
创建业务层和DAO的类
public interface AccountService {

	public void transfer(String from,String to,Double money);
}

public class AccountServiceImpl implements AccountService {

	// 业务层注入DAO:
	private AccountDao accountDao;
	
	public void setAccountDao(AccountDao accountDao) {
		this.accountDao = accountDao;
	}

	@Override
	/**
	 * from:转出的账号
	 * to:转入的账号
	 * money：转账金额
	 */
	public void transfer(String from, String to, Double money) {
		accountDao.outMoney(from, money);
		accountDao.inMoney(to, money);
	}

}

public interface AccountDao {

	public void outMoney(String from,Double money);
	
	public void inMoney(String to,Double money);
}

public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {

	@Override
	public void outMoney(String from, Double money) {
		this.getJdbcTemplate().update("update account set money = money - ? where name = ?", money,from);
	}

	@Override
	public void inMoney(String to, Double money) {
		this.getJdbcTemplate().update("update account set money = money + ? where name = ?", money,to);  
	}
          
}
配置业务层和DAO
    <!-- 配置业务层的类 -->
    <bean id="accountService" class="cn.itcast.transaction.demo1.AccountServiceImpl">
    	<property name="accountDao" ref="accountDao"/>
    </bean>
    
    <!-- 配置DAO的类 -->
    <bean id="accountDao" class="cn.itcast.transaction.demo1.AccountDaoImpl">
    	<property name="dataSource" ref="dataSource"/>
    </bean>
编写测试类
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext2.xml")
public class SpringDemo4 {
	
	@Resource(name="accountService")
	private AccountService accountService;
	
	@Test
	// 转账的测试:
	public void demo1(){
		accountService.transfer("会希", "凤姐", 1000d);
	}
}
Spring的编程式事务(了解)
手动编写代码完成事务的管理:
配置事务管理器
    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
   		 <property name="dataSource" ref="dataSource"/>
    </bean>
配置事务管理的模板
    <!-- 配置事务管理模板 -->
    <bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
    	<property name="transactionManager" ref="transactionManager"/>
    </bean>
需要在业务层注入事务管理模板
    <!-- 配置业务层的类 -->
    <bean id="accountService" class="cn.itcast.transaction.demo1.AccountServiceImpl">
    	<property name="accountDao" ref="accountDao"/>
    	<!-- 注入事务管理模板 -->
    	<property name="transactionTemplate" ref="transactionTemplate"/>
    </bean>
手动编写代码实现事务管理
	public void transfer(final String from, final String to, final Double money) {
		
		transactionTemplate.execute(new TransactionCallbackWithoutResult() {
			
			@Override
			protected void doInTransactionWithoutResult(TransactionStatus status) {
				accountDao.outMoney(from, money);
				int d = 1 / 0;
				accountDao.inMoney(to, money);
				
			}
		});
		
		
	}
Spring的声明式事务管理XML方式(*****)：思想就是AOP.
不需要进行手动编写代码，通过一段配置完成事务管理
引入AOP开发的包
aop联盟.jar
Spring-aop.jar
aspectJ.jar
spring-aspects.jar
恢复转账环境

配置事务管理器
    <!-- 事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    	<property name="dataSource" ref="dataSource"/>
    </bean>
配置事务的通知
    <!-- 配置事务的增强 -->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
    	<tx:attributes>
		  <!-- 
				isolation="DEFAULT"		隔离级别
				propagation="REQUIRED"	传播行为
				read-only="false"	只读
				timeout="-1"		过期时间
				rollback-for=""		-Exception
				no-rollback-for=""	+Exception
			 -->
    		<tx:method name="transfer" propagation="REQUIRED"/>
    	</tx:attributes>
    </tx:advice>
配置aop事务
    <aop:config>
    	<aop:pointcut expression="execution(* cn.itcast.transaction.demo2.AccountServiceImpl.transfer(..))" id="pointcut1"/>
    	<aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut1"/>
    </aop:config>
Spring的声明式事务的注解方式: (*****)
引入jar包:

恢复转账环境:

配置事务管理器:
	<!-- 配置事务管理器 -->
 	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
 		<property name="dataSource" ref="dataSource"/>
 	</bean>
开启事务管理的注解:
	<!-- 开启注解事务管理 -->
	<tx:annotation-driven transaction-manager="transactionManager"/>
在使用事务的类上添加一个注解：@Transactional


Spring_day04总结
今日任务
使用SSH整合完成客户的保存操作
教学导航
教学目标	
教学方法	案例驱动法
案例一使用SSH的整合完成客户的保存操作
案例需求
需求描述
使用SSH整合完成CRM的客户保存操作
相关知识点：
SSH简单的回顾:
SSH的基本开发回顾


SSH框架的整合方式一：零障碍整合(带有Hibernate配置文件)
创建web项目，引入相关jar包.
【Struts2】
D:\struts2\struts-2.3.24\apps\struts2-blank\WEB-INF\lib\*.jar

Struts2需要了解的jar包:
struts2-convention-plugin-2.3.24.jar			---Struts2注解的开发包.
struts2-json-plugin-2.3.24.jar					---Struts2整合AJAX返回JSON数据.
struts2-spring-plugin-2.3.24.jar				---Struts2整合Spring的插件包.
【Hibernate】
D:\hibernate-release-5.0.7.Final\lib\required\*.jar

日志记录:

log4j的包由Spring引入.
数据库驱动:

Hibernate引入连接池:
D:\hibernate-release-5.0.7.Final\lib\optional\c3p0\*.jar


【Spring】
基本的开发:

AOP开发:




JDBC开发:


事务管理的开发:

整合Hibernate:

整合web项目：

引入相关的配置文件:
【Struts2】
web.xml
  <!-- 配置Struts2的核心过滤器 -->
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>struts2</filter-name>
  	<url-pattern>/*</url-pattern>
  </filter-mapping>
struts.xml

【Hibernate】
核心配置：hibernate.cfg.xml


映射文件：

【Spring】
web.xml
  <!-- 配置Spring的核心监听器 -->
  <listener>
  	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  
  <context-param>
  	<param-name>contextConfigLocation</param-name>
  	<param-value>classpath:applicationContext.xml</param-value>
  </context-param>
applicationContext.xml

log4j.propertiess

引入相关的页面并进行修改:

创建包结构和相关的类:


Struts2和Spring的整合:方式一：Action类由Struts2自己创建
【编写Action中的save方法】
	/**
	 * 保存客户的执行的方法:save
	 */
	public String save(){
		System.out.println("Action中的save方法执行了...");
		return NONE;
	}

【配置Action类】
	<package name="ssh" extends="struts-default" namespace="/">
		<action name="customer_*" class="cn.itcast.ssh.web.action.CustomerAction" method="{1}">
		
		</action>
	</package>

【在Action中调用业务层的类】
配置Service:
    <!-- 配置Service -->
    <bean id="customerService" class="cn.itcast.ssh.service.impl.CustomerServiceImpl">
    
    </bean>

在Action中调用
// 传统方式的写法
		WebApplicationContext webApplicationContext = WebApplicationContextUtils
				.getWebApplicationContext(ServletActionContext.getServletContext());
		CustomerService customerService = (CustomerService) webApplicationContext.getBean("customerService");

***** 这种写法很麻烦的，因为需要在每个Action中的每个方法上获取工厂，通过工厂获得类.
为了简化这个代码引入一个插件的包:
struts2-spring-plugin-2.3.24.jar
在这个插件中开启一个Struts2常量
* <constant name="struts.objectFactory" value="spring" />
    * 默认的情况下struts2将这个常量关闭的，现在引入插件以后，将常量开启了，引发下面的一些常量生效.
struts.objectFactory.spring.autoWire = name
那么就可以在Action中提供想注入的属性了:
public class CustomerAction extends ActionSupport implements ModelDriven<Customer> {
	// 模型驱动使用的对象
	private Customer customer = new Customer();

	@Override
	public Customer getModel() {
		return customer;
	}
	
	// 注入业务层的类:
	private CustomerService customerService;

	public void setCustomerService(CustomerService customerService) {
		this.customerService = customerService;
	}


	/**
	 * 保存客户的执行的方法:save
	 */
	public String save() {
		System.out.println("Action中的save方法执行了...");
		// 传统方式的写法
		/*WebApplicationContext webApplicationContext = WebApplicationContextUtils
				.getWebApplicationContext(ServletActionContext.getServletContext());
		CustomerService customerService = (CustomerService) webApplicationContext.getBean("customerService");*/
		
		// 自动注入
		customerService.save(customer);
		return NONE;
	}
}
【在Service中编写save方法】
public class CustomerServiceImpl implements CustomerService {

	@Override
	public void save(Customer customer) {
		System.out.println("Service中的save方法执行了...");
	}

}

Struts2和Spring的整合方式二:Action类由Spring创建.（推荐）
【引入插件包】
struts2-spring-plugin-2.3.24.jar

【Action交给Spring管理】
将Action配置到Spring中.
    <!-- 配置Action -->
    <bean id="customerAction" class="cn.itcast.ssh.web.action.CustomerAction" scope="prototype">
     <!—必须手动注入属性-->
    	<property name="customerService" ref="customerService"/>
    </bean>

Action的配置：
	<package name="ssh" extends="struts-default" namespace="/">
		<action name="customer_*" class="customerAction" method="{1}">
		
		</action>
	</package>

在业务层调用DAO
【将DAO配置到Spring中】
    <!-- 配置DAO -->
    <bean id="customerDao" class="cn.itcast.ssh.dao.impl.CustomerDaoImpl">
    
    </bean>
【在业务层注入Dao】
public class CustomerServiceImpl implements CustomerService {

	// 注入Dao
	private CustomerDao customerDao;
	
	public void setCustomerDao(CustomerDao customerDao) {
		this.customerDao = customerDao;
	}

	@Override
	public void save(Customer customer) {
		System.out.println("Service中的save方法执行了...");
		customerDao.save(customer);
	}

}

    <!-- 配置Service -->
    <bean id="customerService" class="cn.itcast.ssh.service.impl.CustomerServiceImpl">
    	<property name="customerDao" ref="customerDao"/>
    </bean>

Spring整合Hibernate:
【创建映射文件】
<hibernate-mapping>
	<class name="cn.itcast.ssh.domain.Customer" table="cst_customer">
		<id name="cust_id">
			<generator class="native"/>
		</id>
		
		<property name="cust_name"/>
		<property name="cust_user_id"/>
		<property name="cust_create_id"/>
		<property name="cust_source"/>
		<property name="cust_industry"/>
		<property name="cust_level"/>
		<property name="cust_linkman"/>
		<property name="cust_phone"/>
		<property name="cust_mobile"/>
	</class>
</hibernate-mapping>

【加载到核心配置文件】
		<!-- 加载映射文件 -->
		<mapping resource="cn/itcast/ssh/domain/Customer.hbm.xml"/>
【在Spring的配置文件中完成如下配置】
    <!-- 配置Hibernate中的sessionFactory -->
    <bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    	<property name="configLocations" value="classpath:hibernate.cfg.xml"/>
    </bean>

【改写DAO】
public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao {

	@Override
	public void save(Customer customer) {
		System.out.println("DAO中的save方法执行了...");
		
	}

}

    <!-- 配置DAO -->
    <bean id="customerDao" class="cn.itcast.ssh.dao.impl.CustomerDaoImpl">
    	<property name="sessionFactory" ref="sessionFactory"/>
    </bean>
【调用模板中的方法】
	@Override
	public void save(Customer customer) {
		System.out.println("DAO中的save方法执行了...");
		// 保存:
		this.getHibernateTemplate().save(customer);
	}
配置Spring的事务管理：
【配置事务管理器】
    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
    	<property name="sessionFactory" ref="sessionFactory"/>
    </bean>

【注解事务管理的开启】
    <!-- 开启事务管理的注解 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
【在业务层添加一个注解】


SSH框架的整合方式二：不带Hibernate的配置文件
复制一个SSH1的项目.

查看Hibernate的配置文件：
Hibernate的配置文件包含如下内容：
连接数据库必要的参数:
Hibernate的属性:
连接池的配置:
映射文件的引入:

替换数据库连接参数和连接池的配置:
创建jdbc.properties
jdbc.driverClass=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql:///ssh1
jdbc.username=root
jdbc.password=123

在Spring中引入外部属性文件
    <!-- 引入外部属性文件 -->
    <context:property-placeholder location="classpath:jdbc.properties"/>
配置连接池:
      <!-- 配置c3p0连接池: -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    	<property name="driverClass" value="${jdbc.driverClass}"/>
    	<property name="jdbcUrl" value="${jdbc.url}"/>
    	<property name="user" value="${jdbc.username}"/>
    	<property name="password" value="${jdbc.password}"/>
    </bean>
配置Hibernate的其他属性及映射:
    <!-- 配置Hibernate中的sessionFactory -->
    <bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    	<!-- 注入连接池 -->
    	<property name="dataSource" ref="dataSource"/>
    	
    	<!-- 配置Hibernate的相关属性 -->
    	<property name="hibernateProperties">
    		<props>
    			<!-- 配置Hibernate的方言 -->
    			<prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
    			<!-- 显示SQL -->
    			<prop key="hibernate.show_sql">true</prop>
    			<!-- 格式化SQL -->
    			<prop key="hibernate.format_sql">true</prop>
    			<!-- 映射到DDL的自动创建 -->
    			<prop key="hibernate.hbm2ddl.auto">update</prop>
    		</props>
    	</property>
    	
    	<!-- 配置引入映射文件 -->
    	<property name="mappingResources">
    		<list>
    			<value>cn/itcast/ssh/domain/Customer.hbm.xml</value>
    		</list>
    	</property>
    </bean>
HibernateTemplate的使用:
public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao {

	@Override
	public void save(Customer customer) {
		System.out.println("DAO中的save方法执行了...");
		// 保存:
		this.getHibernateTemplate().save(customer);
	}

	@Override
	public void update(Customer customer) {
		this.getHibernateTemplate().update(customer);
	}

	@Override
	public void delete(Customer customer) {
		this.getHibernateTemplate().delete(customer);
	}

	@Override
	public Customer findById(Long id) {
		return this.getHibernateTemplate().load(Customer.class, id);
	}

	@Override
	public List<Customer> findAllByHQL() {
		List<Customer> list = (List<Customer>) this.getHibernateTemplate().find("from Customer");
		return list;
	}
	
	public List<Customer> findAllByQBC(){
		DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class);
		List<Customer> list = (List<Customer>) this.getHibernateTemplate().findByCriteria(detachedCriteria);
		return list;
	}

}
延迟加载的问题的解决：OpenSessionInViewFilter
  <filter>
  	<filter-name>OpenSessionInViewFilter</filter-name>
  	<filter-class>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>OpenSessionInViewFilter</filter-name>
  	<url-pattern>*.action</url-pattern>
  </filter-mapping>


SVN使用手册
一．如果开发过程中没有SVN？
软件研发过程中，任意一个项目都是由一个团队完成的，而不能依靠单一个体完成。
在团队开发过程中，资料数据的共享与同步将成为开发过程中比较突出的问题。
图一：原始开发管理模式（COPY模式）
缺点：
代码管理混乱
备份多个版本，占用磁盘空间大
解决代码冲突困难
容易引发BUG
难于追溯问题代码的修改人和修改时间
难于恢复至以前正确版本
无法进行权限控制
项目版本发布困难
为保障团队开发过程中人员沟通各方面成本的降低，必须使用一种有效的方式减少沟通环节，提高开发效率，对资源的共享进行管理。
图二：现阶段的开发管理模式（Tools模式）
相关概念：
服务器		server		专用的硬件服务器
仓库		repository	专用于某个项目的磁盘空间，位于硬件服务器中
检出		checkout		一次性工作，下载代码并完成与服务器间的关联
上传/提交	commit		多次工作
更新		update		多次工作
记录日志	logger		记录操作相关的信息，包括动作，用户，时间，信息
版本号码	version		记录文件被操作的次数，即版本数
作为一个管理共享资源的工具必须具备以下几点：
1.能够记录日常事务中所有的文件的新建，编译，删除
2.能够记录文件的操作人，操作时间，操作描述信息
3.对于同一个文件，能够提供更多的历史版本供适用者参考
4.对于不同的文件，能够提供更高的管理权限，限制用户的使用能力
5.对于不同的项目/Case，能够提供更多的空间管理模式
6.对于不同的用户，提供远端访问支持，使用户更快捷进行资源共享
二．
什么是版本控制
版本控制(Revision control)是维护工程蓝图的标准做法，能追踪工程蓝图从诞生到定案的过程。是一种记录多个文件内容变化，以便将来查阅特定版本修订情况的系统。
三．主流的版本控制工具
VSS:Visual Source Safe(Microsoft Visual Studio成员)主要任务是负责项目文件的管理
CVS:march-hare出品的一套用于进行文件版本控制软件
SVN:Apache软件基金会名下的一套用于进行文件版本控制软件
在2000年初，开发人员要写一个CVS的自由软件代替品，它保留CVS的基本思想，但没有它的错误和局限，保留CVS的基本特性但去除CVS的bug和不好的特性。
在2000年2月，他们联系《使用CVS开发开源项目》（Open Source Development with CVS）(Coriolis, 1999)的作者Karl Fogel，并征求了他是否愿意在这个新的项目中担任一个角色。巧合的是，当时Karl已经和他的朋友Jim Blandy讨论了一个关于新的版本控制系统的设计。在1995年，这两人就成立了Cyclic Software，一个提供CVS的商业支持的软件公司。虽然他们经营商业服务，但是仍然在每天都在工作中使用CVS。使用CVS的挫折感使得Jim认真思考更好的方法来管理数据，不但确定名字为“Subversion”，而且完成了Subversion档案库的基础设计。
当CollabNet的电话到来时，Karl立即答应了加入项目中，而且Jim让他的雇主RedHat Software同意让他在这个项目中不定期工作。CollabNet雇用了Karl和Ben Collins-Sussman，并在5月开始了详细设计工作。在得到了来自CollabNet的Brian Behlendorf、Jason Robbins和Greg Stein（当时是一名活跃在WebDAV/DeltaV规范过程的自由程序员）很多创意的帮助下，Subversion很快地引起了一个活跃开发者社区的注意。它找出并欢迎很多同样在CVS上受到挫折的社员能来为这个项目做点什么。
Subversion 最初的设计Team定下了几个简单的目标。 它必须在功能上可取代 CVS，也就是说, 所有 CVS 可做到的事, 它都要能够作到。 在修正最明显的瑕疵的同时, 还要保留相同的开发模式。 还有, Subversion 应该要和 CVS 很相像, 任何 CVS 使用者只要花费少许的力气, 就可以很快地上手。
经过十四个月的编码后, Subversion 于2001年8月31日开始实现 “自行管理”。 也就是说, 开发人员不再使用 CVS 来管理 Subversion 的代码, 而以 Subversion 自己来管理。
2009年11月，Subversion被Apache Incubator专案所接收。
2010年1月，正式成为Apache软件基金会的一个顶级专案，所以为Apache Subversion.
目前Apache Subversion的主席为Greg Stein, 项目领导者Release manager为Wandisco公司。
四．SVN是什么
SVN(subversion)是近年来崛起的版本管理工具，是cvs的接班人。目前，绝大多数开源软件都使用SVN作为代码版本管理软件。不要狭义的理解只服务于软件研发，很多公司都适用SVN管理整个公司的文档
五．SVN的作用
针对软件研发企业的软件生产过程而言，SVN用于管理整个开发过程中的源码，进行版本控制。

六．
SVN体系结构图


七．
SVN下载与安装



目录层次结构


八．
SVN服务端指令
SVN服务端指令是指在服务器端进行操作用于对服务器进行系统级设定与操作
1.查看svn版本信息
svnadmin --version 
2.创建数据仓库
svnadmin create E:\repository\svn\itcast
	准备工作
a)首先手动创建磁盘目录作为总数据仓库：E:\repository\svn
b)再手动创建磁盘目录作为具体的数据仓库：E:\repository\svn\itcast
c)执行指令将指定目录设置为具体的数据仓库
指令结果
	将设置指定目录为SVN仓库路径，用于保存共享数据



conf	目录	存放版本库所用配置文件的目录
authz	文件	授权信息
passwd	文件	用户安全信息，包含用户名与密码
svnserve.conf	文件	服务相关信息
db	目录	版本数据存储目录
hooks	目录	存放版本库勾子目录
locks	目录	存储库锁目录，用来跟踪库的访问者
注意事项
	创建数据仓库对应的路径必须存在，而被创建的仓库名称路径则自动创建
3.启动SVN服务器(单仓库)
svnserve –d –r E:\repository\svn\itcast
	准备工作
a)必须存在该路径，且是一个有效的SVN数据仓库
指令结果
		启动对应的数据仓库，作为服务，等待响应用户的SVN管理操作
4.启动SVN服务器(多仓库)
svnserve –d –r E:\repository\svn
	准备工作
a)必须存在该路径，并且其中包含有效的SVN数据仓库路径
指令结果
		启动对应目录下所有的数据仓库，作为服务，等待响应
注意事项
		多仓库启动模式下只有有效的仓库路径才可以被加载
【补】window指令：
查询当前计算机启动服务列表，SVN默认端口为3690
netstat –an
创建SVN服务器启动为window服务
sc create SVN-Service binpath= "D:\Program Files\Subversion\bin\svnserve.exe --service -r E:\repository\svn" displayname= "SVN-Service" start= auto depend= Tcpip
注意：上述指令为DOS指令，格式要求严谨，不能随意修改
sc delete 服务名称
九．
SVN客户端指令
SVN客户端指令是指在客户端进行操作用于对完成与服务器信息的交互
1.检出数据仓库信息(单仓库)
svn checkout svn://192.168.1.100 .
	准备工作
a)磁盘中创建一个目录，用于存放与SVN服务器进行交互的数据
b)执行指令时，将当前路径设置为上述目录
指令结果
	将指定的SVN服务器中的信息检出到当前目录，并在当前目录中生成与SVN服务器的连接数据，方便下一次与SVN服务器的连接。该目录中的不能手工修改
注意事项
a)如果执行指令时，没有进入到保存数据的目录，需要将指令修改为保存到指定路径的格式
		svn checkout svn://192.168.1.100 E:\work\jt
b)本机操作时，可能存在有多个IP地址，不妨换用localhost识别当前计算机
svn checkout svn://localhost E:\work\jt
c)连接时，可以添加端口号进行，默认可以不加，自动访问3690端口
svn checkout svn://localhost:3690 E:\work\jt
d)指令的最后一个参数，也就是同步的目录如果省略，默认为当前，等同于输入了.作为当前目录
svn checkout svn://localhost:3690 .
svn checkout svn://localhost:3690
2.检出数据仓库信息(多仓库)
svn checkout svn://192.168.1.100/itcast .
	准备工作
a)磁盘中创建一个目录，用于存放与SVN服务器进行交互的数据
b)执行指令时，将当前路径设置为上述目录
指令结果
	将指定的SVN服务器指定仓库中的信息检出到指定目录，并在指定目录中生成与SVN服务器的连接数据，方便下一次与SVN服务器的连接。
注意事项
a)所有注意事项参看单仓库提供模式
b)由于多仓库启动模式下，提供有多个仓库可使用，因此在指定了SVN服务器位置后，必须指定仓库名称
c)多仓库检出后会在检出目录中产生一个与被检出仓库相同名称的目录
3.将本地文件/目录加入版本控制
svn add User.java
	准备工作
a)在本地目录中创建文件/目录，用于加入版本控制
指令结果
	将本地文件/目录加入到版本控制，受SVN管理。
注意事项
a)未加入版本控制的文件/目录，无法与服务器进行交互
b)目录加入到版本控制后，目录中的所有文件与目录都将一并加入版本控制
c)如果是多仓库检出，需要设定仓库名称，然后设定文件名称
svn add itcast/User.java
或进入对应目录，使用add指令加入版本控制
4.将加入版本控制的文件/目录提交到服务器
svn commit User.java
	准备工作
a)在本地目录中存在有已加入版本控制的文件/目录
指令结果
	将指定文件或目录提交到SVN服务器，并记录相关日志描述信息
注意事项
a)由于日志信息是SVN进行版本控制中的重要信息，因此不能省略
b)只有加入SVN版本控制的文件/目录才可以进行提交，未加入SVN版本控制的文件/目录不参与提交，因此执行前必须保障add操作的完成
c)提交版本到SVN服务器时，需要进行权限认证，除进行正常的登录认证，也可以使用匿名用户进行操作，需要修改匿名用户的访问权限
开启匿名用户的操作功能
打开数据仓库中conf/svnserve.conf文件的anon-access = write选项，并设定对应的操作权限
d)SVN服务器的认证操作是在每次与SVN服务器进行数据交换时完成，因此无需重启服务器
e)提交后的文档不接受重复提交，SVN服务器发现当前代码与服务器代码版本相同时，不进行提交操作
f)SVN服务器中保存的文档不是源文件格式，
5.更新本地版本为SVN服务器最新版本
svn update
指令结果
	将本地文件/目录信息更新到与服务器相同版本信息
注意事项
a)更新时，如果不添加指定的文件/目录名称，则更新整个数据仓库
svn update fileName.txt
b)如果本地版本与服务器相同，则不进行任何操作
6.删除本地文件
svn delete User.java
	准备工作
a)在本地目录中存在有将要被删除的SVN控制文件/目录
指令结果
	将本地文件/目录信息删除
注意事项
a)delete指令只能删除本地文件，并没有提交/同步到SVN服务器
b)该指令删除的文件/目录，在未进行提交之前可通过revert指令进行恢复
7.恢复本地文件
svn revert User.java
	准备工作
a)在本地目录中存在有使用delete指令删除的SVN控制文件/目录且未提交到SVN服务器
指令结果
	将本地被删除文件/目录信息恢复
注意事项
a)revert指令只能恢复未提交的数据
8.获取服务器信息
svn info
9.获取服务器目录层次结构
svn list
10.获取服务器状态信息
svn status
11.获取svn指令帮助
svn help



十．
SVN图形用户界面操作——TortoiseSVN
TortoiseSVN是一款基于SVN服务器的图形化操作用户界面工具。TortoiseSVN提供了基于鼠标操作为主导的SVN版本控制管理工具
	安装完毕后，对当前操作系统重新启动，启动完成后，系统主菜单加入了使用TortoiseSVN对SVN服务器进行管理的工具

	使用TortoiseSVN完成SVN版本控制管理
	服务器相关操作
1.创建数据仓库
svnadmin create E:\repository\svn\itcast
在任意不是SVN数据仓库的目录中右键打开菜单，选择将当前目录创建为数据仓库

注意：满足如下条件之一，将弹出如下错误提示
当前目录已经是数据仓库
当前目录是数据仓库的子目录

2.启动SVN服务器(单仓库)
svnserve –d –r E:\repository\svn\itcast
日常工作中，SVN服务器多采用独立硬件服务器构建，并发布为服务启动，因此无需进行手工启动服务器的操作
3.启动SVN服务器(多仓库)
svnserve –d –r E:\repository\svn
日常工作中，SVN服务器多采用独立硬件服务器构建，并发布为服务启动，因此无需进行手工启动服务器的操作
	客户端相关操作
1.检出数据仓库信息(多仓库)
svn checkout svn://192.168.1.100/itcast .
创建新目录，用于本地保存SVN服务器对应的本地文件，并在目录中执行如下操作，即可创建于SVN服务器的关联



设置SVN服务器仓库名称与检出保存到对应的目录路径
与SVN服务器进行有效关联后，对应的文件夹将以特殊图标的形式呈现

2.将本地文件/目录加入版本控制
svn add User.java
在本地仓库中新创建的文件/目录，不受SVN服务器控制，需要先将其加入版本控制，对新建文件/目录点击右键，通过菜单完成加入版本控制

加入版本控制后，对应的文件/目录将以特殊图标的形式呈现

此时，由于本地仓库中存在有与SVN服务器中不同步的信息，因此图标发生变化

3.将加入版本控制的文件/目录提交到服务器
svn commit User.java
在待提交的文件上面通过右键菜单，完成对SVN服务器的提交操作

选择提交后，打开提交对话框，输入提交日志信息

提交成功后，返回提交成功信息回执，同时被提交文件/目录的图标发生变化


提交失败后，返回提交失败错误原因

4.更新本地版本为SVN服务器最新版本
svn update
在待更新的文件/目录/工程上面通过右键菜单，完成从SVN服务器进行更新的操作

更新完毕后，弹出对应的提示信息

5.删除本地文件
svn delete User.java
在待删除的文件/目录上面通过右键菜单，完成本地文件/目录的删除操作，该操作在未提交之前是可恢复的

6.恢复本地文件
svn revert User.java
对已删除的文件/目录，在未进行提交操作之前，可以对其进行恢复。在任意位置通过右键菜单完成。

选择恢复后，出现对话框，选择要恢复的文件/目录，然后完成恢复操作

选择确认操作后，完成恢复操作

7.提交冲突问题
在进行正常的提交时，如果本地版本与服务器版本不相同，会引发冲突问题。

解决冲突问题共分为三个步骤：
步骤一：获取服务器最新版本

同时，针对版本不统一的文件信息，会生成对应的文件，供用户查看

	带有黄色惊叹号的文件表示当前文件与SVN服务器中的文件冲突，并已将冲突内容进行了合并，需要用户手工修改。
	.mine后缀的文件是用户在更新之前的最后修改版本内容，可通过原始编辑器查看
	.r*后缀的文件是当前文件对应的各个版本的文件内容，r后面的数字是版本号，可
通过原始编辑器查看
步骤二：查看并修改冲突文件
	打开原始文件，其中包含有冲突内容，用户根据需要进行调整
步骤三：删除冲突备份信息，并进行提交
	将除冲突文件之外所生成的所有文件进行删除，并对原始文件进行合并冲突处理后，原始文件状态由冲突状态转换为已编辑状态。
                        
		此时即可正常提交，实际开发此现象大多发生在公共配置文件或系统配置文件上。
界面操作解决方案：
步骤一：获取服务器最新版本（同上）
步骤二：查看并修改冲突文件

		针对冲突代码进行建议处理

		选中冲突行（红色标识）

步骤三：标识解决冲突

		确认解除冲突，操作完毕后，临时文件将被删除

8.避免提交冲突——为文件加锁（基于权限）
对不希望出现冲突的文件添加属性

添加新的属性

	添加svn:needs-lock属性

确认添加属性

	加锁操作是为文件设置了一种状态，也属于对文件的修改，因此需要进行提交。加锁前与加锁后，文件的显示状态发生变化。
                       



提交冲突问题是使用SVN等版本控制工具中令用户最为头疼的问题，为避免提交冲突，可以为任何一个加入版本控制的资源提供锁，避免多用户同时操作同一文件引发冲突。由于文件锁定后，只能由一个用户操作，实际开发中没有实用性，不推荐使用。
对加锁文件的操作分为三个步骤：
步骤一：获取锁

获取锁后，显示当前被文件被某个用户锁定

此时其他用户再次获取当前文件锁时出现冲突，同时无法对文件进行操作

此时锁定文件的用户显示文件被锁定

步骤二：操作编辑文件，并提交，提交完毕后，恢复未锁定状态。

十一．
用户权限管理
svnserve.conf		svn服务器配置
anon-access = write
匿名用户访问版本库权限，可选值read/write/none
auth-access = write
授权用户访问版本库权限，可选值read/write/none
password-db = passwd
用户名密码文件，可以使用绝对路径，如果使用相对路径指相对于conf目录的位置路径。注意：如果该选项不开启，用户名密码文件将失效
authz-db = authz
授权管理文件，可以使用绝对路径，如果使用相对路径指相对于conf目录的位置路径。注意：如果该选项不开启，授权管理将失效
realm = My First Repository
版本库认证域名称，也就是需要认证的仓库名
passwd	用户名密码管理
[users]
设定用户信息
harry = harryssecret
用户名 = 密码
注意：用户名与密码间的空白
authz		授权管理
[groups]
设定用户组，便于管理
harry_and_sally = harry,sally
用户组名 = 用户名1，用户名2，用户名3，……

[/foo/bar]
设定访问权限按目录结构进行设定，根结构写为[/]
harry = rw
用户名 = 读写权限 r-读 w-写
@ harry_and_sally = rw
@用户组名 = 读写权限
* =
除上述设定外，其他用户权限为无
十二．
SVN本地导入与导出
1.导入
使用导入功能，可以快速为SVN仓库添加资源文件或目录层次结构，对某个要导入的文件夹执行如下右键功能

注意：导入的资源仅包含指定目录内的内容，不包含所选中目录
2.导出
SVN管理的文件，每个目录中都有一个隐含文件，记录了与SVN相关的信息，导出时，此类文件夹将被过滤掉，不跟随导出。对某个要导出的SVN本地工厂执行如下右键功能

然后选择导出位置，此时保存的目录将不携带SVN管理目录
十三．
SVN整合MyEclipse
为Eclipse/MyEclipse添加SVN插件支持，共分五个步骤
步骤一： 通过官网subclipse.tigris.org下载插件文件
eclipse_svn_site-1.6.5.zip		myeclipse-svn-site-1.6.16.zip
步骤二：解压压缩包中features与plugins文件夹，并复制到任意目录X。注意目录中不能包含有中文或空格字符。
步骤三：在MyEclipse安装目录的dropins目录下，创建文本文件，文件名任意，扩展名为.link，录入svn.link，并编辑内容如下：
path=X   注意：路径中的分隔符使用\\
path=E:\\MyEclipse\\myPlugin\\svn
步骤四：删除MyEclipse安装目录下的configuration\org.eclipse.update目录，重新加载配置信息
步骤五：启动MyEclipse，视图中添加了SVN的管理视图模式
SVN实用操作
	工程层次目录
		repositoryName
			trunk		用于保存开发主线
			branches		用于保存支线副本
			tags			用于保存标签副本
		Subversion 提供了主线、分支管理技术，使得在软件开发中可以更方便、灵活的对项目的进度、版本的发布、版本的维护、软件功能的拓展与定制进行管理。
主线(trunk)：一个项目建立时就存在，并伴随着项目的成长而不断的成长，直到项目完全结束。
分支(branch)：一般是指功能分支，例如：我们的某个项目要添加一个模块，但这个模块又比较复杂，实现难度比较大。为了不影响主线的稳定，我们就可以创建一个功能分支来专门开发这个模块，当这个模块开发完成以后，并通过测试部门的各项测试，再合并到主线中去。再比如，我们的交警 GPS 项目已经开发完成了，但是这个项目是给泉州交警做的，现在我们又接到了一个交警项目，不过是要给厦门交警大队的。现在厦门交警大队要求我们给他们定制一些功能。我们又不想再主线上进行修改，这个时候，我们也可以创建一个分支，并在这个分支上开发，这时是不会对主线造成影响的。等给厦门开发完成了以后，我们发现，他们要求的有些功能其实很好，以后别的地方可能也需要同样的功能。这个时候我们就可以根据我们的需要，将有用的模块有选择的合并到主线中来。
标签(tag)：标签和分支一样，也是一个目录，不过这个目录中一般存放的是发布的信息(当然我们也可以只用分支，但是用标签更清楚明了一些)。还是拿我们的交警项目来举个例子：我们的交警项目开发完成了以后，要拿给泉州交警大队用了，也就是要发布(release)，假设这个版本叫做1.0.2。这个时候，我们就要创建一个标签，当泉州交警大队用了三个月，发现了一个 BUG，我们只需要签出这个标签中的代码(它和我们刚提供给泉州交警大队时候的是一模一样的)，进行调试，并修正这个 BUG。然后再发布一个版本，假设叫做1.1.0，这个时候我们就在创建一个 1.1.0的标签……
要注意，标签目录里面的代码，要进行严格的控制，除了修正 BUG 外，不能做任何其他的事情。
共享工程
	检出工程
	提交
	更新
	恢复删除物理删除
恢复历史版本
历史版本比对
	同步
	冲突
	

十四．
SVN服务器整合
使用SVN进行版本控制需要基于SVN服务，实际开发中还存在另一种常见的服务提供方式，即将SVN部署到HTTP服务器中，通过http协议访问。由于SVN管理的仅仅是文件，不存在动态资源，因此使用HTTP服务器即可。
	一．Apache服务器安装与测试
1.下载Apache服务器安装客户端
apache_2.2.14-win32-x86-no_ssl.msi
2.安装Apache服务器
 
 
 
 

3.安装过程中会进行服务的注册，连续弹出三次DOS提示框。
		
4.此时快捷任务栏会添加Apache服务器的图标，默认为开启状态。

5.通过右键菜单可以控制Apache服务器。

6.控制窗口设置服务器状态。

7.通过浏览器访问http://localhost，测试服务器安装是否成功。

二．Apache服务器整合SVN，将SVN服务器访问权限交由Apache管理控制
1.修改Apache配置文件\conf\httpd.conf，开启下列两行配置(L:83 L:84)
LoadModule dav_module modules/mod_dav.so
LoadModule dav_fs_module modules/mod_dav_fs.so
注：上述配置中的文件可以在Apache安装目录的modules目录中查找到
2.将下列两行配置添加到上述内容后面
LoadModule dav_svn_module modules/mod_dav_svn.so
LoadModule authz_svn_module modules/mod_authz_svn.so
注：上述配置中的文件有SVN提供，可以在SVN的安装目录中bin目录中查找到
3.将SVN目录下bin目录中上述两个文件拷贝到Apache安装目录的modules目录中
4.使用Apache安装目录bin目录中的htpasswd指令为Apache服务器添加SVN访问权限
创建文件，保存用户权限，格式：htpasswd -cb [filename] [username] [password]
htpasswd -cb svn.pwd jock 123
添加用户权限到指定文件，格式：htpasswd -b [filename] [username] [password]
htpasswd –b svn.pwd jockme 123
注：操作完成后，会生成svn.pwd文件，该文件可以使用任意名称
5.将生成的密码文件svn.pwd移动到指定的SVN仓库配置路径conf目录下，与之前的三个配置文件同层
注：该文件是使用MD5加密后的文件，可以查阅，但不能修改，否则无法使用
    密码文件存放的位置不是SVN安装路径，是SVN仓库路径
6.在Apache服务器中添加SVN配置
添加到Apache服务器安装路径下的conf目录中的httpd.conf文件的最后，内容如下：
#配置虚拟目录#
<location /svn/project>
#引用远程访问模块
DAV svn
#项目版本库路径#
SVNPath E:\repository\svn\itcast
#授权文件#
AuthzSVNAccessFile E:\repository\svn\itcast\conf\authz
#所有用户都需要身份验证#
Satisfy Any
Require valid-user
#验证方式#
AuthType Basic
#项目的名称#
AuthName "project"
#用户文件#
AuthUserFile E:\repository\svn\itcast\conf\svn.pwd
</location>
说明：
<location /svn/project>
通过该路径访问SVN仓库，根据需要进行修改
SVNPath E:\repository\svn\itcast
SVN仓库路径，即保存SVN版本文件的目录路径
AuthzSVNAccessFile E:\repository\svn\itcast\conf\authz
SVN访问授权文件
AuthUserFile E:\repository\svn\itcast\conf\svn.pwd
Apache整合SVN专用授权用户文件
7.重启服务器，通过Apache服务器访问SVN版本管理
http://localhost/svn/project
三．使用Apache服务器整合SVN仓库
		通过TortoiseSVN访问Apache服务器

		通过MyEclipse访问Apache服务器

十五．
CVS简介(了解)
安装
配置
登录
	set cvsroot=:pserver:Jock@127.0.0.1/project
	cvs login
添加用户
	cvs passwd -a jockme
	cvs passwd -a zhangsan
	cvs passwd -a lisi
	
	cvs passwd -a -r jock zhangsan
cvs passwd -a -r jockme lisi
MyEclipse使用CVS




项目管理工具
maven
学习目标
第一天：
1、会使用maven构建项目的命令
2、会使用maven构建java项目和java web项目
3、构建maven-web工程整合struts2成功


第二天：
1、依赖管理--传递依赖 版本冲突处理
在web工程中加入struts-spring，通过传递依赖将spring加入进来。
通过锁定版本解决版本冲突。


2.在web的单个工程中实现SSH整合。


3、分模块构建工程

4、会向私服上传jar包。会从私服下载jar包
实现将dao上传私服
从私服下载，统一：在setting.xml中配置仓库
实现：从私服下载dao
	1）将dao工程关闭
	2）把本地仓库的dao删除

教学计划

课时	章节	知识点	备注
一	Maven介绍
Maven安装
入门程序-入门工程构建	Maven介绍	了解
		Maven安装与配置	重点
		Maven项目工程目录约定	重点
二	入门程序--Maven仓库
入门程序--常用的maven命令
Maven概念模型	Maven仓库	重点
		常用的maven命令	重点
		Maven概念模型	了解
三	项目构建
	M2e插件安装配置	重点
		坐标定义	重点
		构建web工程	重点
		Eclipse下maven命令的使用	重点
		生命周期	了解
四	依赖管理
Tomcat插件	添加依赖	重点
		依赖范围	重点
		Tomcat插件	重点
			
			
			

maven介绍
maven是什么
	maven翻译为“专家”，“内行”。Maven是Apache下的一个纯java开发的开源项目，它是一个项目管理工具，使用maven对java项目进行构建、依赖管理。当前使用Maven的项目在持续增长。
什么是项目构建
	项目构建是一个项目从编写源代码到编译、测试、运行、打包、部署、运行的过程
传统项目构建过程
	传统的使用eclipse构建项目的过程如下：


构建过程如下：
	1）在eclipse中创建一个java web工程
	2）在工程中编写源代码及配置文件等
	3）对源代码进行编译，java文件编译成class文件
	4）执行Junit单元测试
	5）将工程打成war包部署至tomcat运行
maven项目构建过程
	maven将项目构建的过程进行标准化，每个阶段使用一个命令完成，下图展示了构建过程的一些阶段，后面章节详细介绍每个阶段，这里先大概了解下：

上图中部分阶段对应命令如下：
清理阶段对应maven的命令是clean，清理输出的class文件
编译阶段对应maven的命令是compile，将java代码编译成class文件。
打包阶段对应maven的命令是package，java工程可以打成jar包，web工程可以打成war包

运行一个maven工程（web工程）需要一个命令：tomat:run

maven工程构建的优点：
1、一个命令完成构建、运行，方便快捷。
2、maven对每个构建阶段进行规范，非常有利于大型团队协作开发。

什么是依赖管理
	什么是依赖？一个java项目可能要使用一些第三方的jar包才可以运行，那么我们说这个java项目依赖了这些第三方的jar包。
	举个例子：一个crm系统，它的架构是SSH框架，该crm项目依赖SSH框架，具体它依赖的Hibernate、Spring、Struts2。
	什么是依赖管理？就是对项目所有依赖的jar包进行规范化管理。

传统项目的依赖管理
	传统的项目工程要管理所依赖的jar包完全靠人工进行，程序员从网上下载jar包添加到项目工程中，如下图：程序员手工将Hibernate、struts2、spring的jar添加到工程中的WEB-INF/lib目录下。


手工拷贝jar包添加到工程中的问题是：
1、没有对jar包的版本统一管理，容易导致版本冲突。
2、从网上找jar包非常不方便，有些jar找不到。
3、jar包添加到工程中导致工程过大。

maven项目的依赖管理
	maven项目管理所依赖的jar包不需要手动向工程添加jar包，只需要在pom.xml（maven工程的配置文件）添加jar包的坐标，自动从maven仓库中下载jar包、运行，如下图：



使用maven依赖管理添加jar的好处：
1、通过pom.xml文件对jar包的版本进行统一管理，可避免版本冲突。
2、maven团队维护了一个非常全的maven仓库，里边包括了当前使用的jar包，maven工程可以自动从maven仓库下载jar包，非常方便。


使用maven的好处
通过上边介绍传统项目和maven项目在项目构建及依赖管理方面的区域，maven有如下的好处：

1、一步构建
maven对项目构建的过程进行标准化，通过一个命令即可完成构建过程。
2、依赖管理
maven工程不用手动导jar包，通过在pom.xml中定义坐标从maven仓库自动下载，方便且不易出错。
3、maven的跨平台，可在window、linux上使用。
4、maven遵循规范开发有利于提高大型团队的开发效率，降低项目的维护成本，大公司都会考虑使用maven来构建项目。

maven安装
下载安装
下载
从该网站 http://maven.apache.org/download.cgi 下载maven3.3.9 版本 
	
解压
将maven解压到一个不含有中文和空格的目录中。

	bin目录 mvn.bat （以run方式运行项目）、 mvnDebug.bat（以debug方式运行项目 ）
	boot目录 maven运行需要类加载器 
conf目录 settings.xml 整个maven工具核心配置文件 
	lib目录 maven运行依赖jar包


环境变量配置

电脑上需安装java环境，安装JDK1.7 + 版本  （将JAVA_HOME/bin 配置环境变量path ）

配置 MAVEN_HOME 


将 %MAVEN_HOME%/bin 加入环境变量 path 


通过 mvn -v命令检查 maven是否安装成功，看到maven的版本为3.3.9及java版本为1.7即为安装成功。


maven仓库
maven仓库的作用
	maven的工作需要从仓库下载一些jar包，如下图所示，本地的项目A、项目B等都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。

下图描述了maven中仓库的类型：

	
本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找 
默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows用户目录。


远程仓库：如果本地需要插件或者jar包，本地仓库没有，默认去远程仓库下载。
远程仓库可以在互联网内也可以在局域网内。

中央仓库 ：在maven软件中内置一个远程仓库地址http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。


配置本地仓库
本课程是在无网的状态下学习，需要配置老师提供的本地仓库，将 “repository.rar”解压至自己的电脑上，本教程解压在F:\develop\maven\repository


 在MAVE_HOME/conf/settings.xml文件中配置本地仓库位置： 


全局setting与用户setting
	maven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。
	在maven安装目录下的有 conf/setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。
	如需要个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在：${user.dir} /.m2/settings.xml目录中,${user.dir} 指windows 中的用户目录。
	maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。



入门程序
学习目标
1、说出maven项目工程的目录结构是什么
2、在cmd命令行下测试maven的常用命令

maven工程运行演示
通过使用maven提供的命令来运行maven工程，体会maven构建工程的优点。

运行web工程
进入maven工程目录（当前目录有pom.xml文件），运行tomcat:run命令。



根据上边的提示信息，通过浏览器访问：http://localhost:8080/maven-helloworld/




问题处理
 如果本地仓库配置错误会报下边的错误


分析：
maven工程运行先从本地仓库找jar包，本地仓库没有再从中央仓库找，上边提示downloading。。。表示 从中央仓库下载jar，由于本地没有联网，报错。

解决：
在maven安装目录的conf/setting.xml文件中配置本地仓库，参考：“maven安装/配置本地仓库章节”。

Maven项目工程目录约定
使用maven创建的工程我们称它为maven工程，maven工程具有一定的目录规范，如下：

src/main/java —— 存放项目的.java文件
src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件
src/test/java —— 存放所有单元测试.java文件，如JUnit测试类
src/test/resources —— 测试资源文件
target —— 项目输出位置，编译后的class文件会输出到此目录
pom.xml——maven项目核心配置文件

Project
  |-src
  |   |-main
  |   |  |-java        —— 存放项目的.java文件
  |   |  |-resources   —— 存放项目资源文件，如spring, hibernate配置文件
         |-webapp     —— webapp目录是web工程的主目录
            |-WEB-INF
              |-web.xml
  |   |-test
  |      |-java        ——存放所有测试.java文件，如JUnit测试类
  |      |-resources   —— 测试资源文件
  |-target             —— 目标文件输出位置例如.class、.jar、.war文件
  |-pom.xml           ——maven项目核心配置文件



常用的maven命令
在cmd的状态下测试
compile
compile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。

cmd进入命令状态，执行mvn compile，如下图提示成功：



 查看 target目录，class文件已生成，编译完成。

test
test是maven工程的测试命令，会执行src/test/java下的单元测试类。
cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行1个测试用例，全部成功。





clean
clean是maven工程的清理命令，执行 clean会删除target目录的内容。

package
package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。

install
install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。

生命周期(了解)
三套生命周期
    maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： 

Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 
Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。
Site Lifecycle 生成项目报告，站点，发布站点。

生命周期的阶段
每个生命周期都有很多阶段，每个阶段对应一个执行命令。

1.如下是clean生命周期的阶段

pre-clean 执行一些需要在clean之前完成的工作 
clean 移除所有上一次构建生成的文件 
post-clean 执行一些需要在clean之后立刻完成的工作 

2.如下是default周期的内容：
    validate
    generate-sources
    process-sources
    generate-resources
    process-resources     复制并处理资源文件，至目标目录，准备打包。
    compile     编译项目的源代码。
    process-classes
    generate-test-sources 
    process-test-sources
    generate-test-resources
    process-test-resources     复制并处理资源文件，至目标测试目录。
    test-compile     编译测试源代码。
    process-test-classes
    test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。
    prepare-package
    package     接受编译好的代码，打包成可发布的格式，如 JAR 。
    pre-integration-test
    integration-test
    post-integration-test
    verify
    install     将包安装至本地仓库，以让其它项目依赖。
    deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。

3.如下是site生命周期的阶段
pre-site 执行一些需要在生成站点文档之前完成的工作 
site 生成项目的站点文档 
post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 
site-deploy 将生成的站点文档部署到特定的服务器上 

命令与生命周期的阶段
   每个maven命令对应生命周期的某个阶段，例如：mvn clean 命令对应clean生命周期的clean阶段， mvn test 命令对应default生命周期的test阶段。
   执行命令会将该命令在的在生命周期当中之前的阶段自动执行，比如：执行mvn clean 命令会自动执行pre-clean和clean两个阶段，mvn test命令会自动执行validate、compile、test等阶段。

注意：执行某个生命周期的某个阶段不会影响其它的生命周期！

	如果要同时执行多个生命周期的阶段可在命令行输入多个命令，中间以空格隔开，例如：
clean package 该命令执行clean生命周期的clean阶段和default生命周期的package阶段。

maven的概念模型
	Maven包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。
	下图是maven的概念模型图： 


项目对象模型 (Project Object Model)
一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。

依赖管理系统(Dependency Management System)
通过maven的依赖管理对项目所依赖的jar 包进行统一管理。
比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9，如下所示是junit4.9的依赖定义：
<!-- 依赖关系 -->
	<dependencies>
		<!-- 此项目运行使用junit，所以此项目依赖junit -->
		<dependency>
			<!-- junit的项目名称 -->
			<groupId>junit</groupId>
			<!-- junit的模块名称 -->
			<artifactId>junit</artifactId>
			<!-- junit版本 -->
			<version>4.9</version>
			<!-- 依赖范围：单元测试时使用junit -->
			<scope>test</scope>
		</dependency>

一个项目生命周期(Project Lifecycle)
	使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段： 

maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。

一组标准集合
	maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。

插件(plugin)目标(goal)
maven 管理项目生命周期过程都是基于插件完成的。


项目构建
学习目标
1、独立在eclipse中安装配置maven插件
2、说出maven坐标的含义
3、使用eclipse创建mavan工程（java工程及java web工程）
4、使用eclipse运行maven的命令

m2e插件安装配置
eclipse与maven
	通过入门程序中命令行的方式使用maven工作效率不高，可以在eclipse开发工具中集成maven软件，eclipse是一个开发工具，maven是一个项目管理工具，maven有一套项目构建的规范，在eclipse集成maven软件，最终通过eclipse创建maven工程。
插件安装
	本教程 使用eclipse mars 2版本，此版本自带maven插件不用单独安装。
在新建窗口中可看到maven项目的创建项表示maven插件已存在，如下图：


指定maven安装目录 
	一些高版本的eclipse已经内置了maven的安装，下图是eclipse mars2版本中已经内置了maven3.3.3版本，项目为了统一maven的版本不会使用eclipse内置的maven版本，这里我们maven3.3.9。





User Setting配置
	在eclipse中配置使用的maven的setting.xml文件，使用maven安装目录下的setting.xml文件。





注意：如果修改了 setting.xml文件需要点击上图中的“update settings”按钮对本地仓库重建索引，点击“Reindex”。

eclipse浏览仓库
	maven配置完成需要测试在eclipse中是否可以浏览maven的本地仓库，如果可以正常浏览maven本地仓库则说明eclipse集成maven已经完成。
	打开eclipse仓库视图，对插件和jar包建立索引

找到Local respository本地仓库项，点击Rebuild index重建索引 

重建索引完成点击前边的“+”图标即可查看本地仓库的内容：如下图：




定义maven坐标
	每个maven工程都需要定义本工程的坐标，坐标是maven对jar包的身份定义，比如：入门程序的坐标定义如下：

<!--项目名称，定义为组织名+项目名，类似包名-->
<groupId>cn.itcast.maven</groupId>
<!-- 模块名称 -->
<artifactId>maven-first</artifactId>
<!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 -->
<version>0.0.1-SNAPSHOT</version>
<packaging > ：打包类型
	jar：执行package会打成jar包
	war：执行package会打成war包
	pom ：用于maven工程的继承，通常父工程设置为pom 

构建web工程
需求
创建一个web工程，实现入门程序的功能。
1）添加index.jsp，输出hello world
2）添加一个servlet转发到jsp页面。
第一步创建maven工程
选择 Maven Project




了解一下骨架界面:
当我们不跳过骨架点击“next”会进入骨架选择页面，如果eclipse中配置本地仓库正确则显示出骨架：


选择webapp会创建一个maven工程（java web工程）
选择quickstart会创建一个maven工程（java工程）
注意：使用骨架的问题是创建的maven工程目录不完整，所以不推荐使用，本教程创建maven工程统一跳过骨架。


第二步定义坐标





第三步设置编译版本
	查看上边工程的编译版本为1.5，本教程 使用jdk1.7，需要设置编译版本为1.7，这里需要使用maven的插件来设置：
在pom.xml中加入：

  <build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.7</source>
					<target>1.7</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>
执行update project，查看编译版本为1.7：




第四步定义web.xml
在src/webapp中添加WEB-INF/web.xml文件，内容为：

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	id="WebApp_ID" version="2.5">

	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
		<welcome-file>index.htm</welcome-file>
		<welcome-file>index.jsp</welcome-file>
		<welcome-file>default.html</welcome-file>
		<welcome-file>default.htm</welcome-file>
		<welcome-file>default.jsp</welcome-file>
	</welcome-file-list>
</web-app>

第五步编写servlet

在src/main/java中创建ServletTest




public class ServletTest extends HttpServlet {

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

		this.doPost(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

		req.getRequestDispatcher("/jsp/test.jsp").forward(req, resp);
	}

}

第六步编写jsp


test.jsp的内容如下：


index.jsp的内容如下：


第七步添加servlet/jsp的jar包
servlet类中报错，无法解析javax.sevlet....

在maven工程中添加jar的方式是需要在pom.xml中添加servlet/jsp的坐标，maven自动从创建下载servlet/jsp的jar包

编辑pom.xml，如下：

<!-- 添加servlet-api，jsp-api -->
	<dependencies>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
		
	</dependencies>


第八步配置servlet
在web.xml中配置servlet，如下所示：

	<!-- 配置servlet -->
	<servlet>
		<servlet-name>servletTest</servlet-name>
		<servlet-class>cn.itcast.maven.servlet.ServletTest</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>servletTest</servlet-name>
		<url-pattern>/test</url-pattern>
	</servlet-mapping>

运行
cmd命令行进入工程目录，运行tomcat:run命令


eclipse下使用maven命令
在eclipse下测试命令

clean
compile
test
package
install



Run as 采用 mvn 命令运行 ，Debug as 采用 mvnDebug 命令调试方式运行（可打断点） 
Maven clean 清理target目录
Maven test 执行单元测试
Maven install将工程打包后发布到本地仓库

Maven build 使用之前操作过的命令 
Maven build … 手动输入命令内容，如下图：



编译命令 mvn compile 
	编译后 .class文件在 target/classes 下 （这个命令只会对java源程序编译， 不会编译测试代码 ， 编译测试类 mvn test-compile , 编译后.class 文件在 target\test-classes ）

测试命令 mvn test 
执行所有测试用例方法， 重新编译 

清除命令 mvn clean 
清除target目录 （清除所有编译结果或者打包结果 ），清理后编译。

打包命名 mvn package
java项目生成 jar包， web项目生成war包 
默认生成jar包名称 ： artifactId-version.jar 

安装命令
安装命令 mvn install  将工程打包后发布到本地仓库
	---- 安装到仓库/groupId/artifactId/version 目录






依赖管理-添加依赖
需求
实现web工程整合struts2框架。

添加依赖
dependency
在pom.xml中添加dependency标签，如下：
<dependency>
	<groupId><groupId>
	<artifactId></artifactId>
	<version></version>
</dependency>

参考入门工程的Junit4.9的依赖在web工程的pom.xml中添加dependency
	<dependencies>
		<!-- 添加junit4.9依赖 -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
		</dependency>
	</dependencies>

查找坐标
	添加依赖需要指定依赖jar包的坐标，但是很多情况我们是不知道jar包的的坐标，可以通过如下方式查询：
方法一：从互联网搜索
	http://search.maven.org/
	http://mvnrepository.com/
网站搜索示例：





方法二：使用maven插件的索引功能 
如果在本地仓库有我们要的jar包，可以在pom.xml中邮件添加依赖





构建web工程
添加struts2依赖
编写web工程的pom.xml文件，添加依赖，如下：

<!-- 依赖struts2 -->
<dependency>
		<groupId>org.apache.struts</groupId>
		<artifactId>struts2-core</artifactId>
		<version>2.3.24</version>
</dependency>


依赖范围
基本概念
	A依赖B，需要在A的pom.xml文件中添加B的坐标，添加坐标时需要指定依赖范围，依赖范围包括：
compile：编译范围，指A在编译时依赖B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。

provided：provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依赖在编译和测试时需要，在运行时不需要，比如：servlet api被tomcat容器提供。

runtime：runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以runtime范围的依赖会被打包。

test：test范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。
    
system：system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径，需要指定systemPath磁盘路径，system依赖不推荐使用。



 
在maven-web工程中测试各各scop。

测试总结：
默认引入 的jar包 ------- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ）
servlet-api 、jsp-api ------- provided （编译、测试 有效， 运行时无效 防止和tomcat下jar冲突）
jdbc驱动jar包 ---- runtime （测试、运行 有效 ）
junit ----- test （测试有效）

依赖范围由强到弱的顺序是：compile>provided>runtime>test

测试
1、向web工程 添加jsp/servlet依赖

<!-- servlet jsp -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
		
package打war观察jsp-api和servlet-api是否在war中存在？


2、向dao工程 添加jdbc依赖
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
			<scope>runtime</scope>
		</dependency>
package打war观察mysql-connctor-java是否在war中存在？

完整的pom.xml
根据需求web工程要实现整合struts2，完整的pom.xml如下：
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>cn.itcast.maven</groupId>
	<artifactId>maven-web-0120</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
	<name>web工程，包括jsp、action等</name>
	<description>web工程，包括jsp、action等</description>


	<dependencies>
		<!-- 添加junit4.9依赖 -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
			<scope>runtime</scope>
		</dependency>
		<!-- servlet jsp -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- 依赖struts2 -->
		<dependency>
			<groupId>org.apache.struts</groupId>
			<artifactId>struts2-core</artifactId>
			<version>2.3.24</version>
		</dependency>

	</dependencies>

	<build>
		<plugins>
		<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.7</source>
					<target>1.7</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>


action类
编写action，实现查询客户信息：
public class CustomerAction extends ActionSupport {

	private Long custId;

	/**
	 * @return the custId
	 */
	public Long getCustId() {
		return custId;
	}

	/**
	 * @param custId
	 *            the custId to set
	 */
	public void setCustId(Long custId) {
		this.custId = custId;
	}

	// 查询客户信息
	public String querycustomer() {

		System.out.println("客户请求客户Id："+custId);
		
		return "success";
	}
}

struts.xml

在src/main/resources创建struts.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"
    "http://struts.apache.org/dtds/struts-2.3.dtd">

<struts>
	<!-- 配置常量 -->
	<!-- 字符集 -->
	<constant name="struts.i18n.encoding" value="UTF-8"></constant>
	<!-- 开发模式 -->
	<constant name="struts.devMode" value="true"></constant>
	<!-- 主题 -->
	<constant name="struts.ui.theme" value="simple"></constant>
	<!-- 扩展名 -->
	<constant name="struts.action.extension" value="action"></constant>

	<!-- 通用package -->
	<package name="customer" namespace="/" extends="struts-default">

		<action name="querycustomer" class="cn.itcast.crm.action.CustomerAction"
			method="querycustomer">
			<result name="success">/jsp/querycustomer.jsp</result>
		</action>

	</package>
</struts>

web.xml
在web.xml中配置struts2的前端控制器

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	id="WebApp_ID" version="2.5">
	<filter>
		<filter-name>struts2</filter-name>
		<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>struts2</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
		<welcome-file>index.htm</welcome-file>
		<welcome-file>index.jsp</welcome-file>
		<welcome-file>default.html</welcome-file>
		<welcome-file>default.htm</welcome-file>
		<welcome-file>default.jsp</welcome-file>
	</welcome-file-list>
</web-app>


maven工程运行调试
tomcat插件
maven内置tomcat的插件（org.codehaus.mojo. tomcat-maven-plugin），执行tomcat:run命令即可启动tomcat



访问：http://localhost:8080/工程名/...

可以通过配置plugin修改tomcat的访问路径及端口：

	<build>
		<plugins>
			<!-- maven内置 的tomcat6插件 -->
			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>tomcat-maven-plugin</artifactId>
				<version>1.1</version>
				<configuration>
					<!-- 可以灵活配置工程路径 -->
					<path>/ssh</path>
					<!-- 可以灵活配置端口号 -->
					<port>8080</port>
				</configuration>
			</plugin>

		</plugins>
	</build>


端口占用处理
重新执行tomcat:run命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误：
	Caused by: java.net.BindException: Address already in use: JVM_Bind


断点调试
	maven工程断点调试必须采用“Debug As”方式启动，并且需要引入源码才可源码跟踪：




引入源码：


添加，选择本工程：




以debug方式运行：




总结
maven仓库
1、maven仓库的类型有哪些？
2、maven工程查找仓库的流程是什么？
3、本地仓库如何配置？

常用的maven命令
常用 的maven命令包括：
compile：编译
clean：清理
test：测试
package：打包
install：安装


坐标定义
在pom.xml中定义坐标，内容包括：groupId、artifactId、version，详细内容如下：

<!--项目名称，定义为组织名+项目名，类似包名-->
<groupId>cn.itcast.maven</groupId>
<!-- 模块名称 -->
<artifactId>maven-first</artifactId>
<!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 -->
<version>0.0.1-SNAPSHOT</version>
<packaging > ：打包类型
	jar：执行package会打成jar包
	war：执行package会打成war包
	pom ：用于maven工程的继承，通常父工程设置为pom 

pom基本配置

pom.xml是Maven项目的核心配置文件，位于每个工程的根目录，基本配置如下：

<project > ：文件的根节点 .
<modelversion > ： pom.xml使用的对象模型版本
<groupId > ：项目名称，一般写项目的域名
<artifactId > ：模块名称，子项目名或模块名称
<version > ：产品的版本号 . 
	<packaging > ：打包类型，一般有jar、war、pom 等 
<name > ：项目的显示名，常用于 Maven 生成的文档。  
<description > ：项目描述，常用于 Maven 生成的文档
<dependencies> ：项目依赖构件配置，配置项目依赖构件的坐标
<build> ：项目构建配置，配置编译、运行插件等。






项目管理工具
maven




























学习目标
第一天：
1、会使用maven构建项目的命令
2、会使用maven构建java项目和java web项目
3、构建maven-web工程整合struts2成功


第二天：
1、依赖管理--传递依赖 版本冲突处理
在web工程中加入struts-spring，通过传递依赖将spring加入进来。
通过锁定版本解决版本冲突。


2.在web的单个工程中实现SSH整合。


3、分模块构建工程

4、会向私服上传jar包。会从私服下载jar包
实现将dao上传私服
从私服下载，统一：在setting.xml中配置仓库
实现：从私服下载dao
	1）将dao工程关闭
	2）把本地仓库的dao删除

教学计划

课时	章节	知识点	备注
一	Maven介绍
Maven安装
入门程序-入门工程构建	Maven介绍	了解
		Maven安装与配置	重点
		Maven项目工程目录约定	重点
二	入门程序--Maven仓库
入门程序--常用的maven命令
Maven概念模型	Maven仓库	重点
		常用的maven命令	重点
		Maven概念模型	了解
三	项目构建
	M2e插件安装配置	重点
		坐标定义	重点
		构建web工程	重点
		Eclipse下maven命令的使用	重点
		生命周期	了解
四	依赖管理
Tomcat插件	添加依赖	重点
		依赖范围	重点
		Tomcat插件	重点
			
			
			

maven介绍
maven是什么
	maven翻译为“专家”，“内行”。Maven是Apache下的一个纯java开发的开源项目，它是一个项目管理工具，使用maven对java项目进行构建、依赖管理。当前使用Maven的项目在持续增长。
什么是项目构建
	项目构建是一个项目从编写源代码到编译、测试、运行、打包、部署、运行的过程
传统项目构建过程
	传统的使用eclipse构建项目的过程如下：


构建过程如下：
	1）在eclipse中创建一个java web工程
	2）在工程中编写源代码及配置文件等
	3）对源代码进行编译，java文件编译成class文件
	4）执行Junit单元测试
	5）将工程打成war包部署至tomcat运行
maven项目构建过程
	maven将项目构建的过程进行标准化，每个阶段使用一个命令完成，下图展示了构建过程的一些阶段，后面章节详细介绍每个阶段，这里先大概了解下：

上图中部分阶段对应命令如下：
清理阶段对应maven的命令是clean，清理输出的class文件
编译阶段对应maven的命令是compile，将java代码编译成class文件。
打包阶段对应maven的命令是package，java工程可以打成jar包，web包可以打成war包

运行一个maven工程（web工程）需要一个命令：tomat:run

maven工程构建的优点：
1、一个命令完成构建、运行，方便快捷。
2、maven对每个构建阶段进行规范，非常有利于大型团队协作开发。

什么是依赖管理
	什么是依赖？一个java项目可能要使用一些第三方的jar包才可以运行，那么我们说这个java项目依赖了这些第三方的jar包。
	举个例子：一个crm系统，它的架构是SSH框架，该crm项目依赖SSH框架，具体它依赖的Hibernate、Spring、Struts2。
	什么是依赖管理？就是对项目所有依赖的jar包进行规范化管理。

传统项目的依赖管理
	传统的项目工程要管理所依赖的jar包完全靠人工进行，程序员从网上下载jar包添加到项目工程中，如下图：程序员手工将Hibernate、struts2、spring的jar添加到工程中的WEB-INF/lib目录下。


手工拷贝jar包添加到工程中的问题是：
1、没有对jar包的版本统一管理，容易导致版本冲突。
2、从网上找jar包非常不方便，有些jar找不到。
3、jar包添加到工程中导致工程过大。

maven项目的依赖管理
	maven项目管理所依赖的jar包不需要手动向工程添加jar包，只需要在pom.xml（maven工程的配置文件）添加jar包的坐标，自动从maven仓库中下载jar包、运行，如下图：



使用maven依赖管理添加jar的好处：
1、通过pom.xml文件对jar包的版本进行统一管理，可避免版本冲突。
2、maven团队维护了一个非常全的maven仓库，里边包括了当前使用的jar包，maven工程可以自动从maven仓库下载jar包，非常方便。


使用maven的好处
通过上边介绍传统项目和maven项目在项目构建及依赖管理方面的区域，maven有如下的好处：

1、一步构建
maven对项目构建的过程进行标准化，通过一个命令即可完成构建过程。
2、依赖管理
maven工程不用手动导jar包，通过在pom.xml中定义坐标从maven仓库自动下载，方便且不易出错。
3、maven的跨平台，可在window、linux上使用。
4、maven遵循规范开发有利于提高大型团队的开发效率，降低项目的维护成本，大公司都会考虑使用maven来构建项目。

maven安装
下载安装
下载
从该网站 http://maven.apache.org/download.cgi 下载maven3.3.9 版本 
	
解压
将maven解压到一个不含有中文和空格的目录中。

	bin目录 mvn.bat （以run方式运行项目）、 mvnDebug.bat（以debug方式运行项目 ）
	boot目录 maven运行需要类加载器 
conf目录 settings.xml 整个maven工具核心配置文件 
	lib目录 maven运行依赖jar包


环境变量配置

电脑上需安装java环境，安装JDK1.7 + 版本  （将JAVA_HOME/bin 配置环境变量path ）

配置 MAVEN_HOME 


将 %MAVEN_HOME%/bin 加入环境变量 path 


通过 mvn -v命令检查 maven是否安装成功，看到maven的版本为3.3.9及java版本为1.7即为安装成功。


maven仓库
maven仓库的作用
	maven的工作需要从仓库下载一些jar包，如下图所示，本地的项目A、项目B等都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。

下图描述了maven中仓库的类型：

	
本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找 
默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows用户目录。


远程仓库：如果本地需要插件或者jar包，本地仓库没有，默认去远程仓库下载。
远程仓库可以在互联网内也可以在局域网内。

中央仓库 ：在maven软件中内置一个远程仓库地址http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。


配置本地仓库
本课程是在无网的状态下学习，需要配置老师提供的本地仓库，将 “repository.rar”解压至自己的电脑上，本教程解压在F:\develop\maven\repository


 在MAVE_HOME/conf/settings.xml文件中配置本地仓库位置： 


全局setting与用户setting
	maven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。
	在maven安装目录下的有 conf/setting.xml文件，此setting.xml文件用于maven的所有project项目，它作为maven的全局配置。
	如需要个性配置则需要在用户配置中设置，用户配置的setting.xml文件默认的位置在：${user.dir} /.m2/settings.xml目录中,${user.dir} 指windows 中的用户目录。
	maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。



入门程序
学习目标
1、说出maven项目工程的目录结构是什么
2、在cmd命令行下测试maven的常用命令

maven工程运行演示
通过使用maven提供的命令来运行maven工程，体会maven构建工程的优点。

运行web工程
进入maven工程目录（当前目录有pom.xml文件），运行tomcat:run命令。



根据上边的提示信息，通过浏览器访问：http://localhost:8080/maven-helloworld/




问题处理
 如果本地仓库配置错误会报下边的错误


分析：
maven工程运行先从本地仓库找jar包，本地仓库没有再从中央仓库找，上边提示downloading。。。表示 从中央仓库下载jar，由于本地没有联网，报错。

解决：
在maven安装目录的conf/setting.xml文件中配置本地仓库，参考：“maven安装/配置本地仓库章节”。

Maven项目工程目录约定
使用maven创建的工程我们称它为maven工程，maven工程具有一定的目录规范，如下：

src/main/java —— 存放项目的.java文件
src/main/resources —— 存放项目资源文件，如spring, hibernate配置文件
src/test/java —— 存放所有单元测试.java文件，如JUnit测试类
src/test/resources —— 测试资源文件
target —— 项目输出位置，编译后的class文件会输出到此目录
pom.xml——maven项目核心配置文件

Project
  |-src
  |   |-main
  |   |  |-java        —— 存放项目的.java文件
  |   |  |-resources   —— 存放项目资源文件，如spring, hibernate配置文件
         |-webapp     —— webapp目录是web工程的主目录
            |-WEB-INF
              |-web.xml
  |   |-test
  |      |-java        ——存放所有测试.java文件，如JUnit测试类
  |      |-resources   —— 测试资源文件
  |-target             —— 目标文件输出位置例如.class、.jar、.war文件
  |-pom.xml           ——maven项目核心配置文件



常用的maven命令
在cmd的状态下测试
compile
compile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。

cmd进入命令状态，执行mvn compile，如下图提示成功：



 查看 target目录，class文件已生成，编译完成。

test
test是maven工程的测试命令，会执行src/test/java下的单元测试类。
cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行1个测试用例，全部成功。





clean
clean是maven工程的清理命令，执行 clean会删除target目录的内容。

package
package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。

install
install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。

生命周期(了解)
三套生命周期
    maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： 

Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 
Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。
Site Lifecycle 生成项目报告，站点，发布站点。

生命周期的阶段
每个生命周期都有很多阶段，每个阶段对应一个执行命令。

4.如下是clean生命周期的阶段

pre-clean 执行一些需要在clean之前完成的工作 
clean 移除所有上一次构建生成的文件 
post-clean 执行一些需要在clean之后立刻完成的工作 

5.如下是default周期的内容：
    validate
    generate-sources
    process-sources
    generate-resources
    process-resources     复制并处理资源文件，至目标目录，准备打包。
    compile     编译项目的源代码。
    process-classes
    generate-test-sources 
    process-test-sources
    generate-test-resources
    process-test-resources     复制并处理资源文件，至目标测试目录。
    test-compile     编译测试源代码。
    process-test-classes
    test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。
    prepare-package
    package     接受编译好的代码，打包成可发布的格式，如 JAR 。
    pre-integration-test
    integration-test
    post-integration-test
    verify
    install     将包安装至本地仓库，以让其它项目依赖。
    deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。

6.如下是site生命周期的阶段
pre-site 执行一些需要在生成站点文档之前完成的工作 
site 生成项目的站点文档 
post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 
site-deploy 将生成的站点文档部署到特定的服务器上 

命令与生命周期的阶段
   每个maven命令对应生命周期的某个阶段，例如：mvn clean 命令对应clean生命周期的clean阶段， mvn test 命令对应default生命周期的test阶段。
   执行命令会将该命令在的在生命周期当中之前的阶段自动执行，比如：执行mvn clean 命令会自动执行pre-clean和clean两个阶段，mvn test命令会自动执行validate、compile、test等阶段。

注意：执行某个生命周期的某个阶段不会影响其它的生命周期！

	如果要同时执行多个生命周期的阶段可在命令行输入多个命令，中间以空格隔开，例如：
clean package 该命令执行clean生命周期的clean阶段和default生命周期的package阶段。

maven的概念模型
	Maven包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。
	下图是maven的概念模型图： 


项目对象模型 (Project Object Model)
一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。

依赖管理系统(Dependency Management System)
通过maven的依赖管理对项目所依赖的jar 包进行统一管理。
比如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9，如下所示是junit4.9的依赖定义：
<!-- 依赖关系 -->
	<dependencies>
		<!-- 此项目运行使用junit，所以此项目依赖junit -->
		<dependency>
			<!-- junit的项目名称 -->
			<groupId>junit</groupId>
			<!-- junit的模块名称 -->
			<artifactId>junit</artifactId>
			<!-- junit版本 -->
			<version>4.9</version>
			<!-- 依赖范围：单元测试时使用junit -->
			<scope>test</scope>
		</dependency>

一个项目生命周期(Project Lifecycle)
	使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段： 

maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。

一组标准集合
	maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。

插件(plugin)目标(goal)
maven 管理项目生命周期过程都是基于插件完成的。


项目构建
学习目标
1、独立在eclipse中安装配置maven插件
2、说出maven坐标的含义
3、使用eclipse创建mavan工程（java工程及java web工程）
4、使用eclipse运行maven的命令

m2e插件安装配置
eclipse与maven
	通过入门程序中命令行的方式使用maven工作效率不高，可以在eclipse开发工具中集成maven软件，eclipse是一个开发工具，maven是一个项目管理工具，maven有一套项目构建的规范，在eclipse集成maven软件，最终通过eclipse创建maven工程。
插件安装
	本教程 使用eclipse mars 2版本，此版本自带maven插件不用单独安装。
在新建窗口中可看到maven项目的创建项表示maven插件已存在，如下图：


指定maven安装目录 
	一些高版本的eclipse已经内置了maven的安装，下图是eclipse mars2版本中已经内置了maven3.3.3版本，项目为了统一maven的版本不会使用eclipse内置的maven版本，这里我们maven3.3.9。





User Setting配置
	在eclipse中配置使用的maven的setting.xml文件，使用maven安装目录下的setting.xml文件。





注意：如果修改了 setting.xml文件需要点击上图中的“update settings”按钮对本地仓库重建索引，点击“Reindex”。

eclipse浏览仓库
	maven配置完成需要测试在eclipse中是否可以浏览maven的本地仓库，如果可以正常浏览maven本地仓库则说明eclipse集成maven已经完成。
	打开eclipse仓库视图，对插件和jar包建立索引

找到Local respository本地仓库项，点击Rebuild index重建索引 

重建索引完成点击前边的“+”图标即可查看本地仓库的内容：如下图：




定义maven坐标
	每个maven工程都需要定义本工程的坐标，坐标是maven对jar包的身份定义，比如：入门程序的坐标定义如下：

<!--项目名称，定义为组织名+项目名，类似包名-->
<groupId>cn.itcast.maven</groupId>
<!-- 模块名称 -->
<artifactId>maven-first</artifactId>
<!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 -->
<version>0.0.1-SNAPSHOT</version>
<packaging > ：打包类型
	jar：执行package会打成jar包
	war：执行package会打成war包
	pom ：用于maven工程的继承，通常父工程设置为pom 

构建web工程
需求
创建一个web工程，实现入门程序的功能。
1）添加index.jsp，输出hello world
2）添加一个servlet转发到jsp页面。
第一步创建maven工程
选择 Maven Project




了解一下骨架界面:
当我们不跳过骨架点击“next”会进入骨架选择页面，如果eclipse中配置本地仓库正确则显示出骨架：


选择webapp会创建一个maven工程（java web工程）
选择quickstart会创建一个maven工程（java工程）
注意：使用骨架的问题是创建的maven工程目录不完整，所以不推荐使用，本教程创建maven工程统一跳过骨架。


第二步定义坐标





第三步设置编译版本
	查看上边工程的编译版本为1.5，本教程 使用jdk1.7，需要设置编译版本为1.7，这里需要使用maven的插件来设置：
在pom.xml中加入：

  <build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.7</source>
					<target>1.7</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>
执行update project，查看编译版本为1.7：




第四步定义web.xml
在src/webapp中添加WEB-INF/web.xml文件，内容为：

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	id="WebApp_ID" version="2.5">

	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
		<welcome-file>index.htm</welcome-file>
		<welcome-file>index.jsp</welcome-file>
		<welcome-file>default.html</welcome-file>
		<welcome-file>default.htm</welcome-file>
		<welcome-file>default.jsp</welcome-file>
	</welcome-file-list>
</web-app>

第五步编写servlet

在src/main/java中创建ServletTest




public class ServletTest extends HttpServlet {

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

		this.doPost(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

		req.getRequestDispatcher("/jsp/test.jsp").forward(req, resp);
	}

}

第六步编写jsp


test.jsp的内容如下：


index.jsp的内容如下：


第七步添加servlet/jsp的jar包
servlet类中报错，无法解析javax.sevlet....

在maven工程中添加jar的方式是需要在pom.xml中添加servlet/jsp的坐标，maven自动从创建下载servlet/jsp的jar包

编辑pom.xml，如下：

<!-- 添加servlet-api，jsp-api -->
	<dependencies>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
		
	</dependencies>


第八步配置servlet
在web.xml中配置servlet，如下所示：

	<!-- 配置servlet -->
	<servlet>
		<servlet-name>servletTest</servlet-name>
		<servlet-class>cn.itcast.maven.servlet.ServletTest</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>servletTest</servlet-name>
		<url-pattern>/test</url-pattern>
	</servlet-mapping>

运行
cmd命令行进入工程目录，运行tomcat:run命令


eclipse下使用maven命令
在eclipse下测试命令

clean
compile
test
package
install



Run as 采用 mvn 命令运行 ，Debug as 采用 mvnDebug 命令调试方式运行（可打断点） 
Maven clean 清理target目录
Maven test 执行单元测试
Maven install将工程打包后发布到本地仓库

Maven build 使用之前操作过的命令 
Maven build … 手动输入命令内容，如下图：



编译命令 mvn compile 
	编译后 .class文件在 target/classes 下 （这个命令只会对java源程序编译， 不会编译测试代码 ， 编译测试类 mvn test-compile , 编译后.class 文件在 target\test-classes ）

测试命令 mvn test 
执行所有测试用例方法， 重新编译 

清除命令 mvn clean 
清除target目录 （清除所有编译结果或者打包结果 ），清理后编译。

打包命名 mvn package
java项目生成 jar包， web项目生成war包 
默认生成jar包名称 ： artifactId-version.jar 

安装命令
安装命令 mvn install  将工程打包后发布到本地仓库
	---- 安装到仓库/groupId/artifactId/version 目录






依赖管理-添加依赖
需求
实现web工程整合struts2框架。

添加依赖
dependency
在pom.xml中添加dependency标签，如下：
<dependency>
	<groupId><groupId>
	<artifactId></artifactId>
	<version></version>
</dependency>

参考入门工程的Junit4.9的依赖在web工程的pom.xml中添加dependency
	<dependencies>
		<!-- 添加junit4.9依赖 -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
		</dependency>
	</dependencies>

查找坐标
	添加依赖需要指定依赖jar包的坐标，但是很多情况我们是不知道jar包的的坐标，可以通过如下方式查询：
方法一：从互联网搜索
	http://search.maven.org/
	http://mvnrepository.com/
网站搜索示例：





方法二：使用maven插件的索引功能 
如果在本地仓库有我们要的jar包，可以在pom.xml中邮件添加依赖





构建web工程
添加struts2依赖
编写web工程的pom.xml文件，添加依赖，如下：

<!-- 依赖struts2 -->
<dependency>
		<groupId>org.apache.struts</groupId>
		<artifactId>struts2-core</artifactId>
		<version>2.3.24</version>
</dependency>


依赖范围
基本概念
	A依赖B，需要在A的pom.xml文件中添加B的坐标，添加坐标时需要指定依赖范围，依赖范围包括：
compile：编译范围，指A在编译时依赖B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。

provided：provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依赖在编译和测试时需要，在运行时不需要，比如：servlet api被tomcat容器提供。

runtime：runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以runtime范围的依赖会被打包。

test：test范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。
    
system：system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径，需要指定systemPath磁盘路径，system依赖不推荐使用。



 
在maven-web工程中测试各各scop。

测试总结：
默认引入 的jar包 ------- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ）
servlet-api 、jsp-api ------- provided （编译、测试 有效， 运行时无效 防止和tomcat下jar冲突）
jdbc驱动jar包 ---- runtime （测试、运行 有效 ）
junit ----- test （测试有效）

依赖范围由强到弱的顺序是：compile>provided>runtime>test

测试
1、向web工程 添加jsp/servlet依赖

<!-- servlet jsp -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
		
package打war观察jsp-api和servlet-api是否在war中存在？


2、向dao工程 添加jdbc依赖
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
			<scope>runtime</scope>
		</dependency>
package打war观察mysql-connctor-java是否在war中存在？

完整的pom.xml
根据需求web工程要实现整合struts2，完整的pom.xml如下：
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>cn.itcast.maven</groupId>
	<artifactId>maven-web-0120</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
	<name>web工程，包括jsp、action等</name>
	<description>web工程，包括jsp、action等</description>


	<dependencies>
		<!-- 添加junit4.9依赖 -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
			<scope>runtime</scope>
		</dependency>
		<!-- servlet jsp -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- 依赖struts2 -->
		<dependency>
			<groupId>org.apache.struts</groupId>
			<artifactId>struts2-core</artifactId>
			<version>2.3.24</version>
		</dependency>

	</dependencies>

	<build>
		<plugins>
		<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.7</source>
					<target>1.7</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>


action类
编写action，实现查询客户信息：
public class CustomerAction extends ActionSupport {

	private Long custId;

	/**
	 * @return the custId
	 */
	public Long getCustId() {
		return custId;
	}

	/**
	 * @param custId
	 *            the custId to set
	 */
	public void setCustId(Long custId) {
		this.custId = custId;
	}

	// 查询客户信息
	public String querycustomer() {

		System.out.println("客户请求客户Id："+custId);
		
		return "success";
	}
}

struts.xml

在src/main/resources创建struts.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"
    "http://struts.apache.org/dtds/struts-2.3.dtd">

<struts>
	<!-- 配置常量 -->
	<!-- 字符集 -->
	<constant name="struts.i18n.encoding" value="UTF-8"></constant>
	<!-- 开发模式 -->
	<constant name="struts.devMode" value="true"></constant>
	<!-- 主题 -->
	<constant name="struts.ui.theme" value="simple"></constant>
	<!-- 扩展名 -->
	<constant name="struts.action.extension" value="action"></constant>

	<!-- 通用package -->
	<package name="customer" namespace="/" extends="struts-default">

		<action name="querycustomer" class="cn.itcast.crm.action.CustomerAction"
			method="querycustomer">
			<result name="success">/jsp/querycustomer.jsp</result>
		</action>

	</package>
</struts>

web.xml
在web.xml中配置struts2的前端控制器

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	id="WebApp_ID" version="2.5">
	<filter>
		<filter-name>struts2</filter-name>
		<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>struts2</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
		<welcome-file>index.htm</welcome-file>
		<welcome-file>index.jsp</welcome-file>
		<welcome-file>default.html</welcome-file>
		<welcome-file>default.htm</welcome-file>
		<welcome-file>default.jsp</welcome-file>
	</welcome-file-list>
</web-app>


maven工程运行调试
tomcat插件
maven内置tomcat的插件（org.codehaus.mojo. tomcat-maven-plugin），执行tomcat:run命令即可启动tomcat



访问：http://localhost:8080/工程名/...

可以通过配置plugin修改tomcat的访问路径及端口：

	<build>
		<plugins>
			<!-- maven内置 的tomcat6插件 -->
			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>tomcat-maven-plugin</artifactId>
				<version>1.1</version>
				<configuration>
					<!-- 可以灵活配置工程路径 -->
					<path>/ssh</path>
					<!-- 可以灵活配置端口号 -->
					<port>8080</port>
				</configuration>
			</plugin>

		</plugins>
	</build>


端口占用处理
重新执行tomcat:run命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误：
	Caused by: java.net.BindException: Address already in use: JVM_Bind


断点调试
	maven工程断点调试必须采用“Debug As”方式启动，并且需要引入源码才可源码跟踪：




引入源码：


添加，选择本工程：




以debug方式运行：




总结
maven仓库
1、maven仓库的类型有哪些？
2、maven工程查找仓库的流程是什么？
3、本地仓库如何配置？

常用的maven命令
常用 的maven命令包括：
compile：编译
clean：清理
test：测试
package：打包
install：安装


坐标定义
在pom.xml中定义坐标，内容包括：groupId、artifactId、version，详细内容如下：

<!--项目名称，定义为组织名+项目名，类似包名-->
<groupId>cn.itcast.maven</groupId>
<!-- 模块名称 -->
<artifactId>maven-first</artifactId>
<!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 -->
<version>0.0.1-SNAPSHOT</version>
<packaging > ：打包类型
	jar：执行package会打成jar包
	war：执行package会打成war包
	pom ：用于maven工程的继承，通常父工程设置为pom 

pom基本配置

pom.xml是Maven项目的核心配置文件，位于每个工程的根目录，基本配置如下：

<project > ：文件的根节点 .
<modelversion > ： pom.xml使用的对象模型版本
<groupId > ：项目名称，一般写项目的域名
<artifactId > ：模块名称，子项目名或模块名称
<version > ：产品的版本号 . 
	<packaging > ：打包类型，一般有jar、war、pom 等 
<name > ：项目的显示名，常用于 Maven 生成的文档。  
<description > ：项目描述，常用于 Maven 生成的文档
<dependencies> ：项目依赖构件配置，配置项目依赖构件的坐标
<build> ：项目构建配置，配置编译、运行插件等。






项目管理工具
maven




























教学计划

课时	章节	知识点	备注
一
	传递依赖
依赖版本冲突解决
SSH构建	传递依赖	了解
		依赖版本冲突解决	重点
		SSH构建	重点
二
	SSH构建
分模块构建SSH工程	SSH构建	重点
		分模块构建工程分析	理解
		分模块构建工程-父工程	重点
		分模块构建工程-Dao工程	重点
		分模块构建工程-Service工程	重点
三
	分模块构建SSH工程
Maven私服	分模块构建工程-web工程	重点
		分模块构建工程-调试	重点
		私服介绍、安装配置	了解
			
四
	
Maven私服	私服-将项目发布到私服	了解
		私服-从私服下载jar	了解
		知识点总结	
			


思路：
在第一天的dao、service、web工程的基础上补充，
dao：集成hibernate和spring
service：集成spring的事务管理
web集成struts2+spring

调试通过

注意：
目前三个工程是是互相的依赖，但是只运行了web，如果dao或service修改，及时install到仓库！！！

等到后边的聚合运行，如果dao或service修改就不用install到本地仓库，直接聚合运行！！


依赖管理-传递依赖
传递依赖
什么是传递依赖
	当A 依赖B、B依赖C，在A中导入B后会自动导入C，C是A的传递依赖，如果C依赖D则D也可能是A的传递依赖。

演示：
web中添加struts-spring的jar，传递依赖了spring


依赖范围对传递依赖的影响（了解）
	依赖会有依赖范围，依赖范围对传递依赖也有影响，有A、B、C，A依赖B、B依赖C，C可能是A的传递依赖，如下图：


	最左边一列为直接依赖，理解为A依赖B的范围，最顶层一行为传递依赖，理解为B依赖C的范围，行与列的交叉即为A传递依赖C的范围。
举例：
比如 A对 B 有 compile 依赖，B 对C有 runtime 依赖，那么根据表格所示A对C 有 runtime 依赖。

测试
dao依赖junit，scop为test
service依赖dao.

查看下图红色框内所示传递依赖范围：


所以maven-first所依赖的junit的jar没有加入到maven-web工程。
如果修改maven-first依赖junit的scop为compile，maven-first所依赖的junit的jar包会加入到maven-web工程中，符合上边表格所示，查看下图红色框内所示：


依赖版本冲突解决
问题
	当一个项目依赖的构件比较多时，它们相互之前存在依赖，当你需要对依赖版本统一管理时如果让maven自动来处理可能并不能如你所愿，如下例子：

同时加入以下依赖，观察依赖：
  	<!-- struts2-spring-plugin依赖spirng-beans-3.0.5 -->
  	<dependency>
  		<groupId>org.apache.struts</groupId>
  		<artifactId>struts2-spring-plugin</artifactId>
  		<version>2.3.24</version>
  	</dependency>
  	
  	  	<!-- spring-context依赖spring-beans-4.2.4 -->

  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-context</artifactId>
  		<version>4.2.4.RELEASE</version>
  	</dependency>

org.apache.struts依赖spirng-beans-3.0.5，spring-context依赖spring-beans-4.2.4，但是发现spirng-beans-3.0.5加入到工程中，而我们希望spring-beans-4.2.4加入工程。


依赖调解原则
	maven自动按照下边的原则调解：
1、第一声明者优先原则
	在pom文件定义依赖，先声明的依赖为准。

测试：
如果将上边struts-spring-plugins和spring-context顺序颠倒，系统将导入spring-beans-4.2.4。
分析：
由于spring-context在前边以spring-context依赖的spring-beans-4.2.4为准，所以最终spring-beans-4.2.4添加到了工程中。


2、路径近者优先原则
	例如：A依赖 spirng-beans-4.2.4，A依赖B依赖 spirng-beans-3.0.5，则spring-beans-4.2.4优先被依赖在A中，因为spring-beans-4.2.4相对spirng-beans-3.0.5被A依赖的路径最近。
测试：
在本工程中的pom中加入spirng-beans-4.2.4的依赖，根据路径近者优先原则，系统将导入spirng-beans-4.2.4：

<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-beans</artifactId>
  		<version>4.2.4.RELEASE</version>
  	</dependency>


排除依赖
上边的问题也可以通过排除依赖方法辅助依赖调解，如下：
比如在依赖struts2-spring-plugin的设置中添加排除依赖，排除spring-beans，
下边的配置表示：依赖struts2-spring-plugin，但排除struts2-spring-plugin所依赖的spring-beans。


  	<!-- struts2-spring-plugin依赖spirng-beans-3.0.5 -->
  	<dependency>
  		<groupId>org.apache.struts</groupId>
  		<artifactId>struts2-spring-plugin</artifactId>
  		<version>2.3.24</version>
  		<!-- 排除 spring-beans-->
  		<exclusions>
  			<exclusion>
  				<groupId>org.springframework</groupId>
  				<artifactId>spring-beans</artifactId>
  			</exclusion>
			<exclusion>
  				<groupId>org.springframework</groupId>
  				<artifactId>spring-context</artifactId>
  			</exclusion>
  		</exclusions>
  	</dependency>


锁定版本
	面对众多的依赖，有一种方法不用考虑依赖路径、声明优化等因素可以采用直接锁定版本的方法确定依赖构件的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本的为准添加到工程中，此方法在企业开发中常用。

如下的配置是锁定了spring-beans和spring-context的版本：

  <dependencyManagement>
  	<dependencies>
  		<!--这里锁定版本为4.2.4 -->
  		<dependency>
  			<groupId>org.springframework</groupId>
  			<artifactId>spring-beans</artifactId>
  			<version>4.2.4.RELEASE</version>
  		</dependency>
		<dependency>
  			<groupId>org.springframework</groupId>
  			<artifactId>spring-context</artifactId>
  			<version>4.2.4.RELEASE</version>
  		</dependency>
  	</dependencies>
  </dependencyManagement>

注意：在工程中锁定依赖的版本并不代表在工程中添加了依赖，如果工程需要添加锁定版本的依赖则需要单独添加<dependencies></dependencies>标签，如下：
<dependencies>
  		<!--这里是添加依赖 -->
  		<dependency>
  			<groupId>org.springframework</groupId>
  			<artifactId>spring-beans</artifactId>
 		</dependency>
		<dependency>
  			<groupId>org.springframework</groupId>
  			<artifactId>spring-context</artifactId>
 		</dependency>
  	</dependencies>

上边添加的依赖并没有指定版本，原因是已在<dependencyManagement>中锁定了版本，所以在<dependency>下不需要再指定版本。


maven构建ssh工程
需求
在web工程的基础上实现ssh工程构建，规范依赖管理。

数据库环境
创建数据库：maven
导入sql/cst_customer.sql创建表


定义pom.xml
	maven工程首先要识别依赖，web工程实现SSH整合，需要依赖struts2.3.24、 spring4.2.4、hibernate5.0.7等，在pom.xml添加工程如下依赖：

分两步：
1）锁定依赖版本
2）添加依赖

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>cn.itcast.maven</groupId>
	<artifactId>maven-web-0120</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
	<name>web工程，包括jsp、action等</name>
	<description>web工程，包括jsp、action等</description>

	<!-- 属性 -->
	<properties>
		<spring.version>4.2.4.RELEASE</spring.version>
		<hibernate.version>5.0.7.Final</hibernate.version>
		<struts.version>2.3.24</struts.version>
	</properties>

	<!-- 锁定版本，struts2-2.3.24、spring4.2.4、hibernate5.0.7 -->
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-context</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-aspects</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-orm</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-test</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-web</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.hibernate</groupId>
				<artifactId>hibernate-core</artifactId>
				<version>${hibernate.version}</version>
			</dependency>
			<dependency>
				<groupId>org.apache.struts</groupId>
				<artifactId>struts2-core</artifactId>
				<version>${struts.version}</version>
			</dependency>
			<dependency>
				<groupId>org.apache.struts</groupId>
				<artifactId>struts2-spring-plugin</artifactId>
				<version>${struts.version}</version>
			</dependency>

		</dependencies>
	</dependencyManagement>

	<!-- 依赖管理 -->
	<dependencies>
		<!-- spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aspects</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-web</artifactId>
		</dependency>
		<!-- hibernate -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
		</dependency>

		<!-- 数据库驱动 -->
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
			<scope>runtime</scope>
		</dependency>
		<!-- c3p0 -->

		<dependency>
			<groupId>c3p0</groupId>
			<artifactId>c3p0</artifactId>
			<version>0.9.1.2</version>
		</dependency>
		<!-- 导入 struts2 -->
		<dependency>
			<groupId>org.apache.struts</groupId>
			<artifactId>struts2-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.struts</groupId>
			<artifactId>struts2-spring-plugin</artifactId>
		</dependency>

		<!-- servlet jsp -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- 日志 -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
			<version>1.7.2</version>
		</dependency>
		<!-- junit -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
			<scope>test</scope>
		</dependency>
		<!-- jstl -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<!-- 设置编译版本为1.7 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.7</source>
					<target>1.7</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>

			<!-- maven内置 的tomcat6插件 -->
			<plugin>
				<groupId>org.codehaus.mojo</groupId>
				<artifactId>tomcat-maven-plugin</artifactId>
				<version>1.1</version>
				<configuration>
					<!-- 可以灵活配置工程路径 -->
					<path>/ssh</path>
					<!-- 可以灵活配置端口号 -->
					<port>8080</port>
				</configuration>
			</plugin>

		</plugins>
	</build>
</project>


dao
在src/main/java中定义dao接口，实现根据id 查询客户信息：

domain模型类
在src/main/java创建模型类



public class CstCustomer implements java.io.Serializable {

	private Long custId;
	private String custName;
	private Long custUserId;
	private Long custCreateId;
	private String custIndustry;
	private String custLevel;
	private String custLinkman;
	private String custPhone;
	private String custMobile;
...

dao代码
public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao {

	
	@Override
	public CstCustomer findCustomerById(Long custId) {
		return this.getHibernateTemplate().get(CstCustomer.class, custId);
	}
	
}

配置文件

在 src/main/resources创建hibernate.cfg.xml

<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
	<!-- 会话工厂 -->
	<session-factory>
		<!-- 数据库方言，根据数据库选择 -->
	    <property name="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</property>

		<!--为了方便调试是否在运行hibernate时在日志中输出sql语句 -->
		<property name="hibernate.show_sql">true</property>
		<!-- 是否对日志中输出的sql语句进行格式化 -->
		<property name="hibernate.format_sql">true</property>

		<property name="hibernate.hbm2ddl.auto">none</property>
		
		<!-- 加载映射文件 -->
		<mapping resource="cn/itcast/crm/domain/CstCustomer.hbm.xml"/>
	</session-factory>
</hibernate-configuration>



在 src/main/resources创建applicationContext.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd 
	http://www.springframework.org/schema/context 
	http://www.springframework.org/schema/context/spring-context.xsd 
	http://www.springframework.org/schema/aop 
	http://www.springframework.org/schema/aop/spring-aop.xsd 
	http://www.springframework.org/schema/tx  
	http://www.springframework.org/schema/tx/spring-tx.xsd">

	<!-- 数据库连接池 -->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="driverClass" value="com.mysql.jdbc.Driver" />
		<property name="jdbcUrl" value="jdbc:mysql://localhost:3306/maven" />
		<property name="user" value="root" />
		<property name="password" value="mysql" />
	</bean>

	<!-- 配置sessionFactory -->
	<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<!-- 依赖dataSource -->
		<property name="dataSource" ref="dataSource"/>
		<!-- 创建工厂需要加载hibernate映射文件 -->
		<property name="configLocations" value="classpath:hibernate.cfg.xml"></property>
	</bean>
	
	<!-- dao -->
	<bean id="customerDao" class="cn.itcast.crm.dao.impl.CustomerDaoImpl">
		<property name="sessionFactory" ref="sessionFactory"/>
	</bean>

</beans>

在src/main/resources配置log4j.properties

### direct log messages to stdout ###
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n

### set log levels - for more verbose logging change 'info' to 'debug' ###
#在开发阶段日志级别使用debug
log4j.rootLogger=debug, stdout
### 在日志中输出sql的输入参数 ###
log4j.logger.org.hibernate.type=TRACE


单元测试
在src/test/java创建单元测试类


public class CustomerDaoImplTest {

	@Test
	public void testFindCustomerById() {
		//获取spring容器
		ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
		//获取dao
		CustomerDao customerDao = (CustomerDao) applicationContext.getBean("customerDao");
		//调用dao方法
		CstCustomer cstCustomer = customerDao.findCustomerById(28l);
		System.out.println(cstCustomer);
	}

}


service

代码


public class CustomerServiceImpl implements CustomerService {

	// 定义dao
	private CustomerDao customerDao;

	@Override
	public CstCustomer findCustomerById(Long custId) {
		return customerDao.findCustomerById(custId);
	}

}

配置文件
在applicationContext.xml中配置service

	<!-- service -->
	<bean id="customerService" class="cn.itcast.crm.service.impl.CustomerServiceImpl">
		<property name="customerDao" ref="customerDao"/>
	</bean>

action
代码

public class CustomerAction extends ActionSupport {
	
	//依赖注入
	private CustomerService customerService;
	
	//客户id
	private Long custId;
	
	//客户信息
	private CstCustomer customer;

	//根据主键获取客户信息
	public String querycustomer(){

		customer = customerService.findCustomerById(custId);
		return SUCCESS;
	}

	public Long getCustId() {
		return custId;
	}

	public void setCustId(Long custId) {
		this.custId = custId;
	}

	public CstCustomer getCustomer() {
		return customer;
	}

	public void setCustomer(CstCustomer customer) {
		this.customer = customer;
	}
	
}

配置文件
在applicationContext.xml中配置action

 <!-- action -->
	<bean id="customerAction" class="cn.itcast.crm.action.CustomerAction" scope="prototype">
		<property name="customerService" ref="customerService"/>
	</bean>

在struts.xml中配置action

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"
    "http://struts.apache.org/dtds/struts-2.3.dtd">

<struts>
	<!-- 配置常量 -->
	<!-- 字符集 -->
	<constant name="struts.i18n.encoding" value="UTF-8"></constant>
	<!-- 开发模式 -->
	<constant name="struts.devMode" value="true"></constant>
	<!-- 主题 -->
	<constant name="struts.ui.theme" value="simple"></constant>
	<!-- 扩展名 -->
	<constant name="struts.action.extension" value="action"></constant>

	<!-- 通用package -->
	<package name="customer" namespace="/" extends="struts-default">

		<action name="querycustomer" class="customerAction"
			method="querycustomer">
			<result name="success">/jsp/querycustomer.jsp</result>
		</action>

	</package>
</struts>


web.xml

加载spring容器，配置struts2前端控制器

<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext.xml</param-value>
	</context-param>
	<filter>
		<filter-name>struts2</filter-name>
		<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>struts2</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>


Jsp

/src/main/webapp/jsp/querycustomer.jsp如下：


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>测试</title>
</head>
<body>
<!-- 从模型对象中获取属性值 -->
${customer.custName}
</body>
</html>


运行与调试



分模块构建工程

基于上边的三个工程分析
继承：创建一个parent工程将通用的pom配置抽取出来
聚合：聚合多个模块运行。

需求
需求描述
将ssh工程拆分为多个模块开发：
dao
service
web




理解继承和聚合
通常继承和聚合同时使用。 

何为继承？ 
继承是为了消除重复，如果将dao、service、web分开创建独立的工程则每个工程的pom.xml文件中的内容存在重复，比如：设置编译版本、锁定spring的版本的等，可以将这些重复的配置提取出来在父工程的pom.xml中定义。 


何为聚合？ 
项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如：dao、service、web三个工程最终会打一个独立的war运行。


案例实现
maven-parent父模块

创建父工程


这里选择“跳过骨架选择”


定义坐标：



定义pom.xml
在父工程的pom.xml中抽取一些重复的配置的，比如：锁定jar包的版本、设置编译版本等。


<project xmlns="http://maven.apache.org/POM/4.0.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>cn.itcast.maven</groupId>
  <artifactId>maven-parent</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging>
  <name>父工程</name>
  
  <!-- 属性 -->
	<properties>
		<spring.version>4.2.4.RELEASE</spring.version>
		<hibernate.version>5.0.7.Final</hibernate.version>
		<struts.version>2.3.24</struts.version>
	</properties>
	<dependencyManagement>
		<dependencies>
			<!-- 统一依赖构件版本 -->
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-context</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-aspects</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-orm</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-test</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-web</artifactId>
				<version>${spring.version}</version>
			</dependency>
			<dependency>
				<groupId>org.hibernate</groupId>
				<artifactId>hibernate-core</artifactId>
				<version>${hibernate.version}</version>
			</dependency>
			<dependency>
				<groupId>org.apache.struts</groupId>
				<artifactId>struts2-core</artifactId>
				<version>${struts.version}</version>
			</dependency>
			<dependency>
				<groupId>org.apache.struts</groupId>
				<artifactId>struts2-spring-plugin</artifactId>
				<version>${struts.version}</version>
			</dependency>
			<dependency>
				<groupId>org.apache.struts</groupId>
				<artifactId>struts2-json-plugin</artifactId>
				<version>${struts.version}</version>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<finalName>maven-web</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.7</source>
					<target>1.7</target>
					<encoding>UTF-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>

将父工程发布至仓库
父工程创建完成执行maven-install将父工程发布到仓库方便子工程继承：



maven-dao子模块
创建dao子模块
选择maven模块：


这里指定模块名称，选择“跳过骨架选择”：



定义pom.xml
dao模块的pom.xml文件中需要继承父模块，添加持久层需要的依赖坐标：


<project xmlns="http://maven.apache.org/POM/4.0.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>cn.itcast.maven</groupId>
    <artifactId>maven-parent</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>maven-dao</artifactId>
  <packaging>jar</packaging>
  <dependencies>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aspects</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-web</artifactId>
		</dependency>
		
		<!-- 数据库驱动 -->

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
			<scope>runtime</scope>
		</dependency>
		<!-- c3p0 -->

		<dependency>
			<groupId>c3p0</groupId>
			<artifactId>c3p0</artifactId>
			<version>0.9.1.2</version>
		</dependency>
		<!-- 日志 -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
			<version>1.7.2</version>
		</dependency>
		<!-- junit -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
  
</project>


dao接口

将maven-web工程中的dao接口及domain类拷贝到src/main/java中：


配置文件
拷贝maven-web工程中如下配置文件到dao工程：


注意：
将applicationContext.xml拆分出一个applicationContext-dao.xml，此文件中只配置dao
	
	<!-- dao -->
	<bean id="customerDao" class="cn.itcast.crm.dao.impl.CustomerDaoImpl">
		<property name="sessionFactory" ref="sessionFactory"/>
	</bean>

applicationContext.xml的内容如下：

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd 
	http://www.springframework.org/schema/context 
	http://www.springframework.org/schema/context/spring-context.xsd 
	http://www.springframework.org/schema/aop 
	http://www.springframework.org/schema/aop/spring-aop.xsd 
	http://www.springframework.org/schema/tx  
	http://www.springframework.org/schema/tx/spring-tx.xsd">

	<!-- 数据库连接池 -->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="driverClass" value="com.mysql.jdbc.Driver" />
		<property name="jdbcUrl" value="jdbc:mysql://localhost:3306/maven" />
		<property name="user" value="root" />
		<property name="password" value="mysql" />
	</bean>

	<!-- 配置sessionFactory -->
	<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<!-- 依赖dataSource -->
		<property name="dataSource" ref="dataSource"/>
		<!-- 创建工厂需要加载hibernate映射文件 -->
		<property name="configLocations" value="classpath:hibernate.cfg.xml"></property>
	</bean>


单元测试


@ContextConfiguration(locations = { "classpath:applicationContext.xml", 
classpath:applicationContext-*.xml })
@RunWith(SpringJUnit4ClassRunner.class)
public class CustomerDaoImplTest {
	
	@Autowired
	private CustomerDao customerDao;

	@Before
	public void setUp() throws Exception {
	}

	@Test
	public void testFindCustomerById() {
		CstCustomer customer = customerDao.findCustomerById(1l);
		System.out.println(customer);
	}
}


maven-service子模块

创建service子模块
方法同maven-dao模块创建方法，模块名称为maven-service。


定义pom.xml
service模块的pom.xml文件中需要继承父模块，service依赖dao模块：

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>cn.itcast.maven</groupId>
    <artifactId>maven-parent</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>maven-service</artifactId>
  <packaging>jar</packaging>
  
  <dependencies>
  		<!-- junit -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
			<scope>test</scope>
		</dependency>
		<!-- 依赖dao -->
		<dependency>
			<groupId>cn.itcast.maven</groupId>
			<artifactId>maven-dao</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</dependency>
	</dependencies>
  
</project>


service接口
将maven-web工程中的service接口拷贝到src/main/java中：


配置文件

创建applicationContext-service.xml，此文件中定义的service。

	<!-- service -->
	<bean id="customerService" class="cn.itcast.crm.service.impl.CustomerServiceImpl">
		<property name="customerDao" ref="customerDao"/>
	</bean>



单元测试

@ContextConfiguration(locations = { "classpath:applicationContext.xml",
"classpath:applicationContext-*.xml" })
@RunWith(SpringJUnit4ClassRunner.class)
public class CustomerServiceImplTest {
	
	@Autowired
	private CustomerService customerService;

	@Before
	public void setUp() throws Exception {
	}

	@Test
	public void testFindCustomerById() {
		CstCustomer customer = customerService.findCustomerById(1l);
		System.out.println(customer);
	}

}



maven-web子模块

创建web子模块
方法同maven-dao模块创建方法，模块名称为maven-web。

定义pom.xml
web模块的pom.xml文件中需要继承父模块，web依赖service模块：

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>cn.itcast.maven</groupId>
    <artifactId>maven-parent</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>maven-web</artifactId>
  <packaging>war</packaging>
  <name>web工程</name>
  
   <dependencies>
   		<!-- junit -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.9</version>
			<scope>test</scope>
		</dependency>
		
		<!-- 依赖service -->
		<dependency>
			<groupId>cn.itcast.maven</groupId>
			<artifactId>maven-service</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</dependency>
		
		
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-web</artifactId>
		</dependency>
		<!-- 导入 struts2 -->
		<dependency>
			<groupId>org.apache.struts</groupId>
			<artifactId>struts2-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.struts</groupId>
			<artifactId>struts2-spring-plugin</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.struts</groupId>
			<artifactId>struts2-json-plugin</artifactId>
		</dependency>
		
				<!-- servlet jsp -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.0</version>
			<scope>provided</scope>
		</dependency>
				<!-- jstl -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
	</dependencies>
  
  
</project>


action
将maven-web工程中的action拷贝到src/main/java中：

配置文件
拷贝maven-web工程中如下配置文件：


创建applicationContext-action.xml，此文件配置action

	<!-- action -->
	<bean id="customerAction" class="cn.itcast.crm.action.CustomerAction" scope="prototype">
		<property name="customerService" ref="customerService"/>
	</bean>


模块聚合

修改父工程的pom.xml，添加：

  <!-- 由于父工程要聚合子工程，配置modules -->
   <modules>
    <!-- 在modules中配置相对路径，相对父工程pom.xml的路径找到子工程的pom.xml -->
   	<module>maven-dao</module>
   	<module>maven-service</module>
   	<module>maven-web</module>
   </modules>
注意：上边module中配置的路径，此路径是相对父工程的pom.xml文件找子工程的pom.xml文件的路径。



运行调试
方法1：在maven-web工程的pom.xml中配置tomcat插件运行
运行maven-web工程它会从本地仓库下载依赖的jar包，所以当maven-web依赖的jar包内容修改了必须及时发布到本地仓库，比如：maven-web依赖的maven-service修改了，需要及时将maven-service发布到本地仓库。

方法2：在父工程的pom.xml中配置tomcat插件运行，自动聚合并执行 
推荐方法2，如果子工程都在本地，采用方法2则不需要子工程修改就立即发布到本地仓库，父工程会自动聚合并使用最新代码执行。

注意：如果子工程和父工程中都配置了tomcat插件，运行的端口和路径以子工程为准。

maven私服
正式开发，不同的项目组开发不同的工程。
dao工程开发完毕，发布到私服。
service从私服下载dao


需求
问题5：项目组编写了一个通用的工具类，其它项目组将类拷贝过去使用，当工具类修改bug后通过邮件发送给各各项目组，这种分发机制不规范可能导致工具类版本不统一。
解决方案：项目组将写的工具类通过maven构建，打成jar，将jar包发布到公司的maven仓库中，公司其它项目通过maven依赖管理从仓库自动下载jar包。

分析
	公司在自己的局域网内搭建自己的远程仓库服务器，称为私服，私服服务器即是公司内部的maven远程仓库，每个员工的电脑上安装maven软件并且连接私服服务器，员工将自己开发的项目打成jar并发布到私服服务器，其它项目组从私服服务器下载所依赖的构件（jar）。
	私服还充当一个代理服务器，当私服上没有jar包会从互联网中央仓库自动下载，如下图：



搭建私服环境
下载nexus

	Nexus 是Maven仓库管理器，通过nexus可以搭建maven仓库，同时nexus还提供强大的仓库管理功能，构件搜索功能等。
	下载Nexus， 下载地址：http://www.sonatype.org/nexus/archived/


下载：nexus-2.12.0-01-bundle.zip
 

安装nexus
解压nexus-2.12.0-01-bundle.zip，本教程将它解压在F盘，进入bin目录：


cmd进入bin目录，执行nexus.bat install


安装成功在服务中查看有nexus服务：





卸载nexus
cmd进入nexus的bin目录，执行：nexus.bat uninstall

查看window服务列表nexus已被删除。


启动nexus
方法1：
	cmd进入bin目录，执行nexus.bat start
方法2：
	直接启动nexus服务
	

查看nexus的配置文件conf/nexus.properties


# Jetty section
application-port=8081  	# nexus的访问端口配置
application-host=0.0.0.0 	# nexus主机监听配置(不用修改)
nexus-webapp=${bundleBasedir}/nexus 	# nexus工程目录
nexus-webapp-context-path=/nexus	 # nexus的web访问路径

# Nexus section
nexus-work=${bundleBasedir}/../sonatype-work/nexus   # nexus仓库目录
runtime=${bundleBasedir}/nexus/WEB-INF  # nexus运行程序目录

访问：
http://localhost:8081/nexus/



使用Nexus 内置账户admin/admin123登陆：
点击右上角的Log in，输入账号和密码 登陆


登陆成功：




仓库类型
nexus
查看nexus的仓库：




nexus的仓库有4种类型：


1.hosted，宿主仓库，部署自己的jar到这个类型的仓库，包括releases和snapshot两部分，Releases公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库

2.proxy，代理仓库，用于代理远程的公共仓库，如maven中央仓库，用户连接私服，私服自动去中央仓库下载jar包或者插件。 

3.group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置自己的maven连接仓库组。
4.virtual(虚拟)：兼容Maven1 版本的jar或者插件 


nexus仓库默认在sonatype-work目录中：


central：代理仓库，代理中央仓库


apache-snapshots：代理仓库
存储snapshots构件，代理地址https://repository.apache.org/snapshots/
central-m1：virtual类型仓库，兼容Maven1 版本的jar或者插件
releases：本地仓库，存储releases构件。
snapshots：本地仓库，存储snapshots构件。
thirdparty：第三方仓库
public：仓库组
将项目发布到私服
需求
	企业中多个团队协作开发通常会将一些公用的组件、开发模块等发布到私服供其它团队或模块开发人员使用。
	本例子假设多团队分别开发dao、service、web，某个团队开发完在dao会将dao发布到私服供service团队使用，本例子会将dao工程打成jar包发布到私服。


	
配置
第一步： 需要在客户端即部署dao工程的电脑上配置 maven环境，并修改 settings.xml 文件，配置连接私服的用户和密码 。

此用户名和密码用于私服校验，因为私服需要知道上传都 的账号和密码 是否和私服中的账号和密码 一致。


    <server>
      <id>releases</id>
      <username>admin</username>
      <password>admin123</password>
    </server>
	<server>
      <id>snapshots</id>
      <username>admin</username>
      <password>admin123</password>
    </server>

releases 连接发布版本项目仓库
snapshots 连接测试版本项目仓库 


第二步： 配置项目pom.xml 

配置私服仓库的地址，本公司的自己的jar包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为release则上传到私服的release仓库，如果版本为snapshot则上传到私服的snapshot仓库

  <distributionManagement>
  	<repository>
  		<id>releases</id>
	<url>http://localhost:8081/nexus/content/repositories/releases/</url>
  	</repository> 
  	<snapshotRepository>
  		<id>snapshots</id>
	<url>http://localhost:8081/nexus/content/repositories/snapshots/</url>
  	</snapshotRepository> 
  </distributionManagement>

注意：pom.xml这里<id> 和 settings.xml 配置 <id> 对应！ 

测试
将项目dao工程打成jar包发布到私服：
1、首先启动nexus
2、对dao工程执行deploy命令 


根据本项目pom.xml中version定义决定发布到哪个仓库，如果version定义为snapshot，执行deploy后查看nexus的snapshot仓库，如果version定义为release则项目将发布到nexus的release仓库，本项目将发布到snapshot仓库：


也可以通过http方式查看：

从私服下载jar包 
需求
	没有配置nexus之前，如果本地仓库没有，去中央仓库下载，通常在企业中会在局域网内部署一台私服服务器，有了私服本地项目首先去本地仓库找jar，如果没有找到则连接私服从私服下载jar包，如果私服没有jar包私服同时作为代理服务器从中央仓库下载jar包，这样做的好处是一方面由私服对公司项目的依赖jar包统一管理，一方面提高下载速度，项目连接私服下载jar包的速度要比项目连接中央仓库的速度快的多。
	
	本例子测试从私服下载dao 工程jar包。
管理仓库组
	nexus中包括很多仓库，hosted中存放的是企业自己发布的jar包及第三方公司的jar包，proxy中存放的是中央仓库的jar，为了方便从私服下载jar包可以将多个仓库组成一个仓库组，每个工程需要连接私服的仓库组下载jar包。

打开nexus配置仓库组，如下图：


上图中仓库组包括了本地仓库、代理仓库等。

在setting.xml中配置仓库
	在客户端的setting.xml中配置私服的仓库，由于setting.xml中没有repositories的配置标签需要使用profile定义仓库。

<profile>   
	<!--profile的id-->
   <id>dev</id>   
    <repositories>   
      <repository>  
		<!--仓库id，repositories可以配置多个仓库，保证id不重复-->
        <id>nexus</id>   
		<!--仓库地址，即nexus仓库组的地址-->
        <url>http://localhost:8081/nexus/content/groups/public/</url>   
		<!--是否下载releases构件-->
        <releases>   
          <enabled>true</enabled>   
        </releases>   
		<!--是否下载snapshots构件-->
        <snapshots>   
          <enabled>true</enabled>   
        </snapshots>   
      </repository>   
    </repositories>  
	 <pluginRepositories>  
    	<!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 -->
        <pluginRepository>  
        	<!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 -->
            <id>public</id>  
            <name>Public Repositories</name>  
            <url>http://localhost:8081/nexus/content/groups/public/</url>  
        </pluginRepository>  
    </pluginRepositories>  
  </profile>  

使用profile定义仓库需要激活才可生效。

  <activeProfiles>
    <activeProfile>dev</activeProfile>
  </activeProfiles>


配置成功后通过eclipse查看有效pom，有效pom是maven软件最终使用的pom内容，程序员不直接编辑有效pom，打开有效pom

有效pom内容如下：
下边的pom内容中有两个仓库地址，maven会先从前边的仓库的找，如果找不到jar包再从下边的找，从而就实现了从私服下载jar包。
<repositories>
    <repository>
      <releases>
        <enabled>true</enabled>
      </releases>
      <snapshots>
        <enabled>true</enabled>
      </snapshots>
      <id>public</id>
      <name>Public Repositories</name>
      <url>http://localhost:8081/nexus/content/groups/public/</url>
    </repository>
    <repository>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
    </repository>
  </repositories>
  <pluginRepositories>
    <pluginRepository>
      <id>public</id>
      <name>Public Repositories</name>
      <url>http://localhost:8081/nexus/content/groups/public/</url>
    </pluginRepository>
    <pluginRepository>
      <releases>
        <updatePolicy>never</updatePolicy>
      </releases>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <id>central</id>
      <name>Central Repository</name>
      <url>https://repo.maven.apache.org/maven2</url>
    </pluginRepository>
  </pluginRepositories>

测试从私服下载jar包
测试1：局域网环境或本地网络即可
在service工程中添加以上配置后，添加dao工程的依赖，删除本地仓库中dao工程，同时在eclipse中关闭dao工程。
观察控制台：
Downloading http://localhost:8081/nexus/content/groups/public/cn/itcast/ssh/ssh-dao0423/0.0.1-SNAPSHOT/ssh-dao0423-0.0.1-20160702.123702-1.jar

项目先从本地仓库找dao，找不到从私服找，由于之前执行deploy将dao部署到私服中，所以成功从私服下载dao并在本地仓库保存一份。
如果此时删除私服中的dao，执行update project之后是否正常？
如果将本地仓库的dao和私服的dao全部删除是否正常？

测试2：需要互联网环境
	在项目的pom.xml添加一个依赖，此依赖在本地仓库和私服都不存在，maven会先从本地仓库找，本地仓库没有再从私服找，私服没有再去中央仓库下载，jar包下载成功在私服、本地仓库分别存储一份。

总结
maven工程构建流程
1、创建maven工程，定义坐标
2、添加依赖
3、编写工程代码
4、如果是war工程使用tomcat插件运行

maven工程分模块构建流程

1、创建父工程
	父工程的pom.xml文件内容是将子工程中重复的pom内容进行抽取，通常包括锁定依赖版本、设置编译版本、tomat运行插件
2、创建各各子工程
3、聚合运行
	在父工程中配置module聚合运行。


私服的应用
1、将自己的工程打包jar发布到私服
2、从私服下载jar包到自己的工程中



Maven已经是Java的项目管理标配，如何在JavaEE开发使用Maven调用Web应用，是很多同学关心的问题。本文将介绍，Maven如何介绍Tomcat插件。
Maven Tomcat插件现在主要有两个版本，tomcat-maven-plugin和tomcat7-maven-plugin，使用方式基本相同。
tomcat-maven-plugin 插件官网：http://mojo.codehaus.org/tomcat-maven-plugin/plugin-info.html。
tomcat7-maven-plugin 插件官网：http://tomcat.apache.org/maven-plugin.html。
 
tomcat-maven-plugin  插件使用
配置
在pom.xm 加入以下xml。
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>tomcat-maven-plugin</artifactId>
                <version>1.1</version>
                <configuration>
                    <path>/wp</path>
                    <port>8080</port>
                    <uriEncoding>UTF-8</uriEncoding>
                    <url>http://localhost:8080/manager/html</url>
                    <server>tomcat6</server>
                </configuration>
            </plugin>
简要说明一下：
path  是访问应用的路径
port 是tomcat 的端口号
uriEncoding  URL按UTF-8进行编码，这样就解决了中文参数乱码。
Server 指定tomcat名称。
配置就这么简单，基本搞掂，下面看看如何使用。
插件运行
如果Eclipse 安装了Maven插件，选 择pom.xml文件，击右键——>选择 Run As——> Maven build 。

 
如果是第一次运行，会弹出下面对话框。在Goals框加加入以下命令: tomcat:run
 

这样Tomcat 插件就可以运行。
下面介绍几个常用的Goal
命令	描述
tomcat:deploy	部署一个web war包
tomcat:reload	重新加载web war包
tomcat:start	启动tomcat
tomcat:stop	停止tomcat
tomcat:undeploy	停止一个war包
tomcat:run	启动嵌入式tomcat ，并运行当前项目
tomcat7-maven-plugin 使用
配置
两个插件使用方法基本一样，同样需要在pom.xml引用该插件，需要增加以下配置
 
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.1</version>
                <configuration>
                    <port>9090</port>
                    <path>/mgr</path>
                    <uriEncoding>UTF-8</uriEncoding>
                    <server>tomcat7</server>
                </configuration>
            </plugin>
具体配置一样。
插件使用 
在这里要注意一下，该插件命名方式有些不同，比如启动tomcat ，对应的目标命令是: tomcat7:run ,同样，其它命令也是这样，需要更改为：tomcat7：<插件执行点>
 
 
OK，配置就这么简单，如果需要在 tomcat 跟踪联调，可以用Dubug 方式启动maven命令。如下图

Maven第一天
一、maven的好处？
1.使用传统的web项目开发的crm大小


2.同样的项目使用maven，它的大小

小结：同样的项目使用maven工程来实现，它的项目源码很小，可以初步推断它里面一定没有jar 包，继续思考，没有jar包的项目怎么可能运行呢？
分析jar包查找的过程

二、分析出maven优点是如何实现的？
1.依赖管理
就是对jar 包管理的过程，管理的过程参考上面的图分析过程
2.项目的一键构建
（编译-----测试-----   运行   --打包--------------安装 ）

什么是构建？
指的是项目从编译-----测试-----   运行   --打包--------------安装整个过程都交给maven进行管理，这个过程称为构建


三、Maven的安装


下载之后，放的位置

解压它，得到一个如下的目录结构：

四、Maven的配置及仓库的配置？
1.配置它的环境变量
电脑上需安装java环境，安装JDK1.7 + 版本  （将JAVA_HOME/bin 配置环境变量path ）

配置 MAVEN_HOME ，变量值就是你的maven安装 的路径（bin目录之前一级目录）


将 %MAVEN_HOME%/bin 加入环境变量 path 


通过 mvn -v命令检查 maven是否安装成功，看到maven的版本为3.3.9及java版本为1.7即为安装成功。

2.仓库的配置
2.1仓库的分类

2.2本地仓库的配置
这个配置文件：maven安装路径下\conf\settings.xml文件中


五、分析出maven工程的标准目录结构

Maven目录结构的规范

六、Maven命令？
compile
compile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。

cmd进入命令状态，执行mvn compile，如下图提示成功：



 查看 target目录，class文件已生成，编译完成。

test
test是maven工程的测试命令，会执行src/test/java下的单元测试类。
cmd执行mvn test执行src/test/java下单元测试类，下图为测试结果，运行1个测试用例，全部成功。





clean
clean是maven工程的清理命令，执行 clean会删除target目录的内容。

package
package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。

install
install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。
从运行结果中，可以看出：
当后面的命令执行时，前面的操作过程也都会自动执行，


七、如何使用eclipse开发maven项目
1.m2e的插件
因为使用的eclipse版本比较高，所以它自带了有maven插件。

点击”Add”,进入下面的页面

2.在eclipse中配置仓库的位置

3.构建索引
Window---show view ------other----------maven Repositories

4.重构索引


5.在eclipse中创建一个maven工程

6.选择maven project

7.点next进入下面的界面

8.可以看到一个helloworld工程，但报错(添加下面的内容就OK了)

9.src/java/main创建了一个Servlet，但报错

10.要解决问题，就是要将servlet-api-xxx.jar包放进来，作为maven工程应当添加servlet的坐标，从而导入它的jar
直接打开helloworld工程的pom.xml文件，再添加坐标


添加后自动生成的结果如下：
添加
添加jar包的坐标时，还可以指定这个jar包将来的作用范围



11.
八、如何添加maven工程


SVN检出的MAVEN工程问题
很多初学者都很困惑，Eclipse中从svn检出maven项目之后看到的目录结构并不是maven目录结构，那么应该怎么将项目转换成maven项目呢？具体步骤如下：
 
工具/原料 
电脑
Eclipse软件及svn插件
 
方法/步骤 
1.1
使用Eclipse从svn检出项目。
打开Eclipse，在project explorer空白区域右键鼠标移至import选择import。

2.2
之后选择svn-->从svn检出项目，然后输入svn地址，按照提示一步步从svn上检出maven项目



3.3
检出成功后会在project explorer中显示刚刚检出的maven项目。但此时项目的目录结构还不是maven项目的目录结构，需要转换成maven项目的目录结构。
此时转换成maven项目的方法有两种。
（一）直接单击项目，右键选择configure，选择convert to maven project

4.4
（二）删除project explorer中的项目，并重新从工作区间导入maven项目。
具体操作如下：
1、首先删除刚刚从svn检出的项目（千万别把工作区间相应的项目删除掉了，此操作只是删除从project explorer中移除该项目的显示）
      右键选择delete，选择ok即可（注意弹出框中的delete project contents on disk不能选上，否则会从工作区间文件夹里删除刚刚检出的项目）


5.5
2、然后再重新导入maven项目。
    在project explorer空白区域右键选择import，选择导入maven，选择extisting maven projects，选择工作区间刚刚检出的maven项目，点击确定导入Eclipse中。


6.6
最后，转换成功后，项目左侧会出现一个M字图标并有黄色的svn图标。至此，从svn成功检出了maven项目。


注意事项 
注意弹出框中的delete project contents on disk不能选上，否则会从工作区间文件夹里删除刚刚检出的项目

杰信进出口商贸集团





需求规格说明书
（公司内部管理）








修订历史记录
版本	日期	AMD	修订者	说明
第1.0版		A	陈子枢	新建发布
				
				

（A-添加，M-修改，D-删除）


一、项目概述：
1、项目名称：_陕西杰信商贸综合管理平台___ 
2、项目背景：
杰信商贸是国际物流行业一家专门从事进出口玻璃器皿贸易的公司。公司总部位于十三个朝代的帝王之都西安，业务遍及欧美。随着公司不断发展壮大，旧的信息系统已无法满足公司的快速发展需求，妨碍公司成长，在此背景下，公司领导决定研发《杰信商贸综合管理平台》。
《杰信商贸综合管理平台》分三期完成。一期完成仓储管理（包括：采购单、仓库、货物、条形码、入库、出库、退货、盘点、库存、库存上限报警、统计查询）和展会管理（包括：展会管理、出单管理），形成货物统一数字化管理。二期完成货运全流程管理，包括购销合同、出货表统计、出口报运单、HOME装箱单、装箱单、委托书、发票、财务统计等。三期完成决策分析（包括：成本分析图、销售情况统计、重点客户、经营情况同期比对统计、工作绩效），为公司经营决策提供数据支持。
3、项目目的：
满足企业发展需要，提高企业生产率，提高企业决策能力，为企业经营发展做支撑。
4、项目主要工作： 
需求调研，分析设计，测试部署，上线验收。
二、功能模块：
系统功能概览（USE CASE图）




杰信进出口商贸集团





需求规格说明书
（公司内部管理）








修订历史记录
版本	日期	AMD	修订者	说明
第1.0版		A	陈子枢	新建发布
				
				

（A-添加，M-修改，D-删除）


三、项目概述：
1、项目名称：_陕西杰信商贸综合管理平台___ 
2、项目背景：
杰信商贸是国际物流行业一家专门从事进出口玻璃器皿贸易的公司。公司总部位于十三个朝代的帝王之都西安，业务遍及欧美。随着公司不断发展壮大，旧的信息系统已无法满足公司的快速发展需求，妨碍公司成长，在此背景下，公司领导决定研发《杰信商贸综合管理平台》。
《杰信商贸综合管理平台》分三期完成。一期完成仓储管理（包括：采购单、仓库、货物、条形码、入库、出库、退货、盘点、库存、库存上限报警、统计查询）和展会管理（包括：展会管理、出单管理），形成货物统一数字化管理。二期完成货运全流程管理，包括购销合同、出货表统计、出口报运单、HOME装箱单、装箱单、委托书、发票、财务统计等。三期完成决策分析（包括：成本分析图、销售情况统计、重点客户、经营情况同期比对统计、工作绩效），为公司经营决策提供数据支持。
3、项目目的：
满足企业发展需要，提高企业生产率，提高企业决策能力，为企业经营发展做支撑。
4、项目主要工作： 
需求调研，分析设计，测试部署，上线验收。
四、功能模块：
系统功能概览（USE CASE图）




第一天：项目背景+搭建框架
一．学习项目的心态：
1.用什么方法来学习这些技术的？
是什么？
它的实现原理？
用在哪些地方？
怎么用？
2.如何学习项目课程？
1.学什么？
主要是学习项目的业务！什么是业务？就是做事情的一些步骤。能够跟面试官熟练的表达出你所熟悉的业务。
2.表达能力？很重要
3.能将业务使用代码编写出来
4.学到新知识点，用多少学多少，只讲用少讲原理
5.提高自学能力，提高调试能力，提高表达沟通能力

二.项目背景
商务综合管理平台是国际物流行业一家专门从事进出口玻璃器皿贸易的公司。业务遍及欧美。随着公司不断发展壮大，旧的信息系统已无法满足公司的快速发展需求，妨碍公司成长，在此背景下，公司领导决定研发《商务综合管理平台》。
《商务综合管理平台》分三期完成。一期完成仓储管理（包括：采购单、仓库、货物、条形码、入库、出库、退货、盘点、库存、库存上限报警、统计查询）和展会管理（包括：展会管理、出单管理），形成货物统一数字化管理。二期完成货运全流程管理，包括购销合同、出货表统计、出口报运单、HOME装箱单、装箱单、委托书、发票、财务统计等。三期完成决策分析（包括：成本分析图、销售情况统计、重点客户、经营情况同期比对统计、工作绩效），为公司经营决策提供数据支持。

如何从国外拿到订单？
通过一些展销会，拿到订单。到国内找生产厂家生产货物。在指定日期生产厂家要将生产的货物运到码头，同时一边到海关进行审批。



三.为什么选择国际物流项目？
1.市场
2.很火
3.业务

四.界面原型法
原型它的目的，它给客户提前看未来的系统长什么样子。客户就能有一个直观的印象。
界面原型法，在实际需求调研阶段用的非常多。和用户谈需求并进行记录，跟web前端页面工程师沟通，让其设计出一套相关的页面原型，再拿过去与用户再次进行沟通，并修改进行记录，再回来进行页面的修改，如果确认，将来的页面就基本不再改动。

目的就是在最短的时间里，得到用户最真实的需求。

五.UML的UseCase图
1.获取需求是专业的
2.usecase就是用例图，它是专门用于描述需求的
3.uml代表统一建模语言
  它包含很多图： 用例图，类图，状态图，序列图…….
4.软件：
  Rose,  pd(powerDesigner  可以画uml图也可以进行数据库设计)，Visio
  OOP  面向对象编程
  OOM 面向对象建模
  OOD  面向对象设计
  OOA  面向对象分析  (analysis)

工作空间—新增----oom----use case diagram


进入一个面板：




解决线条的问题：

需求描述：

六. 系统功能模块结构图
系统功能结构图  


它的作用？
1.功能模块一目了然
2.便于分工
3.便于进行项目报价



七．系统框架
如果自己搭建框架：

如果使用的别人的框架：
1.首先看jar包
2.画图
3.确定哪些技术需要学习。

搭建maven结构的过程：
1.找到资源


2.常用配置文件的资源 ：

3.创建一个maven project：jk2601_parent
4.在jk2601_parent中找到pom.xml文件，添加相应的依赖

引入这个pom.xml,如果没有本地的更新，也要先进行本地仓库的更新
5.拆分的maven工程如下：

6.解决上面的jk2601_web上面的小错误

7.添加依赖
Jk2601_domain中添加jk2601_util

DAO中依赖

Service依赖：



8.加入相关的util工具类
9.加入dao相关的类

10.jk_2601_domain中操作的表

编写domain中的Dept类及它的映射文件

11.jk_2601_service中

12.jk2601_web

13.测试并运行


八.面试
1.请写出hibernate中主键生成策略常用6种方式  
native,uuid,increment,identity,sequence,assigned

2.Byte/Short/int/char/varchar运行速度及区别
运行速度: Byte/Short/int/char/varchar  由快到慢
Char是一个固定长度，这样可能导致空间浪费，但反应快速比varchar快。
Varchar可以做到空间最省，但会多长度比较的过程，所以很浪费时间。

3.面试
  请参考数据库表结构写出PO类及映射文件
PO类：

映射文件


面试：PO类的定义规范


hibernate配置文件
Hibernate.cfg.xml文件编写
   
第一天：项目背景+搭建框架
一．学习项目的心态：
3.用什么方法来学习这些技术的？
是什么？
它的实现原理？
用在哪些地方？
怎么用？
4.如何学习项目课程？
6.学什么？
主要是学习项目的业务！什么是业务？就是做事情的一些步骤。能够跟面试官熟练的表达出你所熟悉的业务。
7.表达能力？很重要
8.能将业务使用代码编写出来
9.学到新知识点，用多少学多少，只讲用少讲原理
10.提高自学能力，提高调试能力，提高表达沟通能力

二.项目背景
商务综合管理平台是国际物流行业一家专门从事进出口玻璃器皿贸易的公司。业务遍及欧美。随着公司不断发展壮大，旧的信息系统已无法满足公司的快速发展需求，妨碍公司成长，在此背景下，公司领导决定研发《商务综合管理平台》。
《商务综合管理平台》分三期完成。一期完成仓储管理（包括：采购单、仓库、货物、条形码、入库、出库、退货、盘点、库存、库存上限报警、统计查询）和展会管理（包括：展会管理、出单管理），形成货物统一数字化管理。二期完成货运全流程管理，包括购销合同、出货表统计、出口报运单、HOME装箱单、装箱单、委托书、发票、财务统计等。三期完成决策分析（包括：成本分析图、销售情况统计、重点客户、经营情况同期比对统计、工作绩效），为公司经营决策提供数据支持。

如何从国外拿到订单？
通过一些展销会，拿到订单。到国内找生产厂家生产货物。在指定日期生产厂家要将生产的货物运到码头，同时一边到海关进行审批。



三.为什么选择国际物流项目？
1.市场
2.很火
3.业务

四.界面原型法
原型它的目的，它给客户提前看未来的系统长什么样子。客户就能有一个直观的印象。
界面原型法，在实际需求调研阶段用的非常多。和用户谈需求并进行记录，跟web前端页面工程师沟通，让其设计出一套相关的页面原型，再拿过去与用户再次进行沟通，并修改进行记录，再回来进行页面的修改，如果确认，将来的页面就基本不再改动。

目的就是在最短的时间里，得到用户最真实的需求。

五.UML的UseCase图
1.获取需求是专业的
2.usecase就是用例图，它是专门用于描述需求的
3.uml代表统一建模语言
  它包含很多图： 用例图，类图，状态图，序列图…….
4.软件：
  Rose,  pd(powerDesigner  可以画uml图也可以进行数据库设计)，Visio
  OOP  面向对象编程
  OOM 面向对象建模
  OOD  面向对象设计
  OOA  面向对象分析  (analysis)

工作空间—新增----oom----use case diagram


进入一个面板：




解决线条的问题：

需求描述：

六. 系统功能模块结构图
系统功能结构图  


它的作用？
1.功能模块一目了然
2.便于分工
3.便于进行项目报价



七．系统框架
如果自己搭建框架：

如果使用的别人的框架：
1.首先看jar包
2.画图
3.确定哪些技术需要学习。

搭建maven结构的过程：
14.找到资源


15.常用配置文件的资源 ：

16.创建一个maven project：jk2601_parent
17.在jk2601_parent中找到pom.xml文件，添加相应的依赖

引入这个pom.xml,如果没有本地的更新，也要先进行本地仓库的更新
18.拆分的maven工程如下：

19.解决上面的jk2601_web上面的小错误

20.添加依赖
Jk2601_domain中添加jk2601_util

DAO中依赖

Service依赖：



21.加入相关的util工具类
22.加入dao相关的类

23.jk_2601_domain中操作的表

编写domain中的Dept类及它的映射文件

24.jk_2601_service中

25.jk2601_web

26.测试并运行


八.面试
1.请写出hibernate中主键生成策略常用6种方式  
native,uuid,increment,identity,sequence,assigned

2.Byte/Short/int/char/varchar运行速度及区别
运行速度: Byte/Short/int/char/varchar  由快到慢
Char是一个固定长度，这样可能导致空间浪费，但反应快速比varchar快。
Varchar可以做到空间最省，但会多长度比较的过程，所以很浪费时间。

3.面试
  请参考数据库表结构写出PO类及映射文件
PO类：

映射文件


面试：PO类的定义规范


hibernate配置文件
Hibernate.cfg.xml文件编写
   
 freemarker-2.3.19教程
FreeMarker概述
         FreeMarker是一个模板引擎，一个基于模板生成文本输出的通用工具，使用纯Java编写 
         FreeMarker被设计用来生成HTML Web页面，特别是基于MVC模式的应用程序 
         虽然FreeMarker具有一些编程的能力，但通常由Java程序准备要显示的数据，由FreeMarker生成页面，通过模板显示准备的数据（如下图）

         FreeMarker不是一个Web应用框架，而适合作为Web应用框架一个组件 
         FreeMarker与容器无关，因为它并不知道HTTP或Servlet；FreeMarker同样可以应用于非Web应用程序环境 
         FreeMarker更适合作为Model2框架（如Struts）的视图组件，你也可以在模板中使用JSP标记库 
         FreeMarker是免费的 
  
  
1、通用目标 
         能够生成各种文本：HTML、XML、RTF、Java源代码等等 
         易于嵌入到你的产品中：轻量级；不需要Servlet环境 
         插件式模板载入器：可以从任何源载入模板，如本地文件、数据库等等 
         你可以按你所需生成文本：保存到本地文件；作为Email发送；从Web应用程序发送它返回给Web浏览器 
  
2、强大的模板语言 
         所有常用的指令：include、if/elseif/else、循环结构 
         在模板中创建和改变变量 
         几乎在任何地方都可以使用复杂表达式来指定值 
         命名的宏，可以具有位置参数和嵌套内容 
         名字空间有助于建立和维护可重用的宏库，或者将一个大工程分成模块，而不必担心名字冲突 
         输出转换块：在嵌套模板片段生成输出时，转换HTML转义、压缩、语法高亮等等；你可以定义自己的转换 
  
3、通用数据模型 
         FreeMarker不是直接反射到Java对象，Java对象通过插件式对象封装，以变量方式在模板中显示 
         你可以使用抽象（接口）方式表示对象（JavaBean、XML文档、SQL查询结果集等等），告诉模板开发者使用方法，使其不受技术细节的打扰 
  
4、为Web准备 
         在模板语言中内建处理典型Web相关任务（如HTML转义）的结构 
         能够集成到Model2 Web应用框架中作为JSP的替代 
         支持JSP标记库 
         为MVC模式设计：分离可视化设计和应用程序逻辑；分离页面设计员和程序员 
  
5、智能的国际化和本地化 
         字符集智能化（内部使用UNICODE） 
         数字格式本地化敏感 
         日期和时间格式本地化敏感 
         非US字符集可以用作标识（如变量名） 
         多种不同语言的相同模板 
  
6、强大的XML处理能力 
         <#recurse> 和<#visit>指令（2.3版本）用于递归遍历XML树 
         在模板中清楚和直觉的访问XML对象模型 
  
FreeMarker设计指南(1)


 	 

 
1、快速入门
（1）模板 + 数据模型 = 输出
         FreeMarker基于设计者和程序员是具有不同专业技能的不同个体的观念
         他们是分工劳动的：设计者专注于表示——创建HTML文件、图片、Web页面的其它可视化方面；程序员创建系统，生成设计页面要显示的数据
         经常会遇到的问题是：在Web页面（或其它类型的文档）中显示的信息在设计页面时是无效的，是基于动态数据的
         在这里，你可以在HTML（或其它要输出的文本）中加入一些特定指令，FreeMarker会在输出页面给最终用户时，用适当的数据替代这些代码
         下面是一个例子：
<html>
<head>
  <title>Welcome!</title>
</head>
<body>
  <h1>Welcome ${user}!</h1>
  <p>Our latest product:
  <a href="${latestProduct.url}">${latestProduct.name}</a>!
</body>
</html>  
         这个例子是在简单的HTML中加入了一些由${…}包围的特定代码，这些特定代码是FreeMarker的指令，而包含FreeMarker的指令的文件就称为模板（Template）
         至于user、latestProduct.url和latestProduct.name来自于数据模型（data model）
         数据模型由程序员编程来创建，向模板提供变化的信息，这些信息来自于数据库、文件，甚至于在程序中直接生成
         模板设计者不关心数据从那儿来，只知道使用已经建立的数据模型
         下面是一个可能的数据模型：
(root)
  |
  +- user = "Big Joe"
  |
  +- latestProduct
      |
      +- url = "products/greenmouse.html"
      |
      +- name = "green mouse"
         数据模型类似于计算机的文件系统，latestProduct可以看作是目录，而user、url和name看作是文件，url和name文件位于latestProduct目录中（这只是一个比喻，实际并不存在）
         当FreeMarker将上面的数据模型合并到模板中，就创建了下面的输出：
<html>
<head>
  <title>Welcome!</title>
</head>
<body>
  <h1>Welcome Big Joe!</h1>
  <p>Our latest product:
  <a href="products/greenmouse.html">green mouse</a>!
</body>
</html>  
（2）数据模型
         典型的数据模型是树型结构，可以任意复杂和深层次，如下面的例子：
(root)
  |
  +- animals
  |   |
  |   +- mouse
  |   |   |   
  |   |   +- size = "small"
  |   |   |   
  |   |   +- price = 50
  |   |
  |   +- elephant
  |   |   |   
  |   |   +- size = "large"
  |   |   |   
  |   |   +- price = 5000
  |   |
  |   +- python
  |       |   
  |       +- size = "medium"
  |       |   
  |       +- price = 4999
  |
  +- test = "It is a test"
  |
  +- whatnot
      |
      +- because = "don't know"
         类似于目录的变量称为hashes，包含保存下级变量的唯一的查询名字
         类似于文件的变量称为scalars，保存单值
         scalars保存的值有两种类型：字符串（用引号括起，可以是单引号或双引号）和数字（不要用引号将数字括起，这会作为字符串处理）
         对scalars的访问从root开始，各部分用“.”分隔，如animals.mouse.price
         另外一种变量是sequences，和hashes类似，只是不使用变量名字，而使用数字索引，如下面的例子：
(root)
  |
  +- animals
  |   |
  |   +- (1st)
  |   |   |
  |   |   +- name = "mouse"
  |   |   |
  |   |   +- size = "small"
  |   |   |
  |   |   +- price = 50
  |   |
  |   +- (2nd)
  |   |   |
  |   |   +- name = "elephant"
  |   |   |
  |   |   +- size = "large"
  |   |   |
  |   |   +- price = 5000
  |   |
  |   +- (3rd)
  |       |
  |       +- name = "python"
  |       |
  |       +- size = "medium"
  |       |
  |       +- price = 4999
  |
  +- whatnot
      |
      +- fruits
          |
          +- (1st) = "orange"
          |
          +- (2nd) = "banana"
         这种对scalars的访问使用索引，如animals[0].name
（3）模板
         在FreeMarker模板中可以包括下面三种特定部分：
         ${…}：称为interpolations，FreeMarker会在输出时用实际值进行替代
         FTL标记（FreeMarker模板语言标记）：类似于HTML标记，为了与HTML标记区分，用#开始（有些以@开始，在后面叙述）
         注释：包含在<#--和-->（而不是<!--和-->）之间
         下面是一些使用指令的例子：
         if指令
<#if animals.python.price < animals.elephant.price>
  Pythons are cheaper than elephants today.
<#else>
  Pythons are not cheaper than elephants today.
</#if>  
         list指令
<p>We have these animals:
<table border=1>
  <tr><th>Name<th>Price
  <#list animals as being>
  <tr><td>${being.name}<td>${being.price} Euros
  </#list>
</table>  
输出为：
<p>We have these animals:
<table border=1>
  <tr><th>Name<th>Price
  <tr><td>mouse<td>50 Euros
  <tr><td>elephant<td>5000 Euros
  <tr><td>python<td>4999 Euros
</table>  
         include指令
<html>
<head>
  <title>Test page</title>
</head>
<body>
  <h1>Test page</h1>
  <p>Blah blah...
<#include "/copyright_footer.html">
</body>
</html>  
         一起使用指令
<p>We have these animals:
<table border=1>
  <tr><th>Name<th>Price
  <#list animals as being>
  <tr>
    <td>
      <#if being.size = "large"><b></#if>
      ${being.name}
      <#if being.size = "large"></b></#if>
    <td>${being.price} Euros
  </#list>
</table>  

FreeMarker设计指南(3)


 	 

 
3、模板
（1）整体结构
         模板使用FTL（FreeMarker模板语言）编写，是下面各部分的一个组合：
         文本：直接输出
         Interpolation：由${和}，或#{和}来限定，计算值替代输出
         FTL标记：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出
         注释：由<#--和-->限定，不会输出
         下面是以一个具体模板例子：
<html>[BR]
<head>[BR]
  <title>Welcome!</title>[BR]
</head>[BR]
<body>[BR]
  <#-- Greet the user with his/her name -->[BR]
  <h1>Welcome ${user}!</h1>[BR]
  <p>We have these animals:[BR]
  <ul>[BR]
  <#list animals as being>[BR]
    <li>${being.name} for ${being.price} Euros[BR]
  </#list>[BR]
  </ul>[BR]
</body>[BR]
</html>  
         [BR]是用于换行的特殊字符序列
         注意事项：
         FTL区分大小写，所以list是正确的FTL指令，而List不是；${name}和${NAME}是不同的
         Interpolation只能在文本中使用
         FTL标记不能位于另一个FTL标记内部，例如：
<#if <#include 'foo'>='bar'>...</if>
         注释可以位于FTL标记和Interpolation内部，如下面的例子：
<h1>Welcome ${user <#-- The name of user -->}!</h1>[BR]
<p>We have these animals:[BR]
<ul>[BR]
<#list <#-- some comment... --> animals as <#-- again... --> being>[BR]
...  
         多余的空白字符会在模板输出时移除
（2）指令
         在FreeMarker中，使用FTL标记引用指令
         有三种FTL标记，这和HTML标记是类似的：
         开始标记：<#directivename parameters>
         结束标记：</#directivename>
         空内容指令标记：<#directivename parameters/>
         有两种类型的指令：预定义指令和用户定义指令
         用户定义指令要使用@替换#，如<@mydirective>...</@mydirective>（会在后面讲述）
         FTL标记不能够交叉，而应该正确的嵌套，如下面的代码是错误的：
<ul>
<#list animals as being>
  <li>${being.name} for ${being.price} Euros
  <#if use = "Big Joe">
     (except for you)
</#list>
</#if> <#-- WRONG! -->
</ul>  
         如果使用不存在的指令，FreeMarker不会使用模板输出，而是产生一个错误消息
         FreeMarker会忽略FTL标记中的空白字符，如下面的例子：
<#list[BR]
  animals       as[BR]
     being[BR]
>[BR]
${being.name} for ${being.price} Euros[BR]
</#list    >  
         但是，<、</和指令之间不允许有空白字符
（3）表达式
         直接指定值
         字符串
         使用单引号或双引号限定
         如果包含特殊字符需要转义，如下面的例子：
${"It's \"quoted\" and
this is a backslash: \\"}
 
${'It\'s "quoted" and
this is a backslash: \\'} 
输出结果是：
It's "quoted" and
this is a backslash: \
 
It's "quoted" and
this is a backslash: \ 
         下面是支持的转义序列：
转义序列	含义
\"	双引号(u0022)
\'	单引号(u0027)
\\	反斜杠(u005C)
\n	换行(u000A)
\r	Return (u000D)
\t	Tab (u0009)
\b	Backspace (u0008)
\f	Form feed (u000C)
\l	<
\g	>
\a	&
\{	{
\xCode	4位16进制Unicode代码
         有一类特殊的字符串称为raw字符串，被认为是纯文本，其中的\和{等不具有特殊含义，该类字符串在引号前面加r，下面是一个例子：
${r"${foo}"}
${r"C:\foo\bar"}  
输出的结果是：
${foo}
C:\foo\bar  
         数字
         直接输入，不需要引号
         精度数字使用“.”分隔，不能使用分组符号
         目前版本不支持科学计数法，所以“1E3”是错误的
         不能省略小数点前面的0，所以“.5”是错误的
         数字8、+8、08和8.00都是相同的
         布尔值
         true和false，不使用引号
         序列
         由逗号分隔的子变量列表，由方括号限定，下面是一个例子：
<#list ["winter", "spring", "summer", "autumn"] as x>
${x}
</#list> 
输出的结果是：
winter
spring
summer
autumn
         列表的项目是表达式，所以可以有下面的例子：
[2 + 2, [1, 2, 3, 4], "whatnot"]
         可以使用数字范围定义数字序列，例如2..5等同于[2, 3, 4, 5]，但是更有效率，注意数字范围没有方括号
         可以定义反递增的数字范围，如5..2
         散列（hash）
         由逗号分隔的键/值列表，由大括号限定，键和值之间用冒号分隔，下面是一个例子：
{"name":"green mouse", "price":150}
         键和值都是表达式，但是键必须是字符串
         获取变量
         顶层变量： ${variable}，变量名只能是字母、数字、下划线、$、@和#的组合，且不能以数字开头
         从散列中获取数据
         可以使用点语法或方括号语法，假设有下面的数据模型：
(root)
 |
 +- book
 |   |
 |   +- title = "Breeding green mouses"
 |   |
 |   +- author
 |       |
 |       +- name = "Julia Smith"
 |       |
 |       +- info = "Biologist, 1923-1985, Canada"
 |
 +- test = "title" 
下面都是等价的：
book.author.name
book["author"].name
book.author.["name"]
book["author"]["name"]
         使用点语法，变量名字有顶层变量一样的限制，但方括号语法没有该限制，因为名字是任意表达式的结果
         从序列获得数据：和散列的方括号语法语法一样，只是方括号中的表达式值必须是数字；注意：第一个项目的索引是0
         序列片断：使用[startIndex..endIndex]语法，从序列中获得序列片断（也是序列）；startIndex和endIndex是结果为数字的表达式
         特殊变量：FreeMarker内定义变量，使用.variablename语法访问
         字符串操作
         Interpolation（或连接操作）
         可以使用${..}（或#{..}）在文本部分插入表达式的值，例如：
${"Hello ${user}!"}
${"${user}${user}${user}${user}"}  
         可以使用+操作符获得同样的结果
${"Hello " + user + "!"}
${user + user + user + user}
         ${..}只能用于文本部分，下面的代码是错误的：
<#if ${isBig}>Wow!</#if>
<#if "${isBig}">Wow!</#if>
应该写成：
<#if isBig>Wow!</#if>
         子串
         例子（假设user的值为“Big Joe”）：
${user[0]}${user[4]}
${user[1..4]}
结果是（注意第一个字符的索引是0）：
BJ
ig J 
         序列操作
         连接操作：和字符串一样，使用+，下面是一个例子：
<#list ["Joe", "Fred"] + ["Julia", "Kate"] as user>
- ${user}
</#list>
输出结果是：
- Joe
- Fred
- Julia
- Kate
         散列操作
         连接操作：和字符串一样，使用+，如果具有相同的key，右边的值替代左边的值，例如：
<#assign ages = {"Joe":23, "Fred":25} + {"Joe":30, "Julia":18}>
- Joe is ${ages.Joe}
- Fred is ${ages.Fred}
- Julia is ${ages.Julia}  
输出结果是：
- Joe is 30
- Fred is 25
- Julia is 18  
         算术运算
         ＋、－、×、／、％，下面是一个例子：
${x * x - 100}
${x / 2}
${12 % 10}
输出结果是（假设x为5）：
-75
2.5
2  
         操作符两边必须是数字，因此下面的代码是错误的：
${3 * "5"} <#-- WRONG! -->  
         使用+操作符时，如果一边是数字，一边是字符串，就会自动将数字转换为字符串，例如：
${3 + "5"}  
输出结果是：
35
         使用内建的int（后面讲述）获得整数部分，例如：
${(x/2)?int}
${1.1?int}
${1.999?int}
${-1.1?int}
${-1.999?int}
输出结果是（假设x为5）：
2
1
1
-1
-1
         比较操作符
         使用=（或==，完全相等）测试两个值是否相等，使用!= 测试两个值是否不相等
         =和!=两边必须是相同类型的值，否则会产生错误，例如<#if 1 = "1">会引起错误
         Freemarker是精确比较，所以对"x"、"x  "和"X"是不相等的
         对数字和日期可以使用<、<=、>和>=，但不能用于字符串
         由于Freemarker会将>解释成FTL标记的结束字符，所以对于>和>=可以使用括号来避免这种情况，例如<#if (x > y)>
         另一种替代的方法是，使用lt、lte、gt和gte来替代<、<=、>和>=
         逻辑操作符
         &&（and）、||（or）、!（not），只能用于布尔值，否则会产生错误
         例子：
<#if (x < 12) && color = "green">
  We have less than 12 things, and they are green.
</#if>
<#if !hot> <#-- here hot must be a boolean -->
  It's not hot.
</#if>  
         内建函数
         内建函数的用法类似访问散列的子变量，只是使用“?”替代“.”，下面列出常用的一些函数
         字符串使用的：
         html：对字符串进行HTML编码
         cap_first：使字符串第一个字母大写
         lower_case：将字符串转换成小写
         upper_case：将字符串转换成大写
         trim：去掉字符串前后的空白字符
         序列使用的：
         size：获得序列中元素的数目
         数字使用的：
         int：取得数字的整数部分（如-1.9?int的结果是-1）
         例子（假设test保存字符串"Tom & Jerry"）：
${test?html}
${test?upper_case?html}
输出结果是：
Tom &amp; Jerry
TOM &amp; JERRY  
         操作符优先顺序
操作符组	操作符
后缀	[subvarName] [subStringRange] . (methodParams)
一元	+expr、-expr、!
内建	?
乘法	*、 / 、%
加法	+、-
关系	<、>、<=、>=（lt、lte、gt、gte）
相等	==（=）、!=
逻辑and	&&
逻辑or	||
数字范围	..
（4）Interpolation
         Interpolation有两种类型：
         通用Interpolation：${expr}
         数字Interpolation：#{expr}或#{expr; format}
         注意：Interpolation只能用于文本部分
         通用Interpolation
         插入字符串值：直接输出表达式结果
         插入数字值：根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation，下面是一个例子：
<#setting number_format="currency"/>
<#assign answer=42/>
${answer}
${answer?string}  <#-- the same as ${answer} -->
${answer?string.number}
${answer?string.currency}
${answer?string.percent} 
输出结果是：
$42.00
$42.00
42
$42.00
4,200%
         插入日期值：根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation，下面是一个使用格式模式的例子：
${lastUpdated?string("yyyy-MM-dd HH:mm:ss zzzz")}
${lastUpdated?string("EEE, MMM d, ''yy")}
${lastUpdated?string("EEEE, MMMM dd, yyyy, hh:mm:ss a '('zzz')'")}  
输出的结果类似下面的格式：
2003-04-08 21:24:44 Pacific Daylight Time
Tue, Apr 8, '03
Tuesday, April 08, 2003, 09:24:44 PM (PDT)
         插入布尔值：根据缺省格式（由#setting指令设置）将表达式结果转换成文本输出；可以使用内建函数string格式化单个Interpolation，下面是一个例子：
<#assign foo=true/>
${foo?string("yes", "no")}
输出结果是：
yes
         数字Interpolation的#{expr; format}形式可以用来格式化数字，format可以是：
         mX：小数部分最小X位
         MX：小数部分最大X位
         例子：
           <#-- If the language is US English the output is: -->
<#assign x=2.582/>
<#assign y=4/>
#{x; M2}   <#-- 2.58 -->
#{y; M2}   <#-- 4    -->
#{x; m1}   <#-- 2.6 -->
#{y; m1}   <#-- 4.0 -->
#{x; m1M2} <#-- 2.58 -->
#{y; m1M2} <#-- 4.0  --> 

FreeMarker设计指南(4)


 	 

 
4、杂项
（1）用户定义指令
         宏和变换器变量是两种不同类型的用户定义指令，它们之间的区别是宏是在模板中使用macro指令定义，而变换器是在模板外由程序定义，这里只介绍宏
         基本用法
         宏是和某个变量关联的模板片断，以便在模板中通过用户定义指令使用该变量，下面是一个例子：
<#macro greet>
  <font size="+2">Hello Joe!</font>
</#macro>  
         作为用户定义指令使用宏变量时，使用@替代FTL标记中的#
<@greet></@greet>
         如果没有体内容，也可以使用：
<@greet/>
         参数
         在macro指令中可以在宏变量之后定义参数，如：
<#macro greet person>
  <font size="+2">Hello ${person}!</font>
</#macro> 
         可以这样使用这个宏变量：
<@greet person="Fred"/> and <@greet person="Batman"/> 
输出结果是：
  <font size="+2">Hello Fred!</font>
 and   <font size="+2">Hello Batman!</font>
   
         宏的参数是FTL表达式，所以下面的代码具有不同的意思：
<@greet person=Fred/>
         这意味着将Fred变量的值传给person参数，该值不仅是字符串，还可以是其它类型，甚至是复杂的表达式
         宏可以有多参数，下面是一个例子：
<#macro greet person color>
  <font size="+2" color="${color}">Hello ${person}!</font>
</#macro> 
         可以这样使用该宏变量：
<@greet person="Fred" color="black"/> 
         其中参数的次序是无关的，因此下面是等价的：
<@greet color="black" person="Fred"/>
         只能使用在macro指令中定义的参数，并且对所有参数赋值，所以下面的代码是错误的：
<@greet person="Fred" color="black" background="green"/>
<@greet person="Fred"/>
         可以在定义参数时指定缺省值，如：
<#macro greet person color="black">
  <font size="+2" color="${color}">Hello ${person}!</font>
</#macro>  
         这样<@greet person="Fred"/>就正确了
         宏的参数是局部变量，只能在宏定义中有效
         嵌套内容
         用户定义指令可以有嵌套内容，使用<#nested>指令执行指令开始和结束标记之间的模板片断
         例子：
<#macro border>
  <table border=4 cellspacing=0 cellpadding=4><tr><td>
    <#nested>
  </tr></td></table>
</#macro>  
这样使用该宏变量：
<@border>The bordered text</@border>
输出结果：
  <table border=4 cellspacing=0 cellpadding=4><tr><td>
    The bordered text
  </tr></td></table>
  
         <#nested>指令可以被多次调用，例如：
<#macro do_thrice>
  <#nested>
  <#nested>
  <#nested>
</#macro>
<@do_thrice>
  Anything.
</@do_thrice>  
输出结果：
  Anything.
  Anything.
  Anything. 
         嵌套内容可以是有效的FTL，下面是一个有些复杂的例子：
<@border>
  <ul>
  <@do_thrice>
    <li><@greet person="Joe"/>
  </@do_thrice>
  </ul>
</@border> 
输出结果：
  <table border=4 cellspacing=0 cellpadding=4><tr><td>
      <ul>
    <li><font size="+2">Hello Joe!</font>
 
    <li><font size="+2">Hello Joe!</font>
 
    <li><font size="+2">Hello Joe!</font>
 
  </ul>
 
  </tr></td></table>  
         宏定义中的局部变量对嵌套内容是不可见的，例如：
<#macro repeat count>
  <#local y = "test">
  <#list 1..count as x>
    ${y} ${count}/${x}: <#nested>
  </#list>
</#macro>
<@repeat count=3>${y?default("?")} ${x?default("?")} ${count?default("?")}</@repeat>
输出结果：
    test 3/1: ? ? ?
    test 3/2: ? ? ?
    test 3/3: ? ? ?
          
         在宏定义中使用循环变量
         用户定义指令可以有循环变量，通常用于重复嵌套内容，基本用法是：作为nested指令的参数传递循环变量的实际值，而在调用用户定义指令时，在<@…>开始标记的参数后面指定循环变量的名字
         例子：
<#macro repeat count>
  <#list 1..count as x>
    <#nested x, x/2, x==count>
  </#list>
</#macro>
<@repeat count=4 ; c, halfc, last>
  ${c}. ${halfc}<#if last> Last!</#if>
</@repeat>  
输出结果：
  1. 0.5
  2. 1
  3. 1.5
  4. 2 Last!
  
         指定的循环变量的数目和用户定义指令开始标记指定的不同不会有问题
         调用时少指定循环变量，则多指定的值不可见
         调用时多指定循环变量，多余的循环变量不会被创建
（2）在模板中定义变量
         在模板中定义的变量有三种类型：
         plain变量：可以在模板的任何地方访问，包括使用include指令插入的模板，使用assign指令创建和替换
         局部变量：在宏定义体中有效，使用local指令创建和替换
         循环变量：只能存在于指令的嵌套内容，由指令（如list）自动创建；宏的参数是局部变量，而不是循环变量
         局部变量隐藏（而不是覆盖）同名的plain变量；循环变量隐藏同名的局部变量和plain变量，下面是一个例子：
<#assign x = "plain">
1. ${x}  <#-- we see the plain var. here -->
<@test/>
6. ${x}  <#-- the value of plain var. was not changed -->
<#list ["loop"] as x>
    7. ${x}  <#-- now the loop var. hides the plain var. -->
    <#assign x = "plain2"> <#-- replace the plain var, hiding does not mater here -->
    8. ${x}  <#-- it still hides the plain var. -->
</#list>
9. ${x}  <#-- the new value of plain var. -->
 
<#macro test>
  2. ${x}  <#-- we still see the plain var. here -->
  <#local x = "local">
  3. ${x}  <#-- now the local var. hides it -->
  <#list ["loop"] as x>
    4. ${x}  <#-- now the loop var. hides the local var. -->
  </#list>
  5. ${x}  <#-- now we see the local var. again -->
</#macro>  
输出结果：
1. plain
  2. plain
  3. local
    4. loop
  5. local
6. plain
    7. loop
    8. loop
9. plain2
 
         内部循环变量隐藏同名的外部循环变量，如：
<#list ["loop 1"] as x>
  ${x}
  <#list ["loop 2"] as x>
    ${x}
    <#list ["loop 3"] as x>
      ${x}
    </#list>
    ${x}
  </#list>
  ${x}
</#list>
输出结果：
  loop 1
    loop 2
      loop 3
    loop 2
  loop 1 
         模板中的变量会隐藏（而不是覆盖）数据模型中同名变量，如果需要访问数据模型中的同名变量，使用特殊变量global，下面的例子假设数据模型中的user的值是Big Joe：
<#assign user = "Joe Hider">
${user}          <#-- prints: Joe Hider -->
${.globals.user} <#-- prints: Big Joe -->  
（3）名字空间
         通常情况，只使用一个名字空间，称为主名字空间
         为了创建可重用的宏、变换器或其它变量的集合（通常称库），必须使用多名字空间，其目的是防止同名冲突
         创建库
         下面是一个创建库的例子（假设保存在lib/my_test.ftl中）：
<#macro copyright date>
  <p>Copyright (C) ${date} Julia Smith. All rights reserved.
  <br>Email: ${mail}</p>
</#macro>  
<#assign mail = "jsmith@acme.com"> 
         使用import指令导入库到模板中，Freemarker会为导入的库创建新的名字空间，并可以通过import指令中指定的散列变量访问库中的变量：
<#import "/lib/my_test.ftl" as my>
<#assign mail="fred@acme.com">
<@my.copyright date="1999-2002"/>
${my.mail}
${mail}  
输出结果：
  <p>Copyright (C) 1999-2002 Julia Smith. All rights reserved.
  <br>Email: jsmith@acme.com</p>
jsmith@acme.com
fred@acme.com  
可以看到例子中使用的两个同名变量并没有冲突，因为它们位于不同的名字空间
         可以使用assign指令在导入的名字空间中创建或替代变量，下面是一个例子：
<#import "/lib/my_test.ftl" as my>
${my.mail}
<#assign mail="jsmith@other.com" in my>
${my.mail}  
         输出结果：
jsmith@acme.com
jsmith@other.com  
         数据模型中的变量任何地方都可见，也包括不同的名字空间，下面是修改的库：
<#macro copyright date>
  <p>Copyright (C) ${date} ${user}. All rights reserved.</p>
</#macro>
<#assign mail = "${user}@acme.com">   
         假设数据模型中的user变量的值是Fred，则下面的代码：
<#import "/lib/my_test.ftl" as my>
<@my.copyright date="1999-2002"/>
${my.mail}   
         输出结果：
  <p>Copyright (C) 1999-2002 Fred. All rights reserved.</p>
Fred@acme.com   

 
Freemarker - 几个比较实用的例子 - -
                                      用Freemarker做模本语言有一段时间了，列出几个和JSP或者Velocity相比起来比较方便的用途，目的是引诱更多的人跳上Freemarker这个贼船， 

1. String内置的JavaScript转换： js_string 
用途：用于JavaScript转义，转换',",换行等特殊字符 
模板: 

<script> 
alert("${errorMessage?js_string}"); 
</script> 


输出: 

<script> 
alert("Readonly\'s pet name is \"Cross Bone\""); 
</script> 


2.内置的默认值处理：default 
用途: 用于处理默认值 
模本: 

User: ${userLogin.name?default("Anonymous")} 

<td>${(employee.department.manager.name)?default(" ")}</td> 


输出: 

User: Anonymous 
<td> </td> 


注，可以对整个对象树加上()，再用内置处理器这种方便的做法，偶也是最近刚学会的，以前一直用很傻的方法做..... 

3. Sequence内置的计数器: xxx_index 
用途：显示序号 
模板: 

<#list employees as e> 
${e_index}. ${e.name} 
</#list> 


输出: 

1. Readonly 
2. Robbin 


4. Sequence内置的分段器: chunk 
用途：某些比较BT的排版需求 
模板: 

<#assign seq = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']> 
<#list seq?chunk(4) as row> 
<ul> 
<li><#list row as cell>${cell} </#list></li> 
</ul> 
</#list> 

<#list seq?chunk(4, '-') as row> 
<tr> 
<td><#list row as cell>${cell} </#list></td> 
</tr> 
</#list> 


输出: 

<ul> 
<li>a</li> 
<li>b</li> 
<li>c</li> 
<li>d</li> 
</ul> 
<ul> 
<li>e</li> 
<li>f</li> 
<li>g</li> 
<li>h</li> 
</ul> 
<ul> 
<li>i</li> 
<li>j</li> 
</ul> 

<tr> 
<td>a</td> 
<td>b</td> 
<td>c</td> 
<td>d</td> 
</tr> 
<tr> 
<td>e</td> 
<td>f</td> 
<td>g</td> 
<td>h</td> 
</tr> 
<tr> 
<td>i</td> 
<td>j</td> 
<td>-</td> 
<td>-</td> 
</tr>

提示：本大全每半月更新一次，请持续保持关注！谢谢！	索取网址：www.itcast.cn
从享受生活的角度上来说：“程序员并不是一种最好的职业，我认为两种人可以做程序员，第一，你不做程序员，你就没有什么工作可做，或者说是即使有可以做的工作但是你非常不愿意去做；第二，你非常痴迷和爱好程序，并且在这方面有一些天赋和优势。程序员的结局也是有两种：第一，默默退休，第二以程序员为起点或跳板，注意积累，跟对了好的老板或团队，找到和很好的搭档自己创业，成为IT金领和富翁。”
人们在时间面前是平等的，吾生也有涯，所以，你的经验更丰富点，那不算什么，经验是用时间积累的，你一生只有那么多时间，你能积累多少经验呢？最重要的是你的学习能力和学习方法，这个发挥的能量可以有很大差异，要提高学习能力和学习方法首先要学会思考和总结，要学会掌握事物的根本性的东西，而不是一些表面的细节。学习方法和学习能力对于IT工作者来说尤为重要，因为IT行业技术更新太快，并且细节太多，同一个技术的细节变来变去也是常有的事情，所以，IT技术学习者绝不能照着书籍和老师的讲解死记硬背和生搬硬套。搞IT工作很累人，如果学习方法不对、学习能力不强，那就更累了，不过，这怨不得别人，你的学习方法和学习能力只适合做刷盘子的工作，却非要跑到程序员圈子里来混，那谁能有办法拯救你！
在没有人指引的情况下，只能是自己一个知识点、一个知识点地漫无目的学习，等到积累了足够的知识量后，才有能力开始思考和琢磨原理方面的问题，这个学习过程很漫长。如果能在好老师的指引下，老师会启发你先思考原理问题，然后再去学习一个具体的知识点，让你能够举一反三、触类旁通，这样的学习效率就会更高。
多学了几个知识，并不能说明你就很厉害了，只能说是你比别人投入了更多的时间和精力而已，别人想做也能做到！不是你学了多少知识就算厉害了，关键是要用好学到的知识，要让学到的知识发挥出最大的社会价值和经济价值，这才是最厉害的。
另外，一个人的未来和造化，会深受环境的影响，所谓孟母三迁，近朱者赤、近墨者黑的大大道理，这些典故大家不一定能深刻领悟和感受，我们就不多说了。就拿现代比较接近我们生活的事例来说，如果你周围的朋友全是以擦皮鞋为生、每月辛辛苦苦下来就挣1500元，那么估计你的职业也是跟着擦皮鞋了，即使你再聪明和再勤奋，顶多每月比你那帮朋友多挣300元，合下来也就区区1800元/月。前几年只要抓住了大势，没钱全部找银行贷款了在北京买房、到山西开煤矿，是头猪也能每年大把大把地捞钱，如果你周围的朋友全是投机倒把的买房和开煤矿者，你的职业自然也是与他们干同样的事情，即使你再差，每年也能挣到百来万不成问题，这就是环境的重要性。聪明的你因为没有机会置身于炒房团中，比那些有机会接触炒房者的猪挣得就要少、就要累。到传智播客的环境中来，你就很有机会拿到高薪了，你可以不参加传智播客的培训，但只要想办法与传智播客的学员们住在一起，成功的机会就大多了。

自从我们开设3G的课程后，许多学员都找到了月薪在7k或更高的3g开发工作，这是他们的能力还完全不能与之相称的一份好工作，这些学员眼看到嘴的肥肉又舍不得放弃，最后就害苦我们这些老师了，学员纷纷把他们面试和工作中的要解决的问题带回来让我们老师帮助做，有些问题虽然老师能做，但也是要花费很大的时间和精力才能做的，这相当于学员把自己的工作交给我们老师替他去干了，可不是一句话两句话就解决的问题。哀哉！我们老师自己还有很繁重的备课和教学任务，我们的工作请谁来帮助做呢？同学们似乎没有替我们想过这个问题。
一个两个学员偶尔回来这么干还可以，但架不住一批批的学员都来这么干，加上有的学生还不太会说话，让人很无奈：
“很简单的，顶多占用你一个小时就搞定了！”，这么简单，你为何自己不干啊？
“今天晚上你必须做出来，明天就要交上去了”，哎，我再熬夜命都要丢了，老婆就要来砸电脑了，你叫我怎么办啊？
“你没时间干，那你吩咐其他老师干，也可以啊！”，当老师都是我的奴隶，我随时随地叫他们干啥，他们就干啥吗？老师能把教学做好，就很给我面子了。
现在这些公司怎么都越来越狡猾了，他们把日后工作中要解决的问题、并且是他们自己都很难解决的问题拿出来让面试求职者去搞，不管面试求职者的水平怎样，他们都说谁能搞定，谁就来上班，我们学生很高兴，不管自己水平是否适合做这份工作，反正有传智播客的老师可以依靠，拿回来就让我们做，还说“做好了就有高薪工作，这关于我一辈子的幸福，老师你自己看这个忙帮不帮吧？”，软件公司这招够狠！我们这批老师成了这些公司免费使用的超级劳工。如果奥巴马说你能把伊拉克摆平，我就让你当伊拉克总统，这个奥巴马都摆不平的事情，但因为做完了就可以当伊拉克总统，我们学生也可能拿回来让我们帮助做，让我们帮他摆平伊拉克，这对我们来说也是很难很难的事情啊。
1. 学习方向与面试简历的相关问题
1.如何过简历关？
我先讲解几个软件求职相关的真实故事，以帮助大家了解大多数软件开发企业是如何赛选简历和录用新员工的。
1.传智播客学员A是大四在读的应届毕业生，他自信技术学得很不错，实质上确实也达到用人单位的标准，他不愿意编写两年工作经验的虚假简历，希望凭借自己的真实情况去面对求职，投递了很多份简历，都没有回应；而他周围的很多相似背景的学员因为使用了假简历，都很快找到了薪水4.5k/月左右的工作，最后万不得已，他修改了自己的简历，增加了一些水分，以两年工作经验的身份去投递简历，结果就很快找到了满意的工作。
2.一个穿着和气质给人的印象都很不错的女生咨询时，问：“如果在传智播客学完了，能找到工作吗？”，我问了她一些基本情况后，得知她是郑州航空工业管理学院本科毕业，并且毕业时间已经有两年，谈话中感觉很有工作经验，英语也不错，所以，我斩钉截铁地告诉她：“她学完后绝对能找到一份满意的工作”，并说出了一些原因：（1）她本身的谈吐气质就决定了她找工作没问题，应聘工作除了要求有那些必需的技能外，关键一点还要看这个人的性格和素养，按她的条件，如果她要找软件开发方面的工作，只需要把技术补上就可以了，这一点在传智播客学习是很容易补上的；（2）要想找到好工作，除了掌握必需的技术外，通常都需要编写两年工作经验的简历，她的毕业是证确实两年前的，编造两年软件开发的工作经验更容易，至少不用专门去做假的毕业证了。她听完后，很赞同我的观念，说她现在就在一家软件公司做人力资源，负责挑选应聘者的简历，按领导的吩咐：“凡是工作经验低于两年的简历直接删除到垃圾桶”，可见，如果你的简历首先到达了类似这个女生的人力资源之手，即使你的技术再厉害，如果你的工作经验一栏上写得低于了两年，那简历就永无露脸之日了，何谈后来的笔试和面试呢？ 
3.与传智播客同一楼的一个软件开发单位，因为项目经理读过传智播客老师们的书籍和看过传智播客的视频，所以他们公司想到了从传智播客学员中招聘开发人员，提出薪水在2800元左后，我们公司老师对他们谁，2800元薪水，我们学员肯定看不上！他们公司说对于没有实际经验的新手开出2800元的薪水已经很不错了，我们老师说，传智播客学员通过简历包装都能找到平均4500元的工资，楼下公司说假简历他们一聊就能聊出来，没工作经验的人是骗不住他们的，我们的老师当时就无语了，…，因为就在前几天，我们就有一个学员成功潜伏进了他们公司，并且工资就是4500元，但我们老师不能当他们的面来说这事，就让他们一直蒙在鼓里还很自信吧！我用一个大饼的故事来说明这个问题吧，假如市场上卖的大饼都是10元一个，我也做了一个这样的大饼，比同类大饼还要好吃一点，我也买10元一个，你肯定愿意买，但是，一旦我告诉你，我这个大饼的原材料才5毛钱，你心里还会平衡吗？只会骂我太黑，5毛钱的成本居然卖出10元的暴利，你不会买我的大饼，因为这超出了你的心理承受，只要我不告诉你这么个实际情况，你则能欣然接受。也就是说，给你讲实话，你心里会难受，给你说假话，你心里则舒坦，相比市场上的同类产品，我这假话也算不上欺骗，毕竟你花10元买人家的大饼，还不如买我这个大饼好吃！
4.前面谈到简历上的工作经验很重要，可是大多数要找工作的同学往往是没有工作经验的，所以，只能在简历上加点水分。但是，只要你将简历上写成了两年以上的工作经验，是不是一定就能得到笔试和面试的机会呢？写两年工作经验只是有效简历的开始，离简历被用人单位相中还有一段差距。一个好的毕业学校、优秀的英语水平、中共党员的政治面貌、某省或直辖市的优秀毕业生、奥林匹克竞赛获几等奖等荣耀都会给用人单位一个很好的印象，如果你有这些荣耀，一定要在简历的基本信息部分写清楚。但是，很多人是没有这些荣耀的，那么只能平平淡淡列出自己的一些基本信息，这也没有很大的关系，顶多就是自己的简历不能脱颖而出，但是，对于软件工程师岗位来说，学历一栏怎么着也不能写为高中，起码也要写个大专或以上，毕业院校编个二线城市的不知名的小学院，如果你不愿意去做假证，等到别人面试你时，再说“闲弃以前上的学校不好，因为对编程太感兴趣，就辍学了！”

2.为什么说不需要做出完整的项目吗？
1.众所周知，在实际的软件项目中，都是很多人一块共同做一个项目，每个人只是做项目中的一部分内容，甚至是只做了项目中的一个模块，项目越大，越是如此！随便拿出一个中等大小的项目，也需要好多个熟练的开发人员开发好多个月才能勉强做得差不多，培训期间没有这么多时间，并且你还要先学会了很多技术后才能开始做项目。
 2.一个项目中的很多东西都是重复性的工作量的累积，技术方面都大同小异。做一个项目就好比盖一座楼房，只要告诉你整个楼房的整体结构，然后带着你盖上一间两间房子，其他剩下的几百间房子，老师想继续盖给你看，或者让你自己盖剩下的房间，你肯定也不愿意吧。以后有的是练手的机会，拿着人家发给你的工资，你再去做这些重复性的工作也不迟，岂不是更好！

3.业务重要？还是编码实战更重要？
1.对软件企业来说，两者都很重要，有的项目是业务为重心，有的则是以技术作为核心；以业务为重心的项目大都是企业信息化建设方面的项目，与做鞋差不多，没有多大技术含量和壁垒，只有积累了一定的经验，谁都可以做，利润很薄，例如大多数管理系统，靠的是人海战术和时间纠缠，做这种项目的程序员工作都很辛苦，经常要加班加点。而以技术为核心的项目则很有技术壁垒，不是谁都能做的，利润率很高，例如，360杀毒软件、baidu，qq，迅雷下载，大型bbs项目和淘宝这样的电子商务网站。
  2.对程序员来说，编码实战更重要，业务则不算什么！程序员和软件公司的工作就是要把用户的需求和业务变成代码，即为人作嫁，一开始，需求和业务都在用户那里，用户最懂业务，你不用了解业务，你的任务就是了解用户的业务后编写代码，在开始做项目前，用户会把业务告诉给你的。一个软件公司从来都不是只做自己熟悉业务的项目，而是来了业务不熟悉的项目机会，肯定也会冲上去做，软件公司通常都是在做自己以前没做过的项目，即做以前不了解业务的项目，只有项目做完了才完全熟悉了业务，这才叫做项目，否则就成了卖产品了，所以，软件工程里说的需求调研和理解业务的过程，也是在从侧面说明，程序员是在接到项目之后才开始了解其业务的，而在此之前，对业务可以是完全不懂的。

4.是培训内容和信息量大好？还是培训内容少而精的好？
答：虽然这两种方式都能让学有所获和找到工作，并且，前者对于老师和学生要求都很高，老师教得很辛苦，学生学得也很辛苦，学生甚至会产生畏惧心理，即使水平已经很高，可能还是没有信心；后者对于老师和学生的要求都不高，老师教得轻松，学生学得愉快，学生很容易产生自信，成了井底之蛙，还自以为不得了。但是，内容和信息量大培训课程体系，对大多人来说是更收益的，因为，程序员做的工作总是在变化的，没有一成不变的工作，为了适应这种变化，你的知识面必须很广泛。如果你学的知识内容很少，即使你把这些内容练的滚瓜烂熟了，除非你出去找的一份工作正好就是你以前练习的那些东西，这时候会让人感觉你比谁都厉害，但这种千载难逢的好事怎么就被你碰上了呢？软件开发毕竟不同于刷盘子，不是在重复干一件事情。软件开发的工作总是要面临不同的需求和问题，如果培训课程的内容和信息量很大，即使由于时间关系，你暂时没有完全消化和熟练这么多内容，但是，你在工作中不管遇到什么新问题，都有那么一点点印象，知道大概的解决办法和思路，你就可以慢慢地通过查阅资料和最终解决这个问题，软件开发的工作本来就是这么一种现状，如果你学的知识量很少，一旦遇到了新问题，你完全就没有了思路，完全无从下手，这是何等痛苦，只有灰溜溜走人的份了吧。总之，知识面越宽广，了解的信息越多，解决问题的能力就越强，好比以前治疗哮喘没有很好的办法，即使是一个哮喘病专家医生，也需要让病人吃上半年的药，还不能完全治愈，现在，如果有了一种新药，病人只需要吃上一周，就能彻底治愈，所谓好的哮喘病专家医生，他要做的工作就是迅速知道有这么一种新药问世了，否则，他就成名符其实的庸医了。建筑大师可能自己连一个厕所都盖不出来，但是他能指导别人去干，建筑大师一定要阅历广泛，他经历过的项目很多，但每个项目的很多细节不是他亲力亲为。如果砌砖都是他亲力亲为，那他一辈子可能都是干砌砖工作了。
别的培训机构培养的是技术单一的熟练技工，传智播客培养的是具有很强学习和解决问题能力的技术高手和未来技术经理。很多工厂说，清华毕业的学生刚进工厂时的动手操作不如技校毕业的学生熟练，但过一段时间后，清华学生则能解决工厂生成过程出现中的各种新问题和弊端，甚至能提出创新和发明，后劲十足，因为清华培养的就不是一个单一工种的熟练工人，而是知识全面和具有创新能力的高级工程师。别的机构和传智播客培养出来的学生差别好比如此。

5. IT行业中也会出现蚁族和民工吗？
先看看IT蚁族和IT民工的悲惨命运吧！
http://news.csdn.net/a/20100316/217473.html
http://topic.csdn.net/u/20100317/16/2dba32e3-90f4-40b5-b1fd-0bf3709297c6.html?97395
搜素 程序员的悲哀，还有更多辛酸的故事，但是，我并不同情他们，我只是说他们自己无能！程序员这个职业能创造出许多年轻的富翁，不靠父母不靠天，还有那个职业比IT行业更有机会和诱惑呢。不过，程序员毁坏身体是真，可是，不让你做程序员，你去打游戏，聊QQ不也照样坏身体吗？
SSH（struts,spring,hibernate）是当前做管理信息系统最基本和最流行的通用技术，这几个技术都出现7,8年了，应该很普及了，确实没什么新意。现在培训机构教的都是这些玩意，用来混饭吃，还是管点用的。每个做增删改查的人基本都会SSH，所以，SSH没什么了不起的，SSH这套东西对培训公司和个人发展来说，都不能成为核心竞争力，都难以成大气候。一些公司内部所谓的核心技术，就是那些非SSH的知识，传智播客教的不只是大家都会的SSH。有点档次的项目，确实不怎么用SSH，但是大多数OA类的项目都是增删改查，虽然没有技术含量，但是用工需求量大，这也就是能诞生出IT蚁族和IT民工的由来。
但是，java不只是有SSH这套技术，如果你不想成为IT蚁族，如果你不想厌烦软件开发，那就不能只学SSH，这个没有太多技术含量的单一熟练工种。

2. 笔试答题技巧与若干问题
说明，为了节省大家的时间和提高学习效率，一些过时知识点和被笔试概率极低的题目不再被收录和分析。
回答问题的思路：先正面叙述一些基本的核心知识，然后描述一些特殊的东西，最后再来一些锦上添花的东西。要注意有些不是锦上添花，而是画蛇添足的东西，不要随便写上。把答题像写书一样写。我要回答一个新技术的问题大概思路和步骤是：我们想干什么，怎么干，干的过程中遇到了什么问题，现在用什么方式来解决。其实我们讲课也是这样一个思路。
例如，讲ajax时，我们希望不改变原来的整个网页，而只是改变网页中的局部内容，例如，用户名校验，级联下拉列表，下拉树状菜单。用传统方式，就是浏览器自己直接向服务器发请求，服务器返回新页面会盖掉老页面，这样就不流畅了。
对本面试宝典中的题目有信心吗？本来有信心的，结果听你讲完后，就没信心了！我非常理解。因为他觉得我的太深，他想记住我的些东西，可是记不住，所以没信心了。我又问：听懂了吗？他说听懂了。你到现在只要把你的理解尽量清晰地、有条理地表达出来，就很棒了。

这套面试题主要目的是帮助那些还没有java软件开发实际工作经验，而正在努力寻找java软件开发工作的朋友在笔试时更好地赢得笔试和面试。由于这套面试题涉及的范围很泛，很广，很杂，大家不可能一天两天就看完和学完这套面试宝典，即使你已经学过了有关的技术，那么至少也需要一个月的时间才能消化和掌握这套面试宝典，所以，大家应该早作准备，从拿到这套面试宝典之日起，就要坚持在每天闲暇之余学习其中几道题目，日积月累，等到出去面试时，一切都水到渠成，面试时就自然会游刃有余了。

答题时，先答是什么，再答有什么作用和要注意什么（这部分最重要，展现自己的心得）

答案的段落分别，层次分明，条理清晰都非常重要，从这些表面的东西也可以看出一个人的习惯、办事风格、条理等。
要讲你做出答案的思路过程，或者说你记住答案的思想都写下来。把答题想着是辩论赛。答题就是给别人讲道理、摆事实。答题不局限于什么格式和形式，就是要将自己的学识展现出来！
别因为人家题目本来就模棱两可，你就心里胆怯和没底气了，不敢回答了。你要大胆地指出对方题目很模糊和你的观点，不要把面试官想得有多高，其实他和你就是差不多的，你想想，如果他把你招进去了，你们以后就是同事了，可不是差不多的吗？
关于就业薪水，如果你是应届生，那不能要高工资，好比大饼的故事，没有文凭还想拿高工资，就去中关村缺什么补什么吧！少数人基础确实很好，在校期间确实又做过一些项目，那仍然是可以要到相对高的工资的。

公司招聘程序员更看重的要用到的编码技术、而不是那些业务不太相关的所谓项目经历：
1.公司想招什么样的人2.公司面试会问什么,.3.简历怎么写4怎样达到简历上的标准（培训中心教项目的目的）

对于一些公司接到了一些项目，想招聘一些初中级的程序员过来帮助写代码，完成这个项目，你更看重的是他的专业技术功底，还是以前做过几个项目的经历呢？我们先排除掉那些编码技术功底好，又正好做过相似项目的情况，实际上，这种鱼和熊掌兼得的情况并不常见。其实公司很清楚，只要招聘进来的人技术真的很明白，那他什么项目都可以做出来，公司招人不是让你去重复做你以前的项目，而是做一个新项目，业务方面，你只要进了项目团队，自然就能掌握。所以，大多数招聘单位在招聘那些编码级别的程序员时也没指望能招聘到做过类似项目的人，也不会刻意去找做过类似项目的人，用人单位也不是想把你招进，然后把你以前做过的项目重做一遍，所以，用人单位更看重招进来的人对要用到的编码技术的功底到底怎样，技术扎实不扎实，项目则只要跟着开发团队走，自然就没问题。除非是一些非常专业的行业，要招聘特别高级的开发人员和系统分析师，招聘单位才特别注重他的项目经验和行业经验，要去找到行业高手，公司才关心项目和与你聊项目的细节，这样的人通常都不是通过常规招聘渠道去招聘进来的，而是通过各种手段挖过来的，这情况不再我今天要讨论的范围中。
技术学得明白不明白，人家几个问题就把你的深浅问出来了，只要问一些具体的技术点，就很容易看出你是真懂还是假懂，很容看出你的技术深度和实力，所以，技术是来不得半点虚假的，必须扎扎实实。
由于项目的种类繁多，涉及到现实生活中的各行各业，什么五花八门的业务都有，例如，酒店房间预定管理，公司车辆调度管理，学校课程教室管理，超市进销存管理，知识内容管理，等等……成千上万等等，但是，不管是什么项目，采用的无非都是我们学习的那些目前流行和常用的技术。技术好、经验丰富，则项目做出来的效率高些，程序更稳定和更容易维护些；技术差点，碰碰磕磕最后也能把项目做出来，无非是做的周期长点、返工的次数多点，程序代码写得差些，用的技术笨拙点。如果一个人不是完完全全做过某个项目，他是不太关心该项目的业务的，对其中的一些具体细节更是一窍不知，(如果我招你来做图书管理，你项目经历说你做过汽车调度，那我能问你汽车调度具体怎么回事吗？不会，所以，你很容易蒙混过去的)而一个程序员的整个职业生涯中能实实在在和完完整整做出来的项目没几个，更别说在多个不同行业的项目了，有的程序员更是一辈子都只是在做某一个行业的项目，结果他就成了这个行业的专家(专门干一件事的家伙)。所以，技术面试官通常没正好亲身经历过你简历写的那些项目，他不可能去问你写的那些项目的具体细节，而是只能泛泛地问你这个项目是多少人做的，做了多长时间，开发的过程，你在做项目的过程中有什么心得和收获，用的什么技术等面上的问题，所以，简历上的项目经历可以含有很多水分，很容易作假，技术面试官也无法在项目上甄别你的真伪。
简历该怎么写：精通那些技术，有一些什么项目经历
教项目是为了巩固和灵活整合运用技术，增强学习的趣味性，熟悉做项目的流程，或得一些专业课程中无法获得的特有项目经验，增强自己面试的信心。讲的项目应该真实可靠才有价值，否则，表面上是项目，实际上还是知识点的整合，对巩固技术点和增强学习的趣味性，但无法获得实际的项目经验。（项目主要是增加你经验的可信度，获得更多面试机会，真正能不能找到工作，找到好工作，主要看你键盘上的功夫了），好的面试官几下就能面出你是否真有工作经验，他们问技术以外的公司的人和事，并且问开始、过程、结果，看你怎么编。
建议大家尽量开自己的blog，坚持每天写技术blog。在简历上写上自己的blog地址，可以多转载一些技术文章。
3. 笔试题之Java基础部分
基础部分的顺序：基本语法，类相关的语法，内部类的语法，继承相关的语法，异常的语法，线程的语法，集合的语法，io 的语法，虚拟机方面的语法，其他。有些题来自网上搜集整理，有些题来自传智播客学员面试后的反馈，说真的，少数一些网上的面试题，我真怀疑其是否还有存在价值！
1、一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？ 
可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。
2、Java有没有goto? 
java中的保留字，现在没有在java中使用。

3、说说&和&&的区别。 
&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。
&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。If(x==33 & ++y>0) y会增长，If(x==33 && ++y>0)不会增长
&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。 

备注：这道题先说两者的共同点，再说出&&和&的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。 

4、在JAVA中如何跳出当前的多重嵌套循环？ 
在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如，
ok:
	for(int i=0;i<10;i++)
	{
		for(int j=0;j<10;j++)
		{
			System.out.println(“i=” + i + “,j=” + j);
			if(j == 5) break ok;
		}
	} 
另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。
int arr[][] = {{1,2,3},{4,5,6,7},{9}};
boolean found = false;
for(int i=0;i<arr.length && !found;i++)
	{
		for(int j=0;j<arr[i].length;j++)
		{
			System.out.println(“i=” + i + “,j=” + j);
			if(arr[i][j]  == 5) 
			{
				found = true;
				break;
			}
		}
	} 
 

5、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 
在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 
6、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 
对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。
对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 
7、char型变量中能不能存贮一个中文汉字?为什么? 
char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。
备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。 
8、用最有效率的方法算出2乘以8等於几? 
2 << 3，
因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 << 3。
9、请设计一个一百亿的计算器
首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的面向对象的设计思想。
首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一定的范围的，为了便于讲解和理解，我们先以byte 类型的整数为例，它用1个字节进行存储，表示的最大数值范围为-128到+127。-1在内存中对应的二进制数据为11111111，如果两个-1相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,11111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。-128在内存中对应的二进制数据为10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,00000000，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为00000000，也就是0，这样的结果显然不是我们期望的，这说明计算机中的算术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。由于Java中涉及表达式运算时的类型自动提升，我们无法用byte类型来做演示这种问题和现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下：
		int a = Integer.MAX_VALUE;
		int b = Integer.MAX_VALUE;
		int sum = a + b;
		System.out.println(“a=”+a+”,b=”+b+”,sum=”+sum);

先不考虑long类型，由于int的正数范围为2的31次方，表示的最大数值约等于2*1000*1000*1000，也就是20亿的大小，所以，要实现一个一百亿的计算器，我们得自己设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大概功能如下：
（）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数
（）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中
（）提供加减乘除的功能
public class BigInteger
{
		int sign;
		byte[] val;
		public Biginteger(String val)
		{
			sign = ;
			val = ;
		}
		public BigInteger add(BigInteger other)
		{
			
		}
		public BigInteger subtract(BigInteger other)
		{
			
		}
		public BigInteger multiply(BigInteger other)
		{
			
		}
		public BigInteger divide(BigInteger other)
		{
			
		}

}
备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看jdk中自带的java.math.BigInteger类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一千元。 

10、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 
使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：
 final StringBuffer a=new StringBuffer("immutable");
执行如下语句将报告编译期错误：
a=new StringBuffer("");
但是，执行如下语句则可以通过编译：
a.append(" broken!"); 

有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：
	public void method(final  StringBuffer  param)
	{
	} 
实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：
		param.append("a");
11、"=="和equals方法究竟有什么区别？
（单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚）
==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。
如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。
equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：
String a=new String("foo");
String b=new String("foo");
两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。
在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。
如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：
boolean equals(Object o){
return this==o;
}
这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。
12、静态变量和实例变量的区别？ 
在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。
在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。
public class VariantTest
{
		public static int staticVar = 0; 
		public int instanceVar = 0; 
		public VariantTest()
		{
			staticVar++;
			instanceVar++;
			System.out.println(“staticVar=” + staticVar + ”,instanceVar=” + instanceVar);
		}
}
备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！
13、是否可以从一个static方法内部发出对非static方法的调用？ 
不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。
14、Integer与int的区别
int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。
在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。
另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。

15、Math.round(11.5)等於多少? Math.round(-11.5)等於多少?
Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，所以，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，所以，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。

15、下面的代码有什么不妥之处?
1. if(username.equals(“zxx”){}
	2.	int  x = 1;
		return x==1?true:false;

1、请说出作用域public，private，protected，以及不写时的区别
这四个作用域的可见范围如下表所示。
说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。

作用域    当前类 同一package 子孙类 其他package 
public    √     √          √       √ 
protected  √     √          √      × 
friendly   √     √          ×      × 
private    √     ×          ×      × 

备注：只要记住了有4种访问权限，4个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。
2、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? 
Overload是重载的意思，Override是覆盖的意思，也就是重写。
重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。
重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。
至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 

override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：
1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；
3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。
overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：
1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；
2、不能通过访问权限、返回类型、抛出的异常进行重载；
3、方法的异常类型和数目不会对重载造成影响；
4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。

3、4月21号班同学贡献的一些题? 
朱wenchao，女：3500，21岁
搞了多个重载方法，参数分别是int ,char,和double，然后将double x = 2，传递进去，会选择哪个方法？
说说对javaee中的session的理解，你是怎么用session的？ 


陈yong, 4000
一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？
如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关联。椅子与腿和背时组合关系。
说说has a与is a的区别。
答：is-a表示的是属于得关系。比如兔子属于一种动物（继承关系）。
	has-a表示组合，包含关系。比如兔子包含有腿，头等组件；
工厂模式的类图
4．5月15号班同学贡献的一些题？
1. 线程如何同步和通讯。 同学回答说synchronized方法或代码块！面试官似乎不太满意！
 只有多个synchronized代码块使用的是同一个监视器对象，这些synchronized代码块之间才具有线程互斥的效果，假如a代码块用obj1作为监视器对象，假如b代码块用obj2作为监视器对象，那么，两个并发的线程可以同时分别进入这两个代码块中。 …这里还可以分析一下同步的原理。
   对于同步方法的分析，所用的同步监视器对象是this
   接着对于静态同步方法的分析，所用的同步监视器对象是该类的Class对象
	接着对如何实现代码块与方法的同步进行分析。
2.ClassLoader如何加载class 。
    jvm里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap类加载负责加载jre/lib/rt.jar中的类， 我们平时用的jdk中的类都位于rt.jar中。extclassloader负责加载jar/lib/ext/*.jar中的类，appclassloader负责classpath指定的目录或jar中的类。除了bootstrap之外，其他的类加载器本身也都是java类，它们的父类是ClassLoader。
3.Servlet的生命周期
4.抽象类的作用
5.ArrayList如何实现插入的数据按自定义的方式有序存放
class MyBean implements Comparable{
	public int compareTo(Object obj){
		if(! obj instanceof MyBean)
			throw new ClassCastException() //具体异常的名称，我要查jdk文档。
			
		MyBean other = (MyBean) obj;
		return age > other.age?1:age== other.age?0:-1;
	}
}


class MyTreeSet {

	private ArrayList  datas = new ArrayList();
	
	public void add(Object obj){
		for(int i=0;i<datas.size();i++){
			if(obj.compareTo(datas.get(i) != 1){
				datas.add(i,obj);
			}
		}
	}
}

6.分层设计的好处；把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合，举例说明：如果要注册一个用户，流程为显示界面并通过界面接收用户的输入，接着进行业务逻辑处理，在处理业务逻辑又访问数据库，如果我们将这些步骤全部按流水帐的方式放在一个方法中编写，这也是可以的，但这其中的坏处就是，当界面要修改时，由于代码全在一个方法内，可能会碰坏业务逻辑和数据库访问的码，同样，当修改业务逻辑或数据库访问的代码时，也会碰坏其他部分的代码。分层就是要把界面部分、业务逻辑部分、数据库访问部分的代码放在各自独立的方法或类中编写，这样就不会出现牵一发而动全身的问题了。这样分层后，还可以方便切换各层，譬如原来的界面是Swing，现在要改成BS界面，如果最初是按分层设计的，这时候不需要涉及业务和数据访问的代码，只需编写一条web界面就可以了。
   下面的仅供参考，不建议照搬照套，一定要改成自己的语言，发现内心的感受：
  分层的好处：
		1，实现了软件之间的解耦；
		2.便于进行分工
		3.便于维护
		4，提高软件组件的重用
		5.便于替换某种产品，比如持久层用的是hibernate,需要更换产品用toplink，就不用该其他业务代码，直接把配置一改。
		6.便于产品功能的扩展。
		7。便于适用用户需求的不断变化

7.序列化接口的id有什么用？
   对象经常要通过IO进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person->“zxx,male,28,30000”Person，既然大家都要这么干，并且没有个统一的干法，于是，sun公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被sun的这种方案处理，必须实现Serializable接口。
   ObjectOutputStream.writeObject(obj);
   Object obj = ObjectInputStream.readObject();
   假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun的jdk就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错!

9.hashCode方法的作用？说	
    （网友提供的一段，待改进：hashcode这个方法是用来鉴定2个对象是否相等的。
那你会说，不是还有equals这个方法吗？
不错，这2个方法都是用来判断2个对象是否相等的。但是他们是有区别的。
一般来讲，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等了。简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。举个例子，有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这2个对象是相等的。
hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode这个方法，而且也用到了equals方法。这里不可以重复是说equals和hashcode只要有一个不等就可以了！所以简单来讲，hashcode相当于是一个对象的编码，就好像文件中的md5，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算2个对象相等的话，那么hashcode的方法也要返回姓名的hashcode值加上性别的hashcode值，这样从逻辑上，他们就一致了。
要从物理上判断2个对象是否相等，用==就可以了。
）
10.webservice问得很多
11.设计出计算任意正整数的阶层。

4.在oracle数据库中需要查询出前8条记录的sql语句怎么写？


5.什么是SOA，谈谈你的SOA的理解。service orientied architecture
6.如何实现线程间的通讯。

新题目：编程:1.编写一个函数将一个十六进制数的字符串参数转换成整数返回。
	String str = “13abf”;
	int len = str.length;
	int sum = 0;
	for(int i=0;i<len;i++){
		char c = str.charAt(len-1-i);
		int n = Character.digit(c,16);
		sum += n * (1<<(4*i));	
	}
      
     其实，也可以用Integer.parseInt(str,16)，但面试官很可能是想考我们的编码基本功。

编程2
   :银行贷款的还款方式中最常用的是一种叫“等额本息”，还款法，即借款人在约定还款期限内的每一期（月）归还的金额（产生的利息+部分本金）都是相等的，现有一笔总额为T元的N年期住房贷款，年利率为R，要求算出每一期的还款的本金和利息总额，请写出解决思路和任意一种编程语言实现的主要代码。
	思路：既然是按月还款，那我就要将N年按月来计算，即要还N*12个月，这样就可以求出每月要还的本金。由于每月要还的那部分本金所欠的时间不同，所以，它们所产生的利息是不同的，该部分本金的利息为：部分本金额*所欠月数*月利率。应该是这么个算法，如果利息还计利息，如果月还款不按年利率来算，老百姓算不明白的。
	int monthMoney = T/N/12;
	float monthRate = R/12;
	int totalMonth = N * 12;
	float totalRate = 0;
	for(int i=1;i<=totalMonth;i++){
		totalRate += monthMoney * monthRate * i;
	}
	int result = monthMoney + totalRate/N/12;

几道题：
1. ****Spring的DI是什么（学员注：除了IOC，AOP这些概念，还不太清楚DI的概念）
2. *任意数字序列“123456”之类，输出它们所有的排列组合
3. *****什么是AOP（学员注：会用，但感觉说不清楚）
我注：由上面这些题，可以看出，思想很重要，只有琢磨思想和原理的人才能很好地回答这些问题！
	2题的答案：
	String str = “xafdvs”;
	char[] arr1 = str.toCharArray();
	char[] arr2 = Arrays.copyOf(arr1,arr1.length);
	for(int i=0;i<arr1.length-1;i++)
	{
		for(int j = i+1;j<arr2.length;j++){
			syso: arr1[i] + “,” + arr2[j];
		}
	}
	
	3题的答案：
1.概念介绍：所谓AOP，即Aspect orientied program,就是面向方面的编程，
2.解释什么是方面：贯穿到系统的各个模块中的系统一个功能就是一个方面，
比如，记录日志，统一异常处理，事务处理，全限检查，这些功能都是软件系统
的一个面，而不是一点，在各个模块中都要出现。
3.什么是面向方面编程：把系统的一个方面的功能封装成对象的形式来处理
4.怎么进行面向方面编程：把功能模块对应的对象作为切面嵌入到原来的各个系统模块中，
采用代理技术，代理会调用目标，同时把切面功能的代码（对象）加入进来，所以，
用spring配置代理对象时只要要配两个属性，分别表示目标和切面对象（Advisor）。
3、构造器Constructor是否可被override? 
构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。 
4、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？
接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类中可以有静态的main方法。
备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。
 只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。

5、写clone()方法时，通常都有一行代码，是什么？ 
clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 
6、面向对象的特征有哪些方面
计算机软件系统是现实生活中的业务在计算机中的映射，而现实生活中的业务其实就是一个个对象协作的过程。面向对象编程就是按现实业务一样的方式将程序代码按一个个对象进行组织和编写，让计算机系统能够识别和理解用对象方式组织和编写的程序代码，这样就可以把现实生活中的业务对象映射到计算机系统中。
面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。
1封装：
封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。
例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。

抽象：
抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：
class Person
{
		String name;
		int age;
}
人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。

继承：
在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。

多态：
多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。例如，下面代码中的UserDao是一个接口，它定义引用变量userDao指向的实例对象由daofactory.getDao()在执行的时候返回，有时候指向的是UserJdbcDao这个实现，有时候指向的是UserHibernateDao这个实现，这样，不用修改源代码，就可以改变userDao指向的具体类实现，从而导致userDao.insertUser()方法调用的具体代码也随之改变，即有时候调用的是UserJdbcDao的insertUser方法，有时候调用的是UserHibernateDao的insertUser方法：
UserDao userDao = daofactory.getDao();  
userDao.insertUser(user);

比喻：人吃饭，你看到的是左手，还是右手？
7、java中实现多态的机制是什么？ 
靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 
8、abstract class和interface有什么区别? 	
含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
下面比较一下两者的语法区别：
1.抽象类可以有构造方法，接口中不能有构造方法。
2.抽象类中可以有普通成员变量，接口中没有普通成员变量
3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
5. 抽象类中可以包含静态方法，接口中不能包含静态方法
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类。
	下面接着再说说两者在应用上的区别：
接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：
public abstract class BaseServlet extends HttpServlet
{
		public final void service(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException
		{
			记录访问日志
			进行权限判断
if(具有权限)
{
	try
	{
		doService(request,response);
}
	catch(Excetpion e)
	{
			记录异常信息
	}
}
		} 
		protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException;  
//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的
}

public class MyServlet1 extends BaseServlet
{
protected void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException
		{
			本Servlet只处理的具体业务逻辑代码
		} 

}
父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。
备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。
9、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 
abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！
native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码，可以发现FileOutputStream的open方法的定义如下：
private native void open(String name) throws FileNotFoundException;
如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。
关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。 
10、什么是内部类？Static Nested Class 和 Inner Class的不同。
内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示：
public class Outer
{
		int out_x  = 0;
		public void method()
		{
			Inner1 inner1 = new Inner1();
			public class Inner2   //在方法体内部定义的内部类
			{
				public method()
				{
					out_x = 3;
				}
			}
			Inner2 inner2 = new Inner2();
		}

		public class Inner1   //在方法体外面定义的内部类
		{
		}
		
}
在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：
Outer outer = new Outer();
Outer.Inner1 inner1 = outer.new Innner1();

在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。
对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。

在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：
public class Outer
{
		public void start()
		{
			new Thread(
new Runable(){
					public void run(){};
}
).start();
		}
}

最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：
Outer.Inner inner = new Outer.Inner();
由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。
在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。

备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。
11、内部类可以引用它的包含类的成员吗？有没有什么限制？ 
完全可以。如果不是静态内部类，那没有什么限制！ 
如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：
class Outer
{
	static int x;
	static class Inner
	{
		void test()
		{
			syso(x);
		}
	}
}

答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情况，让人家吃惊。

12、Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? 
可以继承其他类或实现其他接口。不仅是可以，而是必须!
13、super.getClass()方法调用
下面程序的输出结果是多少？
import java.util.Date;
public  class Test extends Date{
	public static void main(String[] args) {
		new Test().test();
	}
	
	public void test(){
		System.out.println(super.getClass().getName());
	}
}

很奇怪，结果是Test
这属于脑筋急转弯的题目，在一个qq群有个网友正好问过这个问题，我觉得挺有趣，就研究了一下，没想到今天还被你面到了，哈哈。
在test方法中，直接调用getClass().getName()方法，返回的是Test类名
由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在
test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。
如果想得到父类的名称，应该用如下代码：
getClass().getSuperClass().getName();

14. jdk中哪些类是不能继承的？
不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中System,String,StringBuffer等都是基本类型。
2、String是最基本的数据类型吗? 
基本数据类型包括byte、int、char、long、float、double、boolean和short。 
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 

111、String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？

没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 "Hello"，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为"Hello world!"，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。
通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。
同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：
public class Demo {
private String s;
...
public Demo {
s = "Initial Value";
}
...
}
而非
s = new String("Initial Value");
后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。
上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。
至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。

41、是否可以继承String类? 
String类是final类故不可以继承。 

27、String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？
两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。
5、String 和StringBuffer的区别
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。

接着要举一个具体的例子来说明，我们要把1到100的所有数字拼起来，组成一个串。
StringBuffer sbf = new StringBuffer();  
for(int i=0;i<100;i++)
{
	sbf.append(i);
}
上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。
String str = new String();  
for(int i=0;i<100;i++)
{
	str = str + i;
}
在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。

String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。

8.StringBuffer与StringBuilder的区别
  StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。

3、如何把一段逗号分割的字符串转换成一个数组?
如果不查jdk api，我很难写出来！我可以说说我的思路：
1.用正则表达式，代码大概为：String [] result = orgStr.split(“,”);
2.用 StingTokenizer ,代码为：StringTokenizer  tokener = StringTokenizer(orgStr,”,”);
String [] result = new String[tokener .countTokens()];
Int i=0;
while(tokener.hasNext(){result[i++]=toker.nextToken();}

38、数组有没有length()这个方法? String有没有length()这个方法？ 
数组没有length()这个方法，有length的属性。String有有length()这个方法。
39、下面这条语句一共创建了多少个对象：String s="a"+"b"+"c"+"d";
答：对于如下代码：
String s1 = "a";
String s2 = s1 + "b";
String s3 = "a" + "b";
System.out.println(s2 == "ab");
System.out.println(s3 == "ab");
第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。
题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，
		String s = "a" + "b" + "c" + "d";
		System.out.println(s == "abcd");
最终打印的结果应该为true。 


43、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后? 
也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果： 
public  class Test {

	/**
	 * @param args add by zxx ,Dec 9, 2008
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(new Test().test());;
	}

	static int test()
	{
		int x = 1;
		try
		{
			return x;
		}
		finally
		{
			++x;
		}
	}
	
}

---------执行结果 ---------
1

运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。
7、下面的程序代码输出的结果是多少？
public class  smallT
{
	public static void  main(String args[])
	{
		smallT t  = new  smallT();
		int  b  =  t.get();
		System.out.println(b);
	}
	
	public int  get()
	{
		try
		{
			return 1 ;
		}
		finally
		{
			return 2 ;
		}
	}
}

返回的结果是2。
我可以通过下面一个例子程序来帮助我解释这个答案，从下面例子的运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。
在讲解答案时可以用下面的程序来帮助分析：
public  class Test {

	/**
	 * @param args add by zxx ,Dec 9, 2008
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(new Test().test());;
	}

	int test()
	{
		try
		{
			return func1();
		}
		finally
		{
			return func2();
		}
	}
	
	int func1()
	{
		System.out.println("func1");
		return 1;
	}
	int func2()
	{
		System.out.println("func2");
		return 2;
	}	
}
-----------执行结果-----------------

func1
func2
2

结论：finally中的代码比return 和break语句后执行

12、final, finally, finalize的区别。 
　　final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……

finally是异常处理语句结构的一部分，表示总是执行。

 
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用

5、运行时异常与一般异常有何异同？ 
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
15、error和exception有什么区别? 
error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 

50、Java中的异常处理机制的简单原理和应用。 
异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。
Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。
java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。

提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误；


33、请写出你最常见到的5个runtime exception。 
这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面的异常，你不一定真要回答出5个具体的系统异常，但你要能够说出什么是系统异常，以及几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，那就用中文吧，有总比没有强！ 
所谓系统异常，就是…..，它们都是RuntimeException的子类，在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比较有印象的系统异常有：NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException。
96、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ 

99、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ 

java5以前，有如下两种：
第一种：
new Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：
new Thread(){
	public void run(){
	}
}.start();

第二种：
new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：
new Thread(new Runnable(){
			public void run(){
			}	
		}
	).start();
	
	
从java5开始，还有如下一些线程池创建多线程的方式：
ExecutorService pool = Executors.newFixedThreadPool(3)
for(int i=0;i<10;i++)
{
 pool.execute(new Runable(){public void run(){}});
}
Executors.newCachedThreadPool().execute(new Runable(){public void run(){}});
Executors.newSingleThreadExecutor().execute(new Runable(){public void run(){}});



有两种实现方法，分别使用new Thread()和new Thread(runnable)形式，第一种直接调用thread的run方法，所以，我们往往使用Thread子类，即new SubThread()。第二种调用runnable的run方法。

有两种实现方法，分别是继承Thread类与实现Runnable接口 
用synchronized关键字修饰同步方法 
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 
13、sleep() 和 wait() 有什么区别? 
     （网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。） 

sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。
package com.huawei.interview;

public class MultiThread {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new Thread(new Thread1()).start();
		try {
			Thread.sleep(10);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		new Thread(new Thread2()).start();		
	}
	
	
	private static class Thread1 implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
//由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。
			synchronized (MultiThread.class) {

				System.out.println("enter thread1...");
				
				System.out.println("thread1 is waiting");
				try {
			//释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。
					MultiThread.class.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				System.out.println("thread1 is going on...");
				System.out.println("thread1 is being over!");			
			}
		}
		
	}
	
	private static class Thread2 implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
			synchronized (MultiThread.class) {
			
				System.out.println("enter thread2...");
				
				System.out.println("thread2 notify other thread can release wait status..");
//由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。

				MultiThread.class.notify();
				
				System.out.println("thread2 is sleeping ten millisecond...");
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				System.out.println("thread2 is going on...");
				System.out.println("thread2 is being over!");
				
			}
		}
		
	}	

}


16、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 

17. 下面两个方法同步吗？（自己发明）
	class Test
{
synchronized static void sayHello3()
		{
		
		}	
	
		synchronized void getX(){}
}
56、多线程有几种实现方法?同步有几种实现方法? 
多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 
同步的实现方面有两种，分别是synchronized,wait与notify 
wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。


30、启动一个线程是用run()还是start()? . 
启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 

47、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 
分几种情况：
     1.其他方法前是否加了synchronized关键字，如果没加，则能。
     2.如果这个方法内部调用了wait，则可以进入其他synchronized方法。
     3.如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。
		4.如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。

58、线程的基本概念、线程的基本状态以及状态之间的关系 

一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。 

  状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。
  调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。 

71、简述synchronized和java.util.concurrent.locks.Lock的异同 ？ 
主要相同点：Lock能完成synchronized所实现的所有功能 
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。 
举例说明（对下面的题用lock进行了改写）：
package com.huawei.interview;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadTest {

	/**
	 * @param args
	 */
	
	private int j;
	private Lock lock = new ReentrantLock();
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		ThreadTest tt = new ThreadTest();
		for(int i=0;i<2;i++)
		{
			new Thread(tt.new Adder()).start();
			new Thread(tt.new Subtractor()).start();
		}
	}

	private class Subtractor implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
			while(true)
			{
				/*synchronized (ThreadTest.this) {			
					System.out.println("j--=" + j--);
					//这里抛异常了，锁能释放吗？
				}*/
				lock.lock();
				try
				{
					System.out.println("j--=" + j--);
				}finally
				{
					lock.unlock();
				}
			}
		}
		
	}
	
	private class Adder implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
			while(true)
			{
				/*synchronized (ThreadTest.this) {
				System.out.println("j++=" + j++);	
				}*/
				lock.lock();
				try
				{
					System.out.println("j++=" + j++);
				}finally
				{
					lock.unlock();
				}				
			}			
		}
		
	}
}
28、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。 
以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。 
public class ThreadTest1 
{ 
private int j; 
public static void main(String args[]){ 
   ThreadTest1 tt=new ThreadTest1(); 
   Inc inc=tt.new Inc(); 
   Dec dec=tt.new Dec(); 
   for(int i=0;i<2;i++){ 
       Thread t=new Thread(inc); 
       t.start(); 
		   t=new Thread(dec); 
       t.start(); 
       } 
   } 
private synchronized void inc(){ 
   j++; 
   System.out.println(Thread.currentThread().getName()+"-inc:"+j); 
   } 
private synchronized void dec(){ 
   j--; 
   System.out.println(Thread.currentThread().getName()+"-dec:"+j); 
   } 
class Inc implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       inc(); 
       } 
   } 
} 
class Dec implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       dec(); 
       } 
   } 
} 
} 

----------随手再写的一个-------------
class A
{
JManger j =new JManager();
main()
{
	new A().call();
}

void call
{
	for(int i=0;i<2;i++)
	{
		new Thread(
			new Runnable(){ public void run(){while(true){j.accumulate()}}}
		).start();
		new Thread(new Runnable(){ public void run(){while(true){j.sub()}}}).start();
	}
}
}

class JManager
{
	private j = 0;
	
	public synchronized void subtract()
	{
		j--
	}
	
	public synchronized void accumulate()
	{
		j++;
	}
	
}

28、子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。 

最终的程序代码如下：
public class ThreadTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new ThreadTest().init();

	}

	public void init()
	{
		final Business business = new Business();
		new Thread(
				new Runnable()
				{

					public void run() {
						for(int i=0;i<50;i++)
						{
							business.SubThread(i);
						}						
					}
					
				}
		
		).start();
		
		for(int i=0;i<50;i++)
		{
			business.MainThread(i);
		}		
	}
	
	private class Business
	{
		boolean bShouldSub = true;//这里相当于定义了控制该谁执行的一个信号灯
		public synchronized void MainThread(int i)
		{
			if(bShouldSub)
				try {
					this.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}		
				
			for(int j=0;j<5;j++)
			{
				System.out.println(Thread.currentThread().getName() + ":i=" + i +",j=" + j);
			}
			bShouldSub = true;
			this.notify();
		
		}
		
		
		public synchronized void SubThread(int i)
		{
			if(!bShouldSub)
				try {
					this.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}	
				
			for(int j=0;j<10;j++)
			{
				System.out.println(Thread.currentThread().getName() + ":i=" + i +",j=" + j);
			}
			bShouldSub = false;				
			this.notify();			
		}
	}
}

备注：不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：

package com.huawei.interview.lym;

public class ThreadTest {
	
	private static boolean bShouldMain = false;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*new Thread(){
		public void run()
		{
			for(int i=0;i<50;i++)
			{
				for(int j=0;j<10;j++)
				{
					System.out.println("i=" + i + ",j=" + j);
				}
			}				
		}
		
	}.start();*/		
		
		
		//final String str = new String("");

		new Thread(
				new Runnable()
				{
					public void run()
					{
						for(int i=0;i<50;i++)
						{
							synchronized (ThreadTest.class) {
								if(bShouldMain)
								{
									try {
										ThreadTest.class.wait();} 
									catch (InterruptedException e) {
										e.printStackTrace();
									}
								}
								for(int j=0;j<10;j++)
								{
									System.out.println(
											Thread.currentThread().getName() + 
											"i=" + i + ",j=" + j);
								}
								bShouldMain = true;
								ThreadTest.class.notify();
							}							
						}						
					}
				}
		).start();
		
		for(int i=0;i<50;i++)
		{
			synchronized (ThreadTest.class) {
				if(!bShouldMain)
				{
					try {
						ThreadTest.class.wait();} 
					catch (InterruptedException e) {
						e.printStackTrace();
					}
				}				
				for(int j=0;j<5;j++)
				{
					System.out.println(
							Thread.currentThread().getName() + 						
							"i=" + i + ",j=" + j);
				}
				bShouldMain = false;
				ThreadTest.class.notify();				
			}			
		}
	}

}
下面使用jdk5中的并发库来实现的：
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

public class ThreadTest
{
	private static Lock lock = new ReentrantLock();
	private static Condition subThreadCondition = lock.newCondition();
	private static boolean bBhouldSubThread = false;
	public static void main(String [] args)
	{
		ExecutorService threadPool = Executors.newFixedThreadPool(3);
		threadPool.execute(new Runnable(){
			public void run()
			{
				for(int i=0;i<50;i++)
				{
					lock.lock();					
					try
					{					
						if(!bBhouldSubThread)
							subThreadCondition.await();
						for(int j=0;j<10;j++)
						{
							System.out.println(Thread.currentThread().getName() + ",j=" + j);
						}
						bBhouldSubThread = false;
						subThreadCondition.signal();
					}catch(Exception e)
					{						
					}
					finally
					{
						lock.unlock();
					}
				}			
			}
			
		});
		threadPool.shutdown();
		for(int i=0;i<50;i++)
		{
				lock.lock();					
				try
				{	
					if(bBhouldSubThread)
							subThreadCondition.await();								
					for(int j=0;j<10;j++)
					{
						System.out.println(Thread.currentThread().getName() + ",j=" + j);
					}
					bBhouldSubThread = true;
					subThreadCondition.signal();					
				}catch(Exception e)
				{						
				}
				finally
				{
					lock.unlock();
				}					
		}
	}
}


3、介绍Collection框架的结构
答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。

3、Collection框架中实现比较要实现什么接口
comparable/comparator
3、ArrayList和Vector的区别
答：
这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与hashset没有任何关系，但为了说清楚ArrayList与Vector的功能，我们使用对比方式，更有利于说明问题）。

接着才说ArrayList与Vector的区别，这主要包括两个方面：. 
（1）同步性：
	Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。

备注：对于Vector&ArrayList、Hashtable&HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。
（2）数据增长：
	ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。
    总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。
4、HashMap和Hashtable的区别
（条理上还需要整理，也是先说相同点，再说不同点）
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 
HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 
HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。

就HashMap与HashTable主要从三方面来说。 
一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 
二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 
三.值：只有HashMap可以让你将空值作为一个表的条目的key或value 
5、List 和 Map 区别?
一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。
35、List, Set, Map是否继承自Collection接口? 
   List，Set是，Map不是 

109、List、Map、Set三个接口，存取元素时，各有什么特点？ 
这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。

首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。
	List表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。
	Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。

List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。


HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，"abc" ---> 78，"def" ---> 62，"xyz" ---> 65在hashSet中的存储顺序不是62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet按插入的顺序存储，那被存储对象的hashcode方法还有什么作用呢？学员想想!hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new 两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。

同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。 

7、说出ArrayList,Vector, LinkedList的存储性能和特性 
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。
4、去掉一个Vector集合中重复的元素 
Vector newVector = new Vector();
For (int i=0;i<vector.size();i++)
{
Object obj = vector.get(i);
	if(!newVector.contains(obj);
		newVector.add(obj);
}
还有一种简单的方式，HashSet set = new HashSet(vector); 
9、Collection 和 Collections的区别。 
　　Collection是集合类的上级接口，继承与他的接口主要有Set 和List. 
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 
39、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别? 
Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 
   equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。

53、你所知道的集合类都有哪些？主要方法？ 
最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 
Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作"键"和"值"），其中每个键映射到一个值。 

ArrayList/VectorList
                    Collection
HashSet/TreeSetSet

PropetiesHashTable
					Map
	Treemap/HashMap

我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，我记得不是很清楚，对于set，大概的方法是add,remove, contains；对于map，大概的方法就是put,remove，contains等，因为，我只要在eclispe下按点操作符，很自然的这些方法就出来了。我记住的一些思想就是List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。 

45、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对? 
对。
如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。
如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的，例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。
46、TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！ 
（应该是没有针对问题的确切的答案，当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的）
实验代码：
public class Parent implements Comparable {
	private int age = 0;
	public Parent(int age){
		this.age = age;
	}
	public int compareTo(Object o) {
		// TODO Auto-generated method stub
		System.out.println("method of parent");
		Parent o1 = (Parent)o;
		return age>o1.age?1:age<o1.age?-1:0;
	}

}

public class Child extends Parent {

	public Child(){
		super(3);
	}
	public int compareTo(Object o) {

			// TODO Auto-generated method stub
			System.out.println("method of child");
//			Child o1 = (Child)o;
			return 1;

	}
}

public class TreeSetTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		TreeSet set = new TreeSet();
		set.add(new Parent(3));
		set.add(new Child());
		set.add(new Parent(4));
		System.out.println(set.size());
	}

}


112、说出一些常用的类，包，接口，请各举5个 
要让人家感觉你对java ee开发很熟，所以，不能仅仅只列core java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。

常用的类：BufferedReader  BufferedWriter  FileReader  FileWirter  String  Integer 
java.util.Date，System，Class，List,HashMap

常用的包：java.lang   java.io  java.util  java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate
常用的接口：Remote  List  Map  Document  NodeList ,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate)、Session(Hibernate),HttpSession
100、java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ 
字节流，字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。 
102、字节流与字符流的区别
	要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。
	在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。
  底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。
  字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，
  其实是转成该字符的某种编码的字节形式，读取也是反之的道理。

讲解字节流与字符流关系的代码案例：
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class IOTest {
	public static void main(String[] args) throws Exception {
		String str = "中国人";
		/*FileOutputStream fos  = new FileOutputStream("1.txt");
		
		fos.write(str.getBytes("UTF-8"));
		fos.close();*/
		
		/*FileWriter fw = new FileWriter("1.txt");
		fw.write(str);
		fw.close();*/
		PrintWriter pw = new PrintWriter("1.txt","utf-8");
		pw.write(str);
		pw.close();
		
		/*FileReader fr = new FileReader("1.txt");
		char[] buf = new char[1024];
		int len = fr.read(buf);
		String myStr = new String(buf,0,len);
		System.out.println(myStr);*/
		/*FileInputStream fr = new FileInputStream("1.txt");
		byte[] buf = new byte[1024];
		int len = fr.read(buf);
		String myStr = new String(buf,0,len,"UTF-8");
		System.out.println(myStr);*/
		BufferedReader br = new BufferedReader(
				new InputStreamReader(
					new FileInputStream("1.txt"),"UTF-8"	
					)
				);
		String myStr = br.readLine();
		br.close();
		System.out.println(myStr);
	}

}
105、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。 

我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。 


例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过rmi等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。

54、描述一下JVM加载class文件的原理机制? 
JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。 

18、heap和stack有什么区别。 
java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。
堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 

24、GC是什么? 为什么要有GC? 　　 
GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

51、垃圾回收的优点和原理。并考虑2种回收机制。 
Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

103、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。 
 

23、什么时候用assert。 
assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。 
package com.huawei.interview;

public class AssertTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i = 0;
		for(i=0;i<5;i++)
		{
			System.out.println(i);
		}
		//假设程序不小心多了一句--i;
		--i;
		assert i==5;		
	}

}

101、java中会存在内存泄漏吗，请简单描述。 
所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收：
package com.huawei.interview;

import java.io.IOException;

public class GarbageTest {

	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		try {
			gcTest();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("has exited gcTest!");
		System.in.read();
		System.in.read();		
		System.out.println("out begin gc!");		
		for(int i=0;i<100;i++)
		{
			System.gc();
			System.in.read();	
			System.in.read();	
		}
	}

	private static void gcTest() throws IOException {
		System.in.read();
		System.in.read();		
		Person p1 = new Person();
		System.in.read();
		System.in.read();		
		Person p2 = new Person();
		p1.setMate(p2);
		p2.setMate(p1);
		System.out.println("before exit gctest!");
		System.in.read();
		System.in.read();		
		System.gc();
		System.out.println("exit gctest!");
	}

	private static class Person
	{
		byte[] data = new byte[20000000];
		Person mate = null;
		public void setMate(Person other)
		{
			mate = other;
		}
	}
}

java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。
检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中消失，将那个元素所在的位置的值设置为null即可）：
我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可是那时我说是我自己想到的也没有人相信的。
    public class Stack {
    private Object[] elements=new Object[10];
    private int size = 0;
    public void push(Object e){
    ensureCapacity();
    elements[size++] = e;
    }
    public Object pop(){
    if( size == 0)
    throw new EmptyStackException();
    return elements[--size];
    }
    private void ensureCapacity(){
    if(elements.length == size){
    Object[] oldElements = elements;
    elements = new Object[2 * elements.length+1];
    System.arraycopy(oldElements,0, elements, 0, size);
    }
    }
    }
    上面的原理应该很简单，假如堆栈加了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，无法回收。
    但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪费了几个K内存而已，反正我们的内存都上G了，哪里会有什么影响，再说这个东西很快就会被回收的，有什么关系。下面看两个例子。
    例子1
    public class Bad{
    public static Stack s=Stack();
    static{
    s.push(new Object());
    s.pop(); //这里有一个对象发生内存泄露
    s.push(new Object()); //上面的对象可以被回收了，等于是自愈了
    }
    }
    因为是static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果你的Stack最多有100个对象，那么最多也就只有100个对象无法被回收其实这个应该很容易理解，Stack内部持有100个引用，最坏的情况就是他们都是无用的，因为我们一旦放新的进取，以前的引用自然消失！

内存泄露的另外一种情况：当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。



8、能不能自己写个类，也叫java.lang.String？

可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF/classess目录中的类，然后才委托上级的类加载器加载，如果我们在tomcat的web应用程序中写一个java.lang.String，这时候Servlet程序加载的就是我们自己写的java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。

虽然java提供了endorsed技术，可以覆盖jdk中的某些类，具体做法是….。但是，能够被覆盖的类是有限制范围，反正不包括java.lang这样的包中的类。

（下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题目泄露了）例如，运行下面的程序：
package java.lang;

public class String {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("string");
	}

}
报告的错误如下：
java.lang.NoSuchMethodError: main
Exception in thread "main"
这是因为加载了jre自带的java.lang.String，而该类中没有main方法。

2. Java代码查错
1.
abstract class Name {
   private String name;
   public abstract boolean isStupidName(String name) {}
}
大侠们，这有何错误?
答案: 错。abstract method必须以分号结尾，且不带花括号。
2.
public class Something {
   void doSomething () {
       private String s = "";
       int l = s.length();
   }
}
有错吗?
答案: 错。局部变量前不能放置任何访问修饰符 (private，public，和protected)。final可以用来修饰局部变量
(final如同abstract和strictfp，都是非访问修饰符，strictfp只能修饰class和method而非variable)。
3.
abstract class Something {
   private abstract String doSomething ();
}
这好像没什么错吧?
答案: 错。abstract的methods不能以private修饰。abstract的methods就是让子类implement(实现)具体细节的，怎么可以用private把abstract
method封锁起来呢? (同理，abstract method前不能加final)。
4.
public class Something {
   public int addOne(final int x) {
       return ++x;
   }
}
这个比较明显。
答案: 错。int x被修饰成final，意味着x不能在addOne method中被修改。
5.
public class Something {
   public static void main(String[] args) {
       Other o = new Other();
       new Something().addOne(o);
   }
   public void addOne(final Other o) {
       o.i++;
   }
}
class Other {
   public int i;
}
和上面的很相似，都是关于final的问题，这有错吗?
答案: 正确。在addOne method中，参数o被修饰成final。如果在addOne method里我们修改了o的reference
(比如: o = new Other();)，那么如同上例这题也是错的。但这里修改的是o的member vairable
(成员变量)，而o的reference并没有改变。
6.
class Something {
    int i;
    public void doSomething() {
        System.out.println("i = " + i);
    }
} 
有什么错呢? 看不出来啊。
答案: 正确。输出的是"i = 0"。int i属於instant variable (实例变量，或叫成员变量)。instant variable有default value。int的default value是0。
7.
class Something {
    final int i;
    public void doSomething() {
        System.out.println("i = " + i);
    }
}
和上面一题只有一个地方不同，就是多了一个final。这难道就错了吗?
答案: 错。final int i是个final的instant variable (实例变量，或叫成员变量)。final的instant variable没有default value，必须在constructor (构造器)结束之前被赋予一个明确的值。可以修改为"final int i = 0;"。
8.
public class Something {
     public static void main(String[] args) {
        Something s = new Something();
        System.out.println("s.doSomething() returns " + doSomething());
    }
    public String doSomething() {
        return "Do something ...";
    }
}
 看上去很完美。
答案: 错。看上去在main里call doSomething没有什么问题，毕竟两个methods都在同一个class里。但仔细看，main是static的。static method不能直接call non-static methods。可改成"System.out.println("s.doSomething() returns " + s.doSomething());"。同理，static method不能访问non-static instant variable。
9.
此处，Something类的文件名叫OtherThing.java
class Something {
    private static void main(String[] something_to_do) {        
        System.out.println("Do something ...");
    }
}
 这个好像很明显。
答案: 正确。从来没有人说过Java的Class名字必须和其文件名相同。但public class的名字必须和文件名相同。
10．
interface  A{
   int x = 0;
}
class B{
   int x =1;
}
class C extends B implements A {
   public void pX(){
      System.out.println(x);
   }
   public static void main(String[] args) {
      new C().pX();
   }
}
答案：错误。在编译时会发生错误(错误描述不同的JVM有不同的信息，意思就是未明确的x调用，两个x都匹配（就象在同时import java.util和java.sql两个包时直接声明Date一样）。对于父类的变量,可以用super.x来明确，而接口的属性默认隐含为 public static final.所以可以通过A.x来明确。
11.
interface Playable {
    void play();
}
interface Bounceable {
    void play();
}
interface Rollable extends Playable, Bounceable {
    Ball ball = new Ball("PingPang");
}
class Ball implements Rollable {
    private String name;
    public String getName() {
        return name;
    }
    public Ball(String name) {
        this.name = name;        
    }
   public void play() {
        ball = new Ball("Football");
        System.out.println(ball.getName());
    }
}
这个错误不容易发现。
答案: 错。"interface Rollable extends Playable, Bounceable"没有问题。interface可继承多个interfaces，所以这里没错。问题出在interface Rollable里的"Ball ball = new Ball("PingPang");"。任何在interface里声明的interface variable (接口变量，也可称成员变量)，默认为public static final。也就是说"Ball ball = new Ball("PingPang");"实际上是"public static final Ball ball = new Ball("PingPang");"。在Ball类的Play()方法中，"ball = new Ball("Football");"改变了ball的reference，而这里的ball来自Rollable interface，Rollable interface里的ball是public static final的，final的object是不能被改变reference的。因此编译器将在"ball = new Ball("Football");"这里显示有错。
4. 算法与编程
1.判断身份证：要么是15位，要么是18位，最后一位可以为字母，并写程序提出其中的年月日。
答：我们可以用正则表达式来定义复杂的字符串格式，(\d{17}[0-9a-zA-Z]|\d{14}[0-9a-zA-Z])可以用来判断是否为合法的15位或18位身份证号码。
因为15位和18位的身份证号码都是从7位到第12位为身份证为日期类型。这样我们可以设计出更精确的正则模式，使身份证号的日期合法，这样我们的正则模式可以进一步将日期部分的正则修改为[12][0-9]{3}[01][0-9][123][0-9]，当然可以更精确的设置日期。
在jdk的java.util.Regex包中有实现正则的类,Pattern和Matcher。以下是实现代码：

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		// 测试是否为合法的身份证号码
		String[] strs = { "130681198712092019", "13068119871209201x",
				"13068119871209201", "123456789012345", "12345678901234x",
				"1234567890123" };
		Pattern p1 = Pattern.compile("(\\d{17}[0-9a-zA-Z]|\\d{14}[0-9a-zA-Z])");
		for (int i = 0; i < strs.length; i++) {
			Matcher matcher = p1.matcher(strs[i]);
			System.out.println(strs[i] + ":" + matcher.matches());
		}

		Pattern p2 = Pattern.compile("\\d{6}(\\d{8}).*"); // 用于提取出生日字符串
		Pattern p3 = Pattern.compile("(\\d{4})(\\d{2})(\\d{2})");// 用于将生日字符串进行分解为年月日
		for (int i = 0; i < strs.length; i++) {
			Matcher matcher = p2.matcher(strs[i]);
			boolean b = matcher.find();
			if (b) {
				String s = matcher.group(1);
				Matcher matcher2 = p3.matcher(s);
				if (matcher2.find()) {
					System.out
							.println("生日为" + matcher2.group(1) + "年"
									+ matcher2.group(2) + "月"
									+ matcher2.group(3) + "日");
				}
			}

		}

	}

}

1、编写一个程序，将a.txt文件中的单词与b.txt文件中的单词交替合并到c.txt文件中，a.txt文件中的单词用回车符分隔，b.txt文件中用回车或空格进行分隔。
答：
		package cn.itcast;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;

public class MainClass{
	public static void main(String[] args) throws Exception{
		FileManager a = new FileManager("a.txt",new char[]{'\n'});
		FileManager b = new FileManager("b.txt",new char[]{'\n',' '});		
		FileWriter c = new FileWriter("c.txt");
		String aWord = null;
		String bWord = null;
		while((aWord = a.nextWord()) !=null ){
			c.write(aWord + "\n");
			bWord = b.nextWord();
			if(bWord != null)
				c.write(bWord + "\n");
		}
		
		while((bWord = b.nextWord()) != null){
			c.write(bWord + "\n");
		}	
		c.close();
	}
	
}


class FileManager{

	String[] words = null;
	int pos = 0;
	public FileManager(String filename,char[] seperators) throws Exception{
		File f = new File(filename);
		FileReader reader = new FileReader(f);
		char[] buf = new char[(int)f.length()];
		int len = reader.read(buf);
		String results = new String(buf,0,len);
		String regex = null;
		if(seperators.length >1 ){
			regex = "" + seperators[0] + "|" + seperators[1];
		}else{
			regex = "" + seperators[0];
		}
		words = results.split(regex);
	}
	
	public String nextWord(){
		if(pos == words.length)
			return null;
		return words[pos++];
	}

}

1、编写一个程序，将d:\java目录下的所有.java文件复制到d:\jad目录下，并将原来文件的扩展名从.java改为.jad。
（大家正在做上面这道题，网上迟到的朋友也请做做这道题，找工作必须能编写这些简单问题的代码！）
答：listFiles方法接受一个FileFilter对象，这个FileFilter对象就是过虑的策略对象，不同的人提供不同的FileFilter实现，即提供了不同的过滤策略。
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class Jad2Java {

	public static void main(String[] args) throws Exception {
		File srcDir = new File("java");
		if(!(srcDir.exists() && srcDir.isDirectory()))
				throw new Exception("目录不存在");
		File[] files = srcDir.listFiles(
			new FilenameFilter(){

					public boolean accept(File dir, String name) {
						return name.endsWith(".java");
					}
					
				}
		);
		
		System.out.println(files.length);
		File destDir = new File("jad");
		if(!destDir.exists()) destDir.mkdir();
		for(File f :files){
			FileInputStream  fis = new FileInputStream(f);
			String destFileName = f.getName().replaceAll("\\.java$", ".jad");
			FileOutputStream fos = new FileOutputStream(new File(destDir,destFileName));
			copy(fis,fos);
			fis.close();
			fos.close();
		}
	}
	
	private static void copy(InputStream ips,OutputStream ops) throws Exception{
		int len = 0;
		byte[] buf = new byte[1024];
		while((len = ips.read(buf)) != -1){
			ops.write(buf,0,len);
		}

	}
}

由本题总结的思想及策略模式的解析：
1.
class jad2java{
	1. 得到某个目录下的所有的java文件集合
		1.1 得到目录 File srcDir = new File("d:\\java");
		1.2 得到目录下的所有java文件：File[] files = srcDir.listFiles(new MyFileFilter());
		1.3 只想得到.java的文件： class MyFileFilter implememyts FileFilter{
			public boolean accept(File pathname){
				return pathname.getName().endsWith(".java")
			}
		}
		
	2.将每个文件复制到另外一个目录，并改扩展名
		2.1 得到目标目录，如果目标目录不存在，则创建之
		2.2 根据源文件名得到目标文件名，注意要用正则表达式，注意.的转义。
		2.3 根据表示目录的File和目标文件名的字符串，得到表示目标文件的File。
			//要在硬盘中准确地创建出一个文件，需要知道文件名和文件的目录。 
		2.4 将源文件的流拷贝成目标文件流，拷贝方法独立成为一个方法，方法的参数采用抽象流的形式。
			//方法接受的参数类型尽量面向父类，越抽象越好，这样适应面更宽广。	
}

分析listFiles方法内部的策略模式实现原理
File[] listFiles(FileFilter filter){
	File[] files = listFiles();
	//Arraylist acceptedFilesList = new ArrayList();
	File[] acceptedFiles = new File[files.length];
	int pos = 0;
	for(File file: files){
		boolean accepted = filter.accept(file);
		if(accepted){
			//acceptedFilesList.add(file);
			acceptedFiles[pos++] = file;
		}		
	}
	
	Arrays.copyOf(acceptedFiles,pos);
	//return (File[])accpetedFilesList.toArray();
	
}
1、编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。
答：
	首先要了解中文字符有多种编码及各种编码的特征。
    假设n为要截取的字节数。
	public static void main(String[] args) throws Exception{
		String str = "我a爱中华abc我爱传智def';
		String str = "我ABC汉";
		int num = trimGBK(str.getBytes("GBK"),5);
		System.out.println(str.substring(0,num) );
	}
	
	public static int  trimGBK(byte[] buf,int n){
		int num = 0;
		boolean bChineseFirstHalf = false;
		for(int i=0;i<n;i++)
		{
			if(buf[i]<0 && !bChineseFirstHalf){
				bChineseFirstHalf = true;
			}else{
				num++;
				bChineseFirstHalf = false;				
			}
		}
		return num;
	}
1、有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。
答：哈哈，其实包含中文字符、英文字符、数字字符原来是出题者放的烟雾弹。
String content = “中国aadf的111萨bbb菲的zz萨菲”;
HashMap map = new HashMap();
for(int i=0;i<content.length;i++)
{
	char c = content.charAt(i);
	Integer num = map.get(c);
	if(num == null)
		num = 1;
	else
		num = num + 1;
	map.put(c,num);
} 
for(Map.EntrySet entry : map)
{
	system.out.println(entry.getkey() + “:” + entry.getValue());
}
估计是当初面试的那个学员表述不清楚，问题很可能是：
如果一串字符如"aaaabbc中国1512"要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。
int engishCount;
int chineseCount;
int digitCount;
for(int i=0;i<str.length;i++)
{
	char ch = str.charAt(i);
	if(ch>=’0’ && ch<=’9’)
	{
		digitCount++
	}
	else if((ch>=’a’ && ch<=’z’) || (ch>=’A’ && ch<=’Z’))
	{
		engishCount++;
	}
	else
	{
		chineseCount++;
	}
}
System.out.println(……………);

1、说明生活中遇到的二叉树，用java实现二叉树
这是组合设计模式。
我有很多个(假设10万个)数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据，（我想说出二叉树的好处，该怎么说呢？那就是说别人的缺点），假如存在数组中，那么，碰巧要找的数字位于99999那个地方，那查找的速度将很慢，因为要从第1个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序，中序，后序）效率要比数组低很多，原理如下图：

代码如下：
package com.huawei.interview;

public class Node {
	public int value;
	public Node left;
	public Node right;
	
	public void store(int value)
	{
		if(value<this.value)
		{
			if(left == null)
			{
				left = new Node();
				left.value=value;
			}
			else
			{
				left.store(value);
			}
		}
		else if(value>this.value)
		{
			if(right == null)
			{
				right = new Node();
				right.value=value;
			}
			else
			{
				right.store(value);
			}			
		}
	}
	
	public boolean find(int value)
	{	
		System.out.println("happen " + this.value);
		if(value == this.value)
		{
			return true;
		}
		else if(value>this.value)
		{
			if(right == null) return false;
			return right.find(value);
		}else
		{
			if(left == null) return false;
			return left.find(value);
		}

	}
	
	public  void preList()
	{
		System.out.print(this.value + ",");
		if(left!=null) left.preList();
		if(right!=null) right.preList();
	}
	
	public void middleList()
	{
		if(left!=null) left.preList();
		System.out.print(this.value + ",");
		if(right!=null) right.preList();		
	}
	public void afterList()
	{
		if(left!=null) left.preList();
		if(right!=null) right.preList();
		System.out.print(this.value + ",");		
	}	
	public static void main(String [] args)
	{
		int [] data = new int[20];
		for(int i=0;i<data.length;i++)
		{
			data[i] = (int)(Math.random()*100) + 1;
			System.out.print(data[i] + ",");
		}
		System.out.println();
		
		Node root = new Node();
		root.value = data[0];
		for(int i=1;i<data.length;i++)
		{
			root.store(data[i]);
		}
		
		root.find(data[19]);
		
		root.preList();
		System.out.println();
		root.middleList();
		System.out.println();		
		root.afterList();
	}
}
-----------------又一次临场写的代码---------------------------
import java.util.Arrays;
import java.util.Iterator;

public class Node {
	private Node left;
	private Node right;
	private int value;
	//private int num;
	
	public Node(int value){
		this.value = value;
	}
	public void add(int value){
		
		if(value > this.value)
		{
			if(right != null)
				right.add(value);
			else
			{
				Node node = new Node(value);				
				right = node;
			}
		}
		else{
			if(left != null)
				left.add(value);
			else
			{
				Node node = new Node(value);				
				left = node;
			}			
		}
	}
	
	public boolean find(int value){
		if(value == this.value) return true;
		else if(value > this.value){
			if(right == null) return false;
			else return right.find(value);
		}else{
			if(left == null) return false;
			else return left.find(value);			
		}

	}
	
	public void display(){
		System.out.println(value);
		if(left != null) left.display();
		if(right != null) right.display();
		
	}
	
	/*public Iterator iterator(){
		
	}*/
	
	public static void main(String[] args){
		int[] values = new int[8];
		for(int i=0;i<8;i++){
			int num = (int)(Math.random() * 15);
			//System.out.println(num);
			//if(Arrays.binarySearch(values, num)<0)
			if(!contains(values,num))
				values[i] = num;
			else
				i--;
		}
		
		System.out.println(Arrays.toString(values));
		
		Node root  = new Node(values[0]);
		for(int i=1;i<values.length;i++){
			root.add(values[i]);
		}
		
		System.out.println(root.find(13));
		
		root.display();
		
	}
	
	public static boolean contains(int [] arr, int value){
		int i = 0;
		for(;i<arr.length;i++){
			if(arr[i] == value) return true;
			
		}
		return false;
	}
	
}
1、从类似如下的文本文件中读取出所有的姓名，并打印出重复的姓名和重复的次数，并按重复次数排序：
1,张三,28
2,李四,35
3,张三,28
4,王五,35
5,张三,28
6,李四,35
7,赵六,28
8,田七,35

程序代码如下（答题要博得用人单位的喜欢，包名用该公司，面试前就提前查好该公司的网址，如果查不到，现场问也是可以的。还要加上实现思路的注释）：
package com.huawei.interview;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeSet;


public class GetNameTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//InputStream ips = GetNameTest.class.getResourceAsStream("/com/huawei/interview/info.txt");
		//用上一行注释的代码和下一行的代码都可以，因为info.txt与GetNameTest类在同一包下面，所以，可以用下面的相对路径形式
		
		Map results = new HashMap();
		InputStream ips = GetNameTest.class.getResourceAsStream("info.txt");
		BufferedReader in = new BufferedReader(new InputStreamReader(ips));
		String line = null;
		try {
			while((line=in.readLine())!=null)
			{
				dealLine(line,results);
			}
			sortResults(results);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	static class User
	{
		public  String name;
		public Integer value;
		public User(String name,Integer value)
		{
			this.name = name;
			this.value = value;
		}

		@Override
		public boolean equals(Object obj) {
			// TODO Auto-generated method stub
				
			//下面的代码没有执行，说明往treeset中增加数据时，不会使用到equals方法。
			boolean result = super.equals(obj);
			System.out.println(result);
			return result;
		}
	}
	
	private static void sortResults(Map results) {
		// TODO Auto-generated method stub
		TreeSet sortedResults = new TreeSet(
				new Comparator(){
					public int compare(Object o1, Object o2) {
						// TODO Auto-generated method stub
						User user1 = (User)o1;
						User user2 = (User)o2;
						/*如果compareTo返回结果0，则认为两个对象相等，新的对象不会增加到集合中去
						 * 所以，不能直接用下面的代码，否则，那些个数相同的其他姓名就打印不出来。
						 * */
						
						//return user1.value-user2.value;
						//return user1.value<user2.value?-1:user1.value==user2.value?0:1;
						if(user1.value<user2.value)
						{
							return -1;
						}else if(user1.value>user2.value)
						{
							return 1;
						}else
						{
							return user1.name.compareTo(user2.name);
						}
					}
					
				}
		);
		Iterator iterator = results.keySet().iterator();
		while(iterator.hasNext())
		{
			String name = (String)iterator.next();
			Integer value = (Integer)results.get(name);
			if(value > 1)
			{				
				sortedResults.add(new User(name,value));				
			}
		}
		
		printResults(sortedResults);
	}
	private static void printResults(TreeSet sortedResults) 
	{
		Iterator iterator  = sortedResults.iterator();
		while(iterator.hasNext())
		{
			User user = (User)iterator.next();
			System.out.println(user.name + ":" + user.value);
		}	
	}
	public static void dealLine(String line,Map map)
	{
		if(!"".equals(line.trim()))
		{
			String [] results = line.split(",");
			if(results.length == 3)
			{
				String name = results[1];
				Integer value = (Integer)map.get(name);
				if(value == null) value = 0;
				map.put(name,value + 1);
			}
		}
	}

}
48、写一个Singleton出来。
第一种：饱汉模式
public class SingleTon {
	private SingleTon(){
		}

	//实例化放在静态代码块里可提高程序的执行效率，但也可能更占用空间	
	private final static SingleTon instance = new SingleTon();
	public static SingleTon getInstance(){
		return instance;
	}
}

第二种：饥汉模式
public class SingleTon {
	private SingleTon(){}
	
	private static instance = null;//new SingleTon();
	
	public static synchronized SingleTon getInstance(){
		if(instance == null)
			instance = new SingleTon();
		return instance;
	}
}

第三种：用枚举
	public enum SingleTon{
		ONE;
	
	}

第三：更实际的应用（在什么情况用单例）
public class SequenceGenerator{
	//下面是该类自身的业务功能代码
	private int count = 0;

	public synchronized int getSequence(){
		++count;
	}
	
	//下面是把该类变成单例的代码
	private SequenceGenerator(){}
	private final static instance = new SequenceGenerator();
	public static SingleTon getInstance(){
		return instance;
	}	
	
}

第四：
	public class MemoryDao
	{
    private HashMap map = new HashMap();
    
   	public void add(Student stu1){ 
    		map.put(SequenceGenerator.getInstance().getSequence(),stu1);
    }
   
   //把MemoryDao变成单例 
  }






Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 
一般Singleton模式通常有几种种形式: 
第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 
public class Singleton { 
private Singleton(){} 
　　    //在自己内部定义自己一个实例，是不是很奇怪？ 
　　    //注意这是private 只供内部调用 
　　    private static Singleton instance = new Singleton(); 
　　    //这里提供了一个供外部访问本class的静态方法，可以直接访问　　 
　　    public static Singleton getInstance() { 
　　　　    return instance; 　　 
　　    } 
   } 
   第二种形式: 
public class Singleton { 
　　private static Singleton instance = null; 
　　public static synchronized Singleton getInstance() { 
　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　 
　　//使用时生成实例，提高了效率！ 
　　if (instance==null) 
　　　　instance＝new Singleton(); 
			return instance; 　　
	} 
} 
其他形式: 
定义一个类，它的构造函数为private的，所有方法为static的。 
一般认为第一种形式要更加安全些 
7、递归算法题1
一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。
例：n=1237
则输出为：
1237，
2474，
4948，
9896，
9896，
4948，
2474，
1237，
提示：写程序时，先致谢按递增方式的代码，写好递增的以后，再增加考虑递减部分。
	public static void doubleNum(int n)
	{
		System.out.println(n);
		if(n<=5000)
			doubleNum(n*2);
		System.out.println(n);		
	}


7、递归算法题2
第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？
package cn.itcast;

import java.util.Date;

public class A1 {

	public static void main(String [] args)
	{
		System.out.println(computeAge(8));
	}
	
	public static int computeAge(int n)
	{
		if(n==1) return 10;
		return computeAge(n-1) + 2;
	}
}

	public static void toBinary(int n,StringBuffer result)
	{

		if(n/2 != 0)
			toBinary(n/2,result);
		result.append(n%2);		
	}
94、排序都有哪几种方法？请列举。用JAVA实现一个快速排序。 
 本人只研究过冒泡排序、选择排序和快速排序，下面是快速排序的代码：
public class QuickSort {
/**
* 快速排序
* @param strDate
* @param left
* @param right
*/
public void quickSort(String[] strDate,int left,int right){
String middle,tempDate;
int i,j;
i=left;
j=right;
middle=strDate[(i+j)/2];
do{
while(strDate[i].compareTo(middle)<0&& i<right)
i++; //找出左边比中间值大的数
while(strDate[j].compareTo(middle)>0&& j>left)
j--; //找出右边比中间值小的数
if(i<=j){ //将左边大的数和右边小的数进行替换 
tempDate=strDate[i];
strDate[i]=strDate[j];
strDate[j]=tempDate;
i++;
j--;
}
}while(i<=j); //当两者交错时停止

if(i<right){
quickSort(strDate,i,right);//从
}
if(j>left){
quickSort(strDate,left,j);
}
}
/**
  * @param args
  */
public static void main(String[] args){
String[] strVoid=new String[]{"11","66","22","0","55","22","0","32"};
QuickSort sort=new QuickSort();
sort.quickSort(strVoid,0,strVoid.length-1);
for(int i=0;i<strVoid.length;i++){
System.out.println(strVoid[i]+" ");
}
}


}
7、有数组a[n]，用java代码将数组元素顺序颠倒
//用下面的也可以
//for(int i=0,int j=a.length-1;i<j;i++,j--) 是否等效于 for(int i=0;i<a.length/2;i++)呢？

import java.util.Arrays;

public class SwapDemo{

	public static void main(String[] args){
		int [] a = new int[]{
						(int)(Math.random() * 1000),
						(int)(Math.random() * 1000),
						(int)(Math.random() * 1000),
						(int)(Math.random() * 1000),						
						(int)(Math.random() * 1000)																		
		};	
		
		System.out.println(a);
		System.out.println(Arrays.toString(a));
		swap(a);
		System.out.println(Arrays.toString(a));		
	}
	
	public static void swap(int a[]){
		int len = a.length;
		for(int i=0;i<len/2;i++){
			int tmp = a[i];
			a[i] = a[len-1-i];
			a[len-1-i] = tmp;
		}
	}
}
2．金额转换，阿拉伯数字的金额转换成中国传统的形式如：（￥1011）－>（一千零一拾一元整）输出。
去零的代码：
	return sb.reverse().toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零");

public class RenMingBi {

	/**
	 * @param args add by zxx ,Nov 29, 2008
	 */
	private static final char[] data = new char[]{
			'零','壹','贰','叁','肆','伍','陆','柒','捌','玖'
		}; 
	private static final char[] units = new char[]{
		'元','拾','佰','仟','万','拾','佰','仟','亿'
	};
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(
				convert(135689123));
	}

	public static String convert(int money)
	{
		StringBuffer sbf = new StringBuffer();
		int unit = 0;
		while(money!=0)
		{
			sbf.insert(0,units[unit++]);
			int number = money%10;
			sbf.insert(0, data[number]);
			money /= 10;
		}

		return sbf.toString();
	}
}
5. html&JavaScript&ajax部分
1. 判断第二个日期比第一个日期大
	如何用脚本判断用户输入的的字符串是下面的时间格式2004-11-21 必须要保证用户的输入是此格式，并且是时间，比如说月份不大于12等等，另外我需要用户输入两个，并且后一个要比前一个晚，只允许用JAVASCRIPT，请详细帮助作答，, 
//这里可用正则表达式判断提前判断一下格式，然后按下提取各时间字段内容
<script type="text/javascript">
	window.onload = function()
	{
		//这么写是为了实现js代码与html代码的分离，当我修改js时，不能影响html代码。
		document.getElementById("frm1").onsubmit = 
			function(){
				var d1 = this.d1.value;
				var d2 = this.d2.value;
				if(!verifyDate (d1)) {alert("第一个日期格式不对");return false;}
				if(!verifyDate (d2)) {alert("第二个日期格式不对");return false;}
				if(!compareDate(d1,d2)) {alert("第二个日期比第一日期小");return false;}			
			};
		}
		
		function compareDate(d1,d2)
		{
			var arrayD1 = d1.split("-");
			var date1 = new Date(arrayD1[0],arrayD1[1],arrayD1[2]);
			var arrayD2 = d2.split("-");
			var date2 = new Date(arrayD2[0],arrayD2[1],arrayD2[2]);	
			if(date1 > date2) return false;		
			return true;
		} 
		
		function verifyDate(d)
		{
			var datePattern = /^\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2]\d|3[0-1])$/;
			return datePattern.test(d);
		}
</script>

<form id="frm1" action="xxx.html">
<input type="text" name="d1" />
<input type="text" name="d2" />
<input type="submit"/>
</form>
1. 用table显示n条记录，每3行换一次颜色，即1，2，3用红色字体，4，5，6用绿色字体，7，8，9用红颜色字体。
<body>
<table id="tbl">
	<tr><td>1</td></tr>
	<tr><td>2</td></tr>
	<tr><td>3</td></tr>
	<tr><td>4</td></tr>
	<tr><td>5</td></tr>
	<tr><td>6</td></tr>
	<tr><td>7</td></tr>
	<tr><td>8</td></tr>
	<tr><td>9</td></tr>
	<tr><td>10</td></tr>
</table>
</body>
<script type="text/javascript">
	window.onload=function()
		{
			var tbl = document.getElementById("tbl");
			rows = tbl.getElementsByTagName("tr");
			for(i=0;i<rows.length;i++)
			{
				var j = parseInt(i/3);
				if(j%2==0) rows[i].style.backgroundColor="#f00";
				else  rows[i].style.backgroundColor="#0f0";
			}
		}
</script>
1、HTML 的 form 提交之前如何验证数值文本框的内容全部为数字? 否则的话提示用户并终止提交? 
<form onsubmit=’return chkForm(this)’>
<input type="text" name="d1"/>
<input type="submit"/>
</form>
<script type=”text/javascript” />	
function chkForm(this)
	{ 
		var value = thist.d1.value;
		var len = value.length;
		for(var i=0;i<len;i++)
		{
			if(value.charAt(i)>"9" || value.charAt(i)<"0")
			{
				alert("含有非数字字符");
				return false;
			}
		}
		return true;
	}
</script>

2、请写出用于校验HTML文本框中输入的内容全部为数字的javascript代码
<input type="text" id="d1" onblur=" chkNumber (this)"/>
<script type=”text/javascript” />	
function chkNumber(eleText)
 
	{ 
		var value = eleText.value;
		var len = value.length;
		for(var i=0;i<len;i++)
		{
			if(value.charAt(i)>"9" || value.charAt(i)<"0")
			{
				alert("含有非数字字符");

				eleText.focus();
				break; 
			}
		}
	}
</script>
除了写完代码，还应该在网页上写出实验步骤和在代码中加入实现思路，让面试官一看就明白你的意图和检查你的结果。

1、说说你用过那些ajax技术和框架，说说它们的区别
答:去掉对web.xml的监视，把jsp提前编辑成Servlet。
有富余物理内存的情况，加大tomcat使用的jvm的内存

6. Java web部分
1、Tomcat的优化经验
答:去掉对web.xml的监视，把jsp提前编辑成Servlet。
有富余物理内存的情况，加大tomcat使用的jvm的内存


1、HTTP请求的GET与POST方式的区别
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。
62、解释一下什么是servlet;
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。
1、说一说Servlet的生命周期? 
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。

Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do***()方法。结束服务，web容器调用servlet的destroy()方法。 

4、Servlet的基本架构 
public class ServletName extends HttpServlet { 
public void doPost(HttpServletRequest request, HttpServletResponse response) throws 
ServletException, IOException { 
} 
public void doGet(HttpServletRequest request, HttpServletResponse response) throws 
ServletException, IOException { 
} 
} 
3、SERVLET API中forward() 与redirect()的区别？ 
答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用
sendRedirect()方法。 

60、什么情况下调用doGet()和doPost()？ 
Jsp页面中的FORM标签里的method属性为get时调用doGet()，为post时调用doPost()。 

66、Request对象的主要方法： 
setAttribute(String name,Object)：设置名字为name的request的参数值 
getAttribute(String name)：返回由name指定的属性值 
getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例 
getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组 
getCharacterEncoding()：返回请求中的字符编码方式 
getContentLength()：返回请求的Body的长度 
getHeader(String name)：获得HTTP协议定义的文件头信息 
getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例 
getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例 
getInputStream()：返回请求的输入流，用于获得请求中的数据 
getMethod()：获得客户端向服务器端传送数据的方法 
getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值 
getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 
getParametervalues(String name)：获得有name指定的参数的所有值 
getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 
getQueryString()：获得查询字符串 
getRequestURI()：获取发出请求字符串的客户端地址 
getRemoteAddr()：获取客户端的IP地址 
getRemoteHost()：获取客户端的名字 
getSession([Boolean create])：返回和请求相关Session 
getServerName()：获取服务器的名字 
getServletPath()：获取客户端所请求的脚本文件的路径 
getServerPort()：获取服务器的端口号 
removeAttribute(String name)：删除请求中的一个属性 



19、forward 和redirect的区别 
forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 
   redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。
4、request.getAttribute() 和 request.getParameter() 有何区别?
1. jsp有哪些内置对象?作用分别是什么? 分别有什么方法？ 
答:JSP共有以下9个内置的对象： 
request 用户端请求，此请求会包含来自GET/POST请求的参数 
response 网页传回用户端的回应 
pageContext 网页的属性是在这里管理 
session 与请求有关的会话期 
application servlet 正在执行的内容 
out 用来传送回应的输出 
config servlet的构架部件 
page JSP网页本身 
exception 针对错误网页，未捕捉的例外 

request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。 
   response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等） 
   out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 
   pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 
   session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 
   applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 
   config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 
   page表示从该页面产生的一个servlet实例 

2. jsp有哪些动作?作用分别是什么? 
（这个问题似乎不重要，不明白为何有此题）
答:JSP共有以下6种基本动作 
jsp:include：在页面被请求的时候引入一个文件。 
jsp:useBean：寻找或者实例化一个JavaBean。 
jsp:setProperty：设置JavaBean的属性。 
jsp:getProperty：输出某个JavaBean的属性。 
jsp:forward：把请求转到一个新的页面。 
jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记
59、JSP的常用指令 
isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式) 

3. JSP中动态INCLUDE与静态INCLUDE的区别？ 
答：动态INCLUDE用jsp:include动作实现 
<jsp:include page=included.jsp flush=true />它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数 静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 <%@ include file=included.htm %> 

4、两种跳转方式分别是什么?有什么区别? 
（下面的回答严重错误，应该是想问forward和sendRedirect 的区别，毕竟出题的人不是专业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推敲原始题目的具体含义是什么，不要一味想着是在答题）
答：有两种，分别为： 
<jsp:include page=included.jsp flush=true> 
<jsp:forward page= nextpage.jsp/> 
前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。

63、页面间对象传递的方法 
request，session，application，cookie等 
64、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？ 
JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是"类servlet"。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。 

1、MVC的各个部分都有那些技术来实现?如何实现? 
答:MVC是Model－View－Controller的简写。Model 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， View 是应用的表示面（由JSP页面产生），Controller 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 

68、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ 
 Public String translate (String str) { 
   String tempStr = ""; 
   try { 
     tempStr = new String(str.getBytes("ISO-8859-1"), "GBK"); 
     tempStr = tempStr.trim(); 
   } 
   catch (Exception e) { 
     System.err.println(e.getMessage()); 
   } 
   return tempStr; 
 } 
1．现在输入n个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一页面显示按什么排序，结果为，提供reset
7. 实际项目开发
1、在eclipse中调试时，怎样查看一个变量的值？
在要查看的变量前先设置断点，然后选中变量，右键选debug as-->Java Application，打开debug透视图，这时在Variables窗口中可以看到变量当前的值。
如果是局部变量，也可以在局部变量窗口中查看。
要知道一个方法被调用的方法调用链，可以在方法栈中查看。

2、你们公司使用的代码配置管理工具是什么？ 
除了说以前使用cvs，现在新项目使用svn了，还简要说一下使用的过程，如果有可能，还说说仓库的概念和如何使用锁之类的细节。

3、你们的项目总金额多少，多少人开发，总共花了多少个月？
像巴巴运动网这种规模的项目，可以说是4、5个人、开发了4、5个月，费用则是4、50万。按每人每月两万收入去计算，就差不多了。

7. 数据库部分
1、用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。
employee:
     eid,ename,salary,deptid;
 select * from employee order by deptid desc,salary


2、列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序
创建表：
       mysql> create table employee921(id int primary key auto_increment,name varchar(5
0),salary bigint,deptid int);

插入实验数据：
mysql> insert into employee921 values(null,'zs',1000,1),(null,'ls',1100,1),(null
,'ww',1100,1),(null,'zl',900,1) ,(null,'zl',1000,2), (null,'zl',900,2) ,(null,'z
l',1000,2) , (null,'zl',1100,2);

编写sql语句：

（）select avg(salary) from employee921 group by deptid;
（）mysql> select employee921.id,employee921.name,employee921.salary,employee921.dep
tid tid from  employee921 where salary > (select avg(salary) from employee921 where  deptid = tid);
   效率低的一个语句，仅供学习参考使用（在group by之后不能使用where，只能使用having，在group by之前可以使用where，即表示对过滤后的结果分组）：
mysql> select employee921.id,employee921.name,employee921.salary,employee921.dep
tid tid from  employee921 where salary > (select avg(salary) from employee921 group by deptid having deptid = tid);
（）select count(*) ,tid 
	from (
		select employee921.id,employee921.name,employee921.salary,employee921.deptid tid 
		from  	employee921 
		where salary >
	 		(select avg(salary) from employee921 where  deptid = tid)
	) as t 
	group by tid ;

另外一种方式：关联查询
select a.ename,a.salary,a.deptid 
 from emp a,
    (select deptd,avg(salary) avgsal from emp group by deptid ) b 
 where a.deptid=b.deptid and a.salary>b.avgsal;
1、存储过程与触发器必须讲，经常被面试到?
create procedure insert_Student (_name varchar(50),_age int ,out _id int)
begin
	insert into student value(null,_name,_age);
	select max(stuId) into _id from student;
end;

call insert_Student('wfz',23,@id);
select @id;

mysql> create trigger update_Student BEFORE update on student FOR EACH ROW
-> select * from student;
触发器不允许返回结果

create trigger update_Student BEFORE update on student FOR EACH ROW  
insert into  student value(null,'zxx',28);
mysql的触发器目前不能对当前表进行操作

create trigger update_Student BEFORE update on student FOR EACH ROW  
delete from articles  where id=8;
这个例子不是很好，最好是用删除一个用户时，顺带删除该用户的所有帖子
这里要注意使用OLD.id

触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而UCH没有用触发器，效率和数据处理能力都很低。
存储过程的实验步骤：
mysql> delimiter |
mysql> create procedure insertArticle_Procedure (pTitle varchar(50),pBid int,out
 pId int)
    -> begin
    -> insert into article1 value(null,pTitle,pBid);
    -> select max(id) into pId from article1;
    -> end;
    -> |
Query OK, 0 rows affected (0.05 sec)

mysql> call insertArticle_Procedure('传智播客',1,@pid);
    -> |
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql> select @pid;
+------+
| @pid |
+------+
| 3    |
+------+
1 row in set (0.00 sec)

mysql> select * from article1;
+----+--------------+------+
| id | title        | bid  |
+----+--------------+------+
| 1  | test         | 1    |
| 2  | chuanzhiboke | 1    |
| 3  | 传智播客     | 1    |
+----+--------------+------+
3 rows in set (0.00 sec)

触发器的实验步骤：
create table board1(id int primary key auto_increment,name varchar(50),ar
ticleCount int);

create table article1(id int primary key auto_increment,title varchar(50)
,bid int references board1(id));

delimiter |

create trigger insertArticle_Trigger after insert on article1 for each ro
w begin
    -> update board1 set articleCount=articleCount+1 where id= NEW.bid;
    -> end;
    -> |

delimiter ;

insert into board1 value (null,'test',0);

insert into article1 value(null,'test',1);
还有，每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，用触发器做效率就很高。下次课设计这样一个案例，写触发器时，对于最后发帖时间可能需要用declare方式声明一个变量，或者是用NEW.posttime来生成。

1、数据库三范式是什么?
第一范式（1NF）：字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式）
	数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。

  第二范式（2NF）：
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。
要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。

第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。
  
 第三范式的要求如下： 
满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
所以第三范式具有如下特征：
         1，每一列只有一个值 
         2，每一行都能区分。 
         3，每一个表都不包含其他表已经包含的非主关键字信息。
例如，帖子表中只能出现发帖人的id，而不能出现发帖人的id，还同时出现发帖人姓名，否则，只要出现同一发帖人id的所有记录，它们中的姓名部分都必须严格保持一致，这就是数据冗余。

1、说出一些数据库优化方面的经验?
用PreparedStatement 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存
“inert into user values(1,1,1)”-二进制
“inert into user values(2,2,2)”-二进制
“inert into user values(?,?,?)”-二进制



有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。（比喻：就好比免检产品，就是为了提高效率，充分相信产品的制造商）
（对于hibernate来说，就应该有一个变化：empleyee->Deptment对象，现在设计时就成了employeedeptid）

看mysql帮助文档子查询章节的最后部分，例如，根据扫描的原理，下面的子查询语句要比第二条关联查询的效率高：
1.  select e.name,e.salary where e.managerid=(select id from employee where name='zxx');

2.   select e.name,e.salary,m.name,m.salary from employees e,employees m where
 e.managerid = m.id and m.name='zxx';

表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等
将姓名和密码单独从用户表中独立出来。这可以是非常好的一对一的案例哟！

sql语句全部大写，特别是列名和表名都大写。特别是sql命令的缓存功能，更加需要统一大小写，sql语句发给oracle服务器语法检查和编译成为内部指令缓存和执行指令。根据缓存的特点，不要拼凑条件，而是用?和PreparedStatment

还有索引对查询性能的改进也是值得关注的。

备注：下面是关于性能的讨论举例

4航班 3个城市

m*n

select * from flight,city where flight.startcityid=city.cityid and city.name='beijing';

m + n


select * from flight where startcityid = (select cityid from city where cityname='beijing');

select flight.id,'beijing',flight.flightTime from flight where startcityid = (select cityid from city where cityname='beijing')
2、union和union all有什么不同?
假设我们有一个表Student，包括以下字段与数据：
drop table student;
create table student
(
id int primary key,
name nvarchar2(50) not null,
score number not null
);
insert into student values(1,'Aaron',78);
insert into student values(2,'Bill',76);
insert into student values(3,'Cindy',89);
insert into student values(4,'Damon',90);
insert into student values(5,'Ella',73);
insert into student values(6,'Frado',61);
insert into student values(7,'Gill',99);
insert into student values(8,'Hellen',56);
insert into student values(9,'Ivan',93);
insert into student values(10,'Jay',90);
commit;
Union和Union All的区别。 
select *
from student
where id < 4
union
select *
from student
where id > 2 and id < 6
结果将是
1    Aaron    78
2    Bill    76
3    Cindy    89
4    Damon    90
5    Ella    73
如果换成Union All连接两个结果集，则返回结果是：
1    Aaron    78
2    Bill    76
3    Cindy    89
3    Cindy    89
4    Damon    90
5    Ella    73
可以看到，Union和Union All的区别之一在于对重复结果的处理。

　　UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。如：
select * from gc_dfys
union
select * from ls_jg_dfys
　　这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。
　而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。
　从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL，
3.分页语句
取出sql表中第31到40的记录（以自动增长ID为主键）
sql server方案1：
	select top 10 * from t where id not in (select top 30 id from t order by id ) orde by id
sql server方案2：
	select top 10 * from t where id in (select top 40 id from t order by id) order by id desc

mysql方案：select * from t order by id limit 30,10

oracle方案：select * from (select rownum r,* from t where r<=40) where r>30

--------------------待整理进去的内容-------------------------------------
pageSize=20;
pageNo = 5;

1.分页技术1（直接利用sql语句进行分页，效率最高和最推荐的）

mysql:sql = "select * from articles limit " + (pageNo-1)*pageSize + "," + pageSize;
oracle: sql = "select * from " +
								"(select rownum r,* from " +
									"(select * from articles order by postime desc)" +
								"where rownum<= " + pageNo*pageSize +") tmp " +
							"where r>" + (pageNo-1)*pageSize;
注释：第7行保证rownum的顺序是确定的，因为oracle的索引会造成rownum返回不同的值
简洋提示：没有order by时，rownum按顺序输出，一旦有了order by，rownum不按顺序输出了，这说明rownum是排序前的编号。如果对order by从句中的字段建立了索引，那么，rownum也是按顺序输出的，因为这时候生成原始的查询结果集时会参照索引表的顺序来构建。

sqlserver:sql = "select top 10 * from id not id(select top " + (pageNo-1)*pageSize + "id from articles)"

DataSource ds = new InitialContext().lookup(jndiurl);
Connection cn = ds.getConnection();
//"select * from user where id=?"  --->binary directive
PreparedStatement pstmt = cn.prepareSatement(sql);
ResultSet rs = pstmt.executeQuery()
while(rs.next())
{
	out.println(rs.getString(1));
}

2.不可滚动的游标
pageSize=20;
pageNo = 5;
cn = null
stmt = null;
rs = null;
try
{
sqlserver:sql = "select  * from articles";

DataSource ds = new InitialContext().lookup(jndiurl);
Connection cn = ds.getConnection();
//"select * from user where id=?"  --->binary directive
PreparedStatement pstmt = cn.prepareSatement(sql);
ResultSet rs = pstmt.executeQuery()
for(int j=0;j<(pageNo-1)*pageSize;j++)
{
	rs.next();
}

int i=0;

while(rs.next() && i<10)
{
	i++;
	out.println(rs.getString(1));
}
}
cacth(){}
finnaly
{
	if(rs!=null)try{rs.close();}catch(Exception e){}
	if(stm.........
	if(cn............
}

3.可滚动的游标
pageSize=20;
pageNo = 5;
cn = null
stmt = null;
rs = null;
try
{
sqlserver:sql = "select  * from articles";

DataSource ds = new InitialContext().lookup(jndiurl);
Connection cn = ds.getConnection();
//"select * from user where id=?"  --->binary directive
PreparedStatement pstmt = cn.prepareSatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,...);
//根据上面这行代码的异常SQLFeatureNotSupportedException，就可判断驱动是否支持可滚动游标

ResultSet rs = pstmt.executeQuery()
rs.absolute((pageNo-1)*pageSize)
int i=0;
while(rs.next() && i<10)
{
	i++;
	out.println(rs.getString(1));
}
}
cacth(){}
finnaly
{
	if(rs!=null)try{rs.close();}catch(Exception e){}
	if(stm.........
	if(cn............
}
3.用一条SQL语句 查询出每门课都大于80分的学生姓名  
name   kecheng   fenshu 
张三     语文       81
张三     数学       75
李四     语文       76
李四     数学       90
王五     语文       81
王五     数学       100
王五     英语       90

准备数据的sql代码：
create table score(id int primary key auto_increment,name varchar(20),subject varchar(20),score int);
insert into score values 
(null,'张三','语文',81),
(null,'张三','数学',75),
(null,'李四','语文',76),
(null,'李四','数学',90),
(null,'王五','语文',81),
(null,'王五','数学',100),
(null,'王五 ','英语',90);

提示：当百思不得其解时，请理想思维，把小变成大做，把大变成小做，

答案：
A: select distinct name from score  where  name not in (select distinct name from score where score<=80)

B:select distince name t1 from score where 80< all (select score from score where name=t1);

4.所有部门之间的比赛组合
一个叫department的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球对，现在四个球对进行比赛，用一条sql语句显示所有可能的比赛组合.

答：select a.name, b.name 
from team a, team b 
where a.name < b.name

4.每个月份的发生额都比101科目多的科目
请用SQL语句实现：从TestDB数据表中查询出所有月份的发生额都比101科目相应月份的发生额高的科目。请注意：TestDB中有很多科目，都有1－12月份的发生额。
AccID：科目代码，Occmonth：发生额月份，DebitOccur：发生额。
数据库名：JcyAudit，数据集：Select * from TestDB
准备数据的sql代码：
drop table if exists TestDB;
create table TestDB(id int primary key auto_increment,AccID varchar(20), Occmonth date, DebitOccur bigint);
insert into TestDB values 
(null,'101','1988-1-1',100),
(null,'101','1988-2-1',110),
(null,'101','1988-3-1',120),
(null,'101','1988-4-1',100),
(null,'101','1988-5-1',100),
(null,'101','1988-6-1',100),
(null,'101','1988-7-1',100),
(null,'101','1988-8-1',100);
--复制上面的数据，故意把第一个月份的发生额数字改小一点
insert into TestDB values 
(null,'102','1988-1-1',90),
(null,'102','1988-2-1',110),
(null,'102','1988-3-1',120),
(null,'102','1988-4-1',100),
(null,'102','1988-5-1',100),
(null,'102','1988-6-1',100),
(null,'102','1988-7-1',100),
(null,'102','1988-8-1',100);
--复制最上面的数据，故意把所有发生额数字改大一点
insert into TestDB values 
(null,'103','1988-1-1',150),
(null,'103','1988-2-1',160),
(null,'103','1988-3-1',180),
(null,'103','1988-4-1',120),
(null,'103','1988-5-1',120),
(null,'103','1988-6-1',120),
(null,'103','1988-7-1',120),
(null,'103','1988-8-1',120);
--复制最上面的数据，故意把所有发生额数字改大一点
insert into TestDB values 
(null,'104','1988-1-1',130),
(null,'104','1988-2-1',130),
(null,'104','1988-3-1',140),
(null,'104','1988-4-1',150),
(null,'104','1988-5-1',160),
(null,'104','1988-6-1',170),
(null,'104','1988-7-1',180),
(null,'104','1988-8-1',140);
--复制最上面的数据，故意把第二个月份的发生额数字改小一点
insert into TestDB values 
(null,'105','1988-1-1',100),
(null,'105','1988-2-1',80),
(null,'105','1988-3-1',120),
(null,'105','1988-4-1',100),
(null,'105','1988-5-1',100),
(null,'105','1988-6-1',100),
(null,'105','1988-7-1',100),
(null,'105','1988-8-1',100);
答案：
select distinct AccID from TestDB 
where AccID not in 
	(select TestDB.AccIDfrom TestDB,
		 (select * from TestDB where AccID='101') as db101 
	where TestDB.Occmonth=db101.Occmonth and TestDB.DebitOccur<=db101.DebitOccur
	);

4.统计每年每月的信息
year  month amount
1991   1     1.1
1991   2     1.2
1991   3     1.3
1991   4     1.4
1992   1     2.1
1992   2     2.2
1992   3     2.3
1992   4     2.4
查成这样一个结果
year m1  m2  m3  m4
1991 1.1 1.2 1.3 1.4
1992 2.1 2.2 2.3 2.4 

提示：这个与工资条非常类似，与学生的科目成绩也很相似。

准备sql语句：
drop table if exists sales;
create table sales(id int auto_increment primary key,year varchar(10), month varchar(10), amount float(2,1));
insert into sales values
(null,'1991','1',1.1),
(null,'1991','2',1.2),
(null,'1991','3',1.3),
(null,'1991','4',1.4),
(null,'1992','1',2.1),
(null,'1992','2',2.2),
(null,'1992','3',2.3),
(null,'1992','4',2.4);

答案一、
select sales.year ,
(select t.amount from sales t where t.month='1' and t.year= sales.year) '1',
(select t.amount from sales t where t.month='1' and t.year= sales.year) '2',
(select t.amount from sales t where t.month='1' and t.year= sales.year) '3',
(select t.amount from sales t where t.month='1' and t.year= sales.year) as '4' 
from sales  group by year;

5.显示文章标题，发帖人、最后回复时间
表：id,title,postuser,postdate,parentid
准备sql语句：
drop table if exists articles;
create table articles(id int auto_increment primary key,title varchar(50), postuser varchar(10), postdate datetime,parentid int references articles(id));
insert into articles values
(null,'第一条','张三','1998-10-10 12:32:32',null),
(null,'第二条','张三','1998-10-10 12:34:32',null),
(null,'第一条回复1','李四','1998-10-10 12:35:32',1),
(null,'第二条回复1','李四','1998-10-10 12:36:32',2),
(null,'第一条回复2','王五','1998-10-10 12:37:32',1),
(null,'第一条回复3','李四','1998-10-10 12:38:32',1),
(null,'第二条回复2','李四','1998-10-10 12:39:32',2),
(null,'第一条回复4','王五','1998-10-10 12:39:40',1);

答案：
select a.title,a.postuser,
	(select max(postdate) from articles where parentid=a.id) reply 
from articles a where a.parentid is null;

注释：子查询可以用在选择列中，也可用于where的比较条件中，还可以用于from从句中。
3.删除除了id号不同,其他都相同的学生冗余信息
2.学生表 如下:
id号   学号   姓名 课程编号 课程名称 分数
1        2005001  张三  0001      数学    69
2        2005002  李四  0001      数学    89
3        2005001  张三  0001      数学    69
A: delete from tablename where id号 not in(select min(id号) from tablename group by 学号,姓名,课程编号,课程名称,分数)
实验：
create table student2(id int auto_increment primary key,code varchar(20),name varchar(20));
insert into student2 values(null,'2005001','张三'),(null,'2005002','李四'),(null,'2005001','张三');

//如下语句，mysql报告错误，可能删除依赖后面统计语句，而删除又导致统计语句结果不一致。

delete from student2 where id not in(select min(id) from student2 group by name);
//但是，如下语句没有问题：
select *  from student2 where id not in(select min(id) from student2 group by name);
//于是，我想先把分组的结果做成虚表，然后从虚表中选出结果，最后再将结果作为删除的条件数据。
delete from student2 where id not in(select mid from (select min(id) mid
from student2 group by name) as t);
或者：
delete from student2 where id not in(select min(id) from (select * from s
tudent2) as t group by t.name);
4.航空网的几个航班查询题：
表结构如下：
flight{flightID,StartCityID ,endCityID,StartTime}
city{cityID, CityName)
实验环境：
create table city(cityID int auto_increment primary key,cityName varchar(20));
create table flight (flightID int auto_increment primary key,
	StartCityID int references city(cityID),
	endCityID  int references city(cityID),
	StartTime timestamp); 
//航班本来应该没有日期部分才好，但是下面的题目当中涉及到了日期
insert into city values(null,'北京'),(null,'上海'),(null,'广州');
insert into flight values
	(null,1,2,'9:37:23'),(null,1,3,'9:37:23'),(null,1,2,'10:37:23'),(null,2,3,'10:37:23');


1、查询起飞城市是北京的所有航班，按到达城市的名字排序


参与运算的列是我起码能够显示出来的那些列，但最终我不一定把它们显示出来。各个表组合出来的中间结果字段中必须包含所有运算的字段。

  select  * from flight f,city c 
	where f.endcityid = c.cityid and startcityid = 
	(select c1.cityid from city c1 where c1.cityname = "北京")
	order by c.cityname asc;

mysql> select flight.flightid,'北京' startcity, e.cityname from flight,city e wh
ere flight.endcityid=e.cityid and flight.startcityid=(select cityid from city wh
ere cityname='北京');

mysql> select flight.flightid,s.cityname,e.cityname from flight,city s,city e wh
ere flight.startcityid=s.cityid and s.cityname='北京' and flight.endCityId=e.cit
yID order by e.cityName desc;


2、查询北京到上海的所有航班纪录（起飞城市，到达城市，起飞时间，航班号）
select c1.CityName,c2.CityName,f.StartTime,f.flightID
from city c1,city c2,flight f
where f.StartCityID=c1.cityID 
and f.endCityID=c2.cityID
and c1.cityName='北京'
and c2.cityName='上海'
3、查询具体某一天（2005-5-8）的北京到上海的的航班次数
select count(*) from 
(select c1.CityName,c2.CityName,f.StartTime,f.flightID
from city c1,city c2,flight f
where f.StartCityID=c1.cityID 
and f.endCityID=c2.cityID
and c1.cityName='北京'
and c2.cityName='上海'
and 查帮助获得的某个日期处理函数(startTime) like '2005-5-8%'

mysql中提取日期部分进行比较的示例代码如下：
select * from flight where date_format(starttime,'%Y-%m-%d')='1998-01-02'
5.查出比经理薪水还高的员工信息：
Drop table if not exists employees;
create table employees(id int primary key auto_increment,name varchar(50)
,salary int,managerid int references employees(id));
insert into employees values (null,' lhm',10000,null), (null,' zxx',15000,1
),(null,'flx',9000,1),(null,'tg',10000,2),(null,'wzg',10000,3);

Wzg大于flx,lhm大于zxx

解题思路：
     根据sql语句的查询特点，是逐行进行运算，不可能两行同时参与运算。
涉及了员工薪水和经理薪水，所有，一行记录要同时包含两个薪水，所有想到要把这个表自关联组合一下。
     首先要组合出一个包含有各个员工及该员工的经理信息的长记录，譬如，左半部分是员工，右半部分是经理。而迪卡尔积会组合出很多垃圾信息，先去除这些垃圾信息。

select e.* from employees e,employees m where e.managerid=m.id and e.sala
ry>m.salary;
6、求出小于45岁的各个老师所带的大于12岁的学生人数
数据库中有3个表 teacher 表，student表，tea_stu关系表。 
teacher 表 teaID name age 
student 表 stuID name age 
teacher_student表 teaID stuID 
要求用一条sql查询出这样的结果 
1.显示的字段要有老师name, age 每个老师所带的学生人数 
2 只列出老师age为40以下，学生age为12以上的记录
预备知识：
      1.sql语句是对每一条记录依次处理，条件为真则执行动作（select,insert,delete,update）
       2.只要是迪卡尔积，就会产生“垃圾”信息，所以，只要迪卡尔积了，我们首先就要想到清除“垃圾”信息
实验准备：
	drop table if exists tea_stu;
	drop table if exists teacher;
	drop table if exists student;
      create table teacher(teaID int primary key,name varchar(50),age int);
      create table student(stuID int primary key,name varchar(50),age int);
      create table tea_stu(teaID int references teacher(teaID),stuID int references student(stuID));
insert into teacher values(1,'zxx',45), (2,'lhm',25) , (3,'wzg',26) , (4,'tg',27);
insert into student values(1,'wy',11), (2,'dh',25) , (3,'ysq',26) , (4,'mxc',27);
insert into tea_stu values(1,1), (1,2), (1,3);
insert into tea_stu values(2,2), (2,3), (2,4);
 insert into tea_stu values(3,3), (3,4), (3,1);
insert into tea_stu values(4,4), (4,1), (4,2) , (4,3);

结果：23,32,43

解题思路：（真实面试答题时，也要写出每个分析步骤，如果纸张不够，就找别人要）
1要会统计分组信息，统计信息放在中间表中：
select teaid,count(*) from tea_stu group by teaid;

2接着其实应该是筛除掉小于12岁的学生，然后再进行统计，中间表必须与student关联才能得到12岁以下学生和把该学生记录从中间表中剔除，代码是：
select tea_stu.teaid,count(*) total from student,tea_stu 
where student.stuid=tea_stu.stuid and student.age>12 group by tea_stu.teaid

3.接着把上面的结果做成虚表与teacher进行关联，并筛除大于45的老师
select teacher.teaid,teacher.name,total from teacher ,(select tea_stu.tea
id,count(*) total from student,tea_stu where student.stuid=tea_stu.stuid and stu
dent.age>12 group by tea_stu.teaid) as tea_stu2 where teacher.teaid=tea_stu2.tea
id and teacher.age<45;


7.求出发帖最多的人：
select authorid,count(*) total from articles 
group by authorid 
having total=
(select max(total2) from (select count(*) total2 from articles group by authorid) as t);

select t.authorid,max(t.total) from
（select authorid,count(*) total from articles ）as t
这条语句不行，因为max只有一列，不能与其他列混淆。

select authorid,count(*) total from articles 
group by authorid having total=max(total)也不行。

10、一个用户表中有一个积分字段，假如数据库中有100多万个用户，若要在每年第一天凌晨将积分清零，你将考虑什么，你将想什么办法解决?
alter table drop column score;
alter table add colunm score int;
可能会很快，但是需要试验，试验不能拿真实的环境来操刀，并且要注意，
这样的操作时无法回滚的，在我的印象中，只有inert update delete等DML语句才能回滚，
对于create table,drop table ,alter table等DDL语句是不能回滚。


解决方案一，update user set score=0; 
解决方案二，假设上面的代码要执行好长时间，超出我们的容忍范围，那我就alter table user drop column score;alter table user add column score int。

下面代码实现每年的那个凌晨时刻进行清零。
Runnable runnable = 
	new Runnable(){
		public void run(){
			clearDb();
			schedule(this,new Date(new Date().getYear()+1,0,0));
			}		
			};

schedule(runnable,
	new Date(new Date().getYear()+1,0,1));

10、一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。
select count(*) as num,tb.id 
from 
 tb,
 (select role from tb where id=xxx) as t1
where
 tb.role = t1.role and tb.id != t1.id
group by tb.id 
having 
	num = select count(role) from tb where id=xxx;
8. xxx公司的sql面试
Table EMPLOYEES Structure:
EMPLOYEE_ID      NUMBER        Primary Key,
FIRST_NAME       VARCHAR2(25),
LAST_NAME       VARCHAR2(25),
Salary number(8,2),
HiredDate DATE,
Departmentid number(2)
Table Departments Structure:
Departmentid number(2)        Primary Key,
DepartmentName  VARCHAR2(25).

 (2）基于上述EMPLOYEES表写出查询：写出雇用日期在今年的，或者工资在[1000,2000]之间的，或者员工姓名（last_name）以’Obama’打头的所有员工，列出这些员工的全部个人信息。（4分）
select * from employees 
where Year(hiredDate) = Year(date()) 
	or (salary between 1000 and 200)
	or left(last_name,3)='abc';

(3) 基于上述EMPLOYEES表写出查询：查出部门平均工资大于1800元的部门的所有员工，列出这些员工的全部个人信息。（4分）
mysql> select id,name,salary,deptid did from employee1 where (select avg(salary)
 from employee1 where deptid = did) > 1800;

(4) 基于上述EMPLOYEES表写出查询：查出个人工资高于其所在部门平均工资的员工，列出这些员工的全部个人信息及该员工工资高出部门平均工资百分比。（5分）
select employee1.*,(employee1.salary-t.avgSalary)*100/employee1.salary 
from employee1,
	(select deptid,avg(salary) avgSalary from employee1 group by deptid) as t
where employee1.deptid = t.deptid and employee1.salary>t.avgSalary;

1、注册Jdbc驱动程序的三种方式

1、用JDBC如何调用存储过程
代码如下：
package com.huawei.interview.lym;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Types;

public class JdbcTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Connection cn = null;
		CallableStatement cstmt = null;		
		try {
			//这里最好不要这么干，因为驱动名写死在程序中了
			Class.forName("com.mysql.jdbc.Driver");
			//实际项目中，这里应用DataSource数据，如果用框架，
			//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()
			//cn = ds.getConnection();			
			cn = DriverManager.getConnection("jdbc:mysql:///test","root","root");
			cstmt = cn.prepareCall("{call insert_Student(?,?,?)}");
			cstmt.registerOutParameter(3,Types.INTEGER);
			cstmt.setString(1, "wangwu");
			cstmt.setInt(2, 25);
			cstmt.execute();
			//get第几个，不同的数据库不一样，建议不写
			System.out.println(cstmt.getString(3));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		finally
		{

			/*try{cstmt.close();}catch(Exception e){}
			try{cn.close();}catch(Exception e){}*/
			try {
				if(cstmt != null)
					cstmt.close();
				if(cn != null)				
					cn.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
1、JDBC中的PreparedStatement相比Statement的好处
答：一个sql命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓存指令，执行指令等过程。
select * from student where id =3----缓存--xxxxx二进制命令
select * from student where id =3----直接取-xxxxx二进制命令
select * from student where id =4--- -会怎么干？
如果当初是select * from student where id =?--- -又会怎么干？
 上面说的是性能提高
可以防止sql注入。
1. 写一个用jdbc连接并访问oracle数据的程序代码
2、Class.forName的作用?为什么要用? 
答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，则返回代表该字节码的Class实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则抛出ClassNotFoundException。加载完这个Class字节码后，接着就可以使用Class字节码的newInstance方法去创建该类的实例对象了。
有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时才能确定，这时候就需要使用Class.forName去动态加载该类，这个类名通常是在配置文件中配置的，例如，spring的ioc中每次依赖注入的具体类就是这样配置的，jdbc的驱动类名通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类名。
3、大数据量下的分页解决方法。
答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。再sql语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取某页的数据。
sql语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页sql：
sql server:
	String sql = 
	"select top " + pageSize + " * from students where id not in" +

 "(select top " + pageSize * (pageNumber-1) + " id from students order by id)" + 
 
 "order by id";

mysql:
  
	String sql = 
	"select * from students order by id limit " + pageSize*(pageNumber-1) + "," + pageSize;
	
oracle:
 
	String sql = 
	 "select * from " +  
	 (select *,rownum rid from (select * from students order by postime desc) where rid<=" + pagesize*pagenumber + ") as t" + 
	 "where t>" + pageSize*(pageNumber-1);
4、用 JDBC 查询学生成绩单, 把主要代码写出来（考试概率极大）. 
Connection cn = null;
PreparedStatement pstmt =null;
Resultset rs = null;
try
{
	Class.forname(driveClassName);
	cn =  DriverManager.getConnection(url,username,password);
	pstmt = cn.prepareStatement(“select  score.* from score ,student “ + 
		“where score.stuId = student.id and student.name = ?”);
	pstmt.setString(1,studentName);
	Resultset rs = pstmt.executeQuery();
	while(rs.next())
	{
		system.out.println(rs.getInt(“subject”)  +  “    ” + rs.getFloat(“score”) );
	}
}catch(Exception e){e.printStackTrace();}
finally
{
	if(rs != null) try{ rs.close() }catch(exception e){}
	if(pstmt != null) try{pstmt.close()}catch(exception e){}
	if(cn != null) try{ cn.close() }catch(exception e){}
}


5、这段代码有什么不足之处? 
try {
Connection conn = ...;
Statement stmt = ...;
ResultSet rs = stmt.executeQuery("select * from table1");
while(rs.next()) {
}
} catch(Exception ex) {
} 
答：没有finally语句来关闭各个对象，另外，使用finally之后，要把变量的定义放在try语句块的外面，以便在try语句块之外的finally块中仍可以访问这些变量。

36、说出数据连接池的工作机制是什么? 
J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 
实现方式，返回的Connection是原始Connection的代理，代理Connection的close方法不是真正关连接，而是把它代理的Connection对象还回到连接池中。

4、为什么要用 ORM?  和 JDBC 有何不一样? 
orm是一种思想，就是把object转变成数据库中的记录，或者把数据库中的记录转变成objecdt，我们可以用jdbc来实现这种思想，其实，如果我们的项目是严格按照oop方式编写的话，我们的jdbc程序不管是有意还是无意，就已经在实现orm的工作了。
现在有许多orm工具，它们底层调用jdbc来实现了orm工作，我们直接使用这些工具，就省去了直接使用jdbc的繁琐细节，提高了开发效率，现在用的较多的orm工具是hibernate。也听说一些其他orm工具，如toplink,ojb等。 
8. XML部分
1、xml有哪些解析技术?区别是什么? 
答:有DOM,SAX,STAX等 
DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 
STAX:Streaming API for XML (StAX) 
讲解这些区别是不需要特别去比较，就像说传智播客与其他培训机构的区别时，我们只需说清楚传智播客有什么特点和优点就行了，这就已经间接回答了彼此的区别。

2、你在项目中用到了xml技术的哪些方面?如何实现的? 
答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。 
3、用jdom解析xml文件时如何解决中文问题?如何解析? 
答:看如下代码,用编码方式加以解决 
package test; 
import java.io.*; 
public class DOMTest 
{ 
private String inFile = "c:\\people.xml" 
private String outFile = "c:\\people.xml" 
public static void main(String args[]) 
{ 
new DOMTest(); 
} 
public DOMTest() 
{ 
try 
{ 
javax.xml.parsers.DocumentBuilder builder = 
javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder(); 
org.w3c.dom.Document doc = builder.newDocument(); 
org.w3c.dom.Element root = doc.createElement("老师"); 
org.w3c.dom.Element wang = doc.createElement("王"); 
org.w3c.dom.Element liu = doc.createElement("刘"); 
wang.appendChild(doc.createTextNode("我是王老师")); 
root.appendChild(wang); 
doc.appendChild(root); 
javax.xml.transform.Transformer transformer = 
javax.xml.transform.TransformerFactory.newInstance().newTransformer(); 
transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, "gb2312"); 
transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, "yes"); 
transformer.transform(new javax.xml.transform.dom.DOMSource(doc), 
new 
javax.xml.transform.stream.StreamResult(outFile)); 
} 
catch (Exception e) 
{ 
System.out.println (e.getMessage()); 
} 
} 
} 
4、编程用JAVA解析XML的方式. 
答:用SAX方式解析XML，XML文件如下： 
<?xml version=1.0 encoding=gb2312?> 
<person> 
<name>王小明</name> 
<college>信息学院</college> 
<telephone>6258113</telephone> 
<notes>男,1955年生,博士，95年调入海南大学</notes> 
</person> 
事件回调类SAXHandler.java 
import java.io.*; 
import java.util.Hashtable; 
import org.xml.sax.*; 
public class SAXHandler extends HandlerBase 
{ 
private Hashtable table = new Hashtable(); 
private String currentElement = null; 
private String currentValue = null; 
public void setTable(Hashtable table) 
{ 
this.table = table; 
} 
public Hashtable getTable() 
{ 
return table; 
} 
public void startElement(String tag, AttributeList attrs) 
throws SAXException 
{ 
currentElement = tag; 
} 
public void characters(char[] ch, int start, int length) 
throws SAXException 
{ 
currentValue = new String(ch, start, length); 
} 
public void endElement(String name) throws SAXException 
{ 
if (currentElement.equals(name)) 
table.put(currentElement, currentValue); 
} 

} 
JSP内容显示源码,SaxXml.jsp: 
<HTML> 
<HEAD> 
<TITLE>剖析XML文件people.xml</TITLE> 
</HEAD> 
<BODY> 
<%@ page errorPage=ErrPage.jsp 
contentType=text/html;charset=GB2312 %> 
<%@ page import=java.io.* %> 
<%@ page import=java.util.Hashtable %> 
<%@ page import=org.w3c.dom.* %> 
<%@ page import=org.xml.sax.* %> 
<%@ page import=javax.xml.parsers.SAXParserFactory %> 
<%@ page import=javax.xml.parsers.SAXParser %> 
<%@ page import=SAXHandler %> 
<% 
File file = new File(c:\people.xml); 
FileReader reader = new FileReader(file); 
Parser parser; 
SAXParserFactory spf = SAXParserFactory.newInstance(); 
SAXParser sp = spf.newSAXParser(); 
SAXHandler handler = new SAXHandler(); 
sp.parse(new InputSource(reader), handler); 
Hashtable hashTable = handler.getTable(); 
out.println(<TABLE BORDER=2><CAPTION>教师信息表</CAPTION>); 
out.println(<TR><TD>姓名</TD> + <TD> + 
(String)hashTable.get(new String(name)) + </TD></TR>); 
out.println(<TR><TD>学院</TD> + <TD> + 
(String)hashTable.get(new String(college))+</TD></TR>); 
out.println(<TR><TD>电话</TD> + <TD> + 
(String)hashTable.get(new String(telephone)) + </TD></TR>); 
out.println(<TR><TD>备注</TD> + <TD> + 
(String)hashTable.get(new String(notes)) + </TD></TR>); 
out.println(</TABLE>); 
%> 
</BODY> 
</HTML> 
70、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ 
a: 两种形式 dtd  schema，b: 本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)，c:有DOM,SAX,STAX等 
   DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问 
SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 
   STAX:Streaming API for XML (StAX) 

9. 流行的框架与新技术

1、谈谈你对Struts的理解。
答: 
1. struts是一个按MVC模式设计的Web层框架，其实它就是一个大大的servlet，这个Servlet名为ActionServlet，或是ActionServlet的子类。我们可以在web.xml文件中将符合某种特征的所有请求交给这个Servlet处理，这个Servlet再参照一个配置文件（通常为/WEB-INF/struts-config.xml）将各个请求分别分配给不同的action去处理。
一个扩展知识点：struts的配置文件可以有多个，可以按模块配置各自的配置文件，这样可以防止配置文件的过度膨胀；
2. ActionServlet把请求交给action去处理之前，会将请求参数封装成一个formbean对象（就是一个java类，这个类中的每个属性对应一个请求参数），封装成一个什么样的formbean对象呢？看配置文件。
3.要说明的是， ActionServlet把formbean对象传递给action的execute方法之前，可能会调用formbean的validate方法进行校验，只有校验通过后才将这个formbean对象传递给action的execute方法，否则，它将返回一个错误页面，这个错误页面由input属性指定，（看配置文件）作者为什么将这里命名为input属性，而不是error属性，我们后面结合实际的运行效果进行分析。
4.action执行完后要返回显示的结果视图，这个结果视图是用一个ActionForward对象来表示的，actionforward对象通过struts-config.xml配置文件中的配置关联到某个jsp页面，因为程序中使用的是在struts-config.xml配置文件为jsp页面设置的逻辑名，这样可以实现action程序代码与返回的jsp页面名称的解耦。

你对struts可能还有自己的应用方面的经验，那也要一并说出来。
2、谈谈你对Hibernate的理解。
答:
1. 面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差异就表现在内存中的对象状态发生了变化。
2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大量对象信息。从Java程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功能来说，应该是一个很不起眼的附属功能，java采用jdbc来实现这个功能，这个不起眼的功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的jdbc代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活和重复性的工作。
3.通过数据库保存java程序运行时产生的对象和恢复对象，其实就是实现了java对象与关系数据库记录的映射关系，称为ORM（即Object Relation Mapping），人们可以通过封装JDBC代码来实现了这种功能，封装出来的产品称之为ORM框架，Hibernate就是其中的一种流行ORM框架。使用Hibernate框架，不用写JDBC代码，仅仅是调用一个save方法，就可以将对象保存到关系数据库中，仅仅是调用一个get方法，就可以从数据库中加载出一个对象。
4.使用Hibernate的基本流程是：配置Configuration对象、产生SessionFactory、创建session对象，启动事务，完成CRUD操作，提交事务，关闭session。
5.使用Hibernate时，先要配置hibernate.cfg.xml文件，其中配置数据库连接信息和方言等，还要为每个实体配置相应的hbm.xml文件，hibernate.cfg.xml文件中需要登记每个hbm.xml文件。
6.在应用Hibernate时，重点要了解Session的缓存原理，级联，延迟加载和hql查询。
3、AOP的作用。
3、你对Spring的理解。
1.Spring实现了工厂模式的工厂类（在这里有必要解释清楚什么是工厂模式），这个类名为BeanFactory（实际上是一个接口），在程序中通常BeanFactory的子类ApplicationContext。Spring相当于一个大的工厂类，在其配置文件中通过<bean>元素配置用于创建实例对象的类名和实例对象的属性。
2. Spring提供了对IOC良好支持，IOC是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC也称为DI（Depency Injection），什么叫依赖注入呢？
譬如，Class Programmer
{
	Computer computer = null;
	public void code()
	{
		//Computer computer = new IBMComputer();
		//Computer computer = beanfacotry.getComputer();
		computer.write();
	}
	public void setComputer(Computer computer)
	{
		this.computer = computer;
	}
}
另外两种方式都由依赖，第一个直接依赖于目标类，第二个把依赖转移到工厂上，第三个彻底与目标和工厂解耦了。在spring的配置文件中配置片段如下：
<bean id=”computer” class=”cn.itcast.interview.Computer”>
</bean>

<bean id=”programmer” class=”cn.itcast.interview.Programmer”>
	<property name=”computer”  ref=”computer”></property>
</bean>
3. Spring提供了对AOP技术的良好封装， AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如，加入日志，加入权限判断，加入异常处理，这种应用称为AOP。实现AOP功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK中采用Proxy类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以Advice对象进行提供，显然要创建出代理对象，至少需要目标类和Advice类。spring提供了这种支持，只需要在spring配置文件中配置这两个元素即可实现代理和aop功能，例如，
<bean id=”proxy” type=”org.spring.framework.aop.ProxyBeanFactory”>
	<property name=”target” ref=””></property>
	<property name=”advisor” ref=””></property>

</bean>

11、谈谈Struts中的Action servlet。

12、Struts优缺点 
优点： 
 1. 实现MVC模式，结构清晰,使开发者只关注业务逻辑的实现.
2．有丰富的tag可以用 ,Struts的标记库(Taglib)，如能灵活动用，则能大大提高开发效率
3. 页面导航
	使系统的脉络更加清晰。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。尤其是当另一批开发者接手这个项目时，这种优势体现得更加明显。
4. 提供Exception处理机制 . 
5. 数据库链接池管理 
6. 支持I18N 
缺点
一、转到展示层时，需要配置forward，如果有十个展示层的jsp，需要配置十次struts，而且还不包括有时候目录、文件变更，需要重新修改forward，注意，每次修改配置之后，要求重新部署整个项目，而tomcate这样的服务器，还必须重新启动服务器
二、二、 Struts 的Action必需是thread－safe方式，它仅仅允许一个实例去处理所有的请求。所以action用到的所有的资源都必需统一同步，这个就引起了线程安全的问题。
三、 测试不方便. Struts的每个Action都同Web层耦合在一起，这样它的测试依赖于Web容器，单元测试也很难实现。不过有一个Junit的扩展工具Struts TestCase可以实现它的单元测试。 
四、 类型的转换. Struts的FormBean把所有的数据都作为String类型，它可以使用工具Commons-Beanutils进行类型转化。但它的转化都是在Class级别，而且转化的类型是不可配置的。类型转化时的错误信息返回给用户也是非常困难的。
五、对Servlet的依赖性过强. Struts处理Action时必需要依赖ServletRequest 和ServletResponse，所有它摆脱不了Servlet容器。 
六、 前端表达式语言方面.Struts集成了JSTL，所以它主要使用JSTL的表达式语言来获取数据。可是JSTL的表达式语言在Collection和索引属性方面处理显得很弱。 
七、 对Action执行的控制困难. Struts创建一个Action，如果想控制它的执行顺序将会非常困难。甚至你要重新去写Servlet来实现你的这个功能需求。 
八、 对Action 执行前和后的处理. Struts处理Action的时候是基于class的hierarchies，很难在action处理前和后进行操作。 
九、 对事件支持不够. 在struts中，实际是一个表单Form对应一个Action类(或DispatchAction)，换一句话说：在Struts中实际是一个表单只能 对应一个事件，struts这种事件方式称为application event，application event和component event相比是一种粗粒度的事件


119、STRUTS的应用(如STRUTS架构) 
Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能： 一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。 二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。

110、说说struts1与struts2的区别。
1.都是MVC的WEB框架,
2 struts1的老牌框架，应用很广泛，有很好的群众基础，使用它开发风险很小，成本更低！struts2虽然基于这个框架，但是应用群众并多，相对不成熟，未知的风险和变化很多，开发人员相对不好招，使用它开发项目的风险系数更大，用人成本更高！
3.struts2毕竟是站在前辈的基础设计出来，它会改善和完善struts1中的一些缺陷，struts1中一些悬而未决问题在struts2得到了解决。
4.struts1的前端控制器是一个Servlet，名称为ActionServlet，struts2的前端控制器是一个filter，在struts2.0中叫FilterDispatcher，在struts2.1中叫StrutsPrepareAndExecuteFilter。
5.struts1的action需要继承Action类，struts2的action可以不继承任何类；struts1对同一个路径的所有请求共享一个Action实例，struts2对同一个路径的每个请求分别使用一个独立Action实例对象，所有对于struts2的Action不用考虑线程安全问题。
6.在struts1中使用formbean封装请求参数，在struts2中直接使用action的属性来封装请求参数。
7.struts1中的多个业务方法放在一个Action中时（即继承DispatchAction时），要么都校验，要么都不校验；对于struts2，可以指定只对某个方法进行校验，当一个Action继承了ActionSupport且在这个类中只编写了validateXxx()方法，那么则只对Xxx()方法进行校验。

（一个请求来了的执行流程进行分析，struts2是自动支持分模块开发，并可以不同模块设置不同的url前缀，这是通过package的namespace来实现的；struts2是支持多种类型的视图；struts2的视图地址可以是动态的，即视图的名称是支持变量方式的，举例，论坛发帖失败后回来还要传递boardid。视图内容显示方面：它的标签用ognl，要el强大很多，在国际化方面支持分模块管理，两个模块用到同样的key，对应不同的消息；）

		
与Struts1不同，Struts2对用户的每一次请求都会创建一个Action，所以Struts2中的Action是线程安全的。

给我印象最深刻的是：struts配置文件中的redirect视图的url不能接受参数，而struts2配置文件中的redirect视图可以接受参数。


110、hibernate中的update()和saveOrUpdate()的区别，session的load()和get()的区别。
110、简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件.
7、iBatis与Hibernate有什么不同?
相同点：屏蔽jdbc api的底层访问细节，使用我们不用与jdbc api打交道，就可以访问数据。
jdbc api编程流程固定，还将sql语句与java代码混杂在了一起，经常需要拼凑sql语句，细节很繁琐。
ibatis的好处：屏蔽jdbc api的底层访问细节；将sql语句与java代码进行分离;提供了将结果集自动封装称为实体对象和对象的集合的功能，queryForList返回对象集合，用queryForObject返回单个对象；提供了自动将实体对象的属性传递给sql语句的参数。

Hibernate是一个全自动的orm映射工具，它可以自动生成sql语句,ibatis需要我们自己在xml配置文件中写sql语句，hibernate要比ibatis功能负责和强大很多。因为hibernate自动生成sql语句，我们无法控制该语句，我们就无法去写特定的高效率的sql。对于一些不太复杂的sql查询，hibernate可以很好帮我们完成，但是，对于特别复杂的查询，hibernate就很难适应了，这时候用ibatis就是不错的选择，因为ibatis还是由我们自己写sql语句。


7、写Hibernate的一对多和多对一双向关联的orm配置?
9、hibernate的inverse属性的作用?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

10、在DAO中如何体现DAO设计模式?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

10、spring+Hibernate中委托方案怎么配置?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

10、spring+Hibernate中委托方案怎么配置?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

8. hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决； 

解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。
8.介绍一下Hibernate的二级缓存
按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了hibernate的Session就是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置Hibernate的二级缓存。
（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），这个数据结构通常是或类似Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。下面是缓存的伪代码：
引出hibernate的第二级缓存，用下面的伪代码分析了Cache的实现原理
Dao
{
	hashmap map = new map();
	User getUser(integer id)
	{
		User user = map.get(id)
		if(user == null)
		{
			user = session.get(id);
			map.put(id,user);
		}
		return user;
	}
}

Dao
{
	Cache cache = null
	setCache(Cache cache)
	{
		this.cache = cache
	}
	
	User getUser(int id)
	{
		if(cache!=null)
		{
			User user = cache.get(id);
			if(user ==null)
			{
				user = session.get(id);
				cache.put(id,user);
			}
			return user;
		}
		
		return session.get(id);
	}
}
（2）Hibernate的Session就是一种缓存，我们通常将之称为Hibernate的一级缓存，当想使用session从数据库中查询出一个对象时，Session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于Session代表一次会话过程，一个Session与一个数据库连接相关连，所以Session最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且Session是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate的Session这一级缓存的缓存作用并不明显，应用价值不大。Hibernate的二级缓存就是要为Hibernate配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session没有这种效果。
（3）二级缓存是独立于Hibernate的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache和OSCache等等。在Hibernate中使用二级缓存，首先就要在hibernate.cfg.xml配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置Hibernate中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起Hibernate的二级缓存。扩展知识：一个SessionFactory可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用Hibernate 的二级缓存后，注意不要有其他的应用或SessionFactory来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。 

111、Spring 的依赖注入是什么意思? 给一个 Bean 的 message 属性, 字符串类型, 注入值为 "Hello" 的 XML 配置文件该怎么写?
 
120、Jdo是什么? 
JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。 

什么是spring的IOC  AOP
STRUTS的工作流程！
spring 与EJB的区别！！

10. 软件工程与设计模式
111、UML方面 
标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。 
112. 软件开发的
92、j2ee常用的设计模式？说明工厂模式。 
总共23种，分为三大类：创建型，结构型，行为型
我只记得其中常用的6、7种，分别是：
创建型（工厂、工厂方法、抽象工厂、单例）
结构型（包装、适配器，组合，代理）
行为（观察者，模版，策略）
然后再针对你熟悉的模式谈谈你的理解即可。   

Java中的23种设计模式： 
Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式）， 
Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式）， 
Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式）， 
Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式）， 
Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式）， 
Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式）， 
Observer（观察者模式），   State（状态模式），         Strategy（策略模式）， 
Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式） 
工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 
113、开发中都用到了那些设计模式?用在什么场合? 
每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。 

11. j2ee部分
117、BS与CS的联系与区别。 
C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、InFORMix或 SQL Server。客户端需要安装专用的客户端软件。 
B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、InFORMix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。 
C/S 与 B/S 区别： 
１．硬件环境不同: 
　　C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. 
　　B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行 
２．对安全要求不同 
　　C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息. 
　　B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。 
３．对程序架构不同 
　　C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. 
　　B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟. 
４．软件重用不同 
　　C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好. 
　　B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 
５．系统维护不同   
　　C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统 
　　B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. 
６．处理问题不同 
　　C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统 
　　B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小. 
７．用户接口不同 
　　C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高 
　　B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本. 
８．信息流不同 
　　C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低 
　　B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心。 
2、应用服务器与WEB SERVER的区别？
应用服务器：Weblogic、Tomcat、Jboss 
WEB SERVER：IIS、 Apache 
32、应用服务器有那些？ 
BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat 

3、J2EE是什么？ 
答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。

一个另类的回答：j2ee就是增删改查。 
67、J2EE是技术还是平台还是框架？ 什么是J2EE
   J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。 
   J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。
95、请对以下在J2EE中常用的名词进行解释(或简单描述) 
web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。 
EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。 
JNDI：（Java Naming & Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。 
JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。 
JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。 
JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。 
RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。
80、如何给weblogic指定大小的内存? 
（这个问题不作具体回答，列出来只是告诉读者可能会遇到什么问题，你不需要面面俱到，什么都精通。）

在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS=-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M 
81、如何设定的weblogic的热启动模式(开发模式)与产品发布模式? 
可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE=true。 
82、如何启动时不需输入用户名与密码? 
修改服务启动文件，增加 WLS_USER和WLS_PW项。也可以在boot.properties文件中增加加密过的用户名和密码. 
83、在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中? 
保存在此Domain的config.xml文件中，它是服务器的核心配置文件。 
84、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入http://主机:端口号//helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办? 
Domain目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。 
85、在weblogic中发布ejb需涉及到哪些配置文件 
不同类型的EJB涉及的配置文件不同，都涉及到的配置文件包括ejb-jar.xml,weblogic-ejb-jar.xmlCMP实体Bean一般还需要weblogic-cmp-rdbms-jar.xml 
86、如何在weblogic中进行ssl配置与客户端的认证配置或说说j2ee(标准)进行ssl的配置?
缺省安装中使用DemoIdentity.jks和DemoTrust.jks  KeyStore实现SSL，需要配置服务器使用Enable SSL，配置其端口，在产品模式下需要从CA获取私有密钥和数字证书，创建identity和trust keystore，装载获得的密钥和数字证书。可以配置此SSL连接是单向还是双向的。 
87、如何查看在weblogic中已经发布的EJB? 
可以使用管理控制台，在它的Deployment中可以查看所有已发布的EJB 
12. ejb部分
8、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。 
   EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。 
SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。 
对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。 
对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。 
Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。 

2、简要讲一下 EJB 的 7 个 Transaction Level? 
3、EJB与JAVA BEAN的区别？ 
Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 
31、EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？ 
SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建一个新的Bean的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个Stateful Session Bean 时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful Session Bean 的方法时容器会把调用分派到与此客户机相关联的Bean实例。 
EntityBean：Entity Beans能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entity beans就一直存活。而不是按照应用程序或者服务进程来说的。即使EJB容器崩溃了，Entity beans也是存活的。Entity Beans生命周期能够被容器或者 Beans自己管理。 
EJB通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems的Transaction Service（JTS）、Java Transaction API（JTA），开发组（X/Open）的XA接口。 
73、EJB容器提供的服务 
主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。

77、EJB的激活机制 
以Stateful Session Bean 为例：其Cache大小决定了内存中可以同时存在的Bean实例的数量，根据MRU或NRU算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个EJB实例业务方法时，如果对应EJB Object发现自己没有绑定对应的Bean实例则从其去激活Bean存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的ejbActive和ejbPassivate方法。 
78、EJB的几种类型 
会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean 
会话Bean又可分为有状态（Stateful）和无状态（Stateless）两种 
实体Bean可分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种 
79、客服端调用EJB对象的几个基本步骤 
设置JNDI服务工厂以及JNDI服务地址系统属性，查找Home接口，从Home接口调用Create方法创建Remote接口，通过Remote接口调用其业务方法。
13. webservice部分
4、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。
Web ServiceWeb Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。 
JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。 
JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。 
WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。 
SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。 
UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。
88、CORBA是什么?用途是什么? 
CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。


14. Linux
118、LINUX下线程，GDI类的解释。 
LINUX实现的就是基于核心轻量级进程的"一对一"线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。 
GDI类为图像设备编程接口类库。 

15. 问得稀里糊涂的题
65、四种会话跟踪技术 
会话作用域ServletsJSP 页面描述 
page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面 
request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系） 
session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求 
application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域 
69、简述逻辑操作(&,|,^)与条件操作(&&,||)的区别。 
区别主要答两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型 
b.逻辑操作不会产生短路 

16. 其他
1、请用英文简单介绍一下自己.
4、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。
2、请把 http://tomcat.apache.org/ 首页的这一段话用中文翻译一下?
Apache Tomcat is the servlet container that is used in the official Reference Implementation for the Java Servlet and JavaServer Pages technologies. The Java Servlet and JavaServer Pages specifications are developed by Sun under the Java Community Process. 
Apache Tomcat is developed in an open and participatory environment and released under the Apache Software License. Apache Tomcat is intended to be a collaboration of the best-of-breed developers from around the world. We invite you to participate in this open development project. To learn more about getting involved, click here. 
Apache Tomcat powers numerous large-scale, mission-critical web applications across a diverse range of industries and organizations. Some of these users and their stories are listed on the PoweredBy wiki page.
3、美资软件公司JAVA工程师电话面试题目 
1. Talk about overriding, overloading.
2. Talk about JAVA design patterns you known.
3. Talk about the difference between LinkList, ArrayList and Victor.
4. Talk about the difference between an Abstract class and an Interface.
5. Class a = new Class(); Class b = new Class();
 if(a == b) returns true or false, why?
6. Why we use StringBuffer when concatenating strings?
7. Try to explain Singleton to us? Is it thread safe? If no, how to make it thread safe?
8. Try to explain Ioc?
9. How to set many-to-many relationship in Hibernate?
10. Talk about the difference between INNER JOIN and LFET JOIN.
11. Why we use index in database? How many indexes is the maximum in one table as your suggestion?
12. When ‘Final’ is used in class, method and property, what dose it mean?
13. Do you have any experience on XML? Talk about any XML tool you used ,e.g. JAXB, JAXG.
14. Do you have any experience on Linux?
15. In OOD what is the reason when you create a Sequence diagram? 
Administrator 10:34:20
  1，堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？
2，什么时候用到接口，什么时候用到抽象类，二者区别
3，有一个100万的数组，里边有两个市重复的，如何设计算法找到。
4，设计数据库时，n维，如何设计。
例如[省份][城市][网吧]，这是三维关系，它的表也应该有三个，网吧有外键引用城市，城市有外键应用省份，这个规律就是下层的要有一外键去引用上层。


提示：本大全每半月更新一次，请持续保持关注！谢谢！	索取网址：www.itcast.cn
从享受生活的角度上来说：“程序员并不是一种最好的职业，我认为两种人可以做程序员，第一，你不做程序员，你就没有什么工作可做，或者说是即使有可以做的工作但是你非常不愿意去做；第二，你非常痴迷和爱好程序，并且在这方面有一些天赋和优势。程序员的结局也是有两种：第一，默默退休，第二以程序员为起点或跳板，注意积累，跟对了好的老板或团队，找到和很好的搭档自己创业，成为IT金领和富翁。”
人们在时间面前是平等的，吾生也有涯，所以，你的经验更丰富点，那不算什么，经验是用时间积累的，你一生只有那么多时间，你能积累多少经验呢？最重要的是你的学习能力和学习方法，这个发挥的能量可以有很大差异，要提高学习能力和学习方法首先要学会思考和总结，要学会掌握事物的根本性的东西，而不是一些表面的细节。学习方法和学习能力对于IT工作者来说尤为重要，因为IT行业技术更新太快，并且细节太多，同一个技术的细节变来变去也是常有的事情，所以，IT技术学习者绝不能照着书籍和老师的讲解死记硬背和生搬硬套。搞IT工作很累人，如果学习方法不对、学习能力不强，那就更累了，不过，这怨不得别人，你的学习方法和学习能力只适合做刷盘子的工作，却非要跑到程序员圈子里来混，那谁能有办法拯救你！
在没有人指引的情况下，只能是自己一个知识点、一个知识点地漫无目的学习，等到积累了足够的知识量后，才有能力开始思考和琢磨原理方面的问题，这个学习过程很漫长。如果能在好老师的指引下，老师会启发你先思考原理问题，然后再去学习一个具体的知识点，让你能够举一反三、触类旁通，这样的学习效率就会更高。
多学了几个知识，并不能说明你就很厉害了，只能说是你比别人投入了更多的时间和精力而已，别人想做也能做到！不是你学了多少知识就算厉害了，关键是要用好学到的知识，要让学到的知识发挥出最大的社会价值和经济价值，这才是最厉害的。
另外，一个人的未来和造化，会深受环境的影响，所谓孟母三迁，近朱者赤、近墨者黑的大大道理，这些典故大家不一定能深刻领悟和感受，我们就不多说了。就拿现代比较接近我们生活的事例来说，如果你周围的朋友全是以擦皮鞋为生、每月辛辛苦苦下来就挣1500元，那么估计你的职业也是跟着擦皮鞋了，即使你再聪明和再勤奋，顶多每月比你那帮朋友多挣300元，合下来也就区区1800元/月。前几年只要抓住了大势，没钱全部找银行贷款了在北京买房、到山西开煤矿，是头猪也能每年大把大把地捞钱，如果你周围的朋友全是投机倒把的买房和开煤矿者，你的职业自然也是与他们干同样的事情，即使你再差，每年也能挣到百来万不成问题，这就是环境的重要性。聪明的你因为没有机会置身于炒房团中，比那些有机会接触炒房者的猪挣得就要少、就要累。到传智播客的环境中来，你就很有机会拿到高薪了，你可以不参加传智播客的培训，但只要想办法与传智播客的学员们住在一起，成功的机会就大多了。

自从我们开设3G的课程后，许多学员都找到了月薪在7k或更高的3g开发工作，这是他们的能力还完全不能与之相称的一份好工作，这些学员眼看到嘴的肥肉又舍不得放弃，最后就害苦我们这些老师了，学员纷纷把他们面试和工作中的要解决的问题带回来让我们老师帮助做，有些问题虽然老师能做，但也是要花费很大的时间和精力才能做的，这相当于学员把自己的工作交给我们老师替他去干了，可不是一句话两句话就解决的问题。哀哉！我们老师自己还有很繁重的备课和教学任务，我们的工作请谁来帮助做呢？同学们似乎没有替我们想过这个问题。
一个两个学员偶尔回来这么干还可以，但架不住一批批的学员都来这么干，加上有的学生还不太会说话，让人很无奈：
“很简单的，顶多占用你一个小时就搞定了！”，这么简单，你为何自己不干啊？
“今天晚上你必须做出来，明天就要交上去了”，哎，我再熬夜命都要丢了，老婆就要来砸电脑了，你叫我怎么办啊？
“你没时间干，那你吩咐其他老师干，也可以啊！”，当老师都是我的奴隶，我随时随地叫他们干啥，他们就干啥吗？老师能把教学做好，就很给我面子了。
现在这些公司怎么都越来越狡猾了，他们把日后工作中要解决的问题、并且是他们自己都很难解决的问题拿出来让面试求职者去搞，不管面试求职者的水平怎样，他们都说谁能搞定，谁就来上班，我们学生很高兴，不管自己水平是否适合做这份工作，反正有传智播客的老师可以依靠，拿回来就让我们做，还说“做好了就有高薪工作，这关于我一辈子的幸福，老师你自己看这个忙帮不帮吧？”，软件公司这招够狠！我们这批老师成了这些公司免费使用的超级劳工。如果奥巴马说你能把伊拉克摆平，我就让你当伊拉克总统，这个奥巴马都摆不平的事情，但因为做完了就可以当伊拉克总统，我们学生也可能拿回来让我们帮助做，让我们帮他摆平伊拉克，这对我们来说也是很难很难的事情啊。
1. 学习方向与面试简历的相关问题
1.如何过简历关？
我先讲解几个软件求职相关的真实故事，以帮助大家了解大多数软件开发企业是如何赛选简历和录用新员工的。
1.传智播客学员A是大四在读的应届毕业生，他自信技术学得很不错，实质上确实也达到用人单位的标准，他不愿意编写两年工作经验的虚假简历，希望凭借自己的真实情况去面对求职，投递了很多份简历，都没有回应；而他周围的很多相似背景的学员因为使用了假简历，都很快找到了薪水4.5k/月左右的工作，最后万不得已，他修改了自己的简历，增加了一些水分，以两年工作经验的身份去投递简历，结果就很快找到了满意的工作。
2.一个穿着和气质给人的印象都很不错的女生咨询时，问：“如果在传智播客学完了，能找到工作吗？”，我问了她一些基本情况后，得知她是郑州航空工业管理学院本科毕业，并且毕业时间已经有两年，谈话中感觉很有工作经验，英语也不错，所以，我斩钉截铁地告诉她：“她学完后绝对能找到一份满意的工作”，并说出了一些原因：（1）她本身的谈吐气质就决定了她找工作没问题，应聘工作除了要求有那些必需的技能外，关键一点还要看这个人的性格和素养，按她的条件，如果她要找软件开发方面的工作，只需要把技术补上就可以了，这一点在传智播客学习是很容易补上的；（2）要想找到好工作，除了掌握必需的技术外，通常都需要编写两年工作经验的简历，她的毕业是证确实两年前的，编造两年软件开发的工作经验更容易，至少不用专门去做假的毕业证了。她听完后，很赞同我的观念，说她现在就在一家软件公司做人力资源，负责挑选应聘者的简历，按领导的吩咐：“凡是工作经验低于两年的简历直接删除到垃圾桶”，可见，如果你的简历首先到达了类似这个女生的人力资源之手，即使你的技术再厉害，如果你的工作经验一栏上写得低于了两年，那简历就永无露脸之日了，何谈后来的笔试和面试呢？ 
3.与传智播客同一楼的一个软件开发单位，因为项目经理读过传智播客老师们的书籍和看过传智播客的视频，所以他们公司想到了从传智播客学员中招聘开发人员，提出薪水在2800元左后，我们公司老师对他们谁，2800元薪水，我们学员肯定看不上！他们公司说对于没有实际经验的新手开出2800元的薪水已经很不错了，我们老师说，传智播客学员通过简历包装都能找到平均4500元的工资，楼下公司说假简历他们一聊就能聊出来，没工作经验的人是骗不住他们的，我们的老师当时就无语了，…，因为就在前几天，我们就有一个学员成功潜伏进了他们公司，并且工资就是4500元，但我们老师不能当他们的面来说这事，就让他们一直蒙在鼓里还很自信吧！我用一个大饼的故事来说明这个问题吧，假如市场上卖的大饼都是10元一个，我也做了一个这样的大饼，比同类大饼还要好吃一点，我也买10元一个，你肯定愿意买，但是，一旦我告诉你，我这个大饼的原材料才5毛钱，你心里还会平衡吗？只会骂我太黑，5毛钱的成本居然卖出10元的暴利，你不会买我的大饼，因为这超出了你的心理承受，只要我不告诉你这么个实际情况，你则能欣然接受。也就是说，给你讲实话，你心里会难受，给你说假话，你心里则舒坦，相比市场上的同类产品，我这假话也算不上欺骗，毕竟你花10元买人家的大饼，还不如买我这个大饼好吃！
4.前面谈到简历上的工作经验很重要，可是大多数要找工作的同学往往是没有工作经验的，所以，只能在简历上加点水分。但是，只要你将简历上写成了两年以上的工作经验，是不是一定就能得到笔试和面试的机会呢？写两年工作经验只是有效简历的开始，离简历被用人单位相中还有一段差距。一个好的毕业学校、优秀的英语水平、中共党员的政治面貌、某省或直辖市的优秀毕业生、奥林匹克竞赛获几等奖等荣耀都会给用人单位一个很好的印象，如果你有这些荣耀，一定要在简历的基本信息部分写清楚。但是，很多人是没有这些荣耀的，那么只能平平淡淡列出自己的一些基本信息，这也没有很大的关系，顶多就是自己的简历不能脱颖而出，但是，对于软件工程师岗位来说，学历一栏怎么着也不能写为高中，起码也要写个大专或以上，毕业院校编个二线城市的不知名的小学院，如果你不愿意去做假证，等到别人面试你时，再说“闲弃以前上的学校不好，因为对编程太感兴趣，就辍学了！”

2.为什么说不需要做出完整的项目吗？
1.众所周知，在实际的软件项目中，都是很多人一块共同做一个项目，每个人只是做项目中的一部分内容，甚至是只做了项目中的一个模块，项目越大，越是如此！随便拿出一个中等大小的项目，也需要好多个熟练的开发人员开发好多个月才能勉强做得差不多，培训期间没有这么多时间，并且你还要先学会了很多技术后才能开始做项目。
 2.一个项目中的很多东西都是重复性的工作量的累积，技术方面都大同小异。做一个项目就好比盖一座楼房，只要告诉你整个楼房的整体结构，然后带着你盖上一间两间房子，其他剩下的几百间房子，老师想继续盖给你看，或者让你自己盖剩下的房间，你肯定也不愿意吧。以后有的是练手的机会，拿着人家发给你的工资，你再去做这些重复性的工作也不迟，岂不是更好！

3.业务重要？还是编码实战更重要？
1.对软件企业来说，两者都很重要，有的项目是业务为重心，有的则是以技术作为核心；以业务为重心的项目大都是企业信息化建设方面的项目，与做鞋差不多，没有多大技术含量和壁垒，只有积累了一定的经验，谁都可以做，利润很薄，例如大多数管理系统，靠的是人海战术和时间纠缠，做这种项目的程序员工作都很辛苦，经常要加班加点。而以技术为核心的项目则很有技术壁垒，不是谁都能做的，利润率很高，例如，360杀毒软件、baidu，qq，迅雷下载，大型bbs项目和淘宝这样的电子商务网站。
  2.对程序员来说，编码实战更重要，业务则不算什么！程序员和软件公司的工作就是要把用户的需求和业务变成代码，即为人作嫁，一开始，需求和业务都在用户那里，用户最懂业务，你不用了解业务，你的任务就是了解用户的业务后编写代码，在开始做项目前，用户会把业务告诉给你的。一个软件公司从来都不是只做自己熟悉业务的项目，而是来了业务不熟悉的项目机会，肯定也会冲上去做，软件公司通常都是在做自己以前没做过的项目，即做以前不了解业务的项目，只有项目做完了才完全熟悉了业务，这才叫做项目，否则就成了卖产品了，所以，软件工程里说的需求调研和理解业务的过程，也是在从侧面说明，程序员是在接到项目之后才开始了解其业务的，而在此之前，对业务可以是完全不懂的。

4.是培训内容和信息量大好？还是培训内容少而精的好？
答：虽然这两种方式都能让学有所获和找到工作，并且，前者对于老师和学生要求都很高，老师教得很辛苦，学生学得也很辛苦，学生甚至会产生畏惧心理，即使水平已经很高，可能还是没有信心；后者对于老师和学生的要求都不高，老师教得轻松，学生学得愉快，学生很容易产生自信，成了井底之蛙，还自以为不得了。但是，内容和信息量大培训课程体系，对大多人来说是更收益的，因为，程序员做的工作总是在变化的，没有一成不变的工作，为了适应这种变化，你的知识面必须很广泛。如果你学的知识内容很少，即使你把这些内容练的滚瓜烂熟了，除非你出去找的一份工作正好就是你以前练习的那些东西，这时候会让人感觉你比谁都厉害，但这种千载难逢的好事怎么就被你碰上了呢？软件开发毕竟不同于刷盘子，不是在重复干一件事情。软件开发的工作总是要面临不同的需求和问题，如果培训课程的内容和信息量很大，即使由于时间关系，你暂时没有完全消化和熟练这么多内容，但是，你在工作中不管遇到什么新问题，都有那么一点点印象，知道大概的解决办法和思路，你就可以慢慢地通过查阅资料和最终解决这个问题，软件开发的工作本来就是这么一种现状，如果你学的知识量很少，一旦遇到了新问题，你完全就没有了思路，完全无从下手，这是何等痛苦，只有灰溜溜走人的份了吧。总之，知识面越宽广，了解的信息越多，解决问题的能力就越强，好比以前治疗哮喘没有很好的办法，即使是一个哮喘病专家医生，也需要让病人吃上半年的药，还不能完全治愈，现在，如果有了一种新药，病人只需要吃上一周，就能彻底治愈，所谓好的哮喘病专家医生，他要做的工作就是迅速知道有这么一种新药问世了，否则，他就成名符其实的庸医了。建筑大师可能自己连一个厕所都盖不出来，但是他能指导别人去干，建筑大师一定要阅历广泛，他经历过的项目很多，但每个项目的很多细节不是他亲力亲为。如果砌砖都是他亲力亲为，那他一辈子可能都是干砌砖工作了。
别的培训机构培养的是技术单一的熟练技工，传智播客培养的是具有很强学习和解决问题能力的技术高手和未来技术经理。很多工厂说，清华毕业的学生刚进工厂时的动手操作不如技校毕业的学生熟练，但过一段时间后，清华学生则能解决工厂生成过程出现中的各种新问题和弊端，甚至能提出创新和发明，后劲十足，因为清华培养的就不是一个单一工种的熟练工人，而是知识全面和具有创新能力的高级工程师。别的机构和传智播客培养出来的学生差别好比如此。

5. IT行业中也会出现蚁族和民工吗？
先看看IT蚁族和IT民工的悲惨命运吧！
http://news.csdn.net/a/20100316/217473.html
http://topic.csdn.net/u/20100317/16/2dba32e3-90f4-40b5-b1fd-0bf3709297c6.html?97395
搜素 程序员的悲哀，还有更多辛酸的故事，但是，我并不同情他们，我只是说他们自己无能！程序员这个职业能创造出许多年轻的富翁，不靠父母不靠天，还有那个职业比IT行业更有机会和诱惑呢。不过，程序员毁坏身体是真，可是，不让你做程序员，你去打游戏，聊QQ不也照样坏身体吗？
SSH（struts,spring,hibernate）是当前做管理信息系统最基本和最流行的通用技术，这几个技术都出现7,8年了，应该很普及了，确实没什么新意。现在培训机构教的都是这些玩意，用来混饭吃，还是管点用的。每个做增删改查的人基本都会SSH，所以，SSH没什么了不起的，SSH这套东西对培训公司和个人发展来说，都不能成为核心竞争力，都难以成大气候。一些公司内部所谓的核心技术，就是那些非SSH的知识，传智播客教的不只是大家都会的SSH。有点档次的项目，确实不怎么用SSH，但是大多数OA类的项目都是增删改查，虽然没有技术含量，但是用工需求量大，这也就是能诞生出IT蚁族和IT民工的由来。
但是，java不只是有SSH这套技术，如果你不想成为IT蚁族，如果你不想厌烦软件开发，那就不能只学SSH，这个没有太多技术含量的单一熟练工种。

2. 笔试答题技巧与若干问题
说明，为了节省大家的时间和提高学习效率，一些过时知识点和被笔试概率极低的题目不再被收录和分析。
回答问题的思路：先正面叙述一些基本的核心知识，然后描述一些特殊的东西，最后再来一些锦上添花的东西。要注意有些不是锦上添花，而是画蛇添足的东西，不要随便写上。把答题像写书一样写。我要回答一个新技术的问题大概思路和步骤是：我们想干什么，怎么干，干的过程中遇到了什么问题，现在用什么方式来解决。其实我们讲课也是这样一个思路。
例如，讲ajax时，我们希望不改变原来的整个网页，而只是改变网页中的局部内容，例如，用户名校验，级联下拉列表，下拉树状菜单。用传统方式，就是浏览器自己直接向服务器发请求，服务器返回新页面会盖掉老页面，这样就不流畅了。
对本面试宝典中的题目有信心吗？本来有信心的，结果听你讲完后，就没信心了！我非常理解。因为他觉得我的太深，他想记住我的些东西，可是记不住，所以没信心了。我又问：听懂了吗？他说听懂了。你到现在只要把你的理解尽量清晰地、有条理地表达出来，就很棒了。

这套面试题主要目的是帮助那些还没有java软件开发实际工作经验，而正在努力寻找java软件开发工作的朋友在笔试时更好地赢得笔试和面试。由于这套面试题涉及的范围很泛，很广，很杂，大家不可能一天两天就看完和学完这套面试宝典，即使你已经学过了有关的技术，那么至少也需要一个月的时间才能消化和掌握这套面试宝典，所以，大家应该早作准备，从拿到这套面试宝典之日起，就要坚持在每天闲暇之余学习其中几道题目，日积月累，等到出去面试时，一切都水到渠成，面试时就自然会游刃有余了。

答题时，先答是什么，再答有什么作用和要注意什么（这部分最重要，展现自己的心得）

答案的段落分别，层次分明，条理清晰都非常重要，从这些表面的东西也可以看出一个人的习惯、办事风格、条理等。
要讲你做出答案的思路过程，或者说你记住答案的思想都写下来。把答题想着是辩论赛。答题就是给别人讲道理、摆事实。答题不局限于什么格式和形式，就是要将自己的学识展现出来！
别因为人家题目本来就模棱两可，你就心里胆怯和没底气了，不敢回答了。你要大胆地指出对方题目很模糊和你的观点，不要把面试官想得有多高，其实他和你就是差不多的，你想想，如果他把你招进去了，你们以后就是同事了，可不是差不多的吗？
关于就业薪水，如果你是应届生，那不能要高工资，好比大饼的故事，没有文凭还想拿高工资，就去中关村缺什么补什么吧！少数人基础确实很好，在校期间确实又做过一些项目，那仍然是可以要到相对高的工资的。

公司招聘程序员更看重的要用到的编码技术、而不是那些业务不太相关的所谓项目经历：
1.公司想招什么样的人2.公司面试会问什么,.3.简历怎么写4怎样达到简历上的标准（培训中心教项目的目的）

对于一些公司接到了一些项目，想招聘一些初中级的程序员过来帮助写代码，完成这个项目，你更看重的是他的专业技术功底，还是以前做过几个项目的经历呢？我们先排除掉那些编码技术功底好，又正好做过相似项目的情况，实际上，这种鱼和熊掌兼得的情况并不常见。其实公司很清楚，只要招聘进来的人技术真的很明白，那他什么项目都可以做出来，公司招人不是让你去重复做你以前的项目，而是做一个新项目，业务方面，你只要进了项目团队，自然就能掌握。所以，大多数招聘单位在招聘那些编码级别的程序员时也没指望能招聘到做过类似项目的人，也不会刻意去找做过类似项目的人，用人单位也不是想把你招进，然后把你以前做过的项目重做一遍，所以，用人单位更看重招进来的人对要用到的编码技术的功底到底怎样，技术扎实不扎实，项目则只要跟着开发团队走，自然就没问题。除非是一些非常专业的行业，要招聘特别高级的开发人员和系统分析师，招聘单位才特别注重他的项目经验和行业经验，要去找到行业高手，公司才关心项目和与你聊项目的细节，这样的人通常都不是通过常规招聘渠道去招聘进来的，而是通过各种手段挖过来的，这情况不再我今天要讨论的范围中。
技术学得明白不明白，人家几个问题就把你的深浅问出来了，只要问一些具体的技术点，就很容易看出你是真懂还是假懂，很容看出你的技术深度和实力，所以，技术是来不得半点虚假的，必须扎扎实实。
由于项目的种类繁多，涉及到现实生活中的各行各业，什么五花八门的业务都有，例如，酒店房间预定管理，公司车辆调度管理，学校课程教室管理，超市进销存管理，知识内容管理，等等……成千上万等等，但是，不管是什么项目，采用的无非都是我们学习的那些目前流行和常用的技术。技术好、经验丰富，则项目做出来的效率高些，程序更稳定和更容易维护些；技术差点，碰碰磕磕最后也能把项目做出来，无非是做的周期长点、返工的次数多点，程序代码写得差些，用的技术笨拙点。如果一个人不是完完全全做过某个项目，他是不太关心该项目的业务的，对其中的一些具体细节更是一窍不知，(如果我招你来做图书管理，你项目经历说你做过汽车调度，那我能问你汽车调度具体怎么回事吗？不会，所以，你很容易蒙混过去的)而一个程序员的整个职业生涯中能实实在在和完完整整做出来的项目没几个，更别说在多个不同行业的项目了，有的程序员更是一辈子都只是在做某一个行业的项目，结果他就成了这个行业的专家(专门干一件事的家伙)。所以，技术面试官通常没正好亲身经历过你简历写的那些项目，他不可能去问你写的那些项目的具体细节，而是只能泛泛地问你这个项目是多少人做的，做了多长时间，开发的过程，你在做项目的过程中有什么心得和收获，用的什么技术等面上的问题，所以，简历上的项目经历可以含有很多水分，很容易作假，技术面试官也无法在项目上甄别你的真伪。
简历该怎么写：精通那些技术，有一些什么项目经历
教项目是为了巩固和灵活整合运用技术，增强学习的趣味性，熟悉做项目的流程，或得一些专业课程中无法获得的特有项目经验，增强自己面试的信心。讲的项目应该真实可靠才有价值，否则，表面上是项目，实际上还是知识点的整合，对巩固技术点和增强学习的趣味性，但无法获得实际的项目经验。（项目主要是增加你经验的可信度，获得更多面试机会，真正能不能找到工作，找到好工作，主要看你键盘上的功夫了），好的面试官几下就能面出你是否真有工作经验，他们问技术以外的公司的人和事，并且问开始、过程、结果，看你怎么编。
建议大家尽量开自己的blog，坚持每天写技术blog。在简历上写上自己的blog地址，可以多转载一些技术文章。
3. 笔试题之Java基础部分
基础部分的顺序：基本语法，类相关的语法，内部类的语法，继承相关的语法，异常的语法，线程的语法，集合的语法，io 的语法，虚拟机方面的语法，其他。有些题来自网上搜集整理，有些题来自传智播客学员面试后的反馈，说真的，少数一些网上的面试题，我真怀疑其是否还有存在价值！
1、一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？ 
可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。
2、Java有没有goto? 
java中的保留字，现在没有在java中使用。

3、说说&和&&的区别。 
&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。
&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。If(x==33 & ++y>0) y会增长，If(x==33 && ++y>0)不会增长
&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。 

备注：这道题先说两者的共同点，再说出&&和&的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。 

4、在JAVA中如何跳出当前的多重嵌套循环？ 
在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如，
ok:
	for(int i=0;i<10;i++)
	{
		for(int j=0;j<10;j++)
		{
			System.out.println(“i=” + i + “,j=” + j);
			if(j == 5) break ok;
		}
	} 
另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。
int arr[][] = {{1,2,3},{4,5,6,7},{9}};
boolean found = false;
for(int i=0;i<arr.length && !found;i++)
	{
		for(int j=0;j<arr[i].length;j++)
		{
			System.out.println(“i=” + i + “,j=” + j);
			if(arr[i][j]  == 5) 
			{
				found = true;
				break;
			}
		}
	} 
 

5、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 
在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 
6、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 
对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。
对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 
7、char型变量中能不能存贮一个中文汉字?为什么? 
char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。
备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。 
8、用最有效率的方法算出2乘以8等於几? 
2 << 3，
因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 << 3。
9、请设计一个一百亿的计算器
首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的面向对象的设计思想。
首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一定的范围的，为了便于讲解和理解，我们先以byte 类型的整数为例，它用1个字节进行存储，表示的最大数值范围为-128到+127。-1在内存中对应的二进制数据为11111111，如果两个-1相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,11111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。-128在内存中对应的二进制数据为10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,00000000，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为00000000，也就是0，这样的结果显然不是我们期望的，这说明计算机中的算术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。由于Java中涉及表达式运算时的类型自动提升，我们无法用byte类型来做演示这种问题和现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下：
		int a = Integer.MAX_VALUE;
		int b = Integer.MAX_VALUE;
		int sum = a + b;
		System.out.println(“a=”+a+”,b=”+b+”,sum=”+sum);

先不考虑long类型，由于int的正数范围为2的31次方，表示的最大数值约等于2*1000*1000*1000，也就是20亿的大小，所以，要实现一个一百亿的计算器，我们得自己设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大概功能如下：
（）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数
（）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中
（）提供加减乘除的功能
public class BigInteger
{
		int sign;
		byte[] val;
		public Biginteger(String val)
		{
			sign = ;
			val = ;
		}
		public BigInteger add(BigInteger other)
		{
			
		}
		public BigInteger subtract(BigInteger other)
		{
			
		}
		public BigInteger multiply(BigInteger other)
		{
			
		}
		public BigInteger divide(BigInteger other)
		{
			
		}

}
备注：要想写出这个类的完整代码，是非常复杂的，如果有兴趣的话，可以参看jdk中自带的java.math.BigInteger类的源码。面试的人也知道谁都不可能在短时间内写出这个类的完整代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一千元。 

10、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 
使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：
 final StringBuffer a=new StringBuffer("immutable");
执行如下语句将报告编译期错误：
a=new StringBuffer("");
但是，执行如下语句则可以通过编译：
a.append(" broken!"); 

有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：
	public void method(final  StringBuffer  param)
	{
	} 
实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：
		param.append("a");
11、"=="和equals方法究竟有什么区别？
（单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚）
==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。
如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。
equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：
String a=new String("foo");
String b=new String("foo");
两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。
在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。
如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：
boolean equals(Object o){
return this==o;
}
这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。
12、静态变量和实例变量的区别？ 
在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。
在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。
public class VariantTest
{
		public static int staticVar = 0; 
		public int instanceVar = 0; 
		public VariantTest()
		{
			staticVar++;
			instanceVar++;
			System.out.println(“staticVar=” + staticVar + ”,instanceVar=” + instanceVar);
		}
}
备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！
13、是否可以从一个static方法内部发出对非static方法的调用？ 
不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。
14、Integer与int的区别
int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。
在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。
另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。

15、Math.round(11.5)等於多少? Math.round(-11.5)等於多少?
Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，所以，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，所以，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。

15、下面的代码有什么不妥之处?
1. if(username.equals(“zxx”){}
	2.	int  x = 1;
		return x==1?true:false;

1、请说出作用域public，private，protected，以及不写时的区别
这四个作用域的可见范围如下表所示。
说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。

作用域    当前类 同一package 子孙类 其他package 
public    √     √          √       √ 
protected  √     √          √      × 
friendly   √     √          ×      × 
private    √     ×          ×      × 

备注：只要记住了有4种访问权限，4个访问范围，然后将全选和范围在水平和垂直方向上分别按排从小到大或从大到小的顺序排列，就很容易画出上面的图了。
2、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? 
Overload是重载的意思，Override是覆盖的意思，也就是重写。
重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。
重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。
至于Overloaded的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 

override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：
1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；
3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。
overload对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：
1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；
2、不能通过访问权限、返回类型、抛出的异常进行重载；
3、方法的异常类型和数目不会对重载造成影响；
4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。

3、4月21号班同学贡献的一些题? 
朱wenchao，女：3500，21岁
搞了多个重载方法，参数分别是int ,char,和double，然后将double x = 2，传递进去，会选择哪个方法？
说说对javaee中的session的理解，你是怎么用session的？ 


陈yong, 4000
一个房子里有椅子，椅子有腿和背，房子与椅子是什么关系，椅子与腿和背是什么关系？
如果房子有多个椅子，就是聚合关系，否则是一种关联关系，当然，聚合是一种特殊的关联。椅子与腿和背时组合关系。
说说has a与is a的区别。
答：is-a表示的是属于得关系。比如兔子属于一种动物（继承关系）。
	has-a表示组合，包含关系。比如兔子包含有腿，头等组件；
工厂模式的类图
4．5月15号班同学贡献的一些题？
1. 线程如何同步和通讯。 同学回答说synchronized方法或代码块！面试官似乎不太满意！
 只有多个synchronized代码块使用的是同一个监视器对象，这些synchronized代码块之间才具有线程互斥的效果，假如a代码块用obj1作为监视器对象，假如b代码块用obj2作为监视器对象，那么，两个并发的线程可以同时分别进入这两个代码块中。 …这里还可以分析一下同步的原理。
   对于同步方法的分析，所用的同步监视器对象是this
   接着对于静态同步方法的分析，所用的同步监视器对象是该类的Class对象
	接着对如何实现代码块与方法的同步进行分析。
2.ClassLoader如何加载class 。
    jvm里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap类加载负责加载jre/lib/rt.jar中的类， 我们平时用的jdk中的类都位于rt.jar中。extclassloader负责加载jar/lib/ext/*.jar中的类，appclassloader负责classpath指定的目录或jar中的类。除了bootstrap之外，其他的类加载器本身也都是java类，它们的父类是ClassLoader。
3.Servlet的生命周期
4.抽象类的作用
5.ArrayList如何实现插入的数据按自定义的方式有序存放
class MyBean implements Comparable{
	public int compareTo(Object obj){
		if(! obj instanceof MyBean)
			throw new ClassCastException() //具体异常的名称，我要查jdk文档。
			
		MyBean other = (MyBean) obj;
		return age > other.age?1:age== other.age?0:-1;
	}
}


class MyTreeSet {

	private ArrayList  datas = new ArrayList();
	
	public void add(Object obj){
		for(int i=0;i<datas.size();i++){
			if(obj.compareTo(datas.get(i) != 1){
				datas.add(i,obj);
			}
		}
	}
}

6.分层设计的好处；把各个功能按调用流程进行了模块化，模块化带来的好处就是可以随意组合，举例说明：如果要注册一个用户，流程为显示界面并通过界面接收用户的输入，接着进行业务逻辑处理，在处理业务逻辑又访问数据库，如果我们将这些步骤全部按流水帐的方式放在一个方法中编写，这也是可以的，但这其中的坏处就是，当界面要修改时，由于代码全在一个方法内，可能会碰坏业务逻辑和数据库访问的码，同样，当修改业务逻辑或数据库访问的代码时，也会碰坏其他部分的代码。分层就是要把界面部分、业务逻辑部分、数据库访问部分的代码放在各自独立的方法或类中编写，这样就不会出现牵一发而动全身的问题了。这样分层后，还可以方便切换各层，譬如原来的界面是Swing，现在要改成BS界面，如果最初是按分层设计的，这时候不需要涉及业务和数据访问的代码，只需编写一条web界面就可以了。
   下面的仅供参考，不建议照搬照套，一定要改成自己的语言，发现内心的感受：
  分层的好处：
		1，实现了软件之间的解耦；
		2.便于进行分工
		3.便于维护
		4，提高软件组件的重用
		5.便于替换某种产品，比如持久层用的是hibernate,需要更换产品用toplink，就不用该其他业务代码，直接把配置一改。
		6.便于产品功能的扩展。
		7。便于适用用户需求的不断变化

7.序列化接口的id有什么用？
   对象经常要通过IO进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person->“zxx,male,28,30000”Person，既然大家都要这么干，并且没有个统一的干法，于是，sun公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被sun的这种方案处理，必须实现Serializable接口。
   ObjectOutputStream.writeObject(obj);
   Object obj = ObjectInputStream.readObject();
   假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun的jdk就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错!

9.hashCode方法的作用？说	
    （网友提供的一段，待改进：hashcode这个方法是用来鉴定2个对象是否相等的。
那你会说，不是还有equals这个方法吗？
不错，这2个方法都是用来判断2个对象是否相等的。但是他们是有区别的。
一般来讲，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等了。简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。举个例子，有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这2个对象是相等的。
hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode这个方法，而且也用到了equals方法。这里不可以重复是说equals和hashcode只要有一个不等就可以了！所以简单来讲，hashcode相当于是一个对象的编码，就好像文件中的md5，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要覆盖hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算2个对象相等的话，那么hashcode的方法也要返回姓名的hashcode值加上性别的hashcode值，这样从逻辑上，他们就一致了。
要从物理上判断2个对象是否相等，用==就可以了。
）
10.webservice问得很多
11.设计出计算任意正整数的阶层。

4.在oracle数据库中需要查询出前8条记录的sql语句怎么写？


5.什么是SOA，谈谈你的SOA的理解。service orientied architecture
6.如何实现线程间的通讯。

新题目：编程:1.编写一个函数将一个十六进制数的字符串参数转换成整数返回。
	String str = “13abf”;
	int len = str.length;
	int sum = 0;
	for(int i=0;i<len;i++){
		char c = str.charAt(len-1-i);
		int n = Character.digit(c,16);
		sum += n * (1<<(4*i));	
	}
      
     其实，也可以用Integer.parseInt(str,16)，但面试官很可能是想考我们的编码基本功。

编程2
   :银行贷款的还款方式中最常用的是一种叫“等额本息”，还款法，即借款人在约定还款期限内的每一期（月）归还的金额（产生的利息+部分本金）都是相等的，现有一笔总额为T元的N年期住房贷款，年利率为R，要求算出每一期的还款的本金和利息总额，请写出解决思路和任意一种编程语言实现的主要代码。
	思路：既然是按月还款，那我就要将N年按月来计算，即要还N*12个月，这样就可以求出每月要还的本金。由于每月要还的那部分本金所欠的时间不同，所以，它们所产生的利息是不同的，该部分本金的利息为：部分本金额*所欠月数*月利率。应该是这么个算法，如果利息还计利息，如果月还款不按年利率来算，老百姓算不明白的。
	int monthMoney = T/N/12;
	float monthRate = R/12;
	int totalMonth = N * 12;
	float totalRate = 0;
	for(int i=1;i<=totalMonth;i++){
		totalRate += monthMoney * monthRate * i;
	}
	int result = monthMoney + totalRate/N/12;

几道题：
1. ****Spring的DI是什么（学员注：除了IOC，AOP这些概念，还不太清楚DI的概念）
2. *任意数字序列“123456”之类，输出它们所有的排列组合
3. *****什么是AOP（学员注：会用，但感觉说不清楚）
我注：由上面这些题，可以看出，思想很重要，只有琢磨思想和原理的人才能很好地回答这些问题！
	2题的答案：
	String str = “xafdvs”;
	char[] arr1 = str.toCharArray();
	char[] arr2 = Arrays.copyOf(arr1,arr1.length);
	for(int i=0;i<arr1.length-1;i++)
	{
		for(int j = i+1;j<arr2.length;j++){
			syso: arr1[i] + “,” + arr2[j];
		}
	}
	
	3题的答案：
1.概念介绍：所谓AOP，即Aspect orientied program,就是面向方面的编程，
2.解释什么是方面：贯穿到系统的各个模块中的系统一个功能就是一个方面，
比如，记录日志，统一异常处理，事务处理，全限检查，这些功能都是软件系统
的一个面，而不是一点，在各个模块中都要出现。
3.什么是面向方面编程：把系统的一个方面的功能封装成对象的形式来处理
4.怎么进行面向方面编程：把功能模块对应的对象作为切面嵌入到原来的各个系统模块中，
采用代理技术，代理会调用目标，同时把切面功能的代码（对象）加入进来，所以，
用spring配置代理对象时只要要配两个属性，分别表示目标和切面对象（Advisor）。
3、构造器Constructor是否可被override? 
构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。 
4、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？
接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承具体类。抽象类中可以有静态的main方法。
备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。
 只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。

5、写clone()方法时，通常都有一行代码，是什么？ 
clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。 
6、面向对象的特征有哪些方面
计算机软件系统是现实生活中的业务在计算机中的映射，而现实生活中的业务其实就是一个个对象协作的过程。面向对象编程就是按现实业务一样的方式将程序代码按一个个对象进行组织和编写，让计算机系统能够识别和理解用对象方式组织和编写的程序代码，这样就可以把现实生活中的业务对象映射到计算机系统中。
面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。
1封装：
封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。
例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。一个更便于理解的例子就是，司机将火车刹住了，刹车的动作是分配给司机，还是分配给火车，显然，应该分配给火车，因为司机自身是不可能有那么大的力气将一个火车给停下来的，只有火车自己才能完成这一动作，火车需要调用内部的离合器和刹车片等多个器件协作才能完成刹车这个动作，司机刹车的过程只是给火车发了一个消息，通知火车要执行刹车动作而已。

抽象：
抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：
class Person
{
		String name;
		int age;
}
人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。

继承：
在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。

多态：
多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。例如，下面代码中的UserDao是一个接口，它定义引用变量userDao指向的实例对象由daofactory.getDao()在执行的时候返回，有时候指向的是UserJdbcDao这个实现，有时候指向的是UserHibernateDao这个实现，这样，不用修改源代码，就可以改变userDao指向的具体类实现，从而导致userDao.insertUser()方法调用的具体代码也随之改变，即有时候调用的是UserJdbcDao的insertUser方法，有时候调用的是UserHibernateDao的insertUser方法：
UserDao userDao = daofactory.getDao();  
userDao.insertUser(user);

比喻：人吃饭，你看到的是左手，还是右手？
7、java中实现多态的机制是什么？ 
靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 
8、abstract class和interface有什么区别? 	
含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。
下面比较一下两者的语法区别：
1.抽象类可以有构造方法，接口中不能有构造方法。
2.抽象类中可以有普通成员变量，接口中没有普通成员变量
3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
5. 抽象类中可以包含静态方法，接口中不能包含静态方法
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类。
	下面接着再说说两者在应用上的区别：
接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：
public abstract class BaseServlet extends HttpServlet
{
		public final void service(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException
		{
			记录访问日志
			进行权限判断
if(具有权限)
{
	try
	{
		doService(request,response);
}
	catch(Excetpion e)
	{
			记录异常信息
	}
}
		} 
		protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException;  
//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的
}

public class MyServlet1 extends BaseServlet
{
protected void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException
		{
			本Servlet只处理的具体业务逻辑代码
		} 

}
父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。
备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。
9、abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 
abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！
native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码，可以发现FileOutputStream的open方法的定义如下：
private native void open(String name) throws FileNotFoundException;
如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。
关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。 
10、什么是内部类？Static Nested Class 和 Inner Class的不同。
内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示：
public class Outer
{
		int out_x  = 0;
		public void method()
		{
			Inner1 inner1 = new Inner1();
			public class Inner2   //在方法体内部定义的内部类
			{
				public method()
				{
					out_x = 3;
				}
			}
			Inner2 inner2 = new Inner2();
		}

		public class Inner1   //在方法体外面定义的内部类
		{
		}
		
}
在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：
Outer outer = new Outer();
Outer.Inner1 inner1 = outer.new Innner1();

在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。
对于这些细节，只要在eclipse写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。

在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：
public class Outer
{
		public void start()
		{
			new Thread(
new Runable(){
					public void run(){};
}
).start();
		}
}

最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：
Outer.Inner inner = new Outer.Inner();
由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。
在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。

备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。
11、内部类可以引用它的包含类的成员吗？有没有什么限制？ 
完全可以。如果不是静态内部类，那没有什么限制！ 
如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：
class Outer
{
	static int x;
	static class Inner
	{
		void test()
		{
			syso(x);
		}
	}
}

答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情况，让人家吃惊。

12、Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? 
可以继承其他类或实现其他接口。不仅是可以，而是必须!
13、super.getClass()方法调用
下面程序的输出结果是多少？
import java.util.Date;
public  class Test extends Date{
	public static void main(String[] args) {
		new Test().test();
	}
	
	public void test(){
		System.out.println(super.getClass().getName());
	}
}

很奇怪，结果是Test
这属于脑筋急转弯的题目，在一个qq群有个网友正好问过这个问题，我觉得挺有趣，就研究了一下，没想到今天还被你面到了，哈哈。
在test方法中，直接调用getClass().getName()方法，返回的是Test类名
由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在
test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。
如果想得到父类的名称，应该用如下代码：
getClass().getSuperClass().getName();

14. jdk中哪些类是不能继承的？
不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中System,String,StringBuffer等都是基本类型。
2、String是最基本的数据类型吗? 
基本数据类型包括byte、int、char、long、float、double、boolean和short。 
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 

111、String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？

没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 "Hello"，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为"Hello world!"，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。
通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。
同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：
public class Demo {
private String s;
...
public Demo {
s = "Initial Value";
}
...
}
而非
s = new String("Initial Value");
后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。
上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。
至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。

41、是否可以继承String类? 
String类是final类故不可以继承。 

27、String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？
两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。
5、String 和StringBuffer的区别
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。

接着要举一个具体的例子来说明，我们要把1到100的所有数字拼起来，组成一个串。
StringBuffer sbf = new StringBuffer();  
for(int i=0;i<100;i++)
{
	sbf.append(i);
}
上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。
String str = new String();  
for(int i=0;i<100;i++)
{
	str = str + i;
}
在讲两者区别时，应把循环的次数搞成10000，然后用endTime-beginTime来比较两者执行的时间差异，最后还要讲讲StringBuilder与StringBuffer的区别。

String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。

8.StringBuffer与StringBuilder的区别
  StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。

3、如何把一段逗号分割的字符串转换成一个数组?
如果不查jdk api，我很难写出来！我可以说说我的思路：
3.用正则表达式，代码大概为：String [] result = orgStr.split(“,”);
4.用 StingTokenizer ,代码为：StringTokenizer  tokener = StringTokenizer(orgStr,”,”);
String [] result = new String[tokener .countTokens()];
Int i=0;
while(tokener.hasNext(){result[i++]=toker.nextToken();}

38、数组有没有length()这个方法? String有没有length()这个方法？ 
数组没有length()这个方法，有length的属性。String有有length()这个方法。
39、下面这条语句一共创建了多少个对象：String s="a"+"b"+"c"+"d";
答：对于如下代码：
String s1 = "a";
String s2 = s1 + "b";
String s3 = "a" + "b";
System.out.println(s2 == "ab");
System.out.println(s3 == "ab");
第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。
题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，
		String s = "a" + "b" + "c" + "d";
		System.out.println(s == "abcd");
最终打印的结果应该为true。 


43、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后? 
也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果： 
public  class Test {

	/**
	 * @param args add by zxx ,Dec 9, 2008
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(new Test().test());;
	}

	static int test()
	{
		int x = 1;
		try
		{
			return x;
		}
		finally
		{
			++x;
		}
	}
	
}

---------执行结果 ---------
1

运行结果是1，为什么呢？主函数调用子函数并得到结果的过程，好比主函数准备一个空罐子，当子函数要返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是子函数说，我不运行了，你主函数继续运行吧，这没什么结果可言，结果是在说这话之前放进罐子里的。
7、下面的程序代码输出的结果是多少？
public class  smallT
{
	public static void  main(String args[])
	{
		smallT t  = new  smallT();
		int  b  =  t.get();
		System.out.println(b);
	}
	
	public int  get()
	{
		try
		{
			return 1 ;
		}
		finally
		{
			return 2 ;
		}
	}
}

返回的结果是2。
我可以通过下面一个例子程序来帮助我解释这个答案，从下面例子的运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。
在讲解答案时可以用下面的程序来帮助分析：
public  class Test {

	/**
	 * @param args add by zxx ,Dec 9, 2008
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(new Test().test());;
	}

	int test()
	{
		try
		{
			return func1();
		}
		finally
		{
			return func2();
		}
	}
	
	int func1()
	{
		System.out.println("func1");
		return 1;
	}
	int func2()
	{
		System.out.println("func2");
		return 2;
	}	
}
-----------执行结果-----------------

func1
func2
2

结论：finally中的代码比return 和break语句后执行

12、final, finally, finalize的区别。 
　　final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……

finally是异常处理语句结构的一部分，表示总是执行。

 
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用

5、运行时异常与一般异常有何异同？ 
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
15、error和exception有什么区别? 
error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 

50、Java中的异常处理机制的简单原理和应用。 
异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。
Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。
java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。

提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误；


33、请写出你最常见到的5个runtime exception。 
这道题主要考你的代码量到底多大，如果你长期写代码的，应该经常都看到过一些系统方面的异常，你不一定真要回答出5个具体的系统异常，但你要能够说出什么是系统异常，以及几个系统异常就可以了，当然，这些异常完全用其英文名称来写是最好的，如果实在写不出，那就用中文吧，有总比没有强！ 
所谓系统异常，就是…..，它们都是RuntimeException的子类，在jdk doc中查RuntimeException类，就可以看到其所有的子类列表，也就是看到了所有的系统异常。我比较有印象的系统异常有：NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException。
96、JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ 

99、java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ 

java5以前，有如下两种：
第一种：
new Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：
new Thread(){
	public void run(){
	}
}.start();

第二种：
new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：
new Thread(new Runnable(){
			public void run(){
			}	
		}
	).start();
	
	
从java5开始，还有如下一些线程池创建多线程的方式：
ExecutorService pool = Executors.newFixedThreadPool(3)
for(int i=0;i<10;i++)
{
 pool.execute(new Runable(){public void run(){}});
}
Executors.newCachedThreadPool().execute(new Runable(){public void run(){}});
Executors.newSingleThreadExecutor().execute(new Runable(){public void run(){}});



有两种实现方法，分别使用new Thread()和new Thread(runnable)形式，第一种直接调用thread的run方法，所以，我们往往使用Thread子类，即new SubThread()。第二种调用runnable的run方法。

有两种实现方法，分别是继承Thread类与实现Runnable接口 
用synchronized关键字修饰同步方法 
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 
13、sleep() 和 wait() 有什么区别? 
     （网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。） 

sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。
package com.huawei.interview;

public class MultiThread {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new Thread(new Thread1()).start();
		try {
			Thread.sleep(10);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		new Thread(new Thread2()).start();		
	}
	
	
	private static class Thread1 implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
//由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。
			synchronized (MultiThread.class) {

				System.out.println("enter thread1...");
				
				System.out.println("thread1 is waiting");
				try {
			//释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。
					MultiThread.class.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				System.out.println("thread1 is going on...");
				System.out.println("thread1 is being over!");			
			}
		}
		
	}
	
	private static class Thread2 implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
			synchronized (MultiThread.class) {
			
				System.out.println("enter thread2...");
				
				System.out.println("thread2 notify other thread can release wait status..");
//由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。

				MultiThread.class.notify();
				
				System.out.println("thread2 is sleeping ten millisecond...");
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				System.out.println("thread2 is going on...");
				System.out.println("thread2 is being over!");
				
			}
		}
		
	}	

}


16、同步和异步有何异同，在什么情况下分别使用他们？举例说明。 
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 

17. 下面两个方法同步吗？（自己发明）
	class Test
{
synchronized static void sayHello3()
		{
		
		}	
	
		synchronized void getX(){}
}
56、多线程有几种实现方法?同步有几种实现方法? 
多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 
同步的实现方面有两种，分别是synchronized,wait与notify 
wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。


30、启动一个线程是用run()还是start()? . 
启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 

47、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 
分几种情况：
     1.其他方法前是否加了synchronized关键字，如果没加，则能。
     2.如果这个方法内部调用了wait，则可以进入其他synchronized方法。
     3.如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。
		4.如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。

58、线程的基本概念、线程的基本状态以及状态之间的关系 

一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。 

  状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。
  调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。 

71、简述synchronized和java.util.concurrent.locks.Lock的异同 ？ 
主要相同点：Lock能完成synchronized所实现的所有功能 
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。 
举例说明（对下面的题用lock进行了改写）：
package com.huawei.interview;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadTest {

	/**
	 * @param args
	 */
	
	private int j;
	private Lock lock = new ReentrantLock();
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		ThreadTest tt = new ThreadTest();
		for(int i=0;i<2;i++)
		{
			new Thread(tt.new Adder()).start();
			new Thread(tt.new Subtractor()).start();
		}
	}

	private class Subtractor implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
			while(true)
			{
				/*synchronized (ThreadTest.this) {			
					System.out.println("j--=" + j--);
					//这里抛异常了，锁能释放吗？
				}*/
				lock.lock();
				try
				{
					System.out.println("j--=" + j--);
				}finally
				{
					lock.unlock();
				}
			}
		}
		
	}
	
	private class Adder implements Runnable
	{

		@Override
		public void run() {
			// TODO Auto-generated method stub
			while(true)
			{
				/*synchronized (ThreadTest.this) {
				System.out.println("j++=" + j++);	
				}*/
				lock.lock();
				try
				{
					System.out.println("j++=" + j++);
				}finally
				{
					lock.unlock();
				}				
			}			
		}
		
	}
}
28、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。 
以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。 
public class ThreadTest1 
{ 
private int j; 
public static void main(String args[]){ 
   ThreadTest1 tt=new ThreadTest1(); 
   Inc inc=tt.new Inc(); 
   Dec dec=tt.new Dec(); 
   for(int i=0;i<2;i++){ 
       Thread t=new Thread(inc); 
       t.start(); 
		   t=new Thread(dec); 
       t.start(); 
       } 
   } 
private synchronized void inc(){ 
   j++; 
   System.out.println(Thread.currentThread().getName()+"-inc:"+j); 
   } 
private synchronized void dec(){ 
   j--; 
   System.out.println(Thread.currentThread().getName()+"-dec:"+j); 
   } 
class Inc implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       inc(); 
       } 
   } 
} 
class Dec implements Runnable{ 
   public void run(){ 
       for(int i=0;i<100;i++){ 
       dec(); 
       } 
   } 
} 
} 

----------随手再写的一个-------------
class A
{
JManger j =new JManager();
main()
{
	new A().call();
}

void call
{
	for(int i=0;i<2;i++)
	{
		new Thread(
			new Runnable(){ public void run(){while(true){j.accumulate()}}}
		).start();
		new Thread(new Runnable(){ public void run(){while(true){j.sub()}}}).start();
	}
}
}

class JManager
{
	private j = 0;
	
	public synchronized void subtract()
	{
		j--
	}
	
	public synchronized void accumulate()
	{
		j++;
	}
	
}

28、子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。 

最终的程序代码如下：
public class ThreadTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new ThreadTest().init();

	}

	public void init()
	{
		final Business business = new Business();
		new Thread(
				new Runnable()
				{

					public void run() {
						for(int i=0;i<50;i++)
						{
							business.SubThread(i);
						}						
					}
					
				}
		
		).start();
		
		for(int i=0;i<50;i++)
		{
			business.MainThread(i);
		}		
	}
	
	private class Business
	{
		boolean bShouldSub = true;//这里相当于定义了控制该谁执行的一个信号灯
		public synchronized void MainThread(int i)
		{
			if(bShouldSub)
				try {
					this.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}		
				
			for(int j=0;j<5;j++)
			{
				System.out.println(Thread.currentThread().getName() + ":i=" + i +",j=" + j);
			}
			bShouldSub = true;
			this.notify();
		
		}
		
		
		public synchronized void SubThread(int i)
		{
			if(!bShouldSub)
				try {
					this.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}	
				
			for(int j=0;j<10;j++)
			{
				System.out.println(Thread.currentThread().getName() + ":i=" + i +",j=" + j);
			}
			bShouldSub = false;				
			this.notify();			
		}
	}
}

备注：不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：

package com.huawei.interview.lym;

public class ThreadTest {
	
	private static boolean bShouldMain = false;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*new Thread(){
		public void run()
		{
			for(int i=0;i<50;i++)
			{
				for(int j=0;j<10;j++)
				{
					System.out.println("i=" + i + ",j=" + j);
				}
			}				
		}
		
	}.start();*/		
		
		
		//final String str = new String("");

		new Thread(
				new Runnable()
				{
					public void run()
					{
						for(int i=0;i<50;i++)
						{
							synchronized (ThreadTest.class) {
								if(bShouldMain)
								{
									try {
										ThreadTest.class.wait();} 
									catch (InterruptedException e) {
										e.printStackTrace();
									}
								}
								for(int j=0;j<10;j++)
								{
									System.out.println(
											Thread.currentThread().getName() + 
											"i=" + i + ",j=" + j);
								}
								bShouldMain = true;
								ThreadTest.class.notify();
							}							
						}						
					}
				}
		).start();
		
		for(int i=0;i<50;i++)
		{
			synchronized (ThreadTest.class) {
				if(!bShouldMain)
				{
					try {
						ThreadTest.class.wait();} 
					catch (InterruptedException e) {
						e.printStackTrace();
					}
				}				
				for(int j=0;j<5;j++)
				{
					System.out.println(
							Thread.currentThread().getName() + 						
							"i=" + i + ",j=" + j);
				}
				bShouldMain = false;
				ThreadTest.class.notify();				
			}			
		}
	}

}
下面使用jdk5中的并发库来实现的：
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

public class ThreadTest
{
	private static Lock lock = new ReentrantLock();
	private static Condition subThreadCondition = lock.newCondition();
	private static boolean bBhouldSubThread = false;
	public static void main(String [] args)
	{
		ExecutorService threadPool = Executors.newFixedThreadPool(3);
		threadPool.execute(new Runnable(){
			public void run()
			{
				for(int i=0;i<50;i++)
				{
					lock.lock();					
					try
					{					
						if(!bBhouldSubThread)
							subThreadCondition.await();
						for(int j=0;j<10;j++)
						{
							System.out.println(Thread.currentThread().getName() + ",j=" + j);
						}
						bBhouldSubThread = false;
						subThreadCondition.signal();
					}catch(Exception e)
					{						
					}
					finally
					{
						lock.unlock();
					}
				}			
			}
			
		});
		threadPool.shutdown();
		for(int i=0;i<50;i++)
		{
				lock.lock();					
				try
				{	
					if(bBhouldSubThread)
							subThreadCondition.await();								
					for(int j=0;j<10;j++)
					{
						System.out.println(Thread.currentThread().getName() + ",j=" + j);
					}
					bBhouldSubThread = true;
					subThreadCondition.signal();					
				}catch(Exception e)
				{						
				}
				finally
				{
					lock.unlock();
				}					
		}
	}
}


3、介绍Collection框架的结构
答：随意发挥题，天南海北谁便谈，只要让别觉得你知识渊博，理解透彻即可。

3、Collection框架中实现比较要实现什么接口
comparable/comparator
3、ArrayList和Vector的区别
答：
这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与hashset没有任何关系，但为了说清楚ArrayList与Vector的功能，我们使用对比方式，更有利于说明问题）。

接着才说ArrayList与Vector的区别，这主要包括两个方面：. 
（1）同步性：
	Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。

备注：对于Vector&ArrayList、Hashtable&HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。
（2）数据增长：
	ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。
    总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。
4、HashMap和Hashtable的区别
（条理上还需要整理，也是先说相同点，再说不同点）
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 
HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 
HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。

就HashMap与HashTable主要从三方面来说。 
一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 
二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 
三.值：只有HashMap可以让你将空值作为一个表的条目的key或value 
5、List 和 Map 区别?
一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。
35、List, Set, Map是否继承自Collection接口? 
   List，Set是，Map不是 

109、List、Map、Set三个接口，存取元素时，各有什么特点？ 
这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。

首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。
	List表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。
	Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。

List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。


HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，"abc" ---> 78，"def" ---> 62，"xyz" ---> 65在hashSet中的存储顺序不是62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet按插入的顺序存储，那被存储对象的hashcode方法还有什么作用呢？学员想想!hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new 两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。

同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。 

7、说出ArrayList,Vector, LinkedList的存储性能和特性 
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。
4、去掉一个Vector集合中重复的元素 
Vector newVector = new Vector();
For (int i=0;i<vector.size();i++)
{
Object obj = vector.get(i);
	if(!newVector.contains(obj);
		newVector.add(obj);
}
还有一种简单的方式，HashSet set = new HashSet(vector); 
9、Collection 和 Collections的区别。 
　　Collection是集合类的上级接口，继承与他的接口主要有Set 和List. 
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 
39、Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别? 
Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。 
   equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。

53、你所知道的集合类都有哪些？主要方法？ 
最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 
Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作"键"和"值"），其中每个键映射到一个值。 

ArrayList/VectorList
                    Collection
HashSet/TreeSetSet

PropetiesHashTable
					Map
	Treemap/HashMap

我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，我记得不是很清楚，对于set，大概的方法是add,remove, contains；对于map，大概的方法就是put,remove，contains等，因为，我只要在eclispe下按点操作符，很自然的这些方法就出来了。我记住的一些思想就是List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。 

45、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对? 
对。
如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。
如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的，例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。
46、TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！ 
（应该是没有针对问题的确切的答案，当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的）
实验代码：
public class Parent implements Comparable {
	private int age = 0;
	public Parent(int age){
		this.age = age;
	}
	public int compareTo(Object o) {
		// TODO Auto-generated method stub
		System.out.println("method of parent");
		Parent o1 = (Parent)o;
		return age>o1.age?1:age<o1.age?-1:0;
	}

}

public class Child extends Parent {

	public Child(){
		super(3);
	}
	public int compareTo(Object o) {

			// TODO Auto-generated method stub
			System.out.println("method of child");
//			Child o1 = (Child)o;
			return 1;

	}
}

public class TreeSetTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		TreeSet set = new TreeSet();
		set.add(new Parent(3));
		set.add(new Child());
		set.add(new Parent(4));
		System.out.println(set.size());
	}

}


112、说出一些常用的类，包，接口，请各举5个 
要让人家感觉你对java ee开发很熟，所以，不能仅仅只列core java中的那些东西，要多列你在做ssh项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。

常用的类：BufferedReader  BufferedWriter  FileReader  FileWirter  String  Integer 
java.util.Date，System，Class，List,HashMap

常用的包：java.lang   java.io  java.util  java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate
常用的接口：Remote  List  Map  Document  NodeList ,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate)、Session(Hibernate),HttpSession
100、java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ 
字节流，字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。 
102、字节流与字符流的区别
	要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。
	在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。
  底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。
  字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，
  其实是转成该字符的某种编码的字节形式，读取也是反之的道理。

讲解字节流与字符流关系的代码案例：
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class IOTest {
	public static void main(String[] args) throws Exception {
		String str = "中国人";
		/*FileOutputStream fos  = new FileOutputStream("1.txt");
		
		fos.write(str.getBytes("UTF-8"));
		fos.close();*/
		
		/*FileWriter fw = new FileWriter("1.txt");
		fw.write(str);
		fw.close();*/
		PrintWriter pw = new PrintWriter("1.txt","utf-8");
		pw.write(str);
		pw.close();
		
		/*FileReader fr = new FileReader("1.txt");
		char[] buf = new char[1024];
		int len = fr.read(buf);
		String myStr = new String(buf,0,len);
		System.out.println(myStr);*/
		/*FileInputStream fr = new FileInputStream("1.txt");
		byte[] buf = new byte[1024];
		int len = fr.read(buf);
		String myStr = new String(buf,0,len,"UTF-8");
		System.out.println(myStr);*/
		BufferedReader br = new BufferedReader(
				new InputStreamReader(
					new FileInputStream("1.txt"),"UTF-8"	
					)
				);
		String myStr = br.readLine();
		br.close();
		System.out.println(myStr);
	}

}
105、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。 

我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。 


例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过rmi等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。

54、描述一下JVM加载class文件的原理机制? 
JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。 

18、heap和stack有什么区别。 
java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。
堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 

24、GC是什么? 为什么要有GC? 　　 
GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

51、垃圾回收的优点和原理。并考虑2种回收机制。 
Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

103、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。 
 

23、什么时候用assert。 
assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，assert将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。 
package com.huawei.interview;

public class AssertTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int i = 0;
		for(i=0;i<5;i++)
		{
			System.out.println(i);
		}
		//假设程序不小心多了一句--i;
		--i;
		assert i==5;		
	}

}

101、java中会存在内存泄漏吗，请简单描述。 
所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收：
package com.huawei.interview;

import java.io.IOException;

public class GarbageTest {

	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		try {
			gcTest();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("has exited gcTest!");
		System.in.read();
		System.in.read();		
		System.out.println("out begin gc!");		
		for(int i=0;i<100;i++)
		{
			System.gc();
			System.in.read();	
			System.in.read();	
		}
	}

	private static void gcTest() throws IOException {
		System.in.read();
		System.in.read();		
		Person p1 = new Person();
		System.in.read();
		System.in.read();		
		Person p2 = new Person();
		p1.setMate(p2);
		p2.setMate(p1);
		System.out.println("before exit gctest!");
		System.in.read();
		System.in.read();		
		System.gc();
		System.out.println("exit gctest!");
	}

	private static class Person
	{
		byte[] data = new byte[20000000];
		Person mate = null;
		public void setMate(Person other)
		{
			mate = other;
		}
	}
}

java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。
检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中消失，将那个元素所在的位置的值设置为null即可）：
我实在想不到比那个堆栈更经典的例子了,以致于我还要引用别人的例子，下面的例子不是我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可是那时我说是我自己想到的也没有人相信的。
    public class Stack {
    private Object[] elements=new Object[10];
    private int size = 0;
    public void push(Object e){
    ensureCapacity();
    elements[size++] = e;
    }
    public Object pop(){
    if( size == 0)
    throw new EmptyStackException();
    return elements[--size];
    }
    private void ensureCapacity(){
    if(elements.length == size){
    Object[] oldElements = elements;
    elements = new Object[2 * elements.length+1];
    System.arraycopy(oldElements,0, elements, 0, size);
    }
    }
    }
    上面的原理应该很简单，假如堆栈加了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，无法回收。
    但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪费了几个K内存而已，反正我们的内存都上G了，哪里会有什么影响，再说这个东西很快就会被回收的，有什么关系。下面看两个例子。
    例子1
    public class Bad{
    public static Stack s=Stack();
    static{
    s.push(new Object());
    s.pop(); //这里有一个对象发生内存泄露
    s.push(new Object()); //上面的对象可以被回收了，等于是自愈了
    }
    }
    因为是static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果你的Stack最多有100个对象，那么最多也就只有100个对象无法被回收其实这个应该很容易理解，Stack内部持有100个引用，最坏的情况就是他们都是无用的，因为我们一旦放新的进取，以前的引用自然消失！

内存泄露的另外一种情况：当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。



8、能不能自己写个类，也叫java.lang.String？

可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB-INF/classess目录中的类，然后才委托上级的类加载器加载，如果我们在tomcat的web应用程序中写一个java.lang.String，这时候Servlet程序加载的就是我们自己写的java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。

虽然java提供了endorsed技术，可以覆盖jdk中的某些类，具体做法是….。但是，能够被覆盖的类是有限制范围，反正不包括java.lang这样的包中的类。

（下面的例如主要是便于大家学习理解只用，不要作为答案的一部分，否则，人家怀疑是题目泄露了）例如，运行下面的程序：
package java.lang;

public class String {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("string");
	}

}
报告的错误如下：
java.lang.NoSuchMethodError: main
Exception in thread "main"
这是因为加载了jre自带的java.lang.String，而该类中没有main方法。

2. Java代码查错
1.
abstract class Name {
   private String name;
   public abstract boolean isStupidName(String name) {}
}
大侠们，这有何错误?
答案: 错。abstract method必须以分号结尾，且不带花括号。
2.
public class Something {
   void doSomething () {
       private String s = "";
       int l = s.length();
   }
}
有错吗?
答案: 错。局部变量前不能放置任何访问修饰符 (private，public，和protected)。final可以用来修饰局部变量
(final如同abstract和strictfp，都是非访问修饰符，strictfp只能修饰class和method而非variable)。
3.
abstract class Something {
   private abstract String doSomething ();
}
这好像没什么错吧?
答案: 错。abstract的methods不能以private修饰。abstract的methods就是让子类implement(实现)具体细节的，怎么可以用private把abstract
method封锁起来呢? (同理，abstract method前不能加final)。
4.
public class Something {
   public int addOne(final int x) {
       return ++x;
   }
}
这个比较明显。
答案: 错。int x被修饰成final，意味着x不能在addOne method中被修改。
5.
public class Something {
   public static void main(String[] args) {
       Other o = new Other();
       new Something().addOne(o);
   }
   public void addOne(final Other o) {
       o.i++;
   }
}
class Other {
   public int i;
}
和上面的很相似，都是关于final的问题，这有错吗?
答案: 正确。在addOne method中，参数o被修饰成final。如果在addOne method里我们修改了o的reference
(比如: o = new Other();)，那么如同上例这题也是错的。但这里修改的是o的member vairable
(成员变量)，而o的reference并没有改变。
6.
class Something {
    int i;
    public void doSomething() {
        System.out.println("i = " + i);
    }
} 
有什么错呢? 看不出来啊。
答案: 正确。输出的是"i = 0"。int i属於instant variable (实例变量，或叫成员变量)。instant variable有default value。int的default value是0。
7.
class Something {
    final int i;
    public void doSomething() {
        System.out.println("i = " + i);
    }
}
和上面一题只有一个地方不同，就是多了一个final。这难道就错了吗?
答案: 错。final int i是个final的instant variable (实例变量，或叫成员变量)。final的instant variable没有default value，必须在constructor (构造器)结束之前被赋予一个明确的值。可以修改为"final int i = 0;"。
8.
public class Something {
     public static void main(String[] args) {
        Something s = new Something();
        System.out.println("s.doSomething() returns " + doSomething());
    }
    public String doSomething() {
        return "Do something ...";
    }
}
 看上去很完美。
答案: 错。看上去在main里call doSomething没有什么问题，毕竟两个methods都在同一个class里。但仔细看，main是static的。static method不能直接call non-static methods。可改成"System.out.println("s.doSomething() returns " + s.doSomething());"。同理，static method不能访问non-static instant variable。
9.
此处，Something类的文件名叫OtherThing.java
class Something {
    private static void main(String[] something_to_do) {        
        System.out.println("Do something ...");
    }
}
 这个好像很明显。
答案: 正确。从来没有人说过Java的Class名字必须和其文件名相同。但public class的名字必须和文件名相同。
10．
interface  A{
   int x = 0;
}
class B{
   int x =1;
}
class C extends B implements A {
   public void pX(){
      System.out.println(x);
   }
   public static void main(String[] args) {
      new C().pX();
   }
}
答案：错误。在编译时会发生错误(错误描述不同的JVM有不同的信息，意思就是未明确的x调用，两个x都匹配（就象在同时import java.util和java.sql两个包时直接声明Date一样）。对于父类的变量,可以用super.x来明确，而接口的属性默认隐含为 public static final.所以可以通过A.x来明确。
11.
interface Playable {
    void play();
}
interface Bounceable {
    void play();
}
interface Rollable extends Playable, Bounceable {
    Ball ball = new Ball("PingPang");
}
class Ball implements Rollable {
    private String name;
    public String getName() {
        return name;
    }
    public Ball(String name) {
        this.name = name;        
    }
   public void play() {
        ball = new Ball("Football");
        System.out.println(ball.getName());
    }
}
这个错误不容易发现。
答案: 错。"interface Rollable extends Playable, Bounceable"没有问题。interface可继承多个interfaces，所以这里没错。问题出在interface Rollable里的"Ball ball = new Ball("PingPang");"。任何在interface里声明的interface variable (接口变量，也可称成员变量)，默认为public static final。也就是说"Ball ball = new Ball("PingPang");"实际上是"public static final Ball ball = new Ball("PingPang");"。在Ball类的Play()方法中，"ball = new Ball("Football");"改变了ball的reference，而这里的ball来自Rollable interface，Rollable interface里的ball是public static final的，final的object是不能被改变reference的。因此编译器将在"ball = new Ball("Football");"这里显示有错。
4. 算法与编程
1.判断身份证：要么是15位，要么是18位，最后一位可以为字母，并写程序提出其中的年月日。
答：我们可以用正则表达式来定义复杂的字符串格式，(\d{17}[0-9a-zA-Z]|\d{14}[0-9a-zA-Z])可以用来判断是否为合法的15位或18位身份证号码。
因为15位和18位的身份证号码都是从7位到第12位为身份证为日期类型。这样我们可以设计出更精确的正则模式，使身份证号的日期合法，这样我们的正则模式可以进一步将日期部分的正则修改为[12][0-9]{3}[01][0-9][123][0-9]，当然可以更精确的设置日期。
在jdk的java.util.Regex包中有实现正则的类,Pattern和Matcher。以下是实现代码：

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		// 测试是否为合法的身份证号码
		String[] strs = { "130681198712092019", "13068119871209201x",
				"13068119871209201", "123456789012345", "12345678901234x",
				"1234567890123" };
		Pattern p1 = Pattern.compile("(\\d{17}[0-9a-zA-Z]|\\d{14}[0-9a-zA-Z])");
		for (int i = 0; i < strs.length; i++) {
			Matcher matcher = p1.matcher(strs[i]);
			System.out.println(strs[i] + ":" + matcher.matches());
		}

		Pattern p2 = Pattern.compile("\\d{6}(\\d{8}).*"); // 用于提取出生日字符串
		Pattern p3 = Pattern.compile("(\\d{4})(\\d{2})(\\d{2})");// 用于将生日字符串进行分解为年月日
		for (int i = 0; i < strs.length; i++) {
			Matcher matcher = p2.matcher(strs[i]);
			boolean b = matcher.find();
			if (b) {
				String s = matcher.group(1);
				Matcher matcher2 = p3.matcher(s);
				if (matcher2.find()) {
					System.out
							.println("生日为" + matcher2.group(1) + "年"
									+ matcher2.group(2) + "月"
									+ matcher2.group(3) + "日");
				}
			}

		}

	}

}

1、编写一个程序，将a.txt文件中的单词与b.txt文件中的单词交替合并到c.txt文件中，a.txt文件中的单词用回车符分隔，b.txt文件中用回车或空格进行分隔。
答：
		package cn.itcast;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;

public class MainClass{
	public static void main(String[] args) throws Exception{
		FileManager a = new FileManager("a.txt",new char[]{'\n'});
		FileManager b = new FileManager("b.txt",new char[]{'\n',' '});		
		FileWriter c = new FileWriter("c.txt");
		String aWord = null;
		String bWord = null;
		while((aWord = a.nextWord()) !=null ){
			c.write(aWord + "\n");
			bWord = b.nextWord();
			if(bWord != null)
				c.write(bWord + "\n");
		}
		
		while((bWord = b.nextWord()) != null){
			c.write(bWord + "\n");
		}	
		c.close();
	}
	
}


class FileManager{

	String[] words = null;
	int pos = 0;
	public FileManager(String filename,char[] seperators) throws Exception{
		File f = new File(filename);
		FileReader reader = new FileReader(f);
		char[] buf = new char[(int)f.length()];
		int len = reader.read(buf);
		String results = new String(buf,0,len);
		String regex = null;
		if(seperators.length >1 ){
			regex = "" + seperators[0] + "|" + seperators[1];
		}else{
			regex = "" + seperators[0];
		}
		words = results.split(regex);
	}
	
	public String nextWord(){
		if(pos == words.length)
			return null;
		return words[pos++];
	}

}

1、编写一个程序，将d:\java目录下的所有.java文件复制到d:\jad目录下，并将原来文件的扩展名从.java改为.jad。
（大家正在做上面这道题，网上迟到的朋友也请做做这道题，找工作必须能编写这些简单问题的代码！）
答：listFiles方法接受一个FileFilter对象，这个FileFilter对象就是过虑的策略对象，不同的人提供不同的FileFilter实现，即提供了不同的过滤策略。
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class Jad2Java {

	public static void main(String[] args) throws Exception {
		File srcDir = new File("java");
		if(!(srcDir.exists() && srcDir.isDirectory()))
				throw new Exception("目录不存在");
		File[] files = srcDir.listFiles(
			new FilenameFilter(){

					public boolean accept(File dir, String name) {
						return name.endsWith(".java");
					}
					
				}
		);
		
		System.out.println(files.length);
		File destDir = new File("jad");
		if(!destDir.exists()) destDir.mkdir();
		for(File f :files){
			FileInputStream  fis = new FileInputStream(f);
			String destFileName = f.getName().replaceAll("\\.java$", ".jad");
			FileOutputStream fos = new FileOutputStream(new File(destDir,destFileName));
			copy(fis,fos);
			fis.close();
			fos.close();
		}
	}
	
	private static void copy(InputStream ips,OutputStream ops) throws Exception{
		int len = 0;
		byte[] buf = new byte[1024];
		while((len = ips.read(buf)) != -1){
			ops.write(buf,0,len);
		}

	}
}

由本题总结的思想及策略模式的解析：
1.
class jad2java{
	1. 得到某个目录下的所有的java文件集合
		1.1 得到目录 File srcDir = new File("d:\\java");
		1.2 得到目录下的所有java文件：File[] files = srcDir.listFiles(new MyFileFilter());
		1.3 只想得到.java的文件： class MyFileFilter implememyts FileFilter{
			public boolean accept(File pathname){
				return pathname.getName().endsWith(".java")
			}
		}
		
	2.将每个文件复制到另外一个目录，并改扩展名
		2.1 得到目标目录，如果目标目录不存在，则创建之
		2.2 根据源文件名得到目标文件名，注意要用正则表达式，注意.的转义。
		2.3 根据表示目录的File和目标文件名的字符串，得到表示目标文件的File。
			//要在硬盘中准确地创建出一个文件，需要知道文件名和文件的目录。 
		2.4 将源文件的流拷贝成目标文件流，拷贝方法独立成为一个方法，方法的参数采用抽象流的形式。
			//方法接受的参数类型尽量面向父类，越抽象越好，这样适应面更宽广。	
}

分析listFiles方法内部的策略模式实现原理
File[] listFiles(FileFilter filter){
	File[] files = listFiles();
	//Arraylist acceptedFilesList = new ArrayList();
	File[] acceptedFiles = new File[files.length];
	int pos = 0;
	for(File file: files){
		boolean accepted = filter.accept(file);
		if(accepted){
			//acceptedFilesList.add(file);
			acceptedFiles[pos++] = file;
		}		
	}
	
	Arrays.copyOf(acceptedFiles,pos);
	//return (File[])accpetedFilesList.toArray();
	
}
1、编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。
答：
	首先要了解中文字符有多种编码及各种编码的特征。
    假设n为要截取的字节数。
	public static void main(String[] args) throws Exception{
		String str = "我a爱中华abc我爱传智def';
		String str = "我ABC汉";
		int num = trimGBK(str.getBytes("GBK"),5);
		System.out.println(str.substring(0,num) );
	}
	
	public static int  trimGBK(byte[] buf,int n){
		int num = 0;
		boolean bChineseFirstHalf = false;
		for(int i=0;i<n;i++)
		{
			if(buf[i]<0 && !bChineseFirstHalf){
				bChineseFirstHalf = true;
			}else{
				num++;
				bChineseFirstHalf = false;				
			}
		}
		return num;
	}
1、有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。
答：哈哈，其实包含中文字符、英文字符、数字字符原来是出题者放的烟雾弹。
String content = “中国aadf的111萨bbb菲的zz萨菲”;
HashMap map = new HashMap();
for(int i=0;i<content.length;i++)
{
	char c = content.charAt(i);
	Integer num = map.get(c);
	if(num == null)
		num = 1;
	else
		num = num + 1;
	map.put(c,num);
} 
for(Map.EntrySet entry : map)
{
	system.out.println(entry.getkey() + “:” + entry.getValue());
}
估计是当初面试的那个学员表述不清楚，问题很可能是：
如果一串字符如"aaaabbc中国1512"要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。
int engishCount;
int chineseCount;
int digitCount;
for(int i=0;i<str.length;i++)
{
	char ch = str.charAt(i);
	if(ch>=’0’ && ch<=’9’)
	{
		digitCount++
	}
	else if((ch>=’a’ && ch<=’z’) || (ch>=’A’ && ch<=’Z’))
	{
		engishCount++;
	}
	else
	{
		chineseCount++;
	}
}
System.out.println(……………);

1、说明生活中遇到的二叉树，用java实现二叉树
这是组合设计模式。
我有很多个(假设10万个)数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据，（我想说出二叉树的好处，该怎么说呢？那就是说别人的缺点），假如存在数组中，那么，碰巧要找的数字位于99999那个地方，那查找的速度将很慢，因为要从第1个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序，中序，后序）效率要比数组低很多，原理如下图：

代码如下：
package com.huawei.interview;

public class Node {
	public int value;
	public Node left;
	public Node right;
	
	public void store(int value)
	{
		if(value<this.value)
		{
			if(left == null)
			{
				left = new Node();
				left.value=value;
			}
			else
			{
				left.store(value);
			}
		}
		else if(value>this.value)
		{
			if(right == null)
			{
				right = new Node();
				right.value=value;
			}
			else
			{
				right.store(value);
			}			
		}
	}
	
	public boolean find(int value)
	{	
		System.out.println("happen " + this.value);
		if(value == this.value)
		{
			return true;
		}
		else if(value>this.value)
		{
			if(right == null) return false;
			return right.find(value);
		}else
		{
			if(left == null) return false;
			return left.find(value);
		}

	}
	
	public  void preList()
	{
		System.out.print(this.value + ",");
		if(left!=null) left.preList();
		if(right!=null) right.preList();
	}
	
	public void middleList()
	{
		if(left!=null) left.preList();
		System.out.print(this.value + ",");
		if(right!=null) right.preList();		
	}
	public void afterList()
	{
		if(left!=null) left.preList();
		if(right!=null) right.preList();
		System.out.print(this.value + ",");		
	}	
	public static void main(String [] args)
	{
		int [] data = new int[20];
		for(int i=0;i<data.length;i++)
		{
			data[i] = (int)(Math.random()*100) + 1;
			System.out.print(data[i] + ",");
		}
		System.out.println();
		
		Node root = new Node();
		root.value = data[0];
		for(int i=1;i<data.length;i++)
		{
			root.store(data[i]);
		}
		
		root.find(data[19]);
		
		root.preList();
		System.out.println();
		root.middleList();
		System.out.println();		
		root.afterList();
	}
}
-----------------又一次临场写的代码---------------------------
import java.util.Arrays;
import java.util.Iterator;

public class Node {
	private Node left;
	private Node right;
	private int value;
	//private int num;
	
	public Node(int value){
		this.value = value;
	}
	public void add(int value){
		
		if(value > this.value)
		{
			if(right != null)
				right.add(value);
			else
			{
				Node node = new Node(value);				
				right = node;
			}
		}
		else{
			if(left != null)
				left.add(value);
			else
			{
				Node node = new Node(value);				
				left = node;
			}			
		}
	}
	
	public boolean find(int value){
		if(value == this.value) return true;
		else if(value > this.value){
			if(right == null) return false;
			else return right.find(value);
		}else{
			if(left == null) return false;
			else return left.find(value);			
		}

	}
	
	public void display(){
		System.out.println(value);
		if(left != null) left.display();
		if(right != null) right.display();
		
	}
	
	/*public Iterator iterator(){
		
	}*/
	
	public static void main(String[] args){
		int[] values = new int[8];
		for(int i=0;i<8;i++){
			int num = (int)(Math.random() * 15);
			//System.out.println(num);
			//if(Arrays.binarySearch(values, num)<0)
			if(!contains(values,num))
				values[i] = num;
			else
				i--;
		}
		
		System.out.println(Arrays.toString(values));
		
		Node root  = new Node(values[0]);
		for(int i=1;i<values.length;i++){
			root.add(values[i]);
		}
		
		System.out.println(root.find(13));
		
		root.display();
		
	}
	
	public static boolean contains(int [] arr, int value){
		int i = 0;
		for(;i<arr.length;i++){
			if(arr[i] == value) return true;
			
		}
		return false;
	}
	
}
1、从类似如下的文本文件中读取出所有的姓名，并打印出重复的姓名和重复的次数，并按重复次数排序：
1,张三,28
2,李四,35
3,张三,28
4,王五,35
5,张三,28
6,李四,35
7,赵六,28
8,田七,35

程序代码如下（答题要博得用人单位的喜欢，包名用该公司，面试前就提前查好该公司的网址，如果查不到，现场问也是可以的。还要加上实现思路的注释）：
package com.huawei.interview;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeSet;


public class GetNameTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//InputStream ips = GetNameTest.class.getResourceAsStream("/com/huawei/interview/info.txt");
		//用上一行注释的代码和下一行的代码都可以，因为info.txt与GetNameTest类在同一包下面，所以，可以用下面的相对路径形式
		
		Map results = new HashMap();
		InputStream ips = GetNameTest.class.getResourceAsStream("info.txt");
		BufferedReader in = new BufferedReader(new InputStreamReader(ips));
		String line = null;
		try {
			while((line=in.readLine())!=null)
			{
				dealLine(line,results);
			}
			sortResults(results);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	static class User
	{
		public  String name;
		public Integer value;
		public User(String name,Integer value)
		{
			this.name = name;
			this.value = value;
		}

		@Override
		public boolean equals(Object obj) {
			// TODO Auto-generated method stub
				
			//下面的代码没有执行，说明往treeset中增加数据时，不会使用到equals方法。
			boolean result = super.equals(obj);
			System.out.println(result);
			return result;
		}
	}
	
	private static void sortResults(Map results) {
		// TODO Auto-generated method stub
		TreeSet sortedResults = new TreeSet(
				new Comparator(){
					public int compare(Object o1, Object o2) {
						// TODO Auto-generated method stub
						User user1 = (User)o1;
						User user2 = (User)o2;
						/*如果compareTo返回结果0，则认为两个对象相等，新的对象不会增加到集合中去
						 * 所以，不能直接用下面的代码，否则，那些个数相同的其他姓名就打印不出来。
						 * */
						
						//return user1.value-user2.value;
						//return user1.value<user2.value?-1:user1.value==user2.value?0:1;
						if(user1.value<user2.value)
						{
							return -1;
						}else if(user1.value>user2.value)
						{
							return 1;
						}else
						{
							return user1.name.compareTo(user2.name);
						}
					}
					
				}
		);
		Iterator iterator = results.keySet().iterator();
		while(iterator.hasNext())
		{
			String name = (String)iterator.next();
			Integer value = (Integer)results.get(name);
			if(value > 1)
			{				
				sortedResults.add(new User(name,value));				
			}
		}
		
		printResults(sortedResults);
	}
	private static void printResults(TreeSet sortedResults) 
	{
		Iterator iterator  = sortedResults.iterator();
		while(iterator.hasNext())
		{
			User user = (User)iterator.next();
			System.out.println(user.name + ":" + user.value);
		}	
	}
	public static void dealLine(String line,Map map)
	{
		if(!"".equals(line.trim()))
		{
			String [] results = line.split(",");
			if(results.length == 3)
			{
				String name = results[1];
				Integer value = (Integer)map.get(name);
				if(value == null) value = 0;
				map.put(name,value + 1);
			}
		}
	}

}
48、写一个Singleton出来。
第一种：饱汉模式
public class SingleTon {
	private SingleTon(){
		}

	//实例化放在静态代码块里可提高程序的执行效率，但也可能更占用空间	
	private final static SingleTon instance = new SingleTon();
	public static SingleTon getInstance(){
		return instance;
	}
}

第二种：饥汉模式
public class SingleTon {
	private SingleTon(){}
	
	private static instance = null;//new SingleTon();
	
	public static synchronized SingleTon getInstance(){
		if(instance == null)
			instance = new SingleTon();
		return instance;
	}
}

第三种：用枚举
	public enum SingleTon{
		ONE;
	
	}

第三：更实际的应用（在什么情况用单例）
public class SequenceGenerator{
	//下面是该类自身的业务功能代码
	private int count = 0;

	public synchronized int getSequence(){
		++count;
	}
	
	//下面是把该类变成单例的代码
	private SequenceGenerator(){}
	private final static instance = new SequenceGenerator();
	public static SingleTon getInstance(){
		return instance;
	}	
	
}

第四：
	public class MemoryDao
	{
    private HashMap map = new HashMap();
    
   	public void add(Student stu1){ 
    		map.put(SequenceGenerator.getInstance().getSequence(),stu1);
    }
   
   //把MemoryDao变成单例 
  }






Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 
一般Singleton模式通常有几种种形式: 
第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 
public class Singleton { 
private Singleton(){} 
　　    //在自己内部定义自己一个实例，是不是很奇怪？ 
　　    //注意这是private 只供内部调用 
　　    private static Singleton instance = new Singleton(); 
　　    //这里提供了一个供外部访问本class的静态方法，可以直接访问　　 
　　    public static Singleton getInstance() { 
　　　　    return instance; 　　 
　　    } 
   } 
   第二种形式: 
public class Singleton { 
　　private static Singleton instance = null; 
　　public static synchronized Singleton getInstance() { 
　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　 
　　//使用时生成实例，提高了效率！ 
　　if (instance==null) 
　　　　instance＝new Singleton(); 
			return instance; 　　
	} 
} 
其他形式: 
定义一个类，它的构造函数为private的，所有方法为static的。 
一般认为第一种形式要更加安全些 
7、递归算法题1
一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。
例：n=1237
则输出为：
1237，
2474，
4948，
9896，
9896，
4948，
2474，
1237，
提示：写程序时，先致谢按递增方式的代码，写好递增的以后，再增加考虑递减部分。
	public static void doubleNum(int n)
	{
		System.out.println(n);
		if(n<=5000)
			doubleNum(n*2);
		System.out.println(n);		
	}


7、递归算法题2
第1个人10，第2个比第1个人大2岁，依次递推，请用递归方式计算出第8个人多大？
package cn.itcast;

import java.util.Date;

public class A1 {

	public static void main(String [] args)
	{
		System.out.println(computeAge(8));
	}
	
	public static int computeAge(int n)
	{
		if(n==1) return 10;
		return computeAge(n-1) + 2;
	}
}

	public static void toBinary(int n,StringBuffer result)
	{

		if(n/2 != 0)
			toBinary(n/2,result);
		result.append(n%2);		
	}
94、排序都有哪几种方法？请列举。用JAVA实现一个快速排序。 
 本人只研究过冒泡排序、选择排序和快速排序，下面是快速排序的代码：
public class QuickSort {
/**
* 快速排序
* @param strDate
* @param left
* @param right
*/
public void quickSort(String[] strDate,int left,int right){
String middle,tempDate;
int i,j;
i=left;
j=right;
middle=strDate[(i+j)/2];
do{
while(strDate[i].compareTo(middle)<0&& i<right)
i++; //找出左边比中间值大的数
while(strDate[j].compareTo(middle)>0&& j>left)
j--; //找出右边比中间值小的数
if(i<=j){ //将左边大的数和右边小的数进行替换 
tempDate=strDate[i];
strDate[i]=strDate[j];
strDate[j]=tempDate;
i++;
j--;
}
}while(i<=j); //当两者交错时停止

if(i<right){
quickSort(strDate,i,right);//从
}
if(j>left){
quickSort(strDate,left,j);
}
}
/**
  * @param args
  */
public static void main(String[] args){
String[] strVoid=new String[]{"11","66","22","0","55","22","0","32"};
QuickSort sort=new QuickSort();
sort.quickSort(strVoid,0,strVoid.length-1);
for(int i=0;i<strVoid.length;i++){
System.out.println(strVoid[i]+" ");
}
}


}
7、有数组a[n]，用java代码将数组元素顺序颠倒
//用下面的也可以
//for(int i=0,int j=a.length-1;i<j;i++,j--) 是否等效于 for(int i=0;i<a.length/2;i++)呢？

import java.util.Arrays;

public class SwapDemo{

	public static void main(String[] args){
		int [] a = new int[]{
						(int)(Math.random() * 1000),
						(int)(Math.random() * 1000),
						(int)(Math.random() * 1000),
						(int)(Math.random() * 1000),						
						(int)(Math.random() * 1000)																		
		};	
		
		System.out.println(a);
		System.out.println(Arrays.toString(a));
		swap(a);
		System.out.println(Arrays.toString(a));		
	}
	
	public static void swap(int a[]){
		int len = a.length;
		for(int i=0;i<len/2;i++){
			int tmp = a[i];
			a[i] = a[len-1-i];
			a[len-1-i] = tmp;
		}
	}
}
2．金额转换，阿拉伯数字的金额转换成中国传统的形式如：（￥1011）－>（一千零一拾一元整）输出。
去零的代码：
	return sb.reverse().toString().replaceAll("零[拾佰仟]","零").replaceAll("零+万","万").replaceAll("零+元","元").replaceAll("零+","零");

public class RenMingBi {

	/**
	 * @param args add by zxx ,Nov 29, 2008
	 */
	private static final char[] data = new char[]{
			'零','壹','贰','叁','肆','伍','陆','柒','捌','玖'
		}; 
	private static final char[] units = new char[]{
		'元','拾','佰','仟','万','拾','佰','仟','亿'
	};
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(
				convert(135689123));
	}

	public static String convert(int money)
	{
		StringBuffer sbf = new StringBuffer();
		int unit = 0;
		while(money!=0)
		{
			sbf.insert(0,units[unit++]);
			int number = money%10;
			sbf.insert(0, data[number]);
			money /= 10;
		}

		return sbf.toString();
	}
}
5. html&JavaScript&ajax部分
1. 判断第二个日期比第一个日期大
	如何用脚本判断用户输入的的字符串是下面的时间格式2004-11-21 必须要保证用户的输入是此格式，并且是时间，比如说月份不大于12等等，另外我需要用户输入两个，并且后一个要比前一个晚，只允许用JAVASCRIPT，请详细帮助作答，, 
//这里可用正则表达式判断提前判断一下格式，然后按下提取各时间字段内容
<script type="text/javascript">
	window.onload = function()
	{
		//这么写是为了实现js代码与html代码的分离，当我修改js时，不能影响html代码。
		document.getElementById("frm1").onsubmit = 
			function(){
				var d1 = this.d1.value;
				var d2 = this.d2.value;
				if(!verifyDate (d1)) {alert("第一个日期格式不对");return false;}
				if(!verifyDate (d2)) {alert("第二个日期格式不对");return false;}
				if(!compareDate(d1,d2)) {alert("第二个日期比第一日期小");return false;}			
			};
		}
		
		function compareDate(d1,d2)
		{
			var arrayD1 = d1.split("-");
			var date1 = new Date(arrayD1[0],arrayD1[1],arrayD1[2]);
			var arrayD2 = d2.split("-");
			var date2 = new Date(arrayD2[0],arrayD2[1],arrayD2[2]);	
			if(date1 > date2) return false;		
			return true;
		} 
		
		function verifyDate(d)
		{
			var datePattern = /^\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2]\d|3[0-1])$/;
			return datePattern.test(d);
		}
</script>

<form id="frm1" action="xxx.html">
<input type="text" name="d1" />
<input type="text" name="d2" />
<input type="submit"/>
</form>
1. 用table显示n条记录，每3行换一次颜色，即1，2，3用红色字体，4，5，6用绿色字体，7，8，9用红颜色字体。
<body>
<table id="tbl">
	<tr><td>1</td></tr>
	<tr><td>2</td></tr>
	<tr><td>3</td></tr>
	<tr><td>4</td></tr>
	<tr><td>5</td></tr>
	<tr><td>6</td></tr>
	<tr><td>7</td></tr>
	<tr><td>8</td></tr>
	<tr><td>9</td></tr>
	<tr><td>10</td></tr>
</table>
</body>
<script type="text/javascript">
	window.onload=function()
		{
			var tbl = document.getElementById("tbl");
			rows = tbl.getElementsByTagName("tr");
			for(i=0;i<rows.length;i++)
			{
				var j = parseInt(i/3);
				if(j%2==0) rows[i].style.backgroundColor="#f00";
				else  rows[i].style.backgroundColor="#0f0";
			}
		}
</script>
1、HTML 的 form 提交之前如何验证数值文本框的内容全部为数字? 否则的话提示用户并终止提交? 
<form onsubmit=’return chkForm(this)’>
<input type="text" name="d1"/>
<input type="submit"/>
</form>
<script type=”text/javascript” />	
function chkForm(this)
	{ 
		var value = thist.d1.value;
		var len = value.length;
		for(var i=0;i<len;i++)
		{
			if(value.charAt(i)>"9" || value.charAt(i)<"0")
			{
				alert("含有非数字字符");
				return false;
			}
		}
		return true;
	}
</script>

2、请写出用于校验HTML文本框中输入的内容全部为数字的javascript代码
<input type="text" id="d1" onblur=" chkNumber (this)"/>
<script type=”text/javascript” />	
function chkNumber(eleText)
 
	{ 
		var value = eleText.value;
		var len = value.length;
		for(var i=0;i<len;i++)
		{
			if(value.charAt(i)>"9" || value.charAt(i)<"0")
			{
				alert("含有非数字字符");

				eleText.focus();
				break; 
			}
		}
	}
</script>
除了写完代码，还应该在网页上写出实验步骤和在代码中加入实现思路，让面试官一看就明白你的意图和检查你的结果。

1、说说你用过那些ajax技术和框架，说说它们的区别
答:去掉对web.xml的监视，把jsp提前编辑成Servlet。
有富余物理内存的情况，加大tomcat使用的jvm的内存

6. Java web部分
1、Tomcat的优化经验
答:去掉对web.xml的监视，把jsp提前编辑成Servlet。
有富余物理内存的情况，加大tomcat使用的jvm的内存


1、HTTP请求的GET与POST方式的区别
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。
62、解释一下什么是servlet;
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。
1、说一说Servlet的生命周期? 
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。

Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do***()方法。结束服务，web容器调用servlet的destroy()方法。 

4、Servlet的基本架构 
public class ServletName extends HttpServlet { 
public void doPost(HttpServletRequest request, HttpServletResponse response) throws 
ServletException, IOException { 
} 
public void doGet(HttpServletRequest request, HttpServletResponse response) throws 
ServletException, IOException { 
} 
} 
3、SERVLET API中forward() 与redirect()的区别？ 
答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用
sendRedirect()方法。 

60、什么情况下调用doGet()和doPost()？ 
Jsp页面中的FORM标签里的method属性为get时调用doGet()，为post时调用doPost()。 

66、Request对象的主要方法： 
setAttribute(String name,Object)：设置名字为name的request的参数值 
getAttribute(String name)：返回由name指定的属性值 
getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例 
getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组 
getCharacterEncoding()：返回请求中的字符编码方式 
getContentLength()：返回请求的Body的长度 
getHeader(String name)：获得HTTP协议定义的文件头信息 
getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例 
getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例 
getInputStream()：返回请求的输入流，用于获得请求中的数据 
getMethod()：获得客户端向服务器端传送数据的方法 
getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值 
getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 
getParametervalues(String name)：获得有name指定的参数的所有值 
getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 
getQueryString()：获得查询字符串 
getRequestURI()：获取发出请求字符串的客户端地址 
getRemoteAddr()：获取客户端的IP地址 
getRemoteHost()：获取客户端的名字 
getSession([Boolean create])：返回和请求相关Session 
getServerName()：获取服务器的名字 
getServletPath()：获取客户端所请求的脚本文件的路径 
getServerPort()：获取服务器的端口号 
removeAttribute(String name)：删除请求中的一个属性 



19、forward 和redirect的区别 
forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 
   redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。
4、request.getAttribute() 和 request.getParameter() 有何区别?
1. jsp有哪些内置对象?作用分别是什么? 分别有什么方法？ 
答:JSP共有以下9个内置的对象： 
request 用户端请求，此请求会包含来自GET/POST请求的参数 
response 网页传回用户端的回应 
pageContext 网页的属性是在这里管理 
session 与请求有关的会话期 
application servlet 正在执行的内容 
out 用来传送回应的输出 
config servlet的构架部件 
page JSP网页本身 
exception 针对错误网页，未捕捉的例外 

request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。 
   response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等） 
   out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 
   pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 
   session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 
   applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 
   config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 
   page表示从该页面产生的一个servlet实例 

2. jsp有哪些动作?作用分别是什么? 
（这个问题似乎不重要，不明白为何有此题）
答:JSP共有以下6种基本动作 
jsp:include：在页面被请求的时候引入一个文件。 
jsp:useBean：寻找或者实例化一个JavaBean。 
jsp:setProperty：设置JavaBean的属性。 
jsp:getProperty：输出某个JavaBean的属性。 
jsp:forward：把请求转到一个新的页面。 
jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记
59、JSP的常用指令 
isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式) 

3. JSP中动态INCLUDE与静态INCLUDE的区别？ 
答：动态INCLUDE用jsp:include动作实现 
<jsp:include page=included.jsp flush=true />它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数 静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 <%@ include file=included.htm %> 

4、两种跳转方式分别是什么?有什么区别? 
（下面的回答严重错误，应该是想问forward和sendRedirect 的区别，毕竟出题的人不是专业搞文字艺术的人，可能表达能力并不见得很强，用词不一定精准，加之其自身的技术面也可能存在一些问题，不一定真正将他的意思表达清楚了，严格意思上来讲，一些题目可能根本就无人能答，所以，答题时要掌握主动，只要把自己知道的表达清楚就够了，而不要去推敲原始题目的具体含义是什么，不要一味想着是在答题）
答：有两种，分别为： 
<jsp:include page=included.jsp flush=true> 
<jsp:forward page= nextpage.jsp/> 
前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。

63、页面间对象传递的方法 
request，session，application，cookie等 
64、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？ 
JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是"类servlet"。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。 

1、MVC的各个部分都有那些技术来实现?如何实现? 
答:MVC是Model－View－Controller的简写。Model 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， View 是应用的表示面（由JSP页面产生），Controller 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 

68、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ 
 Public String translate (String str) { 
   String tempStr = ""; 
   try { 
     tempStr = new String(str.getBytes("ISO-8859-1"), "GBK"); 
     tempStr = tempStr.trim(); 
   } 
   catch (Exception e) { 
     System.err.println(e.getMessage()); 
   } 
   return tempStr; 
 } 
1．现在输入n个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一页面显示按什么排序，结果为，提供reset
7. 实际项目开发
1、在eclipse中调试时，怎样查看一个变量的值？
在要查看的变量前先设置断点，然后选中变量，右键选debug as-->Java Application，打开debug透视图，这时在Variables窗口中可以看到变量当前的值。
如果是局部变量，也可以在局部变量窗口中查看。
要知道一个方法被调用的方法调用链，可以在方法栈中查看。

2、你们公司使用的代码配置管理工具是什么？ 
除了说以前使用cvs，现在新项目使用svn了，还简要说一下使用的过程，如果有可能，还说说仓库的概念和如何使用锁之类的细节。

3、你们的项目总金额多少，多少人开发，总共花了多少个月？
像巴巴运动网这种规模的项目，可以说是4、5个人、开发了4、5个月，费用则是4、50万。按每人每月两万收入去计算，就差不多了。

7. 数据库部分
1、用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。
employee:
     eid,ename,salary,deptid;
 select * from employee order by deptid desc,salary


2、列出各个部门中工资高于本部门的平均工资的员工数和部门号，并按部门号排序
创建表：
       mysql> create table employee921(id int primary key auto_increment,name varchar(5
0),salary bigint,deptid int);

插入实验数据：
mysql> insert into employee921 values(null,'zs',1000,1),(null,'ls',1100,1),(null
,'ww',1100,1),(null,'zl',900,1) ,(null,'zl',1000,2), (null,'zl',900,2) ,(null,'z
l',1000,2) , (null,'zl',1100,2);

编写sql语句：

（）select avg(salary) from employee921 group by deptid;
（）mysql> select employee921.id,employee921.name,employee921.salary,employee921.dep
tid tid from  employee921 where salary > (select avg(salary) from employee921 where  deptid = tid);
   效率低的一个语句，仅供学习参考使用（在group by之后不能使用where，只能使用having，在group by之前可以使用where，即表示对过滤后的结果分组）：
mysql> select employee921.id,employee921.name,employee921.salary,employee921.dep
tid tid from  employee921 where salary > (select avg(salary) from employee921 group by deptid having deptid = tid);
（）select count(*) ,tid 
	from (
		select employee921.id,employee921.name,employee921.salary,employee921.deptid tid 
		from  	employee921 
		where salary >
	 		(select avg(salary) from employee921 where  deptid = tid)
	) as t 
	group by tid ;

另外一种方式：关联查询
select a.ename,a.salary,a.deptid 
 from emp a,
    (select deptd,avg(salary) avgsal from emp group by deptid ) b 
 where a.deptid=b.deptid and a.salary>b.avgsal;
1、存储过程与触发器必须讲，经常被面试到?
create procedure insert_Student (_name varchar(50),_age int ,out _id int)
begin
	insert into student value(null,_name,_age);
	select max(stuId) into _id from student;
end;

call insert_Student('wfz',23,@id);
select @id;

mysql> create trigger update_Student BEFORE update on student FOR EACH ROW
-> select * from student;
触发器不允许返回结果

create trigger update_Student BEFORE update on student FOR EACH ROW  
insert into  student value(null,'zxx',28);
mysql的触发器目前不能对当前表进行操作

create trigger update_Student BEFORE update on student FOR EACH ROW  
delete from articles  where id=8;
这个例子不是很好，最好是用删除一个用户时，顺带删除该用户的所有帖子
这里要注意使用OLD.id

触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而UCH没有用触发器，效率和数据处理能力都很低。
存储过程的实验步骤：
mysql> delimiter |
mysql> create procedure insertArticle_Procedure (pTitle varchar(50),pBid int,out
 pId int)
    -> begin
    -> insert into article1 value(null,pTitle,pBid);
    -> select max(id) into pId from article1;
    -> end;
    -> |
Query OK, 0 rows affected (0.05 sec)

mysql> call insertArticle_Procedure('传智播客',1,@pid);
    -> |
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql> select @pid;
+------+
| @pid |
+------+
| 3    |
+------+
1 row in set (0.00 sec)

mysql> select * from article1;
+----+--------------+------+
| id | title        | bid  |
+----+--------------+------+
| 1  | test         | 1    |
| 2  | chuanzhiboke | 1    |
| 3  | 传智播客     | 1    |
+----+--------------+------+
3 rows in set (0.00 sec)

触发器的实验步骤：
create table board1(id int primary key auto_increment,name varchar(50),ar
ticleCount int);

create table article1(id int primary key auto_increment,title varchar(50)
,bid int references board1(id));

delimiter |

create trigger insertArticle_Trigger after insert on article1 for each ro
w begin
    -> update board1 set articleCount=articleCount+1 where id= NEW.bid;
    -> end;
    -> |

delimiter ;

insert into board1 value (null,'test',0);

insert into article1 value(null,'test',1);
还有，每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，用触发器做效率就很高。下次课设计这样一个案例，写触发器时，对于最后发帖时间可能需要用declare方式声明一个变量，或者是用NEW.posttime来生成。

1、数据库三范式是什么?
第一范式（1NF）：字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式）
	数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。

  第二范式（2NF）：
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。
要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。

第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。
  
 第三范式的要求如下： 
满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
所以第三范式具有如下特征：
         1，每一列只有一个值 
         2，每一行都能区分。 
         3，每一个表都不包含其他表已经包含的非主关键字信息。
例如，帖子表中只能出现发帖人的id，而不能出现发帖人的id，还同时出现发帖人姓名，否则，只要出现同一发帖人id的所有记录，它们中的姓名部分都必须严格保持一致，这就是数据冗余。

1、说出一些数据库优化方面的经验?
用PreparedStatement 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存
“inert into user values(1,1,1)”-二进制
“inert into user values(2,2,2)”-二进制
“inert into user values(?,?,?)”-二进制



有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。（比喻：就好比免检产品，就是为了提高效率，充分相信产品的制造商）
（对于hibernate来说，就应该有一个变化：empleyee->Deptment对象，现在设计时就成了employeedeptid）

看mysql帮助文档子查询章节的最后部分，例如，根据扫描的原理，下面的子查询语句要比第二条关联查询的效率高：
1.  select e.name,e.salary where e.managerid=(select id from employee where name='zxx');

2.   select e.name,e.salary,m.name,m.salary from employees e,employees m where
 e.managerid = m.id and m.name='zxx';

表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等
将姓名和密码单独从用户表中独立出来。这可以是非常好的一对一的案例哟！

sql语句全部大写，特别是列名和表名都大写。特别是sql命令的缓存功能，更加需要统一大小写，sql语句发给oracle服务器语法检查和编译成为内部指令缓存和执行指令。根据缓存的特点，不要拼凑条件，而是用?和PreparedStatment

还有索引对查询性能的改进也是值得关注的。

备注：下面是关于性能的讨论举例

4航班 3个城市

m*n

select * from flight,city where flight.startcityid=city.cityid and city.name='beijing';

m + n


select * from flight where startcityid = (select cityid from city where cityname='beijing');

select flight.id,'beijing',flight.flightTime from flight where startcityid = (select cityid from city where cityname='beijing')
2、union和union all有什么不同?
假设我们有一个表Student，包括以下字段与数据：
drop table student;
create table student
(
id int primary key,
name nvarchar2(50) not null,
score number not null
);
insert into student values(1,'Aaron',78);
insert into student values(2,'Bill',76);
insert into student values(3,'Cindy',89);
insert into student values(4,'Damon',90);
insert into student values(5,'Ella',73);
insert into student values(6,'Frado',61);
insert into student values(7,'Gill',99);
insert into student values(8,'Hellen',56);
insert into student values(9,'Ivan',93);
insert into student values(10,'Jay',90);
commit;
Union和Union All的区别。 
select *
from student
where id < 4
union
select *
from student
where id > 2 and id < 6
结果将是
1    Aaron    78
2    Bill    76
3    Cindy    89
4    Damon    90
5    Ella    73
如果换成Union All连接两个结果集，则返回结果是：
1    Aaron    78
2    Bill    76
3    Cindy    89
3    Cindy    89
4    Damon    90
5    Ella    73
可以看到，Union和Union All的区别之一在于对重复结果的处理。

　　UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。如：
select * from gc_dfys
union
select * from ls_jg_dfys
　　这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。
　而UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。
　从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL，
3.分页语句
取出sql表中第31到40的记录（以自动增长ID为主键）
sql server方案1：
	select top 10 * from t where id not in (select top 30 id from t order by id ) orde by id
sql server方案2：
	select top 10 * from t where id in (select top 40 id from t order by id) order by id desc

mysql方案：select * from t order by id limit 30,10

oracle方案：select * from (select rownum r,* from t where r<=40) where r>30

--------------------待整理进去的内容-------------------------------------
pageSize=20;
pageNo = 5;

1.分页技术1（直接利用sql语句进行分页，效率最高和最推荐的）

mysql:sql = "select * from articles limit " + (pageNo-1)*pageSize + "," + pageSize;
oracle: sql = "select * from " +
								"(select rownum r,* from " +
									"(select * from articles order by postime desc)" +
								"where rownum<= " + pageNo*pageSize +") tmp " +
							"where r>" + (pageNo-1)*pageSize;
注释：第7行保证rownum的顺序是确定的，因为oracle的索引会造成rownum返回不同的值
简洋提示：没有order by时，rownum按顺序输出，一旦有了order by，rownum不按顺序输出了，这说明rownum是排序前的编号。如果对order by从句中的字段建立了索引，那么，rownum也是按顺序输出的，因为这时候生成原始的查询结果集时会参照索引表的顺序来构建。

sqlserver:sql = "select top 10 * from id not id(select top " + (pageNo-1)*pageSize + "id from articles)"

DataSource ds = new InitialContext().lookup(jndiurl);
Connection cn = ds.getConnection();
//"select * from user where id=?"  --->binary directive
PreparedStatement pstmt = cn.prepareSatement(sql);
ResultSet rs = pstmt.executeQuery()
while(rs.next())
{
	out.println(rs.getString(1));
}

2.不可滚动的游标
pageSize=20;
pageNo = 5;
cn = null
stmt = null;
rs = null;
try
{
sqlserver:sql = "select  * from articles";

DataSource ds = new InitialContext().lookup(jndiurl);
Connection cn = ds.getConnection();
//"select * from user where id=?"  --->binary directive
PreparedStatement pstmt = cn.prepareSatement(sql);
ResultSet rs = pstmt.executeQuery()
for(int j=0;j<(pageNo-1)*pageSize;j++)
{
	rs.next();
}

int i=0;

while(rs.next() && i<10)
{
	i++;
	out.println(rs.getString(1));
}
}
cacth(){}
finnaly
{
	if(rs!=null)try{rs.close();}catch(Exception e){}
	if(stm.........
	if(cn............
}

3.可滚动的游标
pageSize=20;
pageNo = 5;
cn = null
stmt = null;
rs = null;
try
{
sqlserver:sql = "select  * from articles";

DataSource ds = new InitialContext().lookup(jndiurl);
Connection cn = ds.getConnection();
//"select * from user where id=?"  --->binary directive
PreparedStatement pstmt = cn.prepareSatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,...);
//根据上面这行代码的异常SQLFeatureNotSupportedException，就可判断驱动是否支持可滚动游标

ResultSet rs = pstmt.executeQuery()
rs.absolute((pageNo-1)*pageSize)
int i=0;
while(rs.next() && i<10)
{
	i++;
	out.println(rs.getString(1));
}
}
cacth(){}
finnaly
{
	if(rs!=null)try{rs.close();}catch(Exception e){}
	if(stm.........
	if(cn............
}
3.用一条SQL语句 查询出每门课都大于80分的学生姓名  
name   kecheng   fenshu 
张三     语文       81
张三     数学       75
李四     语文       76
李四     数学       90
王五     语文       81
王五     数学       100
王五     英语       90

准备数据的sql代码：
create table score(id int primary key auto_increment,name varchar(20),subject varchar(20),score int);
insert into score values 
(null,'张三','语文',81),
(null,'张三','数学',75),
(null,'李四','语文',76),
(null,'李四','数学',90),
(null,'王五','语文',81),
(null,'王五','数学',100),
(null,'王五 ','英语',90);

提示：当百思不得其解时，请理想思维，把小变成大做，把大变成小做，

答案：
A: select distinct name from score  where  name not in (select distinct name from score where score<=80)

B:select distince name t1 from score where 80< all (select score from score where name=t1);

4.所有部门之间的比赛组合
一个叫department的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球对，现在四个球对进行比赛，用一条sql语句显示所有可能的比赛组合.

答：select a.name, b.name 
from team a, team b 
where a.name < b.name

4.每个月份的发生额都比101科目多的科目
请用SQL语句实现：从TestDB数据表中查询出所有月份的发生额都比101科目相应月份的发生额高的科目。请注意：TestDB中有很多科目，都有1－12月份的发生额。
AccID：科目代码，Occmonth：发生额月份，DebitOccur：发生额。
数据库名：JcyAudit，数据集：Select * from TestDB
准备数据的sql代码：
drop table if exists TestDB;
create table TestDB(id int primary key auto_increment,AccID varchar(20), Occmonth date, DebitOccur bigint);
insert into TestDB values 
(null,'101','1988-1-1',100),
(null,'101','1988-2-1',110),
(null,'101','1988-3-1',120),
(null,'101','1988-4-1',100),
(null,'101','1988-5-1',100),
(null,'101','1988-6-1',100),
(null,'101','1988-7-1',100),
(null,'101','1988-8-1',100);
--复制上面的数据，故意把第一个月份的发生额数字改小一点
insert into TestDB values 
(null,'102','1988-1-1',90),
(null,'102','1988-2-1',110),
(null,'102','1988-3-1',120),
(null,'102','1988-4-1',100),
(null,'102','1988-5-1',100),
(null,'102','1988-6-1',100),
(null,'102','1988-7-1',100),
(null,'102','1988-8-1',100);
--复制最上面的数据，故意把所有发生额数字改大一点
insert into TestDB values 
(null,'103','1988-1-1',150),
(null,'103','1988-2-1',160),
(null,'103','1988-3-1',180),
(null,'103','1988-4-1',120),
(null,'103','1988-5-1',120),
(null,'103','1988-6-1',120),
(null,'103','1988-7-1',120),
(null,'103','1988-8-1',120);
--复制最上面的数据，故意把所有发生额数字改大一点
insert into TestDB values 
(null,'104','1988-1-1',130),
(null,'104','1988-2-1',130),
(null,'104','1988-3-1',140),
(null,'104','1988-4-1',150),
(null,'104','1988-5-1',160),
(null,'104','1988-6-1',170),
(null,'104','1988-7-1',180),
(null,'104','1988-8-1',140);
--复制最上面的数据，故意把第二个月份的发生额数字改小一点
insert into TestDB values 
(null,'105','1988-1-1',100),
(null,'105','1988-2-1',80),
(null,'105','1988-3-1',120),
(null,'105','1988-4-1',100),
(null,'105','1988-5-1',100),
(null,'105','1988-6-1',100),
(null,'105','1988-7-1',100),
(null,'105','1988-8-1',100);
答案：
select distinct AccID from TestDB 
where AccID not in 
	(select TestDB.AccIDfrom TestDB,
		 (select * from TestDB where AccID='101') as db101 
	where TestDB.Occmonth=db101.Occmonth and TestDB.DebitOccur<=db101.DebitOccur
	);

4.统计每年每月的信息
year  month amount
1991   1     1.1
1991   2     1.2
1991   3     1.3
1991   4     1.4
1992   1     2.1
1992   2     2.2
1992   3     2.3
1992   4     2.4
查成这样一个结果
year m1  m2  m3  m4
1991 1.1 1.2 1.3 1.4
1992 2.1 2.2 2.3 2.4 

提示：这个与工资条非常类似，与学生的科目成绩也很相似。

准备sql语句：
drop table if exists sales;
create table sales(id int auto_increment primary key,year varchar(10), month varchar(10), amount float(2,1));
insert into sales values
(null,'1991','1',1.1),
(null,'1991','2',1.2),
(null,'1991','3',1.3),
(null,'1991','4',1.4),
(null,'1992','1',2.1),
(null,'1992','2',2.2),
(null,'1992','3',2.3),
(null,'1992','4',2.4);

答案一、
select sales.year ,
(select t.amount from sales t where t.month='1' and t.year= sales.year) '1',
(select t.amount from sales t where t.month='1' and t.year= sales.year) '2',
(select t.amount from sales t where t.month='1' and t.year= sales.year) '3',
(select t.amount from sales t where t.month='1' and t.year= sales.year) as '4' 
from sales  group by year;

5.显示文章标题，发帖人、最后回复时间
表：id,title,postuser,postdate,parentid
准备sql语句：
drop table if exists articles;
create table articles(id int auto_increment primary key,title varchar(50), postuser varchar(10), postdate datetime,parentid int references articles(id));
insert into articles values
(null,'第一条','张三','1998-10-10 12:32:32',null),
(null,'第二条','张三','1998-10-10 12:34:32',null),
(null,'第一条回复1','李四','1998-10-10 12:35:32',1),
(null,'第二条回复1','李四','1998-10-10 12:36:32',2),
(null,'第一条回复2','王五','1998-10-10 12:37:32',1),
(null,'第一条回复3','李四','1998-10-10 12:38:32',1),
(null,'第二条回复2','李四','1998-10-10 12:39:32',2),
(null,'第一条回复4','王五','1998-10-10 12:39:40',1);

答案：
select a.title,a.postuser,
	(select max(postdate) from articles where parentid=a.id) reply 
from articles a where a.parentid is null;

注释：子查询可以用在选择列中，也可用于where的比较条件中，还可以用于from从句中。
3.删除除了id号不同,其他都相同的学生冗余信息
2.学生表 如下:
id号   学号   姓名 课程编号 课程名称 分数
1        2005001  张三  0001      数学    69
2        2005002  李四  0001      数学    89
3        2005001  张三  0001      数学    69
A: delete from tablename where id号 not in(select min(id号) from tablename group by 学号,姓名,课程编号,课程名称,分数)
实验：
create table student2(id int auto_increment primary key,code varchar(20),name varchar(20));
insert into student2 values(null,'2005001','张三'),(null,'2005002','李四'),(null,'2005001','张三');

//如下语句，mysql报告错误，可能删除依赖后面统计语句，而删除又导致统计语句结果不一致。

delete from student2 where id not in(select min(id) from student2 group by name);
//但是，如下语句没有问题：
select *  from student2 where id not in(select min(id) from student2 group by name);
//于是，我想先把分组的结果做成虚表，然后从虚表中选出结果，最后再将结果作为删除的条件数据。
delete from student2 where id not in(select mid from (select min(id) mid
from student2 group by name) as t);
或者：
delete from student2 where id not in(select min(id) from (select * from s
tudent2) as t group by t.name);
4.航空网的几个航班查询题：
表结构如下：
flight{flightID,StartCityID ,endCityID,StartTime}
city{cityID, CityName)
实验环境：
create table city(cityID int auto_increment primary key,cityName varchar(20));
create table flight (flightID int auto_increment primary key,
	StartCityID int references city(cityID),
	endCityID  int references city(cityID),
	StartTime timestamp); 
//航班本来应该没有日期部分才好，但是下面的题目当中涉及到了日期
insert into city values(null,'北京'),(null,'上海'),(null,'广州');
insert into flight values
	(null,1,2,'9:37:23'),(null,1,3,'9:37:23'),(null,1,2,'10:37:23'),(null,2,3,'10:37:23');


1、查询起飞城市是北京的所有航班，按到达城市的名字排序


参与运算的列是我起码能够显示出来的那些列，但最终我不一定把它们显示出来。各个表组合出来的中间结果字段中必须包含所有运算的字段。

  select  * from flight f,city c 
	where f.endcityid = c.cityid and startcityid = 
	(select c1.cityid from city c1 where c1.cityname = "北京")
	order by c.cityname asc;

mysql> select flight.flightid,'北京' startcity, e.cityname from flight,city e wh
ere flight.endcityid=e.cityid and flight.startcityid=(select cityid from city wh
ere cityname='北京');

mysql> select flight.flightid,s.cityname,e.cityname from flight,city s,city e wh
ere flight.startcityid=s.cityid and s.cityname='北京' and flight.endCityId=e.cit
yID order by e.cityName desc;


2、查询北京到上海的所有航班纪录（起飞城市，到达城市，起飞时间，航班号）
select c1.CityName,c2.CityName,f.StartTime,f.flightID
from city c1,city c2,flight f
where f.StartCityID=c1.cityID 
and f.endCityID=c2.cityID
and c1.cityName='北京'
and c2.cityName='上海'
3、查询具体某一天（2005-5-8）的北京到上海的的航班次数
select count(*) from 
(select c1.CityName,c2.CityName,f.StartTime,f.flightID
from city c1,city c2,flight f
where f.StartCityID=c1.cityID 
and f.endCityID=c2.cityID
and c1.cityName='北京'
and c2.cityName='上海'
and 查帮助获得的某个日期处理函数(startTime) like '2005-5-8%'

mysql中提取日期部分进行比较的示例代码如下：
select * from flight where date_format(starttime,'%Y-%m-%d')='1998-01-02'
5.查出比经理薪水还高的员工信息：
Drop table if not exists employees;
create table employees(id int primary key auto_increment,name varchar(50)
,salary int,managerid int references employees(id));
insert into employees values (null,' lhm',10000,null), (null,' zxx',15000,1
),(null,'flx',9000,1),(null,'tg',10000,2),(null,'wzg',10000,3);

Wzg大于flx,lhm大于zxx

解题思路：
     根据sql语句的查询特点，是逐行进行运算，不可能两行同时参与运算。
涉及了员工薪水和经理薪水，所有，一行记录要同时包含两个薪水，所有想到要把这个表自关联组合一下。
     首先要组合出一个包含有各个员工及该员工的经理信息的长记录，譬如，左半部分是员工，右半部分是经理。而迪卡尔积会组合出很多垃圾信息，先去除这些垃圾信息。

select e.* from employees e,employees m where e.managerid=m.id and e.sala
ry>m.salary;
6、求出小于45岁的各个老师所带的大于12岁的学生人数
数据库中有3个表 teacher 表，student表，tea_stu关系表。 
teacher 表 teaID name age 
student 表 stuID name age 
teacher_student表 teaID stuID 
要求用一条sql查询出这样的结果 
1.显示的字段要有老师name, age 每个老师所带的学生人数 
2 只列出老师age为40以下，学生age为12以上的记录
预备知识：
      1.sql语句是对每一条记录依次处理，条件为真则执行动作（select,insert,delete,update）
       2.只要是迪卡尔积，就会产生“垃圾”信息，所以，只要迪卡尔积了，我们首先就要想到清除“垃圾”信息
实验准备：
	drop table if exists tea_stu;
	drop table if exists teacher;
	drop table if exists student;
      create table teacher(teaID int primary key,name varchar(50),age int);
      create table student(stuID int primary key,name varchar(50),age int);
      create table tea_stu(teaID int references teacher(teaID),stuID int references student(stuID));
insert into teacher values(1,'zxx',45), (2,'lhm',25) , (3,'wzg',26) , (4,'tg',27);
insert into student values(1,'wy',11), (2,'dh',25) , (3,'ysq',26) , (4,'mxc',27);
insert into tea_stu values(1,1), (1,2), (1,3);
insert into tea_stu values(2,2), (2,3), (2,4);
 insert into tea_stu values(3,3), (3,4), (3,1);
insert into tea_stu values(4,4), (4,1), (4,2) , (4,3);

结果：23,32,43

解题思路：（真实面试答题时，也要写出每个分析步骤，如果纸张不够，就找别人要）
1要会统计分组信息，统计信息放在中间表中：
select teaid,count(*) from tea_stu group by teaid;

2接着其实应该是筛除掉小于12岁的学生，然后再进行统计，中间表必须与student关联才能得到12岁以下学生和把该学生记录从中间表中剔除，代码是：
select tea_stu.teaid,count(*) total from student,tea_stu 
where student.stuid=tea_stu.stuid and student.age>12 group by tea_stu.teaid

3.接着把上面的结果做成虚表与teacher进行关联，并筛除大于45的老师
select teacher.teaid,teacher.name,total from teacher ,(select tea_stu.tea
id,count(*) total from student,tea_stu where student.stuid=tea_stu.stuid and stu
dent.age>12 group by tea_stu.teaid) as tea_stu2 where teacher.teaid=tea_stu2.tea
id and teacher.age<45;


7.求出发帖最多的人：
select authorid,count(*) total from articles 
group by authorid 
having total=
(select max(total2) from (select count(*) total2 from articles group by authorid) as t);

select t.authorid,max(t.total) from
（select authorid,count(*) total from articles ）as t
这条语句不行，因为max只有一列，不能与其他列混淆。

select authorid,count(*) total from articles 
group by authorid having total=max(total)也不行。

10、一个用户表中有一个积分字段，假如数据库中有100多万个用户，若要在每年第一天凌晨将积分清零，你将考虑什么，你将想什么办法解决?
alter table drop column score;
alter table add colunm score int;
可能会很快，但是需要试验，试验不能拿真实的环境来操刀，并且要注意，
这样的操作时无法回滚的，在我的印象中，只有inert update delete等DML语句才能回滚，
对于create table,drop table ,alter table等DDL语句是不能回滚。


解决方案一，update user set score=0; 
解决方案二，假设上面的代码要执行好长时间，超出我们的容忍范围，那我就alter table user drop column score;alter table user add column score int。

下面代码实现每年的那个凌晨时刻进行清零。
Runnable runnable = 
	new Runnable(){
		public void run(){
			clearDb();
			schedule(this,new Date(new Date().getYear()+1,0,0));
			}		
			};

schedule(runnable,
	new Date(new Date().getYear()+1,0,1));

10、一个用户具有多个角色，请查询出该表中具有该用户的所有角色的其他用户。
select count(*) as num,tb.id 
from 
 tb,
 (select role from tb where id=xxx) as t1
where
 tb.role = t1.role and tb.id != t1.id
group by tb.id 
having 
	num = select count(role) from tb where id=xxx;
8. xxx公司的sql面试
Table EMPLOYEES Structure:
EMPLOYEE_ID      NUMBER        Primary Key,
FIRST_NAME       VARCHAR2(25),
LAST_NAME       VARCHAR2(25),
Salary number(8,2),
HiredDate DATE,
Departmentid number(2)
Table Departments Structure:
Departmentid number(2)        Primary Key,
DepartmentName  VARCHAR2(25).

 (2）基于上述EMPLOYEES表写出查询：写出雇用日期在今年的，或者工资在[1000,2000]之间的，或者员工姓名（last_name）以’Obama’打头的所有员工，列出这些员工的全部个人信息。（4分）
select * from employees 
where Year(hiredDate) = Year(date()) 
	or (salary between 1000 and 200)
	or left(last_name,3)='abc';

(3) 基于上述EMPLOYEES表写出查询：查出部门平均工资大于1800元的部门的所有员工，列出这些员工的全部个人信息。（4分）
mysql> select id,name,salary,deptid did from employee1 where (select avg(salary)
 from employee1 where deptid = did) > 1800;

(4) 基于上述EMPLOYEES表写出查询：查出个人工资高于其所在部门平均工资的员工，列出这些员工的全部个人信息及该员工工资高出部门平均工资百分比。（5分）
select employee1.*,(employee1.salary-t.avgSalary)*100/employee1.salary 
from employee1,
	(select deptid,avg(salary) avgSalary from employee1 group by deptid) as t
where employee1.deptid = t.deptid and employee1.salary>t.avgSalary;

1、注册Jdbc驱动程序的三种方式

1、用JDBC如何调用存储过程
代码如下：
package com.huawei.interview.lym;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Types;

public class JdbcTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Connection cn = null;
		CallableStatement cstmt = null;		
		try {
			//这里最好不要这么干，因为驱动名写死在程序中了
			Class.forName("com.mysql.jdbc.Driver");
			//实际项目中，这里应用DataSource数据，如果用框架，
			//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()
			//cn = ds.getConnection();			
			cn = DriverManager.getConnection("jdbc:mysql:///test","root","root");
			cstmt = cn.prepareCall("{call insert_Student(?,?,?)}");
			cstmt.registerOutParameter(3,Types.INTEGER);
			cstmt.setString(1, "wangwu");
			cstmt.setInt(2, 25);
			cstmt.execute();
			//get第几个，不同的数据库不一样，建议不写
			System.out.println(cstmt.getString(3));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		finally
		{

			/*try{cstmt.close();}catch(Exception e){}
			try{cn.close();}catch(Exception e){}*/
			try {
				if(cstmt != null)
					cstmt.close();
				if(cn != null)				
					cn.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
1、JDBC中的PreparedStatement相比Statement的好处
答：一个sql命令发给服务器去执行的步骤为：语法检查，语义分析，编译成内部指令，缓存指令，执行指令等过程。
select * from student where id =3----缓存--xxxxx二进制命令
select * from student where id =3----直接取-xxxxx二进制命令
select * from student where id =4--- -会怎么干？
如果当初是select * from student where id =?--- -又会怎么干？
 上面说的是性能提高
可以防止sql注入。
1. 写一个用jdbc连接并访问oracle数据的程序代码
2、Class.forName的作用?为什么要用? 
答：按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，则返回代表该字节码的Class实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则抛出ClassNotFoundException。加载完这个Class字节码后，接着就可以使用Class字节码的newInstance方法去创建该类的实例对象了。
有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时才能确定，这时候就需要使用Class.forName去动态加载该类，这个类名通常是在配置文件中配置的，例如，spring的ioc中每次依赖注入的具体类就是这样配置的，jdbc的驱动类名通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类名。
3、大数据量下的分页解决方法。
答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。再sql语句无法实现分页的情况下，可以考虑对大的结果集通过游标定位方式来获取某页的数据。
sql语句分页，不同的数据库下的分页方案各不一样，下面是主流的三种数据库的分页sql：
sql server:
	String sql = 
	"select top " + pageSize + " * from students where id not in" +

 "(select top " + pageSize * (pageNumber-1) + " id from students order by id)" + 
 
 "order by id";

mysql:
  
	String sql = 
	"select * from students order by id limit " + pageSize*(pageNumber-1) + "," + pageSize;
	
oracle:
 
	String sql = 
	 "select * from " +  
	 (select *,rownum rid from (select * from students order by postime desc) where rid<=" + pagesize*pagenumber + ") as t" + 
	 "where t>" + pageSize*(pageNumber-1);
4、用 JDBC 查询学生成绩单, 把主要代码写出来（考试概率极大）. 
Connection cn = null;
PreparedStatement pstmt =null;
Resultset rs = null;
try
{
	Class.forname(driveClassName);
	cn =  DriverManager.getConnection(url,username,password);
	pstmt = cn.prepareStatement(“select  score.* from score ,student “ + 
		“where score.stuId = student.id and student.name = ?”);
	pstmt.setString(1,studentName);
	Resultset rs = pstmt.executeQuery();
	while(rs.next())
	{
		system.out.println(rs.getInt(“subject”)  +  “    ” + rs.getFloat(“score”) );
	}
}catch(Exception e){e.printStackTrace();}
finally
{
	if(rs != null) try{ rs.close() }catch(exception e){}
	if(pstmt != null) try{pstmt.close()}catch(exception e){}
	if(cn != null) try{ cn.close() }catch(exception e){}
}


5、这段代码有什么不足之处? 
try {
Connection conn = ...;
Statement stmt = ...;
ResultSet rs = stmt.executeQuery("select * from table1");
while(rs.next()) {
}
} catch(Exception ex) {
} 
答：没有finally语句来关闭各个对象，另外，使用finally之后，要把变量的定义放在try语句块的外面，以便在try语句块之外的finally块中仍可以访问这些变量。

36、说出数据连接池的工作机制是什么? 
J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 
实现方式，返回的Connection是原始Connection的代理，代理Connection的close方法不是真正关连接，而是把它代理的Connection对象还回到连接池中。

4、为什么要用 ORM?  和 JDBC 有何不一样? 
orm是一种思想，就是把object转变成数据库中的记录，或者把数据库中的记录转变成objecdt，我们可以用jdbc来实现这种思想，其实，如果我们的项目是严格按照oop方式编写的话，我们的jdbc程序不管是有意还是无意，就已经在实现orm的工作了。
现在有许多orm工具，它们底层调用jdbc来实现了orm工作，我们直接使用这些工具，就省去了直接使用jdbc的繁琐细节，提高了开发效率，现在用的较多的orm工具是hibernate。也听说一些其他orm工具，如toplink,ojb等。 
8. XML部分
1、xml有哪些解析技术?区别是什么? 
答:有DOM,SAX,STAX等 
DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 
STAX:Streaming API for XML (StAX) 
讲解这些区别是不需要特别去比较，就像说传智播客与其他培训机构的区别时，我们只需说清楚传智播客有什么特点和优点就行了，这就已经间接回答了彼此的区别。

2、你在项目中用到了xml技术的哪些方面?如何实现的? 
答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。 
3、用jdom解析xml文件时如何解决中文问题?如何解析? 
答:看如下代码,用编码方式加以解决 
package test; 
import java.io.*; 
public class DOMTest 
{ 
private String inFile = "c:\\people.xml" 
private String outFile = "c:\\people.xml" 
public static void main(String args[]) 
{ 
new DOMTest(); 
} 
public DOMTest() 
{ 
try 
{ 
javax.xml.parsers.DocumentBuilder builder = 
javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder(); 
org.w3c.dom.Document doc = builder.newDocument(); 
org.w3c.dom.Element root = doc.createElement("老师"); 
org.w3c.dom.Element wang = doc.createElement("王"); 
org.w3c.dom.Element liu = doc.createElement("刘"); 
wang.appendChild(doc.createTextNode("我是王老师")); 
root.appendChild(wang); 
doc.appendChild(root); 
javax.xml.transform.Transformer transformer = 
javax.xml.transform.TransformerFactory.newInstance().newTransformer(); 
transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, "gb2312"); 
transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, "yes"); 
transformer.transform(new javax.xml.transform.dom.DOMSource(doc), 
new 
javax.xml.transform.stream.StreamResult(outFile)); 
} 
catch (Exception e) 
{ 
System.out.println (e.getMessage()); 
} 
} 
} 
4、编程用JAVA解析XML的方式. 
答:用SAX方式解析XML，XML文件如下： 
<?xml version=1.0 encoding=gb2312?> 
<person> 
<name>王小明</name> 
<college>信息学院</college> 
<telephone>6258113</telephone> 
<notes>男,1955年生,博士，95年调入海南大学</notes> 
</person> 
事件回调类SAXHandler.java 
import java.io.*; 
import java.util.Hashtable; 
import org.xml.sax.*; 
public class SAXHandler extends HandlerBase 
{ 
private Hashtable table = new Hashtable(); 
private String currentElement = null; 
private String currentValue = null; 
public void setTable(Hashtable table) 
{ 
this.table = table; 
} 
public Hashtable getTable() 
{ 
return table; 
} 
public void startElement(String tag, AttributeList attrs) 
throws SAXException 
{ 
currentElement = tag; 
} 
public void characters(char[] ch, int start, int length) 
throws SAXException 
{ 
currentValue = new String(ch, start, length); 
} 
public void endElement(String name) throws SAXException 
{ 
if (currentElement.equals(name)) 
table.put(currentElement, currentValue); 
} 

} 
JSP内容显示源码,SaxXml.jsp: 
<HTML> 
<HEAD> 
<TITLE>剖析XML文件people.xml</TITLE> 
</HEAD> 
<BODY> 
<%@ page errorPage=ErrPage.jsp 
contentType=text/html;charset=GB2312 %> 
<%@ page import=java.io.* %> 
<%@ page import=java.util.Hashtable %> 
<%@ page import=org.w3c.dom.* %> 
<%@ page import=org.xml.sax.* %> 
<%@ page import=javax.xml.parsers.SAXParserFactory %> 
<%@ page import=javax.xml.parsers.SAXParser %> 
<%@ page import=SAXHandler %> 
<% 
File file = new File(c:\people.xml); 
FileReader reader = new FileReader(file); 
Parser parser; 
SAXParserFactory spf = SAXParserFactory.newInstance(); 
SAXParser sp = spf.newSAXParser(); 
SAXHandler handler = new SAXHandler(); 
sp.parse(new InputSource(reader), handler); 
Hashtable hashTable = handler.getTable(); 
out.println(<TABLE BORDER=2><CAPTION>教师信息表</CAPTION>); 
out.println(<TR><TD>姓名</TD> + <TD> + 
(String)hashTable.get(new String(name)) + </TD></TR>); 
out.println(<TR><TD>学院</TD> + <TD> + 
(String)hashTable.get(new String(college))+</TD></TR>); 
out.println(<TR><TD>电话</TD> + <TD> + 
(String)hashTable.get(new String(telephone)) + </TD></TR>); 
out.println(<TR><TD>备注</TD> + <TD> + 
(String)hashTable.get(new String(notes)) + </TD></TR>); 
out.println(</TABLE>); 
%> 
</BODY> 
</HTML> 
70、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ 
a: 两种形式 dtd  schema，b: 本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)，c:有DOM,SAX,STAX等 
   DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问 
SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 
   STAX:Streaming API for XML (StAX) 

9. 流行的框架与新技术

1、谈谈你对Struts的理解。
答: 
1. struts是一个按MVC模式设计的Web层框架，其实它就是一个大大的servlet，这个Servlet名为ActionServlet，或是ActionServlet的子类。我们可以在web.xml文件中将符合某种特征的所有请求交给这个Servlet处理，这个Servlet再参照一个配置文件（通常为/WEB-INF/struts-config.xml）将各个请求分别分配给不同的action去处理。
一个扩展知识点：struts的配置文件可以有多个，可以按模块配置各自的配置文件，这样可以防止配置文件的过度膨胀；
2. ActionServlet把请求交给action去处理之前，会将请求参数封装成一个formbean对象（就是一个java类，这个类中的每个属性对应一个请求参数），封装成一个什么样的formbean对象呢？看配置文件。
3.要说明的是， ActionServlet把formbean对象传递给action的execute方法之前，可能会调用formbean的validate方法进行校验，只有校验通过后才将这个formbean对象传递给action的execute方法，否则，它将返回一个错误页面，这个错误页面由input属性指定，（看配置文件）作者为什么将这里命名为input属性，而不是error属性，我们后面结合实际的运行效果进行分析。
4.action执行完后要返回显示的结果视图，这个结果视图是用一个ActionForward对象来表示的，actionforward对象通过struts-config.xml配置文件中的配置关联到某个jsp页面，因为程序中使用的是在struts-config.xml配置文件为jsp页面设置的逻辑名，这样可以实现action程序代码与返回的jsp页面名称的解耦。

你对struts可能还有自己的应用方面的经验，那也要一并说出来。
2、谈谈你对Hibernate的理解。
答:
1. 面向对象设计的软件内部运行过程可以理解成就是在不断创建各种新对象、建立对象之间的关系，调用对象的方法来改变各个对象的状态和对象消亡的过程，不管程序运行的过程和操作怎么样，本质上都是要得到一个结果，程序上一个时刻和下一个时刻的运行结果的差异就表现在内存中的对象状态发生了变化。
2.为了在关机和内存空间不够的状况下，保持程序的运行状态，需要将内存中的对象状态保存到持久化设备和从持久化设备中恢复出对象的状态，通常都是保存到关系数据库来保存大量对象信息。从Java程序的运行功能上来讲，保存对象状态的功能相比系统运行的其他功能来说，应该是一个很不起眼的附属功能，java采用jdbc来实现这个功能，这个不起眼的功能却要编写大量的代码，而做的事情仅仅是保存对象和恢复对象，并且那些大量的jdbc代码并没有什么技术含量，基本上是采用一套例行公事的标准代码模板来编写，是一种苦活和重复性的工作。
3.通过数据库保存java程序运行时产生的对象和恢复对象，其实就是实现了java对象与关系数据库记录的映射关系，称为ORM（即Object Relation Mapping），人们可以通过封装JDBC代码来实现了这种功能，封装出来的产品称之为ORM框架，Hibernate就是其中的一种流行ORM框架。使用Hibernate框架，不用写JDBC代码，仅仅是调用一个save方法，就可以将对象保存到关系数据库中，仅仅是调用一个get方法，就可以从数据库中加载出一个对象。
4.使用Hibernate的基本流程是：配置Configuration对象、产生SessionFactory、创建session对象，启动事务，完成CRUD操作，提交事务，关闭session。
5.使用Hibernate时，先要配置hibernate.cfg.xml文件，其中配置数据库连接信息和方言等，还要为每个实体配置相应的hbm.xml文件，hibernate.cfg.xml文件中需要登记每个hbm.xml文件。
6.在应用Hibernate时，重点要了解Session的缓存原理，级联，延迟加载和hql查询。
3、AOP的作用。
3、你对Spring的理解。
1.Spring实现了工厂模式的工厂类（在这里有必要解释清楚什么是工厂模式），这个类名为BeanFactory（实际上是一个接口），在程序中通常BeanFactory的子类ApplicationContext。Spring相当于一个大的工厂类，在其配置文件中通过<bean>元素配置用于创建实例对象的类名和实例对象的属性。
2. Spring提供了对IOC良好支持，IOC是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC也称为DI（Depency Injection），什么叫依赖注入呢？
譬如，Class Programmer
{
	Computer computer = null;
	public void code()
	{
		//Computer computer = new IBMComputer();
		//Computer computer = beanfacotry.getComputer();
		computer.write();
	}
	public void setComputer(Computer computer)
	{
		this.computer = computer;
	}
}
另外两种方式都由依赖，第一个直接依赖于目标类，第二个把依赖转移到工厂上，第三个彻底与目标和工厂解耦了。在spring的配置文件中配置片段如下：
<bean id=”computer” class=”cn.itcast.interview.Computer”>
</bean>

<bean id=”programmer” class=”cn.itcast.interview.Programmer”>
	<property name=”computer”  ref=”computer”></property>
</bean>
3. Spring提供了对AOP技术的良好封装， AOP称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如，加入日志，加入权限判断，加入异常处理，这种应用称为AOP。实现AOP功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK中采用Proxy类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以Advice对象进行提供，显然要创建出代理对象，至少需要目标类和Advice类。spring提供了这种支持，只需要在spring配置文件中配置这两个元素即可实现代理和aop功能，例如，
<bean id=”proxy” type=”org.spring.framework.aop.ProxyBeanFactory”>
	<property name=”target” ref=””></property>
	<property name=”advisor” ref=””></property>

</bean>

11、谈谈Struts中的Action servlet。

12、Struts优缺点 
优点： 
 1. 实现MVC模式，结构清晰,使开发者只关注业务逻辑的实现.
2．有丰富的tag可以用 ,Struts的标记库(Taglib)，如能灵活动用，则能大大提高开发效率
3. 页面导航
	使系统的脉络更加清晰。通过一个配置文件，即可把握整个系统各部分之间的联系，这对于后期的维护有着莫大的好处。尤其是当另一批开发者接手这个项目时，这种优势体现得更加明显。
4. 提供Exception处理机制 . 
5. 数据库链接池管理 
6. 支持I18N 
缺点
十、转到展示层时，需要配置forward，如果有十个展示层的jsp，需要配置十次struts，而且还不包括有时候目录、文件变更，需要重新修改forward，注意，每次修改配置之后，要求重新部署整个项目，而tomcate这样的服务器，还必须重新启动服务器
十一、二、 Struts 的Action必需是thread－safe方式，它仅仅允许一个实例去处理所有的请求。所以action用到的所有的资源都必需统一同步，这个就引起了线程安全的问题。
十二、 测试不方便. Struts的每个Action都同Web层耦合在一起，这样它的测试依赖于Web容器，单元测试也很难实现。不过有一个Junit的扩展工具Struts TestCase可以实现它的单元测试。 
十三、 类型的转换. Struts的FormBean把所有的数据都作为String类型，它可以使用工具Commons-Beanutils进行类型转化。但它的转化都是在Class级别，而且转化的类型是不可配置的。类型转化时的错误信息返回给用户也是非常困难的。
十四、对Servlet的依赖性过强. Struts处理Action时必需要依赖ServletRequest 和ServletResponse，所有它摆脱不了Servlet容器。 
十五、 前端表达式语言方面.Struts集成了JSTL，所以它主要使用JSTL的表达式语言来获取数据。可是JSTL的表达式语言在Collection和索引属性方面处理显得很弱。 
十六、 对Action执行的控制困难. Struts创建一个Action，如果想控制它的执行顺序将会非常困难。甚至你要重新去写Servlet来实现你的这个功能需求。 
十七、 对Action 执行前和后的处理. Struts处理Action的时候是基于class的hierarchies，很难在action处理前和后进行操作。 
十八、 对事件支持不够. 在struts中，实际是一个表单Form对应一个Action类(或DispatchAction)，换一句话说：在Struts中实际是一个表单只能 对应一个事件，struts这种事件方式称为application event，application event和component event相比是一种粗粒度的事件


119、STRUTS的应用(如STRUTS架构) 
Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能： 一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。 二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。

110、说说struts1与struts2的区别。
1.都是MVC的WEB框架,
2 struts1的老牌框架，应用很广泛，有很好的群众基础，使用它开发风险很小，成本更低！struts2虽然基于这个框架，但是应用群众并多，相对不成熟，未知的风险和变化很多，开发人员相对不好招，使用它开发项目的风险系数更大，用人成本更高！
3.struts2毕竟是站在前辈的基础设计出来，它会改善和完善struts1中的一些缺陷，struts1中一些悬而未决问题在struts2得到了解决。
4.struts1的前端控制器是一个Servlet，名称为ActionServlet，struts2的前端控制器是一个filter，在struts2.0中叫FilterDispatcher，在struts2.1中叫StrutsPrepareAndExecuteFilter。
5.struts1的action需要继承Action类，struts2的action可以不继承任何类；struts1对同一个路径的所有请求共享一个Action实例，struts2对同一个路径的每个请求分别使用一个独立Action实例对象，所有对于struts2的Action不用考虑线程安全问题。
6.在struts1中使用formbean封装请求参数，在struts2中直接使用action的属性来封装请求参数。
7.struts1中的多个业务方法放在一个Action中时（即继承DispatchAction时），要么都校验，要么都不校验；对于struts2，可以指定只对某个方法进行校验，当一个Action继承了ActionSupport且在这个类中只编写了validateXxx()方法，那么则只对Xxx()方法进行校验。

（一个请求来了的执行流程进行分析，struts2是自动支持分模块开发，并可以不同模块设置不同的url前缀，这是通过package的namespace来实现的；struts2是支持多种类型的视图；struts2的视图地址可以是动态的，即视图的名称是支持变量方式的，举例，论坛发帖失败后回来还要传递boardid。视图内容显示方面：它的标签用ognl，要el强大很多，在国际化方面支持分模块管理，两个模块用到同样的key，对应不同的消息；）

		
与Struts1不同，Struts2对用户的每一次请求都会创建一个Action，所以Struts2中的Action是线程安全的。

给我印象最深刻的是：struts配置文件中的redirect视图的url不能接受参数，而struts2配置文件中的redirect视图可以接受参数。


110、hibernate中的update()和saveOrUpdate()的区别，session的load()和get()的区别。
110、简述 Hibernate 和 JDBC 的优缺点? 如何书写一个 one to many 配置文件.
7、iBatis与Hibernate有什么不同?
相同点：屏蔽jdbc api的底层访问细节，使用我们不用与jdbc api打交道，就可以访问数据。
jdbc api编程流程固定，还将sql语句与java代码混杂在了一起，经常需要拼凑sql语句，细节很繁琐。
ibatis的好处：屏蔽jdbc api的底层访问细节；将sql语句与java代码进行分离;提供了将结果集自动封装称为实体对象和对象的集合的功能，queryForList返回对象集合，用queryForObject返回单个对象；提供了自动将实体对象的属性传递给sql语句的参数。

Hibernate是一个全自动的orm映射工具，它可以自动生成sql语句,ibatis需要我们自己在xml配置文件中写sql语句，hibernate要比ibatis功能负责和强大很多。因为hibernate自动生成sql语句，我们无法控制该语句，我们就无法去写特定的高效率的sql。对于一些不太复杂的sql查询，hibernate可以很好帮我们完成，但是，对于特别复杂的查询，hibernate就很难适应了，这时候用ibatis就是不错的选择，因为ibatis还是由我们自己写sql语句。


7、写Hibernate的一对多和多对一双向关联的orm配置?
9、hibernate的inverse属性的作用?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

10、在DAO中如何体现DAO设计模式?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

10、spring+Hibernate中委托方案怎么配置?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

10、spring+Hibernate中委托方案怎么配置?
解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。

8. hibernate进行多表查询每个表中各取几个字段，也就是说查询出来的结果集没有一个实体类与之对应如何解决； 

解决方案一，按照Object[]数据取出数据，然后自己组bean
解决方案二，对每个表的bean写构造函数，比如表一要查出field1,field2两个字段，那么有一个构造函数就是Bean(type1 filed1,type2 
field2) ，然后在hql里面就可以直接生成这个bean了。
8.介绍一下Hibernate的二级缓存
按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了hibernate的Session就是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置Hibernate的二级缓存。
（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），这个数据结构通常是或类似Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。下面是缓存的伪代码：
引出hibernate的第二级缓存，用下面的伪代码分析了Cache的实现原理
Dao
{
	hashmap map = new map();
	User getUser(integer id)
	{
		User user = map.get(id)
		if(user == null)
		{
			user = session.get(id);
			map.put(id,user);
		}
		return user;
	}
}

Dao
{
	Cache cache = null
	setCache(Cache cache)
	{
		this.cache = cache
	}
	
	User getUser(int id)
	{
		if(cache!=null)
		{
			User user = cache.get(id);
			if(user ==null)
			{
				user = session.get(id);
				cache.put(id,user);
			}
			return user;
		}
		
		return session.get(id);
	}
}
（2）Hibernate的Session就是一种缓存，我们通常将之称为Hibernate的一级缓存，当想使用session从数据库中查询出一个对象时，Session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于Session代表一次会话过程，一个Session与一个数据库连接相关连，所以Session最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且Session是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate的Session这一级缓存的缓存作用并不明显，应用价值不大。Hibernate的二级缓存就是要为Hibernate配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session没有这种效果。
（3）二级缓存是独立于Hibernate的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache和OSCache等等。在Hibernate中使用二级缓存，首先就要在hibernate.cfg.xml配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置Hibernate中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起Hibernate的二级缓存。扩展知识：一个SessionFactory可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用Hibernate 的二级缓存后，注意不要有其他的应用或SessionFactory来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。 

111、Spring 的依赖注入是什么意思? 给一个 Bean 的 message 属性, 字符串类型, 注入值为 "Hello" 的 XML 配置文件该怎么写?
 
120、Jdo是什么? 
JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。 

什么是spring的IOC  AOP
STRUTS的工作流程！
spring 与EJB的区别！！

10. 软件工程与设计模式
111、UML方面 
标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。 
112. 软件开发的
92、j2ee常用的设计模式？说明工厂模式。 
总共23种，分为三大类：创建型，结构型，行为型
我只记得其中常用的6、7种，分别是：
创建型（工厂、工厂方法、抽象工厂、单例）
结构型（包装、适配器，组合，代理）
行为（观察者，模版，策略）
然后再针对你熟悉的模式谈谈你的理解即可。   

Java中的23种设计模式： 
Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式）， 
Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式）， 
Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式）， 
Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式）， 
Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式）， 
Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式）， 
Observer（观察者模式），   State（状态模式），         Strategy（策略模式）， 
Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式） 
工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 
113、开发中都用到了那些设计模式?用在什么场合? 
每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。 

11. j2ee部分
117、BS与CS的联系与区别。 
C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、InFORMix或 SQL Server。客户端需要安装专用的客户端软件。 
B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、InFORMix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。 
C/S 与 B/S 区别： 
１．硬件环境不同: 
　　C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. 
　　B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行 
２．对安全要求不同 
　　C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息. 
　　B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。 
３．对程序架构不同 
　　C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. 
　　B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟. 
４．软件重用不同 
　　C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好. 
　　B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 
５．系统维护不同   
　　C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统 
　　B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. 
６．处理问题不同 
　　C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统 
　　B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小. 
７．用户接口不同 
　　C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高 
　　B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本. 
８．信息流不同 
　　C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低 
　　B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心。 
2、应用服务器与WEB SERVER的区别？
应用服务器：Weblogic、Tomcat、Jboss 
WEB SERVER：IIS、 Apache 
32、应用服务器有那些？ 
BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat 

3、J2EE是什么？ 
答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。

一个另类的回答：j2ee就是增删改查。 
67、J2EE是技术还是平台还是框架？ 什么是J2EE
   J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。 
   J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。
95、请对以下在J2EE中常用的名词进行解释(或简单描述) 
web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。 
EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。 
JNDI：（Java Naming & Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。 
JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。 
JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。 
JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。 
RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。
80、如何给weblogic指定大小的内存? 
（这个问题不作具体回答，列出来只是告诉读者可能会遇到什么问题，你不需要面面俱到，什么都精通。）

在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS=-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M 
81、如何设定的weblogic的热启动模式(开发模式)与产品发布模式? 
可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE=true。 
82、如何启动时不需输入用户名与密码? 
修改服务启动文件，增加 WLS_USER和WLS_PW项。也可以在boot.properties文件中增加加密过的用户名和密码. 
83、在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中? 
保存在此Domain的config.xml文件中，它是服务器的核心配置文件。 
84、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入http://主机:端口号//helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办? 
Domain目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。 
85、在weblogic中发布ejb需涉及到哪些配置文件 
不同类型的EJB涉及的配置文件不同，都涉及到的配置文件包括ejb-jar.xml,weblogic-ejb-jar.xmlCMP实体Bean一般还需要weblogic-cmp-rdbms-jar.xml 
86、如何在weblogic中进行ssl配置与客户端的认证配置或说说j2ee(标准)进行ssl的配置?
缺省安装中使用DemoIdentity.jks和DemoTrust.jks  KeyStore实现SSL，需要配置服务器使用Enable SSL，配置其端口，在产品模式下需要从CA获取私有密钥和数字证书，创建identity和trust keystore，装载获得的密钥和数字证书。可以配置此SSL连接是单向还是双向的。 
87、如何查看在weblogic中已经发布的EJB? 
可以使用管理控制台，在它的Deployment中可以查看所有已发布的EJB 
12. ejb部分
8、EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。 
   EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。 
SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。 
对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。 
对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。 
Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。 

2、简要讲一下 EJB 的 7 个 Transaction Level? 
3、EJB与JAVA BEAN的区别？ 
Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 
31、EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？ 
SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建一个新的Bean的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个Stateful Session Bean 时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful Session Bean 的方法时容器会把调用分派到与此客户机相关联的Bean实例。 
EntityBean：Entity Beans能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entity beans就一直存活。而不是按照应用程序或者服务进程来说的。即使EJB容器崩溃了，Entity beans也是存活的。Entity Beans生命周期能够被容器或者 Beans自己管理。 
EJB通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems的Transaction Service（JTS）、Java Transaction API（JTA），开发组（X/Open）的XA接口。 
73、EJB容器提供的服务 
主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。

77、EJB的激活机制 
以Stateful Session Bean 为例：其Cache大小决定了内存中可以同时存在的Bean实例的数量，根据MRU或NRU算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个EJB实例业务方法时，如果对应EJB Object发现自己没有绑定对应的Bean实例则从其去激活Bean存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的ejbActive和ejbPassivate方法。 
78、EJB的几种类型 
会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean 
会话Bean又可分为有状态（Stateful）和无状态（Stateless）两种 
实体Bean可分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种 
79、客服端调用EJB对象的几个基本步骤 
设置JNDI服务工厂以及JNDI服务地址系统属性，查找Home接口，从Home接口调用Create方法创建Remote接口，通过Remote接口调用其业务方法。
13. webservice部分
4、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。
Web ServiceWeb Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。 
JAXP(Java API for XML Parsing) 定义了在Java中使用DOM, SAX, XSLT的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。 
JAXM(Java API for XML Messaging) 是为SOAP通信提供访问方法和传输机制的API。 
WSDL是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。 
SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。 
UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。
88、CORBA是什么?用途是什么? 
CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。


14. Linux
118、LINUX下线程，GDI类的解释。 
LINUX实现的就是基于核心轻量级进程的"一对一"线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。 
GDI类为图像设备编程接口类库。 

15. 问得稀里糊涂的题
65、四种会话跟踪技术 
会话作用域ServletsJSP 页面描述 
page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面 
request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系） 
session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求 
application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域 
69、简述逻辑操作(&,|,^)与条件操作(&&,||)的区别。 
区别主要答两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型 
b.逻辑操作不会产生短路 

16. 其他
1、请用英文简单介绍一下自己.
4、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。
2、请把 http://tomcat.apache.org/ 首页的这一段话用中文翻译一下?
Apache Tomcat is the servlet container that is used in the official Reference Implementation for the Java Servlet and JavaServer Pages technologies. The Java Servlet and JavaServer Pages specifications are developed by Sun under the Java Community Process. 
Apache Tomcat is developed in an open and participatory environment and released under the Apache Software License. Apache Tomcat is intended to be a collaboration of the best-of-breed developers from around the world. We invite you to participate in this open development project. To learn more about getting involved, click here. 
Apache Tomcat powers numerous large-scale, mission-critical web applications across a diverse range of industries and organizations. Some of these users and their stories are listed on the PoweredBy wiki page.
3、美资软件公司JAVA工程师电话面试题目 
1. Talk about overriding, overloading.
2. Talk about JAVA design patterns you known.
3. Talk about the difference between LinkList, ArrayList and Victor.
4. Talk about the difference between an Abstract class and an Interface.
5. Class a = new Class(); Class b = new Class();
 if(a == b) returns true or false, why?
6. Why we use StringBuffer when concatenating strings?
7. Try to explain Singleton to us? Is it thread safe? If no, how to make it thread safe?
8. Try to explain Ioc?
9. How to set many-to-many relationship in Hibernate?
10. Talk about the difference between INNER JOIN and LFET JOIN.
11. Why we use index in database? How many indexes is the maximum in one table as your suggestion?
12. When ‘Final’ is used in class, method and property, what dose it mean?
13. Do you have any experience on XML? Talk about any XML tool you used ,e.g. JAXB, JAXG.
14. Do you have any experience on Linux?
15. In OOD what is the reason when you create a Sequence diagram? 
Administrator 10:34:20
  1，堆和栈的区别，有一个64k的字符串，是放到堆上，还是放到栈上，为什么？
2，什么时候用到接口，什么时候用到抽象类，二者区别
3，有一个100万的数组，里边有两个市重复的，如何设计算法找到。
4，设计数据库时，n维，如何设计。
例如[省份][城市][网吧]，这是三维关系，它的表也应该有三个，网吧有外键引用城市，城市有外键应用省份，这个规律就是下层的要有一外键去引用上层。





JFreeChart 1.0.6 用户开发指南(中文)
草稿（0.9.0）



译者：乖乖兔
2007-10-25
2000-2007, Object Refinery Limited. All rights reserved.
一．
简介
什么是JFreeChart
概述
JFreeChart是一款免费的java图形开发类库。主要用来在application/ applets/ servlets/ jsp/上生成各种图表。JFreeChart是完全开源，并且严格遵循GNU的通用公共许可证，力保JFreeChart用户对源代码的自由修改与使用。

图1.1 一个简单的图表
  图1.1就是一个典型的使用JFreeChart创建的图表。在本文后续章节将陆续展示更多的实例。
特征
JFreeChart能产生饼图（pie）、柱状/条形统计图（bar）、折线图（line）、散点图（scatter plots）、时序图（time series）、甘特图（Gantt）、仪表盘图（meter，比如刻度盘、温度计、罗盘等）、混合图、symbol图和风力方向图等。
主要特征如下：
定义接口的任何实现通俗易懂
易于导出PNG和JPEG图像文件格式（也可以使用java的图像I/O类库生成类库支持的任何格式）。
使用Graphics2D工具导出其他格式：
使用iText工具导出PDF格式文件
使用Batik工具导出SVG格式文件
图像工具栏
图表支持鼠标事件
支持注解。
产生HTML图像映射
可以工作于application/servlets/jsp/applets等环境。
完全开源、严格遵守GNU的通用公共认证协议。
JFreeChart完全由java语言编写，可以运行在java2的任何平台上（JDK1.3.1版本或者更高版本）
下载主页
JFreeChart 可以在下面的链接中找到：
http://www.jfree.org/jfreechart/ 这里我们可以找到JFreechart最新的版本，目前是1.0.6。包括图表实例、下载链接、javadoc文档、讨论社区等。
使用文档
文档有两个有效的版本：
免费版本  可以充JFreeChart主网站上下载免费版本《JFreeChart Installation Guide》，主要讲述内容是：JFreeChart的安装过程和JFreeChart实例的运行。
收费版本  需要支付一定费用才能获得《JFreeChart Developer Guide》，主要包括开发指南章节和JFreeChart类参考文档。
感谢
   JFreeChart的代码和思路源于很多人。在这里我将感谢下面帮助JFreeChart成长的人,也许有些人员名字漏掉，望给予指正，在此表示歉意。名单如下：
Richard Atkinson, David Berry, Anthony Boulestreau, Jeremy Bowman, Daniel Bridenbecker,
Nicolas Brodu, David Browning, Søren Caspersen, Chuanhao Chiu, Pascal Collet,
Martin Cordova, Paolo Cova, Michael Duffy, Jonathan Gabbai, Serge V. Grachov,
Hans-Jurgen Greiner, Joao Guilherme Del Valle, Aiman Han, Jon Iles, Wolfgang Irler,
Xun Kang, Bill Kelemen, Norbert Kiesel, Gideon Krause, Arnaud Lelievre, David
Li, Tin Luu, Craig MacFarlane, Achilleus Mantzios, Thomas Meier, Aaron Metzger,
Jim Moore, Jonathan Nash, Barak Naveh, David M. O’Donnell, Krzysztof Paz, Tomer
Peretz, Andrzej Porebski, Luke Quinane, Viktor Rajewski, Eduardo Ramalho, Michael
Rauch, Cameron Riley, Dan Rivett, Michel Santos, Thierry Saura, Andreas Schneider,
Jean-Luc Schwab, Bryan Scott, Roger Studner, Irv Thomae, Eric Thomas, Rich Unger,
Daniel van Enckevort, Laurence Vanhelsuw´e, Sylvain Vieujot, JelaiWang, MarkWatson,
Alex Weber, Matthew Wright, Christian W. Zuckschwerdt, Hari and Sam (oldman).
建议
如果您对本文档有任何的建议或想法，请发送：david.gilbert@object-refinery.com。
二．图表实例
介绍
本章节显示了许多使用JFreeChart创建的图表实例。内容特意对JFreeChart产生的图表类型做了概述。运行实例命令如下：
java -jar jfreechart-1.0.6-demo.jar
  如果您购买了《JFreeChart Developer Guide》，可获得该实例的源代码。
饼图（Pie Charts）
JFreeChart能够创使用符合PieDataset接口标准的数据创建饼图。下图2.1显示了一个简单的饼图。

图2.1 一个简单的饼图（参见：PieChartDemo1.java）
其中 ，单个的区域也可以被“取出”，如下图2.2所示：

图2.2 一个带有取出“区域”的饼图（参见：PieChartDemo2.java）
我们也可以显示3D效果的饼图，如下图2.3所示：

图2.3 3D效果图的图表（参见：PieChart3DDemo1.java）
3D效果的饼图，部分区域不能取出。
直方条形图（Bar Charts）
JFreeChart可以创建一系列的直方条形图。创建直方条形图的数据必须符合CategoryDataset接口标准。图2.4显示了一个垂直定向的直方条形图。

图2.4 一个垂直的直方条形图（参见：BarChartDemo1.java）
直方条形图可以用3D效果显示，如下图2.5所示。

如2.5 3D效果的直方条形图（参见：BarChart3DDemo1.java）
直方条形图的另一种变型，瀑布图表。如下图2.6所示：

如2.6 一个瀑布图表（参见：WaterfallChartDemo1.java）
直方条形图可以从时序数据中产生。如下图2.7所示：

图2.7 一个XY图表（参考 XYBarChartDemo1.java）

折线图（Line Charts）
折线图可以使用直方条形图的数据对象CategoryDataset产生。如下图2.8：

图2.8 一个折线图（参考LineChartDemo1.java）
XY(散点图)
XYDataset是第三种数据类型，用来产生一系列图表的类型。标准的XY区域有X和Y数轴。默认的，使用相应的数据按照一定比例画出X轴和Y轴。如图2.9所示。

图2.9 折线图（参考：LineChartDemo4.java）
散点图是每一个数据点用一个图形画出来，而不是使用线将点连起来。一个实例如下图2.10所示：

图2.10 散点图（参考：ScatterPlotDemo1.java）

时序图
JFreeChart支持时间序列图表，时序图包括平均值图、high-low-open-close图和candlestick图，如下图2.11所示：

图2.11 序列图（参考：TimeSeriesDemo1.java）
我们可以在时序图上添加一条平均值线——如下图2.12所示：

图2.12 带有平均线线的时序图（参考：TimeSeriesDemo8.java）
我们可以使用OHLCDataset（XYDataset的扩展）显示high-low-open-close数据图表。如下图2.13所示：

图2.13 high-low-open-close图表（参考：HighLowChartDemo2.java)）
柱状图
可以使用一个IntervalXYDataset（XYDataset的另一个扩展）数据产生柱状图。如下图2.14所示：

图2.14 柱状图（参考：HistogramDemo1.java）
面积图
我们可以使用CategoryDataset或者XYDataset产成面积图表。如下图2.15所示：

图2.15 面积图（参考：XYAreaChartDemo1.java）
同时，JFreeChart也支持堆栈式面积图表，如下图2.16所示：

图2.16 堆栈式面积图（参考：StackedXYAreaChartDemo1.java）
差异图
差异图是显示两个序列之间的不同。如下图2.17所示。

图2.17 差异图（参考：DifferenceChartDemo1.java）

图2.18 差异图（参考：DifferenceChartDemo2.java）
梯形图
梯形图使用一系列的“梯形”来显示数据数值。——如下图2.19所示：

图2.19 梯形图（参考：XYStepRendererDemo1.java）
梯形图数据使用XYDataset数据对象。
甘特图
我们可以使用IntervalCategoryDataset数据集类产生甘特图。如图2.20所示

图2.20 甘特图（参考：GanttChartDemo1.java）
此外，甘特图可以具有子任务和进度显示器。如下图2.21所示

图2.21 带有进度显示的甘特图
多轴图
JFreeChart支持多轴图表。如下图2.22显示了一个价格－数量的图表。

图2.22 价格－数量图表（参考：PriceVolumeDemo1.java）
CategoryPlot和XYPot支持多轴特征。图2.23显示了一个具有四个数轴的图表。

图2.23 多轴图表（参考：MultipleAxisDemo1.java）
复合/覆盖图
JFreeChart支持复合/覆盖图表。图2.24显示了一个条形图上覆盖了一个折线图。

图2.24 覆盖图（参考：ParetoChartDemo1.java）
也有可能使用同一个主轴，组合几种图表。如下图2.25。

图2.25 带有公共区域的图表（参考：CombinedCategoryPlotDemo1.java）
类似的，JFreeChart可以复合几种图表，共用相同刻度范围的轴。如图2.26所示：

图2.26 共用相同范围轴的复合图表（参考：CombinedXYPlotDemo2.java）
开发远景
JFreeChart为免费软件，任何人可以扩展它，可以添加新的特征。已经有80多人向JFreeChart项目贡献代码。不久开发者将开发更多的图表来满足更多的需求。我们可以从JFreeChart网站上获得更多的信息和版本的更新：
http://www.jfree.org/jfreechart/ 
    欢迎您的加入。
三．下载和安装JFreeChart 1.0.6
简介
    本章主要介绍JFreeChart的下载、解包和编译内容。同时讲述如何运行JfreeChart应用实例，如何从源代码生成JavaDoc的HTML文件内容等。
下载
我们可以从JFreeChart主网站上获得最新的JFreeChart版本：
http://www.jfree.org/jfreechart/download 
网页上提供了两个可下载的版本：
文件	描述
jfreechart-1.0.6.tar.gz	Linux/Unix版本
jfreechart-1.0.6.zip	Windows版本
这两个文件包含相同的源代码。主要不同在于下载的zip文件中所有的文本文件已被重新编码，有回车返回，并且每行结尾有换行符号。
JFreeChart是有JCommon（目前版本是1.0.9）基础类库.JCommon是运行时的jar文件，在JFreeChart下载时，包含该jar文件。如果你需要JCommon的源代码，可以从下面链接下载：
http://www.jfree.org/jcommon/ 
解包
下载完JFreeChart压缩文件之后，我们需要将该压缩文件解开。我们可以将文件解压到指定的目录下面。
Linux/Unix环境下解压
在Linux/Unix环境下解压文件，使用下面命令：

该命令将JFreeChart所有的文件包括源代码，运行jar文件和doc文档解压到jfreechart-1.0.6目录下面。
Windows环境下解压
在Windows环境下解压文件，使用下面命令：

该命令将JFreeChart所有的文件包括源代码，运行jar文件和doc文档解压到jfreechart-1.0.6目录下面。
文件目录说明
解压后的jfreechart-1.0.6目录下面，有许多文件和文件夹，列表如下：
文件/目录	说明
Ant	该目录下面包含了一个ant的build.xml脚本。我们使用该脚本可以用现有的版本源代码重新构建JFreeChart。
checkstyle	该目录下面包含了几种检查风格属性文件。文件定义了JFreeChart中的编码规范。
experimental	该文件夹下面包含了一些不属于JFreeChart标准API的类文件。注意这些代码的API可能会改变。
gjdoc	该文件夹下面包含了一种产生JFreeChart文档的脚本。
lib	该目录下面包含了JFreeChart的jar文件，以及JFreeChart依赖的jar文件。
source	JFreeChart源代码目录。
swt	该目录下面包含了具有实践经验的swt源代码。注意该代码API有可能发生改变。
Tests	JFreeChart单元测试的源代码文件。
jfreechart-1.0.6-demo.jar	一个具有实例演示的可运行的jar文件。
CHANGELOG.txt	老的JFreeChart变更的日志记录。
ChangeLog	JFreeChart变更的详细日志记录。
licence-LGPL.txt	JFreeChart公共认证（GNU LGPL）
NEWS	JFreeChart项目新闻
README.txt	重要信息—一定要读！
我们应当花一部分时间来熟悉这些文件，并详细的阅读README.txt文件。
运行演示实例
在解压的文件中，有一个实例演示应用包含了JFreeChart产生的大量图表演示实例。输入下面命令可以运行该应用：

实例的源代码跟JFreeChart开发指南一并发行，是收费的。
编译源代码
我们可是使用ant的build.xml文件重新编译JFreeChart类文件。进入ant目录，然后键入：

这将重新编译全部的源文件和创建创建JFreeChart运行时依赖的jar文件。Ant工具需要1.5.1版本或更高版本，我们可以从下面链接获得更多ant信息：
http://ant.apache.org/ 
产生javadoc文档
JFreeChart源代码文件中包含了大量丰富的Javadoc注释。我们使用javadoc工具可以直接从源代码中产生HTML文件。
产生javadoc文件使用ant的javadoc目标，进入ant目录键入：

这将产生javadoc目录。目录下面包含了全部的Javadoc的HTML文件。
四．使用JFreeChart1.0.6
概述
本章节向使用JFreeChart的新用户编写了一个简单的实例，以说明JFreeChart的使用方法。
创建第一个图表
概述
使用JFreeChart创建图表共有三个步骤。如下：
创建一个dataset。该dataset包含图表要显示的数据。
创建一个JFreeChart对象。该对象负责画这个图表。
创建一个输出目标（如：一个panel，显示在屏幕上）。该输出目标画这个图表。
下面，我们使用一个简单的应用（First.java）来描述这个过程。该应用产生了一个饼图，如下图4.1所示：

图4.1 创建的第一个饼图（参考First.java）
上面描述的三个步骤，将在下面的章节里面，均有代码详细说明。
数据
步骤一要求我们为我们的图表创建一个dataset。使用DefaultPieDataset类可以很容易创建。如下代码：

注意：
JFreeChart可以使用符合PieDataset接口的任何实现数据来创建饼图。DefaultDataset类实现了PieDataset接口，提供了一种便利的使用方式。
我们可以自由的开发符合实际需的任意PieDataset接口实现。
创建一个饼图
步骤二关心的是我们如何使用这个dataset展示在区域中。这就需要我们创建一个JFreeChart对象，该对象使用我们的饼图dataset数据画一个图表。我们使用ChartFactory类来创建，代码如下：

注意：
代码中将一个dataset的引用传入到工厂方法中。JFreeChart持有这个dataset引用的目的是便于在画图表时能够获得数据。使用JFreeChart创建图表有许多定制外观的方式，在这个例子中我们使用缺省的属性值。后面章节将详细介绍。
显示图表
最好一个步骤就是在某个地方显示该图表。JFreeChart提供了非常灵活的图表输出方式。
现在我们可以在一个屏幕的框架中显示这个图表。ChartFrame具有显示图表的机制（ChartPanel）。代码如下：

代码全部完成，运行main()方法,可以出现图4.1界面。
全部程序代码
下面是整个例子的全部代码，更加清楚的看到我们需要导入的类包和实现方法。

五．饼图（Pie Charts）
简介
本章主要讲解JFreeChart中饼图的一些特征。内容如下：
控制颜色和饼图片区的外廓
null值和零值的处理
饼图片区的标签（定制文本，改变分配的比例空间）
“取出”某个片区
多个饼图显示
显示3D效果的饼图
更多的信息，可以参见PiePlot参考文档，见章节33.72。
创建一个简单的饼图（Pie Charts）
在前面的第四章的手把手的向导里创建了一个简单的饼图。在这里不做详细介绍。
片区颜色
饼图片区缺省填充的颜色是自动分配的，正如你上面实例看到的。如果你不喜欢这个缺省的颜色，你可以实用setSectionPaint（）方法来设置片区颜色。例如：

JFreeChart的实例PieChartDemo2.java演示了如何定制颜色。在JFreeChart的代码中，片区颜色使用三层色属性机制来定义的。同时，我们也可以对饼图中的每一个系列定义填充的颜色，这里我们不做细述，更多的信息请参阅PiePlot类（33.27章节）。
片区外廓
每一个饼图片区的外廓默认是一条细灰线勾画出来的。PiePlot类提供了如下选择项：
完全不显示片区外廓
通过改变缺省的值来改变全部的片区外廓
单独改变部分饼图的片区外廓
片区外廓的可见性控制
为了完全关闭片区外廓，使用下面代码：

在任何时候，你只需要使用下面代码可以让外廓显示出来：

调用该方法可以触发PlotChangeEvent事件。
片区外廓的控制
在片区外廓显示的时候，我们可以改变饼图片区的整个外廓颜色或风格或者单个饼图片区的颜色或风格。整个外廓颜色或风格的修改需要在基本层里面设置，单个饼图片区的颜色设置需要在系列层中设置。在基本层里，如果没有更高层的颜色设置，则调用已定义的默认设置。我们可以使用PiePot类的方法来改变我们的设置。如下方法：

有时候在图表里面，我们会更喜欢设置饼图里面某个具体的片区的外廓的颜色，或许突出显示某些片区的细节方面。做到这些，我们可以是使用系列层层设置，通过下面的方法来定义。

方法的第一个参数是dataset的片区关键值。如果我们将该值设为null，则系统将使用基本层的设置。
空置、零值和负值
PieDataset可能会包含一些饼图不可能显示的数值，比如null、零值或者负值。对于这些数据PiePlot类有专门的处理机制来处理。如果是零值，并且该值有意义，PiePlot类默认将一个标签放置在饼图片区显示的位置，并且在图表的图例中添加一个分类。如果零值可以忽略，我们可以使用下面代码设置一个标志，不显示该数据：

类似的null值也是如此处理，nul值代表dataset丢失或者不知来源的值。缺省的处理与零值相同，如果忽略null值，则代码如下：

在饼图中处理负值是非常不明知的 ，所以在JFreeChart中负值总是被忽略的。
片区和图例标签
片区标签使用的文本，即可以在图表上显示，也可以在图表的图例上显示，并且完全可以定制。标签是自动默认产生的，但我们可以使用下面方法来改变：

StandPieSectionLabelGenerator类专门用来生成图例的一个实现类，提供灵活处理定制标签的功能（如果你不喜欢用这个类，可以定义自己的类，只要实现接口PieSectionLabelGenerator即可）。Dataset显示出的标签值由Javade信息格式类来进行格式化——表5.1所示格式化的变量值。
名称	描述
{0}	片区关键值（字符串）
{1}	片区值
{2}	百分比的片区值
表5.1 StandardPieSectionLabelGenerator substitutions
下面举例说，假如我们有一个PieData包含下面的值
片区标识	片区值
S1	3.0
S2	5.0
S3	Null
S4	2.0
表 5.2 一个dataset实例
下面是格式化字符串产生的标签值内容：
格式化字符串	片区	产生的标签值
{0}	0	S1
{0} has value {1}	1	S2 has value 5.0
{0}({2} percent)	0	S1(30 percent)
{0} = {1}	2	S3 = null
类PieChartDemo2.java使用了定制标签的方法。
“取出”某个片区
PiePlot类支持将某个片区“取出“显示。即某个片区偏离图表中心，以突出显示。如类所显示。
片区偏离的数值是图表半径的一个百分值来表示。例如0.3（30 persent）代码偏离的值是半径的长度×0.3.代码如下：

3D饼图
JFreeChart具有一个实现3D效果的饼图类PiePlot3D，如图5.5所示, (PieChart3DDemo1.java)。PiePlot3D是PiePlot的子类，因此在我们创建自己的饼图时，使用PiePlot3D替换掉原来的PiePlot即可。创建3D效果的饼图时，使用ChartFactory的 createPieChart3D（）方法，而不是createPieChart（）方法。

如5.5  3D效果图。
对于该类有一些限制，如下：
不支持”取出”片区功能。
不支持轴项转动——如果支持，3D效果图可能会变型。
3D的实例主要是类PieChart3DDemo1-3.java。讲解类中没有列出其他两个。因为功能雷同于非3D效果。
多饼图
我们可是使用类MultiplePiePlot在一个图表上显示多个饼图。饼图的数据使用CatoryDataset。如图5.6所示。每个独立的饼图由一个专门的图表多次创建而成。创建的每一个饼图的PieDataset是由系统提供的CategoryDataset按照行或者列拆分出来的。代码见5.10.11.

图5.6 多饼图图表

实例讲解
体会
也分为三层界面显示层、数据层、控制层。
数据层比较复杂。每个图形有不同的数据类型。Dataset类控制。
控制层Plot，饼图使用PiePlot设置显示的图形的面貌的控制，JFreeChart最丰富的功能。
设置片区颜色
设置标签（文本格式、背景颜色等）
设置是否取出某块。
设置饼图是否为圆形
设置饼图旋转。
显示层JFreeChart使用数据、控制直接将数据显示出来。
类PieChartDemo1.java
效果图如下：

代码编写典型的使用了面对对象的方法：

全部代码如下：
package demo;

import java.awt.Dimension;
import java.awt.Font;

import javax.swing.JPanel;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PiePlot;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.data.general.PieDataset;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RefineryUtilities;

public class PieChartDemo1 extends ApplicationFrame {
	/**
	 * 
	 */
	private static final long serialVersionUID = 2598557557724085474L;

	public PieChartDemo1(String string) {
		super(string);
		JPanel jpanel = createDemoPanel();
		jpanel.setPreferredSize(new Dimension(500, 270));
		setContentPane(jpanel);
	}

	private static PieDataset createDataset() {
		DefaultPieDataset defaultpiedataset = new DefaultPieDataset();
		defaultpiedataset.setValue("One", new Double(43.2));
		defaultpiedataset.setValue("Two", new Double(10.0));
		defaultpiedataset.setValue("Three", new Double(27.5));
		defaultpiedataset.setValue("Four", new Double(17.5));
		defaultpiedataset.setValue("Five", new Double(11.0));
		defaultpiedataset.setValue("Six", new Double(19.4));
		return defaultpiedataset;
	}

	private static JFreeChart createChart(PieDataset piedataset) {
		JFreeChart jfreechart = ChartFactory.createPieChart("Pie Chart Demo 1",
				piedataset, true, true, false);
		TextTitle texttitle = jfreechart.getTitle();
		texttitle.setToolTipText("A title tooltip!");
		PiePlot pieplot = (PiePlot) jfreechart.getPlot();
		pieplot.setLabelFont(new Font("Arial Black", 0, 20));
		pieplot.setNoDataMessage("No data available");
		pieplot.setCircular(false);
		pieplot.setLabelGap(0.02);
		return jfreechart;
	}

	public static JPanel createDemoPanel() {
		JFreeChart jfreechart = createChart(createDataset());
		return new ChartPanel(jfreechart);
	}

	public static void main(String[] strings) {
		PieChartDemo1 piechartdemo1 = new PieChartDemo1("Pie Chart Demo 1");
		piechartdemo1.pack();
		RefineryUtilities.centerFrameOnScreen(piechartdemo1);
		piechartdemo1.setVisible(true);
	}
}
类PieChartDemo2.java
功能：
     “取出“片区显示。
效果：

代码：

程序代码说明：
setSectionPaint("One", new Color(160, 160, 255))：设置某个片区的填充颜色。第一个参数为片区的标识，第二个参数为色值。
setNoDataMessage("No data available")：设置dataset为null时显示的提示信息。
setLabelGenerator(new StandardPieSectionLabelGenerator("{0}({2} percent)"))：设置标签显示的格式。
setLabelBackgroundPaint(new Color(220, 220, 220))：设置标签的背景颜色。
setLegendLabelToolTipGenerator(new StandardPieSectionLabelGenerator("Tooltip for legend item {0}"))：设置鼠标滑过图表是显示鼠标当前片区的提示信息。
pieplot.setExplodePercent("Two", 0.5)：将第2个片区取出显示。后面一个参数是取出的距离，是一个比例数。
类PieChartDemo3.java
功能：
显示了dataset为空时，设置的提示信息。
效果：

代码：

程序代码说明：
setNoDataMessage("没有有效的数据显示!")：设置提示信息内容。
setNoDataMessageFont(new Font("Serif", 2, 10))：设置提示信息的字体和大小。
setNoDataMessagePaint(Color.red)：设置提示信息字体的颜色。
类PieChartDemo4.java
功能：
带有按钮的图表，通过对dataset的排序，可以改变片区的位置。
效果：

代码：

程序代码说明：
dataset.sortByKeys(SortOrder.ASCENDING);通过片区的关键值进行升序排序。
dataset.sortByValues(SortOrder.DESCENDING);通过片区的值进行降序排序。
类PieChartDemo5.java
功能：
右边两个饼图为原形的，而左边两个为椭圆形的。
效果：

代码：
	public static JPanel createDemoPanel() {
		JPanel jpanel = new JPanel(new GridLayout(2, 2));
		DefaultPieDataset defaultpiedataset = new DefaultPieDataset();
		defaultpiedataset.setValue("Section 1", 23.3);
		defaultpiedataset.setValue("Section 2", 56.5);
		defaultpiedataset.setValue("Section 3", 43.3);
		defaultpiedataset.setValue("Section 4", 11.1);
		//
		JFreeChart jfreechart = ChartFactory.createPieChart("Chart 1",
				defaultpiedataset, false, false, false);
		jfreechart.addSubtitle(new TextTitle("setCircular(true);", new Font(
				"Dialog", 0, 12)));
		PiePlot pieplot = (PiePlot) jfreechart.getPlot();
		pieplot.setCircular(true);
		
		//
		JFreeChart jfreechart_0_ = ChartFactory.createPieChart("Chart 2",
				defaultpiedataset, false, false, false);
		jfreechart_0_.addSubtitle(new TextTitle("setCircular(false);",
				new Font("Dialog", 0, 12)));
		PiePlot pieplot_1_ = (PiePlot) jfreechart_0_.getPlot();
		pieplot_1_.setCircular(false);
		
		//
		JFreeChart jfreechart_2_ = ChartFactory.createPieChart3D("Chart 3",
				defaultpiedataset, false, false, false);
		jfreechart_2_.addSubtitle(new TextTitle("setCircular(true);", new Font(
				"Dialog", 0, 12)));
		PiePlot3D pieplot3d = (PiePlot3D) jfreechart_2_.getPlot();
		pieplot3d.setForegroundAlpha(0.6F);
		pieplot3d.setCircular(true);
		
		//
		JFreeChart jfreechart_3_ = ChartFactory.createPieChart3D("Chart 4",
				defaultpiedataset, false, false, false);
		jfreechart_3_.addSubtitle(new TextTitle("setCircular(false);",
				new Font("Dialog", 0, 12)));
		PiePlot3D pieplot3d_4_ = (PiePlot3D) jfreechart_3_.getPlot();
		pieplot3d_4_.setForegroundAlpha(0.6F);
		pieplot3d_4_.setCircular(false);
		
		jpanel.add(new ChartPanel(jfreechart));
		jpanel.add(new ChartPanel(jfreechart_0_));
		jpanel.add(new ChartPanel(jfreechart_2_));
		jpanel.add(new ChartPanel(jfreechart_3_));
		jpanel.setPreferredSize(new Dimension(800, 600));
		return jpanel;
	}
程序代码说明：
pieplot.setCircular(true)：设置饼图为圆形。
jpanel.add方法可以添加多个图形的panel
类PieChartDemo6.java
功能：
显示饼图对零值和null值的处理。
效果：

代码：
	public static JPanel createDemoPanel() {
		JPanel jpanel = new JPanel(new GridLayout(2, 2));
		JFreeChart jfreechart = createChart("Pie Chart 1", createDataset());
		Font font = new Font("Dialog", 0, 12);
		jfreechart.addSubtitle(new TextTitle(
				"Ignore nulls: false; Ignore zeros: false;", font));
		JFreeChart jfreechart_0_ = createChart("Pie Chart 2", createDataset());
		jfreechart_0_.addSubtitle(new TextTitle(
				"Ignore nulls: true; Ignore zeros: false;", font));
		PiePlot pieplot = (PiePlot) jfreechart_0_.getPlot();
		pieplot.setIgnoreNullValues(true);
		pieplot.setIgnoreZeroValues(false);
		JFreeChart jfreechart_1_ = createChart("Pie Chart 3", createDataset());
		jfreechart_1_.addSubtitle(new TextTitle(
				"Ignore nulls: false; Ignore zeros: true;", font));
		PiePlot pieplot_2_ = (PiePlot) jfreechart_1_.getPlot();
		pieplot_2_.setIgnoreNullValues(false);
		pieplot_2_.setIgnoreZeroValues(true);
		JFreeChart jfreechart_3_ = createChart("Pie Chart 4", createDataset());
		jfreechart_3_.addSubtitle(new TextTitle(
				"Ignore nulls: true; Ignore zeros: true;", font));
		PiePlot pieplot_4_ = (PiePlot) jfreechart_3_.getPlot();
		pieplot_4_.setIgnoreNullValues(true);
		pieplot_4_.setIgnoreZeroValues(true);
		jpanel.add(new ChartPanel(jfreechart));
		jpanel.add(new ChartPanel(jfreechart_0_));
		jpanel.add(new ChartPanel(jfreechart_1_));
		jpanel.add(new ChartPanel(jfreechart_3_));
		return jpanel;
	}
程序代码说明：
pieplot.setIgnoreNullValues(true)：设置饼图忽略null值，即是null值将不显示。
	pieplot.setIgnoreZeroValues(false);设置饼图不忽略零值。即图表中显示出零值。
类PieChartDemo7.java
功能：
图表能够旋转，标签也随之移动。
效果：

代码：

程序代码说明：
使用Rotator对象，旋转饼图。代码如上。
类PieChartDemo8.java
功能：
编写自定义标签产生器，将Two标签不显示。
效果：

代码：
private static JFreeChart createChart(PieDataset piedataset) {
		JFreeChart jfreechart = ChartFactory.createPieChart("Pie Chart Demo 8",
				piedataset, false, true, false);
		PiePlot pieplot = (PiePlot) jfreechart.getPlot();
		pieplot.setLabelGenerator(new CustomLabelGenerator());
		return jfreechart;
}

static class CustomLabelGenerator implements PieSectionLabelGenerator {
		public String generateSectionLabel(PieDataset piedataset,
				Comparable comparable) {
			String string = null;
			if (piedataset != null && !comparable.equals("Two"))
				string = comparable.toString();
			return string;
		}

		public AttributedString generateAttributedSectionLabel(
				PieDataset piedataset, Comparable comparable) {
			Object object = null;
			String string = comparable.toString();
			String string_0_ = (string + " : " + String.valueOf(piedataset
					.getValue(comparable)));
			AttributedString attributedstring = new AttributedString(string_0_);
			attributedstring.addAttribute(TextAttribute.WEIGHT,
					TextAttribute.WEIGHT_BOLD, 0, string.length() - 1);
			return attributedstring;
		}
	}

程序代码说明：
自定义CustomLabelGenerator，必须实现接口PieSectionLabelGenerator。
类PieChart3DDemo1.java
功能：
3D效果的饼图。
效果：

代码：

程序代码说明：
使用ChartFactory的方法createPieChart3D创建3D效果的饼图。
setStartAngle(180.0)：设置旋转角度。
setDirection(Rotation.CLOCKWISE)：设置旋转方向，Rotation.CLOCKWISE)为顺时针。
setForegroundAlpha(0.5F)：设置图表透明图0.0~1.0范围。0.0为完全透明，1.0为完全不透明。
类MultiplePieChartDemo1.java
功能：
    使用CategoryDataset数据集，在一个图表上产生多个饼图。
效果：

代码：

程序代码说明：
创建CategoryDataset的方法。

程序代码说明：
使用ChartFactory的方法createMultiplePieChart（）创建多个饼图的图表。
multiplepieplot.getPieChart()：获得单个饼图的图表。

类.java
功能：
    。
效果：

代码：

程序代码说明：

类.java
功能：
    。
效果：

代码：

程序代码说明：


六．直方条形图（Bar Charts）
简介
本章详细介绍了使用JFreeChart创建直方条形图的过程。开始我们先用一个简单的直方条形图例子进行说明，然后进一步深入了解JFreeChart为直方条形图提供的定制方法。在了解了这些标准的直方条形图配置项之后，然后再深入了解更复杂的图表：
堆栈式直方条形图
时序数据的条形直方图
柱状图
本章结束之后，我们将会对JFreeChart支持直方条形图创建的特点有个整体的了解。
创建一个直方条形图
概述
直方条形图常常被用来显示表列数据。如下表，为一个简单的两行、三列数据。
表 6.1
	Colnums1	Colnums2	Colnums3
Row1	1.0	5.0	3.0
Row2	2.0	3.0	2.0
在JFreeChart里，这个表格数据封装为一个dataset数据对象，每列标题为一个种类，每行为一个系列。每行标题为一个系列名称（或者系列关键值）。直方条形图展现的数据图如图6.2.

图6.2  简单的直方条形图（参见：BarExample1.java）
 在这个图表的实例中，我们可以看到JFreeChart将每列数据（即一个种类）组合在一起。而且对每行数据（即每个系列）使用各种颜色高亮显示。图表的图例将颜色和系列的名称/关键值对应起来。
创一个dataset
创建直方条形图的第一步就是创建一个合适的dataset数据集。JFreeChart为直方条形图提供的访问表列数据的一系列方法，必须符合接口CategoryDataset定义。
JFreeChart中提供了一个便利的实现CategoryDataset接口的类为DefaultCategoryDataset。下面显示我们如何使用这个类来封装表6.1数据。代码如下：

创建一个chart图表
    接下来就是要创建一个JFreeChart的实例，使用上面提供的dataset数据集画一个直方条形图。简单的，我们使用ChartFactory类来创建这个JFreeChart实例。代码如下：

CreateBarChart()的大部分参数是比较容易理解的，但其中一部分还需要进一步说明。
图显示的方向可以是水平的，还是可以是垂直的。
图表的信息提示，是否要添加，有一个标志来控制——在上面的例子中，我们将这个标识设置为true，因此当我们在一个swing应用窗口显示这个图表时，我们会看到这个信息提示。
URLs标志，设置为false。
我们完成这个直方条形图后，我们将会过头来，仔细看看ChartFactory类在后台做了写什么。
显示该chart图表
为了完成我们的第一个直方条形图实例，我们将JFreeChart实例传给一个ChartPanel对象，然后在一个Swing应用窗口上显示该实例。全部的代码如下：
import java.awt.Dimension;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RefineryUtilities;

/**
 * A simple demonstration application showing how to create a bar chart.
 */
public class BarExample1 extends ApplicationFrame {
	/**
	 * Creates a new demo instance.
	 * 
	 * @param title
	 *            the frame title.
	 */
	public BarExample1(String title) {
		super(title);
		DefaultCategoryDataset dataset = new DefaultCategoryDataset();
		dataset.addValue(1.0, "Row 1", "Column 1");
		dataset.addValue(5.0, "Row 1", "Column 2");
		dataset.addValue(3.0, "Row 1", "Column 3");
		dataset.addValue(2.0, "Row 2", "Column 1");
		dataset.addValue(3.0, "Row 2", "Column 2");
		dataset.addValue(2.0, "Row 2", "Column 3");
		JFreeChart chart = ChartFactory.createBarChart("Bar Chart Demo", // chart
																			// title
				"Category", // domain axis label
				"Value", // range axis label
				dataset, // data
				PlotOrientation.VERTICAL, // orientation
				true, // include legend
				true, // tooltips?
				false // URLs?
				);
		ChartPanel chartPanel = new ChartPanel(chart, false);
		chartPanel.setPreferredSize(new Dimension(500, 270));
		setContentPane(chartPanel);
	}

	/**
	 * Starting point for the demonstration application.
	 * 
	 * @param args
	 *            ignored.
	 */
	public static void main(String[] args) {
		BarExample1 demo = new BarExample1("Bar Demo 1");
		demo.pack();
		RefineryUtilities.centerFrameOnScreen(demo);
		demo.setVisible(true);
	}
}
完成这些代码后，运行代码，将会显示如6.2图的界面。
ChartFactory类
在上面的实例代码中，我们使用ChartFactory类来组装一个JFreeChart实例来显示一个直方条形图。下面我们更仔细的看一下该类是如何工作的，因此我们可以看到直方条形图更多底层的框架结构。理解底层结构的关键是能定制图表的外观。下面是ChartFactory方法createBarChart()方法部分代码：

以下就是代码所做的工作。
我们的直方条形图有两个轴，一个轴显示dataset（CategoryAxis）的种类，另一个是显示带有数据（NumberAxis）刻度的数据轴。上面代码中代码1、2行建立了这两个轴，轴的标签是createBarChart()方法传入的。
第三行，创建了一个BarRender——该类为每一个数据项目画直方图。该render处理大部分画图工作，我们后续代码也会看到可以使用另一个类型的render替换现有的render，来改变图表的整个外观。
Dataset、axes和render都由CategorryPlot来管理，CategorryPlot系统组件之间的大部分交互工作。当我们定制一个图表时，我们经常需要先获得整个图表plot、renderer和dataset的引用。在代码的第四行，创建了一个plot，然后其他组件对它进行赋值。
最后，在JFreeChart实例中，这个plot用指定的标题被封装。JFreeChart类提供了比较高层次的访问图表。但在这个plot曾思图表就大部分被定义出来了（Plot管理很多对象，例如axes、dataset和renderer）。
图表的内部结构基本上是由上面的知识理论组成。在后续的章节，我们会逐渐学习更多的定制我们图表的方法。
直方条形图的简单定制
调用JFreeChart和CategoryPlot类方法可以进行一些简单的直方图表外观的修改。例如，改变图表和区域的背景颜色代码如下：

该片段代码（摘自BarExample2.java类）显示了改变图表的背景颜色、获得图表的plot（区域）的引用，并且进行了修改——效果如图6.3.

图6.3一个直方条形图（参考：BarExample2.java）
区域Plot的引用（CategoryPlot）是必须的——转换类型也是非常安全的，因为我们知道该图表类型使用CategoryPlot。JFreeChart使用不同的区域类型（比如PiePlot、XYPlot）控制不同类型的图表。我们必须将plot的引用转化成图表响应的类型，因为基本类Plot仅仅定义了一些通用的属性和方法。随着对JFreeChart了解的加深，我们将学习每一种图表使用的不同的plot子类。
在我们的例子中，我们使用plot的引用来改变水平轴的网格线颜色。看一下CategoryPlot类的API文件，就会看到我们能够修改的地方。
定制外观
    回顾6.3节内容，CategoryPlot管理这一个BarRenderer的实例renderer。如果我们想获得这个renderer的引用，大量的定制选择项会变得有效。
直方条形图颜色
改变图表中每个系列直方图的颜色，使用如下代码：

运行上面代码显示的结果如下图6.4.注意setSeriesPaint（）方法是在抽象AbstractRenderer基类里面定义的——所以，我们可以在任何类型的renderer里面使用。

图6.4一个直方条形图（参考：BarExample3.java）
种类里直方条形图之间的空间
   此外，renderer还可以控制每个种类中直方条形图之间的间距。因此我们可以在同一个种类中将空间完全去掉，代码如下：

代码显示的结果如图6.5所示。

图6.5一个直方条形图（参考：BarExample4.java）
注意条形图看上去有点变宽——主要是因为JFreeChart分配空间时，分配给种类条形图之间的间距的尺度比较少，所以看上去就显得有点长宽了。
示例代码解读
体会
与饼图的数据集不同之处在于：
饼图数据集是key/value二维数据（PieDataset）。而直方条形图需要三维数据（CategoryDataset）。

类BarChartDemo1.java
功能：
       一个简单的直方条形图。使用GradientPaint实例对象为每一个系列修改renderer
效果：

代码：
public class BarChartDemo1 extends ApplicationFrame {
	private static final long serialVersionUID = 1L;

	public BarChartDemo1(String string) {
		super(string);
		JPanel jpanel = createDemoPanel();
		jpanel.setPreferredSize(new Dimension(500, 270));
		setContentPane(jpanel);
	}

	private static CategoryDataset createDataset() {
		String string = "First";
		String string_0_ = "Second";
		String string_1_ = "Third";
		String string_2_ = "Category 1";
		String string_3_ = "Category 2";
		String string_4_ = "Category 3";
		String string_5_ = "Category 4";
		String string_6_ = "Category 5";
		DefaultCategoryDataset defaultcategorydataset = new DefaultCategoryDataset();
		defaultcategorydataset.addValue(1.0, string, string_2_);
		defaultcategorydataset.addValue(4.0, string, string_3_);
		defaultcategorydataset.addValue(3.0, string, string_4_);
		defaultcategorydataset.addValue(5.0, string, string_5_);
		defaultcategorydataset.addValue(5.0, string, string_6_);
		defaultcategorydataset.addValue(5.0, string_0_, string_2_);
		defaultcategorydataset.addValue(7.0, string_0_, string_3_);
		defaultcategorydataset.addValue(6.0, string_0_, string_4_);
		defaultcategorydataset.addValue(8.0, string_0_, string_5_);
		defaultcategorydataset.addValue(4.0, string_0_, string_6_);
		defaultcategorydataset.addValue(4.0, string_1_, string_2_);
		defaultcategorydataset.addValue(3.0, string_1_, string_3_);
		defaultcategorydataset.addValue(2.0, string_1_, string_4_);
		defaultcategorydataset.addValue(3.0, string_1_, string_5_);
		defaultcategorydataset.addValue(6.0, string_1_, string_6_);
		return defaultcategorydataset;
	}

	private static JFreeChart createChart(CategoryDataset categorydataset) {
		JFreeChart jfreechart = ChartFactory.createBarChart("Bar Chart Demo 1",
				"Category", "Value", categorydataset, PlotOrientation.VERTICAL,
				true, true, false);
		jfreechart.setBackgroundPaint(Color.WHITE);
		CategoryPlot categoryplot = (CategoryPlot) jfreechart.getPlot();
		categoryplot.setBackgroundPaint(Color.lightGray);
		categoryplot.setDomainGridlinePaint(Color.white);
		categoryplot.setDomainGridlinesVisible(true);
		categoryplot.setRangeGridlinePaint(Color.white);

		//刻度轴刻度设置
		NumberAxis numberaxis = (NumberAxis) categoryplot.getRangeAxis();
		numberaxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());

		//renderer设置
		BarRenderer barrenderer = (BarRenderer) categoryplot.getRenderer();
		barrenderer.setDrawBarOutline(false);//设置外廓线不可见
		GradientPaint gradientpaint = new GradientPaint(0.0F, 0.0F, Color.blue,
				0.0F, 0.0F, new Color(0, 0, 64));
		GradientPaint gradientpaint_7_ = new GradientPaint(0.0F, 0.0F,
				Color.green, 0.0F, 0.0F, new Color(0, 64, 0));
		GradientPaint gradientpaint_8_ = new GradientPaint(0.0F, 0.0F,
				Color.red, 0.0F, 0.0F, new Color(64, 0, 0));
		barrenderer.setSeriesPaint(0, gradientpaint);
		barrenderer.setSeriesPaint(1, gradientpaint_7_);
		barrenderer.setSeriesPaint(2, gradientpaint_8_);

		//设置种类标签旋转的角度，逆时针旋转
		CategoryAxis categoryaxis = categoryplot.getDomainAxis();
		categoryaxis.setCategoryLabelPositions(CategoryLabelPositions
				.createUpRotationLabelPositions(Math.PI / 6));
		return jfreechart;
	}

	public static JPanel createDemoPanel() {
		JFreeChart jfreechart = createChart(createDataset());
		return new ChartPanel(jfreechart);
	}

	public static void main(String[] strings) {
		BarChartDemo1 barchartdemo1 = new BarChartDemo1("Bar Chart Demo");
		barchartdemo1.pack();
		RefineryUtilities.centerFrameOnScreen(barchartdemo1);
		barchartdemo1.setVisible(true);
	}
}
程序代码说明：
Main（）方法执行直方条形图。编写方法与饼图一样。
BarChartDemo1构造函数中创了一个JPanel，并设置大小。
createDemoPanel()方法创建了一个JPanel，并且在该panel上创建了直方条形图。
createDataset()方法创建了数据集。类型为CategoryDataset。注意数据集为三维数据。与饼图不同。
使用ChartFactory.createBarChart（）方法创建直方条形图
jfreechart.setBackgroundPaint(Color.WHITE)：设置图表的背景颜色。
categoryplot.setBackgroundPaint(Color.lightGray)：设置直方条形图的背景颜色。
setDomainGridlinePaint（Color.whites）：设置垂直格线的颜色。默认不可见。
setRangeGridlinePaint(Color.white)：设置水平格线的颜色。默认可见。
setStandardTickUnits(NumberAxis.createIntegerTickUnits())：设置数据轴的刻度递进范围。
GradientPaint类用来设置渐变色。
categoryaxis.setCategoryLabelPositions（）：设置标签文字旋转的角度。
类BarChartDemo2.java
功能：
       显示水平的直方条形图。
效果：

代码：
	private static CategoryDataset createDataset() {
		double[][] ds = { { 1.0, 43.0, 35.0, 58.0, 54.0, 77.0, 71.0, 89.0 },
				{ 54.0, 75.0, 63.0, 83.0, 43.0, 46.0, 27.0, 13.0 },
				{ 41.0, 33.0, 22.0, 34.0, 62.0, 32.0, 42.0, 34.0 } };
		return DatasetUtilities.createCategoryDataset("Series ", "Factor ", ds);
	}

	private static JFreeChart createChart(CategoryDataset categorydataset) {
		JFreeChart jfreechart = ChartFactory.createBarChart("Bar Chart Demo 2",
				"Category", "Score (%)", categorydataset,
				PlotOrientation.VERTICAL, true, true, false);
		jfreechart.setBackgroundPaint(Color.white);
		CategoryPlot categoryplot = (CategoryPlot) jfreechart.getPlot();
		categoryplot.setBackgroundPaint(Color.lightGray);
		categoryplot.setRangeGridlinePaint(Color.white);
		categoryplot.setRangeAxisLocation(AxisLocation.BOTTOM_OR_LEFT);
		NumberAxis numberaxis = (NumberAxis) categoryplot.getRangeAxis();
		numberaxis.setRange(0.0, 100.0);
		numberaxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
		BarRenderer barrenderer = (BarRenderer) categoryplot.getRenderer();
		barrenderer.setDrawBarOutline(false);
		barrenderer
				.setLegendItemToolTipGenerator(new StandardCategorySeriesLabelGenerator(
						"Tooltip: {0}"));
		return jfreechart;
	}
程序代码说明：
数据集的创建另一种方式，使用二维数组。
类BarChartDemo.java
功能：
       。
效果：

代码：

程序代码说明：

类BarChartDemo.java
功能：
       。
效果：

代码：

程序代码说明：

类BarChartDemo.java
功能：
       。
效果：

代码：

程序代码说明：

类BarChartDemo.java
功能：
       。
效果：

代码：

程序代码说明：

类BarChartDemo.java
功能：
       。
效果：

代码：

程序代码说明：

类BarChartDemo.java
功能：
       。
效果：

代码：

程序代码说明：

类BarChartDemo.java
功能：
       。
效果：

代码：

程序代码说明：



七．折线图
简介
    本章讲述了JFreeChart创建折线图的内容。我们可以使用CategoryDataset或XYDataset数据集接口创建折线图。
使用categoryDataset数据集创建折线图
概述
使用CategoryDataset创建的折线图将每个数据点（种类，值）使用一条直线连接起来。本章讲的一个简单应用产生如下界面，如图7.1：

图7.1  一个简单的折线图
   全部的代码简JFreeChart开发指南一并下载的demo（参考：LineChartDemo1.java）。
CategoryDataset
正如其他图表一样，创建折线图的第一步是创建第一个dataset。在本例子中，使用DefaultCategoryDataset，代码如下：

    注意：你可以使用任何实现Category接口的数据集。
创建图表
ChartFactory类提供了一个便利的方法createLineChart()创建折线图。代码如下：

该方法构建了一个带有标题、图例、和相应的数轴和心态提示产生器的JFreeChart对象。创建Dataset数据集的过程见上节。
定制图表
折线图表将使用大部分缺省的属性来进行初始化。当然了，我们也可以随意修改折线图的属性，来改变我们图表的外观。在本例中，我们通过下面的方式定制折线图：
在图表上添加两个副标题；
图表的背景颜色设成白色；
图区背景颜色设成亮灰色；
网格线颜色改变成白色；
范围轴修改成仅显示整数数值；
renderer使用白色填充的形状。
首先，将副标题添加在缺省的位置（主标题下方），代码如下：

第二个副标题加入了一些额外的代码，来改变字体，并放置在图表的下方，并且靠右对其，代码如下：

改变图表的背景颜色非常简单，因为JFreeChart类就有设置背景颜色的属性。代码如下：

如果改变其他属性的，则需要首先获得图表CategoryPlot对象的引用，然后对该引用进行相应属性的设置。获得对象引用的代码如下：

使用CategoryPlot设置图区的背景颜色为亮灰色，设置网格线颜色为白色的代码如下：

图区负责在图表上画出数据和轴。其中一部分工作由renderer来完成，我们可以通过getRender()来获得一个renderer。renderer维护大部分与图表内数据项的显示相关的属性。代码如下：

同时图区也管理着图表所有的轴。在本实例中，修改范围轴以便范围轴的刻度标签显示为整数值。

定制图表还有很多其他的方式。具体的内容详见本文档相关章节，API文档以及源代码实例。
程序的全部代码
/* -------------------
 * LineChartDemo1.java
 * -------------------
 * (C) Copyright 2002-2005, by Object Refinery Limited.
 *
 */
package demo;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.geom.Ellipse2D;
import java.net.URL;

import javax.swing.ImageIcon;
import javax.swing.JPanel;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.renderer.category.LineAndShapeRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.HorizontalAlignment;
import org.jfree.ui.RectangleEdge;
import org.jfree.ui.RefineryUtilities;

public class LineChartDemo1 extends ApplicationFrame {
	/**
	 * 
	 */
	private static final long serialVersionUID = -6354350604313079793L;

	/* synthetic */static Class class$demo$LineChartDemo1;

	public LineChartDemo1(String string) {
		super(string);
		JPanel jpanel = createDemoPanel();
		jpanel.setPreferredSize(new Dimension(500, 270));
		setContentPane(jpanel);
	}

	private static CategoryDataset createDataset() {
		DefaultCategoryDataset defaultcategorydataset = new DefaultCategoryDataset();
		defaultcategorydataset.addValue(212.0, "Classes", "JDK 1.0");
		defaultcategorydataset.addValue(504.0, "Classes", "JDK 1.1");
		defaultcategorydataset.addValue(1520.0, "Classes", "JDK 1.2");
		defaultcategorydataset.addValue(1842.0, "Classes", "JDK 1.3");
		defaultcategorydataset.addValue(2991.0, "Classes", "JDK 1.4");
		defaultcategorydataset.addValue(3500.0, "Classes", "JDK 1.5");
		return defaultcategorydataset;
	}

	private static JFreeChart createChart(CategoryDataset categorydataset) {
		JFreeChart jfreechart = ChartFactory.createLineChart(
				"Java Standard Class Library",// 图表标题
				null, // 主轴标签
				"Class Count",// 范围轴标签
				categorydataset, // 数据集
				PlotOrientation.VERTICAL,// 方向
				false, // 是否包含图例
				true, // 提示信息是否显示
				false);// 是否使用urls

		// 添加主标题
		jfreechart.addSubtitle(new TextTitle("Number of Classes By Release"));
		TextTitle texttitle = (new TextTitle(
				"Source: Java In A Nutshell (5th Edition) by David Flanagan (O'Reilly)"));
		texttitle.setFont(new Font("SansSerif", 0, 10));
		texttitle.setPosition(RectangleEdge.BOTTOM);
		texttitle.setHorizontalAlignment(HorizontalAlignment.RIGHT);
		jfreechart.addSubtitle(texttitle);

		// 改变图表的背景颜色
		jfreechart.setBackgroundPaint(Color.white);

		CategoryPlot categoryplot = (CategoryPlot) jfreechart.getPlot();
		categoryplot.setBackgroundPaint(Color.lightGray);
		categoryplot.setRangeGridlinePaint(Color.white);
		categoryplot.setRangeGridlinesVisible(false);
		URL url = (class$demo$LineChartDemo1 == null ? class$demo$LineChartDemo1 = class$("demo.LineChartDemo1")
				: class$demo$LineChartDemo1).getClassLoader().getResource(
				"OnBridge11small.png");
		if (url != null) {
			ImageIcon imageicon = new ImageIcon(url);
			jfreechart.setBackgroundImage(imageicon.getImage());
			categoryplot.setBackgroundPaint(new Color(0, 0, 0, 0));
		}
		NumberAxis numberaxis = (NumberAxis) categoryplot.getRangeAxis();
		numberaxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
		LineAndShapeRenderer lineandshaperenderer = (LineAndShapeRenderer) categoryplot
				.getRenderer();
		lineandshaperenderer.setShapesVisible(true);
		lineandshaperenderer.setDrawOutlines(true);
		lineandshaperenderer.setUseFillPaint(true);
		lineandshaperenderer.setBaseFillPaint(Color.white);
		lineandshaperenderer.setSeriesStroke(0, new BasicStroke(3.0F));
		lineandshaperenderer.setSeriesOutlineStroke(0, new BasicStroke(2.0F));
		lineandshaperenderer.setSeriesShape(0, new Ellipse2D.Double(-5.0, -5.0,
				10.0, 10.0));

		LineAndShapeRenderer renderer = (LineAndShapeRenderer) categoryplot
				.getRenderer();
		renderer.setShapesVisible(true);
		renderer.setDrawOutlines(true);
		renderer.setUseFillPaint(true);

		return jfreechart;
	}

	public static JPanel createDemoPanel() {
		JFreeChart jfreechart = createChart(createDataset());
		return new ChartPanel(jfreechart);
	}

	public static void main(String[] strings) {
		LineChartDemo1 linechartdemo1 = new LineChartDemo1(
				"JFreeChart - Line Chart Demo 1");
		linechartdemo1.pack();
		RefineryUtilities.centerFrameOnScreen(linechartdemo1);
		linechartdemo1.setVisible(true);
	}

	/* synthetic */
	static Class class$(String string) {
		Class var_class;
		try {
			var_class = Class.forName(string);
		} catch (ClassNotFoundException classnotfoundexception) {
			throw new NoClassDefFoundError(classnotfoundexception.getMessage());
		}
		return var_class;
	}
}

使用XYDataset数据集创建折线图
概述
折线图也可以使用XYDataset数据集，使用一条直线将相邻的点（x，y）点连接起来。本章介绍的一个使用XYDataset数据集创建折线图的简单实例，如下图7.2所示。

图7.2 一个简单的基于XYDataset数据集的折线图（参考：LineChartDemo2.java）
XYDataset
对于该图表来说，使用的数据集是XYSeriesCollection（当然我们可以使用实现XYDataset接口的其他数据集）。出于独立演示的目点，我们创建的dataset代码如下：

注意：每个系列必须有x值（不是必须有y值），并且该系列独立于其他系列。数据集可以接受一个y值为null的值。当图表遇到null值时，连接线不被画出，该系列的连线不会连续。出现下图7.3类型。

图7.3有一个 y值为null时，图表显示断续。
创建图表
ChartFactory类提供了一个便利的方法createXYLineChart()创图表：

上面方法构建了一个JFreeChart对象，该对象具有一个标题、图例和相关轴的图区及renderer。数据集使用上节我们创建的数据集。
定制图表
图表将使用大部分缺省的属性进行初始化设置。当然了，我们也可以随意修改这些属性，来改变我们图表的外观。在本实例中，设置的几个属性如下：
设置图表的背景颜色
设置图区的背景颜色
设置轴的平移值
设置主轴和范围轴网格线颜色
修改renderer改变连线点的形状
范围轴刻度的设置，以便显示整数值。
改变图表背景颜色非常简单。代码如下：

改变图区背景颜色、轴平移、网格线颜色，需要使用plot图区对象的一个引用来修改。图片对象需要转化成XYPlot对象，主要是因为我们可以访问更多更具体的图区方法。代码如下：

修改renderer来显示连线之间的形状。代码如下：

最后就是修改范围轴。我们将默认刻度值（允许显示小数）改成只显示整数的刻度值。代码如下：

参考源代码、Javadoc的API文档以及其他相关XYPlot的定制内容，来学习更多的细节。
程序的全部代码

示例代码解读
体会

类.java
功能：
       。
效果：

代码：

程序代码说明：


八．时序图
简介
时序图类似于折线图，唯一不同的地方是时序图的主轴是日期而不是数值。本章讲述如何使用JFreeChart创建时序图。
创建时序图
概述
时序图表的确是一个使用XYDataset数据集的折线图。不同点就是再主轴上X轴值显示的是日期。本章讲述的一个简单应用如下图8.1所示

图8.1 一个简单的时序图表（参考：TimeSeriesDemo1.java）。
上图实例代码参见类TimeSeriesDemo1.java。
日期还是数字？
创建序图使用的数据集是XYDataset。接口不能有返回日期类型以外的方法。那么JFreeChart是如何创建时序图表的呢？
数据集返回的x值是基本的double类型，但这个值通过一种特殊的方式来进行转译成日期——该数是反映了一个从1970/1/1起计算的一个毫秒级值（译码过程使用java.util.Data类计算）。
具体的轴类（DateAxis）将毫秒级数据转化成日期，并作为需要返回该值，将数值作为主轴刻度显示出来。
数据集
演示的本实例，数据使用的是一个TimeSeriesCollection对象（我们可以是任何XYDataset接口的实现）。代码如下：
	private static XYDataset createDataset() {
		TimeSeries timeseries = new TimeSeries(
				"L&G European Index Trust",
				(class$org$jfree$data$time$Month == null ? (class$org$jfree$data$time$Month = class$("org.jfree.data.time.Month"))
						: class$org$jfree$data$time$Month));
		timeseries.add(new Month(2, 2001), 181.8);
		timeseries.add(new Month(3, 2001), 167.3);
		timeseries.add(new Month(4, 2001), 153.8);
		timeseries.add(new Month(5, 2001), 167.6);
		timeseries.add(new Month(6, 2001), 158.8);
		timeseries.add(new Month(7, 2001), 148.3);
		timeseries.add(new Month(8, 2001), 153.9);
		timeseries.add(new Month(9, 2001), 142.7);
		timeseries.add(new Month(10, 2001), 123.2);
		timeseries.add(new Month(11, 2001), 131.8);
		timeseries.add(new Month(12, 2001), 139.6);
		timeseries.add(new Month(1, 2002), 142.9);
		timeseries.add(new Month(2, 2002), 138.7);
		timeseries.add(new Month(3, 2002), 137.3);
		timeseries.add(new Month(4, 2002), 143.9);
		timeseries.add(new Month(5, 2002), 139.8);
		timeseries.add(new Month(6, 2002), 137.0);
		timeseries.add(new Month(7, 2002), 132.8);
		TimeSeries timeseries_0_ = new TimeSeries(
				"L&G UK Index Trust",
				(class$org$jfree$data$time$Month == null ? (class$org$jfree$data$time$Month = class$("org.jfree.data.time.Month"))
						: class$org$jfree$data$time$Month));
		timeseries_0_.add(new Month(2, 2001), 129.6);
		timeseries_0_.add(new Month(3, 2001), 123.2);
		timeseries_0_.add(new Month(4, 2001), 117.2);
		timeseries_0_.add(new Month(5, 2001), 124.1);
		timeseries_0_.add(new Month(6, 2001), 122.6);
		timeseries_0_.add(new Month(7, 2001), 119.2);
		timeseries_0_.add(new Month(8, 2001), 116.5);
		timeseries_0_.add(new Month(9, 2001), 112.7);
		timeseries_0_.add(new Month(10, 2001), 101.5);
		timeseries_0_.add(new Month(11, 2001), 106.1);
		timeseries_0_.add(new Month(12, 2001), 110.3);
		timeseries_0_.add(new Month(1, 2002), 111.7);
		timeseries_0_.add(new Month(2, 2002), 111.0);
		timeseries_0_.add(new Month(3, 2002), 109.6);
		timeseries_0_.add(new Month(4, 2002), 113.2);
		timeseries_0_.add(new Month(5, 2002), 111.6);
		timeseries_0_.add(new Month(6, 2002), 108.8);
		timeseries_0_.add(new Month(7, 2002), 101.6);
		TimeSeriesCollection timeseriescollection = new TimeSeriesCollection();
		timeseriescollection.addSeries(timeseries);
		timeseriescollection.addSeries(timeseries_0_);
		return timeseriescollection;
	}
实例中，系列包含了每月的数据。尽管如此，仍然使用TimeSeries类来显示间隔的时间值（年、日、小时等）。
构建图表
使用ChartFactory类提供的便利方法createTimeSeriesChart()创建图表，代码如下：

该方法构建了一个带有标题、图例、相应轴的区域和展示器的JFreeChart对象。使用的数据集见上一节内容。
定制图表
图表的大部分属性使用了缺省的值进行初始化。当然，我们可以随时修改这些属性的设置来改变我们图表的外观展现。在本实例中，修改的几个属性如下：
修改renderer，改变每个数据点显示的系列形状，数据点之间的折线除外。
主轴的数据格式进行格式化后显示。
修改renderer需要一下两个步骤：获得renderer引用和将renderer对象转化成XYLineAndShapeRenderer类型。代码如下：

最后，将格式化的数据传给主轴，以改变显示。代码如下：

当设置了Dataaxis时，系统将自动选择一个DataTickUnit来显示主轴刻度。但系统将使用上面我们格式化的数据来显示，而不是系统默认的格式。
全部代码
文档的全部代码如下：
/* TimeSeriesDemo1 - Decompiled by JODE
 * Visit http://jode.sourceforge.net/
 */
package demo;

import java.awt.Color;
import java.awt.Dimension;
import java.text.SimpleDateFormat;

import javax.swing.JPanel;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.time.Month;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.data.xy.XYDataset;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RectangleInsets;
import org.jfree.ui.RefineryUtilities;

public class TimeSeriesDemo1 extends ApplicationFrame {

	private static final long serialVersionUID = -5412286370956646368L;

	/* synthetic */static Class class$org$jfree$data$time$Month;

	public TimeSeriesDemo1(String string) {
		super(string);
		XYDataset xydataset = createDataset();
		JFreeChart jfreechart = createChart(xydataset);
		ChartPanel chartpanel = new ChartPanel(jfreechart, false);
		chartpanel.setPreferredSize(new Dimension(500, 270));
		chartpanel.setMouseZoomable(true, false);
		setContentPane(chartpanel);
	}

	private static JFreeChart createChart(XYDataset xydataset) {
		JFreeChart jfreechart = ChartFactory.createTimeSeriesChart(
				"Legal & General Unit Trust Prices", // title
				"Date", // x-axis label
				"Price Per Unit", // y-axis label
				xydataset, // data
				true, // create legend?
				true, // generate tooltips?
				false // generate URLs?
				);

		jfreechart.setBackgroundPaint(Color.white);
		XYPlot xyplot = (XYPlot) jfreechart.getPlot();
		xyplot.setBackgroundPaint(Color.lightGray);
		xyplot.setDomainGridlinePaint(Color.white);
		xyplot.setRangeGridlinePaint(Color.white);
		xyplot.setAxisOffset(new RectangleInsets(5.0, 5.0, 5.0, 5.0));
		xyplot.setDomainCrosshairVisible(true);
		xyplot.setRangeCrosshairVisible(true);
		org.jfree.chart.renderer.xy.XYItemRenderer xyitemrenderer = xyplot
				.getRenderer();
		if (xyitemrenderer instanceof XYLineAndShapeRenderer) {
			XYLineAndShapeRenderer xylineandshaperenderer = (XYLineAndShapeRenderer) xyitemrenderer;
			xylineandshaperenderer.setBaseShapesVisible(true);
			xylineandshaperenderer.setBaseShapesFilled(true);
		}
		DateAxis dateaxis = (DateAxis) xyplot.getDomainAxis();
		dateaxis.setDateFormatOverride(new SimpleDateFormat("MMM-yyyy"));
		return jfreechart;
	}

	private static XYDataset createDataset() {
		TimeSeries timeseries = new TimeSeries(
				"L&G European Index Trust",
				(class$org$jfree$data$time$Month == null ? (class$org$jfree$data$time$Month = class$("org.jfree.data.time.Month"))
						: class$org$jfree$data$time$Month));
		timeseries.add(new Month(2, 2001), 181.8);
		timeseries.add(new Month(3, 2001), 167.3);
		timeseries.add(new Month(4, 2001), 153.8);
		timeseries.add(new Month(5, 2001), 167.6);
		timeseries.add(new Month(6, 2001), 158.8);
		timeseries.add(new Month(7, 2001), 148.3);
		timeseries.add(new Month(8, 2001), 153.9);
		timeseries.add(new Month(9, 2001), 142.7);
		timeseries.add(new Month(10, 2001), 123.2);
		timeseries.add(new Month(11, 2001), 131.8);
		timeseries.add(new Month(12, 2001), 139.6);
		timeseries.add(new Month(1, 2002), 142.9);
		timeseries.add(new Month(2, 2002), 138.7);
		timeseries.add(new Month(3, 2002), 137.3);
		timeseries.add(new Month(4, 2002), 143.9);
		timeseries.add(new Month(5, 2002), 139.8);
		timeseries.add(new Month(6, 2002), 137.0);
		timeseries.add(new Month(7, 2002), 132.8);
		TimeSeries timeseries_0_ = new TimeSeries(
				"L&G UK Index Trust",
				(class$org$jfree$data$time$Month == null ? (class$org$jfree$data$time$Month = class$("org.jfree.data.time.Month"))
						: class$org$jfree$data$time$Month));
		timeseries_0_.add(new Month(2, 2001), 129.6);
		timeseries_0_.add(new Month(3, 2001), 123.2);
		timeseries_0_.add(new Month(4, 2001), 117.2);
		timeseries_0_.add(new Month(5, 2001), 124.1);
		timeseries_0_.add(new Month(6, 2001), 122.6);
		timeseries_0_.add(new Month(7, 2001), 119.2);
		timeseries_0_.add(new Month(8, 2001), 116.5);
		timeseries_0_.add(new Month(9, 2001), 112.7);
		timeseries_0_.add(new Month(10, 2001), 101.5);
		timeseries_0_.add(new Month(11, 2001), 106.1);
		timeseries_0_.add(new Month(12, 2001), 110.3);
		timeseries_0_.add(new Month(1, 2002), 111.7);
		timeseries_0_.add(new Month(2, 2002), 111.0);
		timeseries_0_.add(new Month(3, 2002), 109.6);
		timeseries_0_.add(new Month(4, 2002), 113.2);
		timeseries_0_.add(new Month(5, 2002), 111.6);
		timeseries_0_.add(new Month(6, 2002), 108.8);
		timeseries_0_.add(new Month(7, 2002), 101.6);
		TimeSeriesCollection timeseriescollection = new TimeSeriesCollection();
		timeseriescollection.addSeries(timeseries);
		timeseriescollection.addSeries(timeseries_0_);
		return timeseriescollection;
	}

	public static JPanel createDemoPanel() {
		JFreeChart jfreechart = createChart(createDataset());
		return new ChartPanel(jfreechart);
	}

	public static void main$(String[] strings) {
		TimeSeriesDemo1 timeseriesdemo1 = new TimeSeriesDemo1(
				"Time Series Demo 1");
		timeseriesdemo1.pack();
		RefineryUtilities.centerFrameOnScreen(timeseriesdemo1);
		timeseriesdemo1.setVisible(true);
	}

	public static void main(String[] args) {
		main$(args);
	}

	/* synthetic */static Class class$(String string) {
		Class var_class;
		try {
			var_class = Class.forName(string);
		} catch (ClassNotFoundException classnotfoundexception) {
			throw new NoClassDefFoundError(classnotfoundexception.getMessage());
		}
		return var_class;
	}
}
示例代码解读
体会
包含了一个时间处理的方式。值得学习。
类.java
功能：
       。
效果：

代码：

程序代码说明：



九．定制图表（Customising Charts）
简介
JFreeChart的设计的定制功能是非常灵活的。我们可以使用非常多的属性来设置我们图表的外观。本章将详细介绍一些图表通用的定制技术。
图表属性
概述
我们可以使用JFreeChart类方法从更高的层次来定制我们图表的外观。可控制的属性有：
图表的边框
图表的标题和副标题
图表的背景颜色和图片
使用绘制建议（Rendering Hints）画图表，该属性有是否反锯齿功能。
在下面的章节中将详细描述这些内容。
图表边框
JFreeChart可以在图表的外围画出一个边框。默认状态下，JFreeChart是不画出边框的，但我们可以使用方法setBorderVisible()来设置。边框的颜色和线条风格可使用方法setBorderPaint()和setBorderStroke()来控制。
注意：如果我们在一个ChartPanel里面显示我们的图表，那么我们可能更愿意使用Swing提供的边框。
图表标题
图表有一个标题，显示在图表的顶部、底部、左侧或右侧（同时，我们也可以添加副标题，见下章讲述）。标题使用一个TextTitle的实例对象。我们可以使用getTitle()方法来获得标题的引用。

修改标题文本（不修改字体和位置）的代码如下：

题头放置在图表的顶部、底部、左侧或右侧的设置，使用标题本书属性设置来完成。下面代码显示的是将标题移植到图表的底部。

如果在我们图表上，我们不希望显示标题，则将标题设置为null即可。
副标题
图表可以拥有任何数量的副标题。添加副标题，需要先创建一个副标题对象（任何Title类的子类），然后将该对象加到图表上即可。代码如下：

我们可以在图表上添加任何数量的副标题，但是紧急我们添加的副标题越多，图表画图的区域就越小。
修改一个已有的副标题，我们需要先获得副标题的一个引用。代码如下：

在我们改变副标题属性之前，我们需要将Title的引用转换成我们需要的适当的子类类型。
我们可以使用getSubtitleCount()方法获得副标题的数量。
设置图表背景颜色
我们可以使用setBackgroundPaint()方法设置图表的背景颜色（注意，我们也可以设置我们图区的背景颜色，这与图表的背景颜色不同）。例如：

我们可使用Paint接口的任何实现作为背景颜色的设置参数，其中有Color、GradientPaint（渐变颜色）和TexturePaint等。代码如下：

我们可以设置我们的背景颜色为null，这时推荐使用一个背景图片来设置我们的图表。
使用背景图片
我们可以使用方法setBackgroundImage()来为我们的图表设置一幅背景图表。

默认的，图片充满图表的整个背景，图片失真。但我们可以使用setBackgroundImageAlignment()方法来改变图片不充满整个背景。代码如下：

使用setBackgroundImageAlpha()方法，我们可以控制图片的透明度。如果我们希望图片只填充我们图表的区域（区域包含轴），那么我们需要将背景图片添加到图表的图区。代码如下（以饼图为例）：

Rendering Hints（绘制建议）
JFreeChart使用java2D的API来画图表。在java2D中的API中，我们可以提供绘制建议让绘制引擎绘制图表。JFreeChart允许我们在画图表时，使用setRenderingHints()方法，将绘制建议参数传入java2D的API中。
JFreeChart还提供了一个便利反锯齿开关方法。当反锯齿开关开时，图表会绘制出比较光滑的图表，但是花费的时间要长。代码如下：

JFreeChart画图时，默认为反锯齿开关为开。
图区属性
概述
JFreeChart类在绘制图表时，将大部分工作交给了Plot类（图形绘制结构）或Plot的子类。JFreeChart类的getPlot()方法返回了一个图表创建的图区（plot）的引用。
	  Plot plot = jfreechart.getPlot();
我们需要将该引用转化成Plot的一个具体子类。例如：
CategoryPlot plot = jfreechart.getCategoryPlot();
  或
      XYPlot plot = jfreechart.getXYPlot();
注意：如果plot不是相应的类，则在转化的时候，会抛出ClassCastException类型转制异常。
图区子类
那么我们如何知道我们图表使用的Plot是那个子类呢？作为使用JFreeChart的经验，分清那些图表使用CategoryPlot和那些图表使用XYPlot是非常清晰的。如果还怀疑，看一下ChartFactory类的源代码就会明白每个类型的图表是如何放在一起的。
设置图区背景颜色
我们可以使用方法setBackgroundPaint()设置图区的背景颜色。例如：

	我们可使用Paint接口的任何实现作为背景颜色的设置参数，其中有Color、GradientPaint（渐变颜色）和TexturePaint等。同时，我们也可以设置背景颜色为null。
设置背景图片
我们可以使用方法setBackgroundImage()为图区设置备有图片。

默认的，图片充满图表的整个背景，图片失真。但我们可以改变图片不充满整个背景，使用方法是setBackgroundImageAlignment()。

使用setBackgroundImageAlpha()方法，我们可以控制图片的透明度。如果我们希望图片充满这个图表区域，那么我们需要将背景图片添加到JFreeChart对象上（前面已经介绍过）。
轴属性
概述
使用JFreeChart创建的大部分图表都带有两个轴。X轴和Y轴。当然对于一些图表（比如饼图）根本就没有轴。对于使用轴的图表来说，图区使用Axis对象来管理轴。
获得轴对象引用
在你修改轴的属性之前，我们需要先获得一个轴的引用。图区类CategoryPlot和XYPlot类有两个方法getDomainAxis()和getRangeAxis()分别是获得X轴Y轴对象。这两个方法返回了一个ValueAxis对象的引用，除了在使用CategoryPlot的情况下，X轴使用的是CategoryAxis。代码如下：

CategoryAxis和ValueAxis类有许多不同的子类。有时我们需要将轴对象引用转化成具体的子类，为了获取更多具体的属性。如，如果我们想获得y轴为一个对象NumberAxis。代码如下：

设置轴标签
我们使用方法setLabel()可以改变轴的标签。如果我们不想在图表的轴上有标签，那么我们就设置为null即可。
我们可以使用Axis类定义的方法setLabelFont(), setLabelPaint(), 和 setLabelInsets()改变标签的字体、颜色等内容。
改变周边标签显示方向
当图区在左侧或右侧画一个轴（水平轴）时，轴标签会自动旋转90度，以满足小空间的需要。如果我们希望标签也水平，我们需要修改标签的角度：

注意角度的表示使用弧度（PI为180度）。
隐藏刻度标签
隐藏某个轴的刻度标签：

对于CategoryAxis，方法setTickLabelsVisible(false)隐藏种类标签。
隐藏刻度符号
隐藏某个轴的刻度符号：

注意category轴没有刻度符号。
设置刻度尺寸
默认的，数值和日期会自动选择一个刻度尺寸，以便刻度标签不会重复显示。但我们也可以使用setTickUnit()方法设置我们自己的饿刻度单位。
指定标准的数值刻度单位
在NumberAxis类中，方法允许我们设置我们自己的刻度单位替代系统自动选择刻度danwi的机制。最普通的应用就是我们有一个仅仅显示整数的数轴。在实例中，我们不想让0.5或者0.25作为刻度单位。在NumberAxis类中有一个静态方法返回一系列的标准整数刻度单位：

如果我们想控制标准的刻度单位时，我们可以自由定制自己的TickUnits集合。
指定标准的日期刻度单位
类似于上一节内容，DateAxis类也有一个setStandardTickUnits()方法，来设置我们的刻度单位。方法createStandardDateTickUnits()为DateAxis返回了一个缺省的集合。同时我们也可以创建我们自己的标准日期刻度单位。
心得体会
Title子类如下图：
  包图如下所示：

关系类图如下：

Plot类

类结构图如下：



十．动态图（Dynamic Charts）
简介
为了说明使用JFreeChart创建“动态”的图表，本章节阐述了一个简单的应用说明这个过程，该应用为动态刷新JVM内存显示已使用和未使用情况。如下图10.1

如图10.1 一个简单的“动态”实例（参考：MemoryUsageDemo.java）。
知识背景
事件监听
JFreeChart使用监听机制来响应其他chart组件改变的响应。例如，不论数据源在何时发生更新，一个DatasetChangeEvent事件总被发送给已注册进数据源的监听器。
响应触发发生一系列事件：
图区监听到数据源改变的通知。如果需要更新轴的值，然后将PlotChangeEvent事件通知所有注册的监听器。
图表监听到图区更改事件的通知，然后将ChartChangeEvent事件通知给所有注册的监听器。
最后，ChartPanel接受到该面板上显示的图表的更改事件，ChartPanel根据响应的事件画出响应的图表——完全重新画，而不是仅仅更新数据。
所有图表或者其他子控件改变发生的事件过程都遵循上面的过程。
性能优化
关于性能优化，我们必须明白JFreeChart不会产生实时图表。每次数据源的更新，ChartPanel都需要重新画全部的图表。
性能优化通常是非常困难的。 比如，JFreeChart调用图像2D的API提取最新变更的点，从而只画更新的点。我们使用JFreeChart完成这个实时过程的实例将限制了“每秒产生页面”的数量。产生数量的大小是否是一个瓶颈的关键问题，主要取决我们我们画图表所依赖的数据，应用的环境和操作环境。
实例应用
概述
实例MemoryUsageDemo.java文档可以从下面的链接中获得：
http://www.object-refinery.com/jfreechart/premium/index.html 
页面需要输入购买JFreeChart开发指南时需要的用户名和密码。
创建一个dataset
创建的实例代码数据源，包含了一个单一的时序集合，集合内有两个TimeSeries对象（一个是计算总内存，另一个是计算剩余内存）。代码如下：

每个时间系列的maximumItemAge属性设置为30000毫秒（30秒）。因此任何时候添加到新系列的新数据，都是30秒前记录的老数据。
创建一个图表
图表的创建（定制）都遵循所有图表创建的标准模式。创建动态图也是一样，没有任何特殊的步骤。除了我们将autoRange属性设置为true之外。同时，这也有利于维护图表使用的数据源的引用。
更新一个dataset
在本实例演示中，通过向两个时序图添加的数据来更新数据源，该数据的添加有一个独立的线程Timer管理。代码如下：

注意JFreeChart在画图表和数据源更新代码之间没有使用线程同步，因此是不安全的。另一点需要注意的是，曾做过一个关于JFreeChart内存泄露问题的测试，将JFreeChart的实例在一个机器上连续运行6天。随着图表的不断更新，我们就可以看到垃圾收集器所产生的影响。六天之后，发现总内存的使用量保持不变。当JFreChart产生并丢弃的临时对象（垃圾对象）时，剩余可用内存减少了。增加的使用内存量是垃圾收集器工作时所使用的。
全部代码
下面是全部的实例代码：
/* MemoryUsageDemo - Decompiled by JODE
 * Visit http://jode.sourceforge.net/
 */
package demo;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.Timer;

import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.time.Millisecond;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.ui.RectangleInsets;

public class MemoryUsageDemo extends JPanel {
	private static final long serialVersionUID = 6776712838359498649L;

	private TimeSeries total;

	private TimeSeries free;

	/* synthetic */static Class class$org$jfree$data$time$Millisecond;

	class DataGenerator extends Timer implements ActionListener {
		private static final long serialVersionUID = 1L;

		DataGenerator(int i) {
			super(i, null);
			addActionListener(this);
		}

		public void actionPerformed(ActionEvent actionevent) {
			long l = Runtime.getRuntime().freeMemory();
			long l_0_ = Runtime.getRuntime().totalMemory();
			MemoryUsageDemo.this.addTotalObservation((double) l_0_);
			MemoryUsageDemo.this.addFreeObservation((double) l);
		}
	}

	public MemoryUsageDemo(int i) {
		super(new BorderLayout());
		total = new TimeSeries(
				"Total Memory",
				(class$org$jfree$data$time$Millisecond == null ? (class$org$jfree$data$time$Millisecond = class$("org.jfree.data.time.Millisecond"))
						: class$org$jfree$data$time$Millisecond));
		total.setMaximumItemAge((long) i);
		free = new TimeSeries(
				"Free Memory",
				(class$org$jfree$data$time$Millisecond == null ? (class$org$jfree$data$time$Millisecond = class$("org.jfree.data.time.Millisecond"))
						: class$org$jfree$data$time$Millisecond));
		free.setMaximumItemAge((long) i);
		TimeSeriesCollection timeseriescollection = new TimeSeriesCollection();
		timeseriescollection.addSeries(total);
		timeseriescollection.addSeries(free);
		
		DateAxis dateaxis = new DateAxis("Time");
		NumberAxis numberaxis = new NumberAxis("Memory");
		dateaxis.setTickLabelFont(new Font("SansSerif", 0, 12));
		numberaxis.setTickLabelFont(new Font("SansSerif", 0, 12));
		dateaxis.setLabelFont(new Font("SansSerif", 0, 14));
		numberaxis.setLabelFont(new Font("SansSerif", 0, 14));
		XYLineAndShapeRenderer xylineandshaperenderer = new XYLineAndShapeRenderer(
				true, false);
		xylineandshaperenderer.setSeriesPaint(0, Color.red);
		xylineandshaperenderer.setSeriesPaint(1, Color.green);
		xylineandshaperenderer.setSeriesStroke(0, new BasicStroke(3.0F, 0, 2));
		xylineandshaperenderer.setSeriesStroke(1, new BasicStroke(3.0F, 0, 2));
		XYPlot xyplot = new XYPlot(timeseriescollection, dateaxis, numberaxis,
				xylineandshaperenderer);
		xyplot.setBackgroundPaint(Color.lightGray);
		xyplot.setDomainGridlinePaint(Color.white);
		xyplot.setRangeGridlinePaint(Color.white);
		xyplot.setAxisOffset(new RectangleInsets(5.0, 5.0, 5.0, 5.0));
		dateaxis.setAutoRange(true);
		dateaxis.setLowerMargin(0.0);
		dateaxis.setUpperMargin(0.0);
		dateaxis.setTickLabelsVisible(true);
		numberaxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
		JFreeChart jfreechart = new JFreeChart("JVM Memory Usage", new Font(
				"SansSerif", 1, 24), xyplot, true);
		jfreechart.setBackgroundPaint(Color.white);
		ChartPanel chartpanel = new ChartPanel(jfreechart, true);
		chartpanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory
				.createEmptyBorder(4, 4, 4, 4), BorderFactory
				.createLineBorder(Color.black)));
		add(chartpanel);
	}

	private void addTotalObservation(double d) {
		total.add(new Millisecond(), d);
	}

	private void addFreeObservation(double d) {
		free.add(new Millisecond(), d);
	}

	public static void main(String[] strings) {
		JFrame jframe = new JFrame("Memory Usage Demo");
		MemoryUsageDemo memoryusagedemo = new MemoryUsageDemo(30000);
		jframe.getContentPane().add(memoryusagedemo, "Center");
		jframe.setBounds(200, 120, 600, 280);
		jframe.setVisible(true);
		memoryusagedemo.new DataGenerator(100).start();
		jframe.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent windowevent) {
				System.exit(0);
			}
		});
	}

	/* synthetic */static Class class$(String string) {
		Class var_class;
		try {
			var_class = Class.forName(string);
		} catch (ClassNotFoundException classnotfoundexception) {
			throw new NoClassDefFoundError(classnotfoundexception.getMessage());
		}
		return var_class;
	}
}
十一．图表工具条（Tooltips）
概述
JFreeChart为图表的每个组件提供了一套产生、收集和显示工具条的机制。本章主要介绍：
如何产生图表工具条（包括定制图表工具条）
如何收集图表工具条
如何显示图表工具条
如何隐藏图表工具条
创建图表工具条
如果我们需要使用图表工具条，我们首先确保所画的图表中已经产生图表工具条。我们可以为我们的图区或图区条目设置图表工具条产生器。在下面的相关章节里面，我们将了解如何为一个图表设置一个图表工具条。
饼图
饼图类PiePlot使用PieToolTipGenerator接口产生接口图表工具条。系统通过了该接口的一个标准实现类StandardPieToolTipGenerator。PiePlot设置图表工具条的方法如下：

该方法可以为饼图设置工具条产生器，如果设置null，则表示没有工具条。
generated.种类图
种类图表—包括JFreeChart创建最多的直方条形图—基于CategoryPlot类并使用CategoryItemRenderer来画每一个数据条目。Renderer使用接口CategoryToolTipGenerator的指定方法来获得图表工具条。为种类图区条目设置图表工具条产生器，使用类AbstractCategoryItemRenderer的方法：

该方法可以为饼图设置工具条产生器，如果设置null，则表示没有工具条。
XY图
XY图表—包括JFreeChart创建的散点图和时序图—基于类XYPlot并使用XYItemRenderer画出每一个数据条目。Renderer使用一个XYToolTipGenerator产生图表工具条。
设置XY图区条目的工具条，使用在AbstractXYItemRenderer定义的方法：

如果设置产生器为null，表示没有图表工具条产生器。
收集图表工具条
使用ChartRenderingInfo类可收集图表工具条信息，以及图表的其他信息。我们首先要向JFreeChart的draw()方法传入该类实例，否则图表工具条信息将不被记录（即便是产生器已经被注册到图区的数据条目中）。
幸运的是，ChartPanel会自动的处理图表工具条的收集。因此如果我们使用ChartPanel显示我们的图表，就不用担心图表工具条的收集—因为ChartPanel已经为我们收集了。
显示图表工具条
使用ChartPanel类创建我们的图表时，图表工具条会自动显示出来。并且你可以为图区（或者图区的renderer）设置一个图表工具条。
我们可是使用类的方法设置显示或隐藏图表工具条。方法如下：
      
隐藏图表工具条
最有效的方式就是将图表工具条设置为null。确保没有任何图表工具条信息产生，这样可以节省内存同时提供处理速度（特别是对于大数据源时，非常有好处）。
我们可是使用上节讲的方法使用ChartPanele类设置图表工具条的隐藏。
定制图表工具条
    我们可以通过相应的图表工具条产生器接口对每一个图表工具条进行文本的各种操作。
十二．图表条目标签（Item Label）
简介
概述
对于大多数的图表类型来说，JFreeChart允许我们在图表的每个条目上、或者内部、或者附近显示条目标签。例如，下图12.1 在每个条形图上显示出了真实的值。

图12.1 显示数组的条形图（参考：）
本章主要讲述：
如何让条目标签可视（仅限于支持条目标签的图表类型）
如何改变条目标签的外观（字体和颜色）
如何指定条目标签的位置
如何定制条目标签的文本
忠告：我们使用上面的特征时，要谨慎。图表是期望用来分析总结数据的——如果我们觉得在图表上显示真实数据是非常有必要的话，那我们的数据应使用一个表格格式显示更为合适。
局限性
在当前版本JFreeChart中，条目标签的使用是有很多局限性的：
一些renderer不支持条目标签
轴范围的自动调节，忽略了条目标签的自动调整——如果图表的周围没有足够的空间（使用方法setUpperMargin()或setLowerMargin()进行了相应的调整），那么一些图表条目标签在图表上显示不出来。
相信，在以后的JFreeChart版本中，这些限制问题将被解决。
显示条目标签
概述
条目标签默认是不显示的，因此我们需要使用renderer进行创建和显示条目标签。这主要有以下两个步骤：
分配一个CategoryItemLabelGenerator或XYItemLabelGenerator给renderer—这是一个负责创建标签的对象。
在renderer里面设置一个标签可视的标志。可以针对全部系列进行设置，也可以针对具体的每一个系列进行设置。
此外，我们可以定制条目标签的位置、字体和颜色。在下面的章节里我们将详细的介绍。
创建一个条目标签并赋值
使用renderer分配的一个标签产生器创建条目标签（这与图表工具条的机制是相同的）。
下面代码说了将一个标签产生器指派给CategoryItemRenderer：

同样的，将一个产生器指派给XYItemRenderer，代码如下：

我们可以在标准产生器的构造函数中定制不同的行为。当然了，我们也可以创建我们总计的产生器，详见12.5.2章节。
所有的系列显示条目标签
方法renderer.setBaseItemLabelsVisible(false)是控制着条目标签的显示。对于CategoryItemRenderer：

同样对于：XYItemRenderer

一旦设置，这个标志优先管理我们在所有地方对每一系列做的设置，主要为了应用每一系列的设置。我们可以设置个标志为null（见12.2.4章节）
为选择的系列显示条目标签
我们可以控制图表的每一个系列的条目标签是否显示。例如：如下图12.2仅显示第一系列条目标签。

如图12.2显示第一系列条目标签
下面代码可以设置如上效果：

注意：上面代码中对全部的系列设置为null—这一点非常重要，因为全部系列的标志控制每一个系列的标志。

问题与解决
如果按照上面的步骤操作，你仍然未看见条目标签显示在图表上，那么我们从以下几个方面进行考虑：
Renderere必须需要一个标签产生器——这是一个用来创建每一个标签的文本条目的对象。
一些renderer不支持条目标签（具体参考renderer相关的文档）
条目标签外观
概述
我们可以通过改变条目的颜色、字体来改变图表条目标签的外观。正如其他renderer属性一样，属性的设置可以是全部的系列，可以是具体某一系列。
在JFreeChart目前的版本中，标签是月年个一个透明的背景画出来的。我们不能设置标签的背景颜色，也不能指定标签的边框。这些在以后的版本中会得到解决。
改变条目标签的字体
为了在所有的系列中改变条目标签的字体，我们可以使用下面的代码：

同样，也可以为单个系列设置字体：

注意：renderer.setBaseItemLabelFont(null)方法会出错。开发指南显示的代码有错误。
改变条目标签的颜色
改变条目标签的颜色，我们可以使用下面的代码：

同样的，可以为单独每一系列设置颜色：

注意：renderer.setBaseItemLabelPaint(null);方法会出错。开发指南显示的代码有错误。
条目标签位置 
概述
条目标签的位置是通过ItemLabelPosition对象的四个属性来控制的。
我们可以通过接口CategoryItemRenderer的方法来独立定义条目标签的正负点位置：

理解这些属性如何影响独立标签的最终位置的关键是了解JFreeChart里面条目标签的特征。四个特征是：
条目标签点——决定标签的起始位置
文本点——标签里的文本相对于条目标签的位置。
旋转点——标签文本旋转的点位置
旋转角度——标签的旋转角度。
这些的详细描述在下一章详细介绍。
条目标签的位置
设置条目标签位置的目的，主要是为了找出标签在图表上贴向数据条目的一个点（x,y）位置。同时在画图表时，该标签也被画在该点处。更多的信息可以参考ItemLabelAnchor文档。
标签文本的位置
标签文本的位置，主要取决于上节讲的标签位置。我们可以讲标签文本在标签里设置在右上部、或左下部等，更多的信息参见TextAnchor文档。
运行JCommon包内的org.demo.package下面的DrawStringDemo应用，可以更好的理解标签文本在标签内是如何放置的。
标签旋转点
在标签上定义了一个旋转点，用于旋转标签。在DrawStringDemo实例中很好演示了这个特征。
标签旋转角度
旋转角度定义了标签沿旋转点旋转的角度。该角度为弧度。
定制条目标签文本
概述
定制条目标签文本，我们需要依赖用JFreeChart里的标签产生器来为条目标签创建文本。如果要想完全控制标签文本的控制，我们就需要编写自己的标签产生器，需要实现接口CategoryItemLabelGenerator。
在本章节里，我们对自定义标签器技术做了简要的讲述，然后用两个实例来说明该技术过程。
实现一个自定义的标签产生器
开发一个自定义标签产生器，我们需要写一个类，该类必须实现CategoryItemLabelGenerator接口里的方法。

该renderer调用该方法获得一个标签的字符串，并且将该字符串传入到当前条目的CategoryDataset、序列和种类。这就意味着创建这个标签时，我们拥有完全的访问权限。
该方法可以返回任意字符串，因此我们格式化这个字符串。如果我们不想显示标签，可以设置为null。
在下面的两个例子中很好的说明了这个特征。
实例1
概述
在第一个实例中，目的就是当当条目的值大于某个限定的值时，就显示该标签。如图12.3所示。

如图12.3 超过某个限定值显示条目标签的实例
做到这一点并不困难，需要做以下工作：
写一个实现接口CategoryItemLabelGenerator的类，并且实现generateItemLabel()方法。该方法实现如果条目的值小于限定值时，返回null。
创建该类的实例，将该实例使用renderer的方法setLabelGenerator()设置到renderer中去。
源代码
package demo;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.text.DecimalFormat;
import java.text.NumberFormat;

import javax.swing.JPanel;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.labels.AbstractCategoryItemLabelGenerator;
import org.jfree.chart.labels.CategoryItemLabelGenerator;
import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
import org.jfree.chart.labels.StandardXYItemLabelGenerator;
import org.jfree.chart.labels.XYItemLabelGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.category.CategoryItemRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RefineryUtilities;

public class ItemLabelDemo1 extends ApplicationFrame {
	static class LabelGenerator extends AbstractCategoryItemLabelGenerator
			implements CategoryItemLabelGenerator {
		private double threshold;

		public LabelGenerator(double d) {
			super("", NumberFormat.getInstance());
			threshold = d;
		}

		public String generateLabel(CategoryDataset categorydataset, int i,
				int i_0_) {
			String string = null;
			Number number = categorydataset.getValue(i, i_0_);
			if (number != null) {
				double d = number.doubleValue();
				if (d > threshold)
					string = number.toString();
			}
			return string;
		}
	}

	public ItemLabelDemo1(String string) {
		super(string);
		CategoryDataset categorydataset = createDataset();
		JFreeChart jfreechart = createChart(categorydataset);
		ChartPanel chartpanel = new ChartPanel(jfreechart);
		chartpanel.setPreferredSize(new Dimension(500, 270));
		setContentPane(chartpanel);
	}

	private static CategoryDataset createDataset() {
		DefaultCategoryDataset defaultcategorydataset = new DefaultCategoryDataset();
		defaultcategorydataset.addValue(11.0, "S1", "C1");
		defaultcategorydataset.addValue(44.3, "S1", "C2");
		defaultcategorydataset.addValue(93.0, "S1", "C3");
		defaultcategorydataset.addValue(35.6, "S1", "C4");
		defaultcategorydataset.addValue(75.1, "S1", "C5");
		return defaultcategorydataset;
	}

	private static JFreeChart createChart(CategoryDataset categorydataset) {
		JFreeChart jfreechart = ChartFactory.createBarChart(
				"Item Label Demo 1", "Category", "Value", categorydataset,
				PlotOrientation.VERTICAL, false, true, false);
		jfreechart.setBackgroundPaint(Color.white);
		
		CategoryPlot categoryplot = (CategoryPlot) jfreechart.getPlot();
		categoryplot.setBackgroundPaint(Color.lightGray);
		categoryplot.setDomainGridlinePaint(Color.white);
		categoryplot.setRangeGridlinePaint(Color.white);
		
		NumberAxis numberaxis = (NumberAxis) categoryplot.getRangeAxis();
		numberaxis.setUpperMargin(0.15);

		return jfreechart;
	}

	public static JPanel createDemoPanel() {
		JFreeChart jfreechart = createChart(createDataset());
		return new ChartPanel(jfreechart);
	}

	public static void main(String[] strings) {
		ItemLabelDemo1 itemlabeldemo1 = new ItemLabelDemo1("Item Label Demo 1");
		itemlabeldemo1.pack();
		RefineryUtilities.centerFrameOnScreen(itemlabeldemo1);
		itemlabeldemo1.setVisible(true);
	}
}
实例2
概述
在本实例中，目的是在每个系列的标签上显示出值和百分比值（这个百分比值，这个系列在某一部分的条形直方图或全部条形直方图的总值中的比值）。如下图12.4所示。

图12.4 带有比值的直方图
该实现中，标签产生器计算出百分比。如果传入构造函数的是一个种类索引，那么这个百分比的基数就是指定种类的当前系列的值。如果种类索引是无效的，那么这个基数就是指定种类的全部系列总和。
标签产生器会默认创建一个百分比格式——一种比较成熟的格式，提供格式化能力。
源代码
package demo;

import java.awt.Color;
import java.awt.Dimension;
import java.text.NumberFormat;

import javax.swing.JPanel;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.labels.AbstractCategoryItemLabelGenerator;
import org.jfree.chart.labels.CategoryItemLabelGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.renderer.category.CategoryItemRenderer;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.ui.ApplicationFrame;
import org.jfree.ui.RefineryUtilities;

public class ItemLabelDemo2 extends ApplicationFrame {
	static class LabelGenerator extends AbstractCategoryItemLabelGenerator
			implements CategoryItemLabelGenerator {
		private Integer category;

		private NumberFormat formatter = NumberFormat.getPercentInstance();

		public LabelGenerator(int i) {
			this(new Integer(i));
		}

		public LabelGenerator(Integer integer) {
			super("", NumberFormat.getInstance());
			category = integer;
		}

		public String generateLabel(CategoryDataset categorydataset, int i,
				int i_0_) {
			String string = null;
			double d = 0.0;
			if (category != null) {
				Number number = categorydataset
						.getValue(i, category.intValue());
				d = number.doubleValue();
			} else
				d = calculateSeriesTotal(categorydataset, i);
			Number number = categorydataset.getValue(i, i_0_);
			if (number != null) {
				double d_1_ = number.doubleValue();
				string = (number.toString() + " (" + formatter.format(d_1_ / d) + ")");
			}
			return string;
		}

		private double calculateSeriesTotal(CategoryDataset categorydataset,
				int i) {
			double d = 0.0;
			for (int i_2_ = 0; i_2_ < categorydataset.getColumnCount(); i_2_++) {
				Number number = categorydataset.getValue(i, i_2_);
				if (number != null)
					d += number.doubleValue();
			}
			return d;
		}
	}

	public ItemLabelDemo2(String string) {
		super(string);
		CategoryDataset categorydataset = createDataset();
		JFreeChart jfreechart = createChart(categorydataset);
		ChartPanel chartpanel = new ChartPanel(jfreechart);
		chartpanel.setPreferredSize(new Dimension(500, 270));
		setContentPane(chartpanel);
	}

	private static CategoryDataset createDataset() {
		DefaultCategoryDataset defaultcategorydataset = new DefaultCategoryDataset();
		defaultcategorydataset.addValue(100.0, "S1", "C1");
		defaultcategorydataset.addValue(44.3, "S1", "C2");
		defaultcategorydataset.addValue(93.0, "S1", "C3");
		defaultcategorydataset.addValue(80.0, "S2", "C1");
		defaultcategorydataset.addValue(75.1, "S2", "C2");
		defaultcategorydataset.addValue(15.1, "S2", "C3");
		return defaultcategorydataset;
	}

	private static JFreeChart createChart(CategoryDataset categorydataset) {
		JFreeChart jfreechart = ChartFactory.createBarChart(
				"Item Label Demo 2", "Category", "Value", categorydataset,
				PlotOrientation.HORIZONTAL, true, true, false);
		jfreechart.setBackgroundPaint(Color.white);
		CategoryPlot categoryplot = (CategoryPlot) jfreechart.getPlot();
		categoryplot.setBackgroundPaint(Color.lightGray);
		categoryplot.setDomainGridlinePaint(Color.white);
		categoryplot.setRangeGridlinePaint(Color.white);
		categoryplot.setRangeAxisLocation(AxisLocation.BOTTOM_OR_LEFT);
		NumberAxis numberaxis = (NumberAxis) categoryplot.getRangeAxis();
		numberaxis.setUpperMargin(0.25);
		CategoryItemRenderer categoryitemrenderer = categoryplot.getRenderer();
		categoryitemrenderer.setBaseItemLabelsVisible(true);
		categoryitemrenderer.setBaseItemLabelGenerator(new LabelGenerator(
				(Integer) null));
		return jfreechart;
	}

	public static JPanel createDemoPanel() {
		JFreeChart jfreechart = createChart(createDataset());
		return new ChartPanel(jfreechart);
	}

	public static void main(String[] strings) {
		ItemLabelDemo2 itemlabeldemo2 = new ItemLabelDemo2("Item Label Demo 2");
		itemlabeldemo2.pack();
		RefineryUtilities.centerFrameOnScreen(itemlabeldemo2);
		itemlabeldemo2.setVisible(true);
	}
}
十三．多轴和数据源图表（Multi Axis and Dataset）
简介
J    FreeChart在CategoryPlot和XYPlot类中支持多轴和数据源显示。我们利用这个特征可以在一个图表上显示两个或多个数据源数据，但对于数据包含的数据有巨大差距时留有一定的余地。如图13.1所示。

图13.1 具有多轴的图表
典型的，使用JFreeChart构建图表时，图表有一个单数据源、单renderer、单X/Y轴的图区最为常见。然而，在一个图区上添加多个数据源、多个renderer和多个轴也是可能的。在本章的实例中，展示了如何在一个图区上显示其他额外的数据源、renderer和轴。
实例
简介
MultipleAxisDemo1.java例子提供了一个很好的实例演示如何在一个图表上创建多轴的应用。本章在每一步的代码中提供了很多建议，详见后面的章节。
创建一个图表
创建一个具有多轴、多数据源、多renderer的图表，我们首先要创建一个常规的图表（例如使用ChartFactory类创建）。在本实例中，创建了一个时序图，代码如下：


添加额外的轴
如果在图区上添加额外的轴，我们使用setRangeAxis()方法来添加：

方法setRangeAxis()是用来添加图区的轴，注意轴的索引1已经被使用——我们添加其他轴时，通过增加该索引来添加新轴。方法setRangeAxisLocation()允许我们指定轴出现的位置（使用AxisLocation类）。我们添加的轴可以跟主坐标轴同一边，或者在对立边。例如：如果指定的是AxisLocation.BOTTOM_OR_LEFT，这意味着如果图区的方向是垂直的话，将在右边添加了一个Y轴，如果图区的方向是水平的话，将在底部添加一个Y轴。
在这里，图表上每一添加多余的数据源，因此如果我们显示该图表，我们将看到图上显示多轴，但轴上无数据显示。
添加一个额外的数据源
在图区上添加一个额外的数据源，使用setDataset()方法：

缺省的，数据源将使用主轴来显示数据。如果使数据源在另外的轴上显示数据，需使用方法mapDatasetToDomainAxis()和mapDatasetToRangeAxis()。这两个方法接受两个参数，第一个参数是数据源的索引，第二个是轴的索引。
添加一个额外的renderer
当我们添加一个数据源时，通常为该数据源添加一个附加的renderer也是非常有意义的。使用方法setRenderer()：

方法的第一个参数为上节中添加的数据源的索引。注意：如果我们不想为数据源指定一个附加的rendere，系统将默认使用主renderer，这样系列的颜色就会在主数据源和附加数据源之间共享。
建议和技巧
当我们使用多轴图表时，我们需要为系列对应的轴提供一些可视化的建议。比如在例子MultipleAxisDemo1.java中轴标签的颜色与系列颜色是相匹配的。
可以从下面的实例中学习更多的技巧：
DualAxisDemo1.java
DualAxisDemo2.java
DualAxisDemo3.java
DualAxisDemo4.java
MultipleAxisDemo1.java
MultipleAxisDemo2.java
MultipleAxisDemo3.java
十四．组合图表（Combined Charts）
简介
JFreeChart支持几个图区类（可以管理着多个子类）组合而成的图表。图区类可以管理几个子类：
CombinedDomainCategoryPlot / CombinedRangeCategoryPlot
CombinedDomainXYPlot / CombinedRangeXYPlot;
    本章使用几个实例说明了JFreeChart创建组合图表时的便利性。
组合X种类图区
概述
组合主域种类图区就是在一个图区上显示两个或者多个子图区（CategoryPlot实例），共享一个X轴的图区。每个子图区维护自己的Y轴。实例如图14.1所示。

如图14.1 组合X种类图区(共享X轴)
显示图表可以是水平的，也可以是垂直方向的——实例演示的是垂直的图表。
构建图表
提供了一个很好的例子，演示如何创建该图表的类型。关键的步骤是创建CombinedDomainCategoryPlot实例，然后添加两个子图区：

注意，我们subplot1添加码值时是2（方法add()的第二个参数），而subplot1添加的是1呢？因为这控制着分配给各个图区的空间大小。
子图区的CategoryPlot实例对象将它们的X轴设置为null。例如在演示的实例中，代码如下：

组合Y种类图区
概述
一个组合Y种类图区就是一个图区显示两个或两个以上的子图区（CategoryPlot实例），共享Y轴。如果14.2.

图14.2 组合Y种类图区
该图表可以水平显示也可以垂直显示（本例是垂直显示）。
构建图表
实例演示了如何创建该类型图表。关键的步骤是创建一个实例，然后添加两个子图区：

注意添加的子图区subplot1什么码值是3而子图区subplot2码值是2呢。这是因为该值控制这两个子图区分配的空间大小。
子图区是CategoryPlot实例，将Y轴设置为null。例如，在本实例演示的代码如下：

组合X-XY图区
概述
组合X-XY图区就是一个图区显示两个或者多个子图区（XYPlot实例），共享一个X轴。每一个子图区维护自己的Y轴。如下图14.3所示.

图14.3 组合X-XY图区（参见：CombinedXYPlotDemo5.java）
    图区可能水平显示也可能垂直显示（本例子中垂直显示）。
构建图表
   CombinedXYPlotDemo5.java实例演示了如何创建该类型的图表。关键的步骤是创建一个实例CombinedDomainXYPlot，并在该实例上添加两个子图区：

注意两个图区的码值为什么都是1呢？因为该数值控制着每个图区分配的空间大小。
子图区是XYPlot实例，将自己的X轴设置为null。例如，下面的代码演示了这个特征：

组合Y-XY图区
概述
   组合Y-XY图区就是一个图区显示两个或者多个子图区（XYPlot实例），共享一个Y轴。每一个子图区维护自己的X轴。如下图14.4所示.

图14.4 组合Y-XY图区（参见：CombinedXYPlotDemo5.java）
    图区可能水平显示也可能垂直显示（本例子中垂直显示）。
构建图表
   CombinedXYPlotDemo2java实例演示了如何创建该类型的图表。关键的步骤是创建一个实例CombinedRangeXYPlot，并在该实例上添加两个子图区：

注意两个图区的码值为什么都是1呢？因为该数值控制着每个图区分配的空间大小。
子图区是XYPlot实例，将自己的X轴设置为null。例如，下面的代码演示了这个特征：

十五．数据源和JDBC(Dataset And JDBC)
简介
本章节，主要讲述使用JDBC从数据库表中获得数据的几种数据源方法：
JDBCPieDataset
JDBCCategoryDataset
JDBCXYDataset
关于JDBC
JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。
样本数据
我们再看一下实际运行中的JDBC数据源。我们需要在一个测试数据库中创建一些样本数据。
下面列出了创建饼图、直方条形图和时序图的样本数据。
创建饼图可以使用下面数据（在表中称谓饼数据）：
CATEGORY	VALUE
London	54.3
New York	43.4
Paris	17.9
同样，直方条形图使用下面数据创建（在表中称谓种类数据）：
CATEGORY	SERIES1	SERIES2	SERIES3
London	54.3	32.1	53.4
New York	43.4	54.3	75.2
Paris	17.9	34.8	37.1
最后，时序图表的使用的数据如下（在表中称谓xy数据）：
X	SERIES1	SERIES2	SERIES3
1-Aug-2002	54.3	32.1	53.4
2-Aug-2002	43.4	54.3	75.2
3-Aug-2002	39.6	55.9	37.1
4-Aug-2002	35.4	55.2	27.5
5-Aug-2002	33.9	49.8	22.3
6-Aug-2002	35.2	48.4	17.7
7-Aug-2002	38.9	49.7	15.3
8-Aug-2002	36.3	44.4	12.1
9-Aug-2002	31.0	46.3	11.0
我们可以创建一个测试数据库，包含上面的表。这里我们创建一个jfreechartdb数据库。
在下一章节里，我们使用PostgreSQL创建数据。如果使用的是不同的数据库系统，我们需要对这个过程做一些修改。
PostgreSQL
关于PostgreSQL
PostgreSQL是一个非常强大的面向关系的数据库服务系统，是一个开源的分布式系统。我们可以从下面链接获得更多的信息：
http://www.postgresql.org 
    注意尽管PostgreSQL是开源的，但它具有其他大型商业关系数据库系统的大部分特征。这里鼓励你安装，并使用它。
创建一个新的数据库
首先，登录数据库管理系统，创建一个名为jfreechartdb的数据库。

其次，创建一个jfreechart用户：

JDBC可以使用这个用户名和密码进行数据库的连接。
创建饼图数据
创建饼图数据库表：

加入样本数据：


创建种类图表数据
创建种类图数据库表：

加入样本数据：

创建XY图表数据
创建种类图数据库表：

加入样本数据：

设置权限
最后一步是给样本数据授一读的权限给新用户jfreechart：

JDBC驱动
为了使用JDBC访问样本数据，我们需要获得数据库的JDBC驱动。对于PostgreSQL，可以从下面的连接下载：
 http://jdbc.postgresql.org 
为了使用这个驱动，确保这个驱动jar文件加到classpath中。
应用演示
JDBC饼图演示
JDBC饼图演示实例将使用饼图数据表的数据产生饼图。该数据是由我们配置的数据库中获得的。
读数据的代码在方法readData()中：

在代码中需要注意的事项：
url是连接数据库的链接字符串。
返回的查询数据使用了JDBCPieDataset类对象进行了封装。详细内容见文档。

JDBC种类图演示
JDBC种类图应用使用种类数据产生了一个条形直方图。代码类似于JDBC饼图代码。但我们需要使用JDBCCategoryDataset类类封装格式化数据。
JDBC XY图演示
JDBC XY图应用使用XY数据产生了一个时序图。代码类似于JDBC饼图代码。但我们需要使用JDBCXYDataset类类封装格式化数据。

十六．导出图表为PDF格式
简介
在本章节中，我们讲述如何将一个JFreeChart生成图表转换成PDF格式文件。主要使用的工具是IText。随着讲述，在后面的章节中用一个简单的实例说明创建PDF文件的过程，该PDF文件包含了一个简单的图表。生成的文件，可以使用Acrobat阅读器来阅读，也可以使用支持PDF文件阅读的阅读器来阅读。
什么是Acrobat PDF
Acrobat PDF是一款非常流行的电子文档阅读器。可实现不同的硬件平台和软件应用程序之间的信息共享,不受软件版本的不同和安装的字体的影响。PDF可以使用Adobe 提供的一个免费工具Acrodbat Reader来创建。Acrodbat Reader在终端用户各种平台上是有效的，包括GNU/Linux,Windows,Unix,Machintosh等。
如果你的系统上没有安装Acrodbat Reader，可以到下面链接去下载：
http://www.adobe.com/products/acrobat/readstep.html 
IText
iText 是一个能够快速产生PDF文件的java类库。iText的主页下载地址是：
http://www.lowagie.com/iText 
截止写本文的时间，最新的版本是2.0.6
Graphics2D
JFreeChart使用iText工具是非常容易的事情，因为iText提供了Graphics2D的实现。在我们说明实例应用之前，我们先回顾一下Graphics2D的类。
Java.awt. Graphics2D类，标准java2D API的一部分。定义了在二维空间中大量画文本和图形的方法。Graphics2D部分子类处理全部的转化细节，从输出（文本和图形）到具体设置的映射转化。
JFreeChart画图表时，仅仅使用Graphics2D定义的方法。这就意味着JFreeChart可以将图表输出到Graphics2D子类支持的任何设备。


图16.2 JFreeChart画图的方法
    iText工具融入了PdfGraphics2D的一个类，这就意味着iText使用Graphics2D类定义的方法产生PDF内容。并且正如你在后面的章节中看到的，在PDF格式中产生图表会变的非常的容易。
开始导出
为了完成和演示应用实例，我们需要下面的jar文件：
文件	描述
jfreechart-1.0.6.jar	JFreeChart类库
jcommon-1.0.9.jar	Jcommon类库
itext-2.0.6.jar	Itext类库
首先JFreeChart包括两个jar文件，其次iText需要一个jar文件。
实例应用
首先，需要创建一个图表，我们创建一个时序图，代码如下：

这里没有任何的特殊代码——事实上，我们可以使用创建JFreeChart的其他对象替代上面的代码。
下一步，我们将在一个PDF文件中保存一个图表的副本：

下面有一些需要注意的问题：
首先，PDF文件名称是硬编码完成的，不能修改。主要是在演示中，减少代码量。在实际应用中，我们需要提供一些让用户指定文件名称与路径的方式，比如弹出一个文件选择对话框。
其次，saveChartAsPDF()方法还未实现。为了创建这个方法，我们先创建另一个更通用的writeChartAsPDF().方法。该方法执行saveChartAsPDF()方法需要的全部工作。但该方法的输入参数是一个文件输出流而不是一个文件，代码如下：

在上面代码的方法里面，我们看到一些创建和代码iText文档的代码，从文档中获得了一个Graphics2D实例，使用Graphics2D对象画出这个图表，并关闭了这个文档。
同时我们也注意到方法的一个参数是FontMapper对象。iText使用FontMapper接口将java字体对象映射成基本的字体对象。DefaultFontMapper类预先默认映射为java本地化字体。如果你希望用这些字体，使用DefaultFontMapper构建缺省的对象即可，如果你相使用其他的字体（例如，支持一个特殊的字符集），那么我们需要做一些额外的工作。本章后面将有介绍。
在writeChartAsPDF()方法的实现里面，我们创建了一个自定义页面尺寸大小（匹配字符的需要尺寸）的PDF文档。我们提前设置了改变了字符的尺寸、位置并且在PDF文档中画出多个字符，以适应不同的页面尺寸。
现在我们将使用saveChartAsPDF()方法很容易的实现了将一个PDF数据发送到一个数据流上。建化了创建文件输出流的过程，并且将该对象传给了writeChartAsPDF()方法。代码如下：

上面的每一步代码都是必须的。上面的代码组合成全部的代码如下（整个工程的代码都在这里，以便我们可以看到所有的声明和内容）：
package demo;

import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.time.Month;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.data.xy.XYDataset;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Rectangle;
import com.lowagie.text.pdf.DefaultFontMapper;
import com.lowagie.text.pdf.FontMapper;
import com.lowagie.text.pdf.PdfContentByte;
import com.lowagie.text.pdf.PdfTemplate;
import com.lowagie.text.pdf.PdfWriter;

/**
 * A simple demonstration showing how to write a chart to PDF format using
 * JFreeChart and iText.
 * <P>
 * You can download iText from http://www.lowagie.com/iText.
 */
public class PDFExportDemo1 {
	/**
	 * Saves a chart to a PDF file.
	 * 
	 * @param file
	 *            the file.
	 * @param chart
	 *            the chart.
	 * @param width
	 *            the chart width.
	 * @param height
	 *            the chart height.
	 */
	public static void saveChartAsPDF(File file, JFreeChart chart, int width,
			int height, FontMapper mapper) throws IOException {
		OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
		writeChartAsPDF(out, chart, width, height, mapper);
		out.close();
	}

	/**
	 * Writes a chart to an output stream in PDF format.
	 * 
	 * @param out
	 *            the output stream.
	 * @param chart
	 *            the chart.
	 * @param width
	 *            the chart width.
	 * @param height
	 *            the chart height.
	 * 
	 */
	public static void writeChartAsPDF(OutputStream out, JFreeChart chart,
			int width, int height, FontMapper mapper) throws IOException {
		Rectangle pagesize = new Rectangle(width, height);
		Document document = new Document(pagesize, 50, 50, 50, 50);
		try {
			PdfWriter writer = PdfWriter.getInstance(document, out);
			document.addAuthor("JFreeChart");
			document.addSubject("Demonstration");
			document.open();
			PdfContentByte cb = writer.getDirectContent();
			PdfTemplate tp = cb.createTemplate(width, height);
			Graphics2D g2 = tp.createGraphics(width, height, mapper);
			Rectangle2D r2D = new Rectangle2D.Double(0, 0, width, height);
			chart.draw(g2, r2D);
			g2.dispose();
			cb.addTemplate(tp, 0, 0);
		} catch (DocumentException de) {
			System.err.println(de.getMessage());
		}
		document.close();
	}

	/**
	 * Creates a dataset, consisting of two series of monthly data. * *
	 * 
	 * @return the dataset.
	 */
	public static XYDataset createDataset() {
		TimeSeries s1 = new TimeSeries("L&G European Index Trust", Month.class);
		s1.add(new Month(2, 2001), 181.8);
		s1.add(new Month(3, 2001), 167.3);
		s1.add(new Month(4, 2001), 153.8);
		s1.add(new Month(5, 2001), 167.6);
		s1.add(new Month(6, 2001), 158.8);
		s1.add(new Month(7, 2001), 148.3);
		s1.add(new Month(8, 2001), 153.9);
		s1.add(new Month(9, 2001), 142.7);
		s1.add(new Month(10, 2001), 123.2);
		s1.add(new Month(11, 2001), 131.8);
		s1.add(new Month(12, 2001), 139.6);
		s1.add(new Month(1, 2002), 142.9);
		s1.add(new Month(2, 2002), 138.7);
		s1.add(new Month(3, 2002), 137.3);
		s1.add(new Month(4, 2002), 143.9);
		s1.add(new Month(5, 2002), 139.8);
		s1.add(new Month(6, 2002), 137.0);
		s1.add(new Month(7, 2002), 132.8);
		TimeSeries s2 = new TimeSeries("L&G UK Index Trust", Month.class);
		s2.add(new Month(2, 2001), 129.6);
		s2.add(new Month(3, 2001), 123.2);
		s2.add(new Month(4, 2001), 117.2);
		s2.add(new Month(5, 2001), 124.1);
		s2.add(new Month(6, 2001), 122.6);
		s2.add(new Month(7, 2001), 119.2);
		s2.add(new Month(8, 2001), 116.5);
		s2.add(new Month(9, 2001), 112.7);
		s2.add(new Month(10, 2001), 101.5);
		s2.add(new Month(11, 2001), 106.1);
		s2.add(new Month(12, 2001), 110.3);
		s2.add(new Month(1, 2002), 111.7);
		s2.add(new Month(2, 2002), 111.0);
		s2.add(new Month(3, 2002), 109.6);
		s2.add(new Month(4, 2002), 113.2);
		s2.add(new Month(5, 2002), 111.6);
		s2.add(new Month(6, 2002), 108.8);
		s2.add(new Month(7, 2002), 101.6);
		TimeSeriesCollection dataset = new TimeSeriesCollection();
		dataset.addSeries(s1);
		dataset.addSeries(s2);
		return dataset;
	}

	public static void main(String[] args) {
		try {
			// create a chart...
			XYDataset dataset = createDataset();
			JFreeChart chart = ChartFactory.createTimeSeriesChart(
					"Legal & General Unit Trust Prices", "Date",
					"Price Per Unit", dataset, true, true, false);
			
			// some additional chart customisation here...
			XYPlot plot = chart.getXYPlot();
			XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) plot
					.getRenderer();
			renderer.setShapesVisible(true);
			DateAxis axis = (DateAxis) plot.getDomainAxis();
			axis.setDateFormatOverride(new SimpleDateFormat("MMM-yyyy"));
			// write the chart to a PDF file...
			File fileName = new File(System.getProperty("user.home")
					+ "/jfreechart1.pdf");
			System.out.println(fileName.getPath());
			saveChartAsPDF(fileName, chart, 400, 300, new DefaultFontMapper());
		} catch (IOException e) {
			System.out.println(e.getMessage());
		}
	}
}
在你完成和运行上面的应用之前，记得修改PDF文件的名称以满足我们的要求。同时前面16.5节提到的jar也必须在我们的classpath中。.
查看PDF 文件
在我们完成上面实例，运行实例，会产生一个PDF文档。我们可以使用一个PDF浏览器（比如AcrobatReader（或者其他支持的阅读器，Gnome PDF Viewer））查看该文件，显示的界面如下图16.3

图16.3 JFreeChart使用iText生成的PDF文件图
    大部分的PDF阅读器都提供了缩放技术，以允许我们更进一步浏览我们的图表。
Unicode字符问题
声明：由于本人对自字符集了解不深，因此翻译效果比较差，忘各大网友给予大力支持。
在我们关心我们所使用的字体字符集时，在JFreeChart和iText中使用Unicode字符集是没有任何问题的。在上面的例子中我们需要做一些修改来演示如何做到这些。
背景
Java使用同一的字符集译码成文本字符串。这种译码对每个字符使用16进制。这就意味着将有65，536个有效的不同字符集（在Unicode标准中定义了大约38，000个字符）。
我们可以在JFreeChart和iText中使用这些字符,但归于一条：那就是只要我们使用的字体，包括我们用来显示的文本或者不显示的，都必须定义这些字符。许多字体并不完全显示成Unicode字符集。下面的网站含有那些的确支持Unicode的字体的有用信息：
http://www.slovo.info/unifonts.htm 
  我们可以成功的提取使用tahoma.ttf字体。实际上，下面实例中我们将使用该字体，Tahoma字体并不是支持Unicode定义的每一个字符。因此，如果我们想使用一种特殊的字体时，就得必须选Unicode中一种相近的字体来代替。我们系统上都安装了字体Unicode MS (arialuni.ttf)——该字体完全支持Unicode字符集，尽管这种字体的定义的文件特别大（大约24M）
字体、iText和Java
iText依照PDF规格来处理字体，这就对使用PDF文件嵌入的字体来处理文件带来了非常大的方便性，同时也需要自由读取定义文件的字体。
而java在字体类中汲取了部分字体格式的大部分细节内容。
在iText中，为支持Graphics2D的实现画图功能，实现从Java字体对象到BaseFont对象的映射字体对象是非常有必要的。这就是FontMapper接口所扮演的角色。
如果我们使用缺省的构建器构建了一个新的DefaultFontMapper实例，那么总会带有Java规格定义的本地字体映射。但是如果我们想使用其他一些字体——并且我们必须使用Unicode之外的字符——那么我们需要将其他的字符映射加入到DefaultFontMapper对象中。
映射第三方的字体
这里我们决定使用Tahoma字体来显示标题。该字体的定义文件(tahoma.ttf)在我们系统下面的目录下可以找到。
/opt/sun-jdk-1.4.2.08/jre/lib/fonts
现在我们使用代码说明，使用iText创建FontMapper对象来使用Tahoma字体：

现在我们可以修改创建图表的代码，将图表的标题使用该字体：

副标题的输出如下图16.2所示。实例已经嵌入到PDF文件中。因此本文演示的该小程序很好的展示了这种类型的输出，给出了详细的步骤指南，便于我们正确使用。

如图16.2 一个Unicode副标题的图表

十七．导出图表为SVG格式
简介
    在本章里，我们介绍了一个简单实例，实例演示使用JFreeChart和Batik工具（SVG开源的类库）如何将图表导出为SVG格式。
背景
什么是SVG?
SVG(可放缩的矢量图形) 是W3C(World Wide Web ConSor—tium国际互联网标准组织)在2000年8月制定的一种基于XML格式的新的二维矢量图形格式，也是规范中的网络矢量图形标准。
Batik
Batik是一个java开源的工具包，允许我们产生SVG内容。可以从下面的链接获得有效的Batik：
http://xml.apache.org/batik 
在写本文之前，Batik最新的版本是1.7
实例代码
JFreeChart 和Batik
JFreeChart和Batik兼容性非常好，因为：
因为JFreeChart画的所有图表的输出都是使用的Java的Graphics2D；
Batik具体实现了Graphics2D产生SVG输出的功能（SVGGraphics2D）。 
在本章节，使用一个简单的实例说明使用JFreeChart和Batik实现SVG的输出。关于该实例的详细技术详见下面链接：
http://xml.apache.org/batik/svggen.html 
开始
首先，我们需要下载Batik并依照网站的指导进行安装。
确保下章节的例子能够正常运行，需要将下面的jar包加到我们的classpath：
文件	描述
jcommon-1.0.9.jar	JFreeChart的通用类包。
jfreechart-1.0.6.jar	JFreeChart的类包
batik-awt-util.jar	Batik实时运行文件
batik-dom.jar	Batik实时运行文件
batik-svggen.jar	Batik实时运行文件
batik-util.jar	Batik实时运行文件
实例应用
在我们的开发环境中创建一个工程，并且将上节列出的jar包添加到工程路径上，并输入下面代码：
package demo;

import java.awt.geom.Rectangle2D;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.apache.batik.dom.GenericDOMImplementation;
import org.apache.batik.svggen.SVGGraphics2D;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.data.general.DefaultPieDataset;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;

/**
 * A demonstration showing the export of a chart to SVG format.
 */
public class SVGExportDemo {
	/**
	 * Starting point for the demo.
	 * 
	 * @param args
	 *            ignored.
	 */
	public static void main(String[] args) throws IOException {
		// create a dataset...
		DefaultPieDataset data = new DefaultPieDataset();
		data.setValue("Category 1", new Double(43.2));
		data.setValue("Category 2", new Double(27.9));
		data.setValue("Category 3", new Double(79.5));
		// create a chart
		JFreeChart chart = ChartFactory.createPieChart("Sample Pie Chart",
				data, true, false, false);
		// THE FOLLOWING CODE BASED ON THE EXAMPLE IN THE BATIK DOCUMENTATION...
		// Get a DOMImplementation
		DOMImplementation domImpl = GenericDOMImplementation
				.getDOMImplementation();
		// Create an instance of org.w3c.dom.Document
		Document document = domImpl.createDocument(null, "svg", null);
		// Create an instance of the SVG Generator
		SVGGraphics2D svgGenerator = new SVGGraphics2D(document);
		// set the precision to avoid a null pointer exception in Batik 1.5
		svgGenerator.getGeneratorContext().setPrecision(6);
		// Ask the chart to render into the SVG Graphics2D implementation
		chart.draw(svgGenerator, new Rectangle2D.Double(0, 0, 400, 300), null);
		// Finally, stream out SVG to a file using UTF-8 character to
		// byte encoding
		boolean useCSS = true;
		Writer out = new OutputStreamWriter(new FileOutputStream(new File(
				"test.svg")), "UTF-8");
		svgGenerator.stream(out, useCSS);
	}
}
浏览SVG图
Batik类库内包含了一个”Squiggle”的小应用，我们可以使用该工具浏览SVG文件。我们可以使用下面命令打开：
java -jar batik-squiggle.jar
下图截屏显示了上述代码创建的一个饼图的界面。使用应用浏览器工具，将图表在浏览器中进行了45度旋转。

如图17.1 SVG截图



十八．Applet
简介
局限于一些条件，在Applet中使用JFreeChart还是比较容易的。本章节对Applet进行了整体的介绍，并举例说明了工作过程。这样对我们开始使用Applet提供极大帮助。

图18.1 JFreeChart在Applet上的应用
图18.1显示了一个使用JFreeChart的Applet简单应用。该applet可以通过下面链接看效果。
http://www.object-refinery.com/jfreechart/applet.html 
    后面的章节有全部的代码。
问题
在开发applet时，考虑的主要问题（与JFreeChart无关）是：
浏览器器支持
安全约束
字节码文件大小
    在我们用提供的有效资源写applets时，确保我们对上面问题有所了解
浏览器支持
     绝大部分的web浏览器均对最新版本的JDK1.5提供支持，因此使用JFreeChart运行applets也是绝对没有任何问题的（JFreeChart可以运行在JDK1.3.1版本或以上版本）。尽管如此，很大一部分用户还是使用一个浏览器的——微软的IE浏览器——该浏览器仅仅支持JDK1.1版本，并且现在已经过期。这里有一个问题是，使用JFreeChart的applet应用在微软的IE上是不能默认运行的。这就必须下载一个Java的插件，但是这样会造成很多不必要的麻烦和困难，最终的问题就是那些开发者选择写applets开发的问题，这导致开发者放弃开发applets，而选择Java Servlets（见下一章节）。
安全
    Applets设计时，是符合java安全规范的。当一个applet运行在我们的web浏览器上时，在操作上是受到很大的约束的。例如，一个applet典型的是不能读写本地文件系统的。关于Java安全机制的描述已经超出了本章的范围，但是我们必须意识到JFreeChart的一些功能在applets上是不能运行的（例如将图表保存成PNG格式的文件），主要受java缺省的安全规则约束。如果我们想使用这些功能，那么我们需要认真学习一下java的安全机制的更多细节。
代码大小
    最后一个文件就是我们applet运行时需要的代码量问题。在我们运行一个applet之前，代码被下载到本地客户端。显然对用户来说是有带宽限制的，代码量的大小成了关键问题。JFreeChart代码的jar文件大约是1M左右，对JFreeChart支持的图表来说，不算很大，但对使用modem拨号上网的用户来说，的确不是很理想的。同时我们需要将JCommon的jar包（大约290KB）加到我们的applet上。考虑到这些问题，我们将对JFreeChart进行重新打包，仅仅将applet需要的类文件包含进来，从而优化代码结构。
实例应用
正如在简介中所提及的，使用JFreeChart的applet可以在下面链接中看到：
http://www.object-refinery.com/jfreechart/applet.html 
运行applet应用时，需要两个方面饿支持。一是代码方式创建applet，二是HTML文件用来调用applet。
HTML
     因为applet需要引入额外的jar文件，所以在HTML中使用applet是显得非常重要。HTML applet标签如下：

     注意这里有三个jar需要引入，第一个包含了applet类，另外两个jar文件是JFreeChart和JCommon类库。我们需要在HTML文件中将applet标签引入。
源代码
实例applet的源代码见下（代码中我们使用了很少的applet特殊的代码，仅仅扩展了JApplet）：
package demo;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JApplet;
import javax.swing.Timer;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.time.Millisecond;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;

/**
 * A simple applet demo.
 */
public class Applet1 extends JApplet {
	/** Time series for total memory used. */
	private TimeSeries total;

	/** Time series for free memory. */
	private TimeSeries free;

	/**
	 * Creates a new instance.
	 */
	public Applet1() {
		// create two series that automatically discard data more than
		// 30 seconds old...
		this.total = new TimeSeries("Total", Millisecond.class);
		this.total.setMaximumItemAge(30000);
		this.free = new TimeSeries("Free", Millisecond.class);
		this.free.setMaximumItemAge(30000);
		TimeSeriesCollection dataset = new TimeSeriesCollection();
		dataset.addSeries(total);
		dataset.addSeries(free);
		DateAxis domain = new DateAxis("Time");
		NumberAxis range = new NumberAxis("Memory");
		XYItemRenderer renderer = new XYLineAndShapeRenderer(true, false);
		XYPlot plot = new XYPlot(dataset, domain, range, renderer);
		plot.setBackgroundPaint(Color.lightGray);
		plot.setDomainGridlinePaint(Color.white);
		plot.setRangeGridlinePaint(Color.white);
		renderer.setSeriesPaint(0, Color.red);
		renderer.setSeriesPaint(1, Color.green);
		renderer.setSeriesStroke(0, new BasicStroke(1.5f));
		renderer.setSeriesStroke(1, new BasicStroke(1.5f));
		domain.setAutoRange(true);
		domain.setLowerMargin(0.0);
		domain.setUpperMargin(0.0);
		domain.setTickLabelsVisible(true);
		range.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
		JFreeChart chart = new JFreeChart("Memory Usage",
				JFreeChart.DEFAULT_TITLE_FONT, plot, true);
		chart.setBackgroundPaint(Color.white);
		ChartPanel chartPanel = new ChartPanel(chart);
		chartPanel.setPopupMenu(null);
		getContentPane().add(chartPanel);
		new Applet1.DataGenerator().start();
	}

	/**
	 * Adds an observation to the ’total memory’ time series.
	 * 
	 * @param y
	 *            the total memory used.
	 */
	private void addTotalObservation(double y) {
		total.add(new Millisecond(), y);
	}

	/**
	 * Adds an observation to the ’free memory’ time series.
	 * 
	 * @param y
	 *            the free memory.
	 */
	private void addFreeObservation(double y) {
		free.add(new Millisecond(), y);
	}

	/**
	 * The data generator.
	 */
	class DataGenerator extends Timer implements ActionListener {
		/**
		 * Constructor.
		 */
		DataGenerator() {
			super(100, null);
			addActionListener(this);
		}

		/**
		 * Adds a new free/total memory reading to the dataset.
		 * 
		 * @param event
		 *            the action event.
		 */
		public void actionPerformed(ActionEvent event) {
			long f = Runtime.getRuntime().freeMemory();
			long t = Runtime.getRuntime().totalMemory();
			addTotalObservation(t);
			addFreeObservation(f);
		}
	}
}
十九．Servlets
介绍
Java Servlet API是一套创建web应用非常流行成熟的技术。在servlet环境中使用JFreeChart是非常合适的。在本章节中，协助开发者在web应用中使用JFreeChart。本章所有的实例可以从下面链接中下载：
http://www.object-refinery.com/jfreechart/premium/index.html 
下载的文件名为：jfreechart-1.0.6-demo.zip（该信息是收费的）.
编写一个简单的Servlet应用
ServletDemo1类实现了一个非常简单的servlet，该servlet返回了一个PNG图，PNG图是使用JFreeChart生成的直方条形图表。当运行该程序时，servlet在客户端仅仅显示一幅图片，而没有任何的HTML修饰，参见下图19.1。

如图19.1 浏览器中的servlet效果
我们以这种方式显示图片，是没有特殊意义，仅仅是为了：
很好演示servlets的请求－响应交互特征；
作为测试实例非常有用，我们会了解如何配置一个服务环境，如何让页面控件工作。
我们可以浏览后面更复杂的实例，显示使用HMTL表单如何请求不同的图表，并且将产生的图表的输出植入到HTML中。下面是基本servlet的代码。
package demo;

import java.io.IOException;
import java.io.OutputStream;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.category.DefaultCategoryDataset;

/**
 * A basic servlet that returns a PNG image file generated by JFreeChart. This
 * class is described in the JFreeChart Developer Guide in the "Servlets"
 * chapter.
 */
public class ServletDemo1 extends HttpServlet {
	/**
	 * Creates a new demo.
	 */
	public ServletDemo1() {
		// nothing required
	}

	/**
	 * Processes a GET request.
	 * 
	 * @param request
	 *            the request.
	 * @param response
	 *            the response.
	 * 
	 * @throws ServletException
	 *             if there is a servlet related problem.
	 * @throws IOException
	 *             if there is an I/O problem.
	 */
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		OutputStream out = response.getOutputStream();
		try {
			DefaultCategoryDataset dataset = new DefaultCategoryDataset();
			dataset.addValue(10.0, "S1", "C1");
			dataset.addValue(4.0, "S1", "C2");
			dataset.addValue(15.0, "S1", "C3");
			dataset.addValue(14.0, "S1", "C4");
			dataset.addValue(-5.0, "S2", "C1");
			dataset.addValue(-7.0, "S2", "C2");
			dataset.addValue(14.0, "S2", "C3");
			dataset.addValue(-3.0, "S2", "C4");
			dataset.addValue(6.0, "S3", "C1");
			dataset.addValue(17.0, "S3", "C2");
			dataset.addValue(-12.0, "S3", "C3");
			dataset.addValue(7.0, "S3", "C4");
			dataset.addValue(7.0, "S4", "C1");
			dataset.addValue(15.0, "S4", "C2");
			dataset.addValue(11.0, "S4", "C3");
			dataset.addValue(0.0, "S4", "C4");
			dataset.addValue(-8.0, "S5", "C1");
			dataset.addValue(-6.0, "S5", "C2");
			dataset.addValue(10.0, "S5", "C3");
			dataset.addValue(-9.0, "S5", "C4");
			dataset.addValue(9.0, "S6", "C1");
			dataset.addValue(8.0, "S6", "C2");
			dataset.addValue(null, "S6", "C3");
			dataset.addValue(6.0, "S6", "C4");
			dataset.addValue(-10.0, "S7", "C1");
			dataset.addValue(9.0, "S7", "C2");
			dataset.addValue(7.0, "S7", "C3");
			dataset.addValue(7.0, "S7", "C4");
			dataset.addValue(11.0, "S8", "C1");
			dataset.addValue(13.0, "S8", "C2");
			dataset.addValue(9.0, "S8", "C3");
			dataset.addValue(9.0, "S8", "C4");
			dataset.addValue(-3.0, "S9", "C1");
			dataset.addValue(7.0, "S9", "C2");
			dataset.addValue(11.0, "S9", "C3");
			dataset.addValue(-10.0, "S9", "C4");
			JFreeChart chart = ChartFactory.createBarChart("Bar Chart",
					"Category", "Value", dataset, PlotOrientation.VERTICAL,
					true, true, false);
			response.setContentType("image/png");
			ChartUtilities.writeChartAsPNG(out, chart, 400, 300);
		} catch (Exception e) {
			System.err.println(e.toString());
		} finally {
			out.close();
		}
	}
}
当一个客户端（通常是一个web浏览器）发出一个请求时，Servlet引擎调用DoGet()方法，以响应这个请求，servlet执行下面几步：
为客户端返回的输出获得一个输出流引用
创建一个图表；
响应的内容类型设置为image/png，这告诉客户端接受的数据类型是什么；
一个图表的PNG图表beii写进输出流；
输出流关闭。
编译实例Servlet
注意在javax.servlet.*包（包括子包）内的类，也就是实例使用的servlet，并不是J2SE的一部分。为了使用J2SE编译上面的代码需要另一个jar文件servlet.jar。我们使用了tomcat（是用java编写的一个开源servlet引擎）版本下面的这个servlet.jar文件。Tomcat可以在下面链接中获得：
http://tomcat.apache.org/ 
同时我们需要JFreeChat和JCommon两个类包文件来编译上面的代码。改变我们当前的工作目录，输入下面的命令（如果在Windows上，你需要将冒号“：“更改为分号“；“）

   这样就生成了一个ServletDemo1.class文件，下一章内容描述了如何使用Tomcat部署这个servlet。
部署实例Servlet
Servlets部署在我们服务引擎的webapps的目录下面，在我们的例子中，使用的是Tomcat 5.5.20，将代码部署在：

在webapp目录下，创建一个目录jfreechart1来存放servlet演示实例，然后创建下面的结构目录。

    我们需要创建web.xml文件——提供servlet的信息。

一旦上面的文件部署在servlet服务引擎上，然后启动我们的servlet服务引擎，在web浏览器中输入下面的地址：
http://localhost:8080/jfreechart1/servlet/ServletDemo1 
如果不出现意外，我们就会在浏览器中看到如图19.1所示的界面。
在HMTL页面种嵌入图表
在HTML页面中嵌入servlet产生的图表图像也是可以的，下面实例ServletDemo2演示了这一特征。ServletDemo2实例处理一个HTML页面的请求，该HTML引用了另一个servlet（ServletDemo2ChartGenerator），引用的这个servlet返回了一个图表产生的PNG图像。最终的结果就是将图表嵌入到了一个HTML中，如图19.2所示：

如图19.2 浏览器中的ServletDemo2
全部代码如下：
package demo;

import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * A basic servlet that generates an HTML page that displays a chart generated
 * by JFreeChart.
 * <P>
 * This servlet uses another servlet (ServletDemo2ChartGenerator) to create a
 * PNG image for the embedded chart.
 * <P>
 * This class is described in the JFreeChart Developer Guide.
 */
public class ServletDemo2 extends HttpServlet {
	/**
	 * 
	 */
	private static final long serialVersionUID = 9024040467697909853L;

	/**
	 * Creates a new servlet demo.
	 */
	public ServletDemo2() {
		// nothing required
	}

	/**
	 * Processes a POST request.
	 * <P>
	 * The chart.html page contains a form for generating the first request,
	 * after that the HTML returned by this servlet contains the same form for
	 * generating subsequent requests.
	 * 
	 * @param request
	 *            the request.
	 * @param response
	 *            the response.
	 * 
	 * @throws ServletException
	 *             if there is a servlet related problem.
	 * @throws IOException
	 *             if there is an I/O problem.
	 */
	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		PrintWriter out = new PrintWriter(response.getWriter());
		try {
			String param = request.getParameter("chart");
			response.setContentType("text/html");
			out.println("<HTML>");
			out.println("<HEAD>");
			out.println("<TITLE>JFreeChart Servlet Demo 2</TITLE>");
			out.println("</HEAD>");
			out.println("<BODY>");
			out.println("<H2>JFreeChart Servlet Demo</H2>");
			out.println("<P>");
			out.println("Please choose a chart type:");
			out.println("<FORM ACTION=\"ServletDemo2\" METHOD=POST>");
			String pieChecked = (param.equals("pie") ? " CHECKED" : "");
			String barChecked = (param.equals("bar") ? " CHECKED" : "");
			String timeChecked = (param.equals("time") ? " CHECKED" : "");
			out.println("<INPUT TYPE=\"radio\" NAME=\"chart\" VALUE=\"pie\""
					+ pieChecked + "> Pie Chart");
			out.println("<INPUT TYPE=\"radio\" NAME=\"chart\" VALUE=\"bar\""
					+ barChecked + "> Bar Chart");
			out.println("<INPUT TYPE=\"radio\" NAME=\"chart\" VALUE=\"time\""
					+ timeChecked + "> Time Series Chart");
			out.println("<P>");
			out.println("<INPUT TYPE=\"submit\" VALUE=\"Generate Chart\">");
			out.println("</FORM>");
			out.println("<P>");
			out.println("<IMG SRC=\"ServletDemo2ChartGenerator?type=" + param
					+ "\" BORDER=1 WIDTH=400 HEIGHT=300/>");
			out.println("</BODY>");
			out.println("</HTML>");
			out.flush();
			out.close();
		} catch (Exception e) {
			System.err.println(e.toString());
		} finally {
			out.close();
		}
	}
}
注意该代码是如何从响应的参数获得一个引用的，而不是上面实例中的一个输出流。愿意是因为该servlet将返回HTML文本，与前章返回的二进制数据（一个PNG图片）不同。响应的类型设置成为text/html格式，因为servlet返回的是HTML文件。重要的一点就是HTML引用另一个servlet（ServletDemo2ChartGenerator）中的<IMG>标签，ServletDemo2ChartGenerator创建了必要的图表图片。HTML使用<FORM>元素来建立图表参数控制着实际图表的返回。
下面是ServletDemo2ChartGenerator的全部代码：
package demo;

import java.io.IOException;
import java.io.OutputStream;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.data.time.Day;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.data.xy.XYDataset;
import org.jfree.date.SerialDate;

/**
 * A servlet that returns one of three charts as a PNG image file. This servlet
 * is referenced in the HTML generated by ServletDemo2.
 * <P>
 * Three different charts can be generated, controlled by the ’type’ parameter.
 * The possible values are ’pie’, ’bar’ and ’time’ (for time series).
 * <P>
 * This class is described in the JFreeChart Developer Guide.
 */
public class ServletDemo2ChartGenerator extends HttpServlet {
	/**
	 * Default constructor.
	 */
	public ServletDemo2ChartGenerator() {
		// nothing required
	}

	/**
	 * Process a GET request.
	 * 
	 * @param request
	 *            the request.
	 * @param response
	 *            the response.
	 * 
	 * @throws ServletException
	 *             if there is a servlet related problem.
	 * @throws IOException
	 *             if there is an I/O problem.
	 */
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		OutputStream out = response.getOutputStream();
		try {
			String type = request.getParameter("type");
			JFreeChart chart = null;
			if (type.equals("pie")) {
				chart = createPieChart();
			} else if (type.equals("bar")) {
				chart = createBarChart();
			} else if (type.equals("time")) {
				chart = createTimeSeriesChart();
			}
			if (chart != null) {
				response.setContentType("image/png");
				ChartUtilities.writeChartAsPNG(out, chart, 400, 300);
			}
		} catch (Exception e) {
			System.err.println(e.toString());
		} finally {
			out.close();
		}
	}

	/**
	 * Creates a sample pie chart.
	 * 
	 * @return a pie chart.
	 */
	private JFreeChart createPieChart() {
		// create a dataset...
		DefaultPieDataset data = new DefaultPieDataset();
		data.setValue("One", new Double(43.2));
		data.setValue("Two", new Double(10.0));
		data.setValue("Three", new Double(27.5));
		data.setValue("Four", new Double(17.5));
		data.setValue("Five", new Double(11.0));
		data.setValue("Six", new Double(19.4));
		JFreeChart chart = ChartFactory.createPieChart("Pie Chart", data, true,
				true, false);
		return chart;
	}

	/**
	 * Creates a sample bar chart.
	 * 
	 * @return a bar chart.
	 */
	private JFreeChart createBarChart() {
		DefaultCategoryDataset dataset = new DefaultCategoryDataset();
		dataset.addValue(10.0, "S1", "C1");
		dataset.addValue(4.0, "S1", "C2");
		dataset.addValue(15.0, "S1", "C3");
		dataset.addValue(14.0, "S1", "C4");
		dataset.addValue(-5.0, "S2", "C1");
		dataset.addValue(-7.0, "S2", "C2");
		dataset.addValue(14.0, "S2", "C3");
		dataset.addValue(-3.0, "S2", "C4");
		dataset.addValue(6.0, "S3", "C1");
		dataset.addValue(17.0, "S3", "C2");
		dataset.addValue(-12.0, "S3", "C3");
		dataset.addValue(7.0, "S3", "C4");
		dataset.addValue(7.0, "S4", "C1");
		dataset.addValue(15.0, "S4", "C2");
		dataset.addValue(11.0, "S4", "C3");
		dataset.addValue(0.0, "S4", "C4");
		dataset.addValue(-8.0, "S5", "C1");
		dataset.addValue(-6.0, "S5", "C2");
		dataset.addValue(10.0, "S5", "C3");
		dataset.addValue(-9.0, "S5", "C4");
		dataset.addValue(9.0, "S6", "C1");
		dataset.addValue(8.0, "S6", "C2");
		dataset.addValue(null, "S6", "C3");
		dataset.addValue(6.0, "S6", "C4");
		dataset.addValue(-10.0, "S7", "C1");
		dataset.addValue(9.0, "S7", "C2");
		dataset.addValue(7.0, "S7", "C3");
		dataset.addValue(7.0, "S7", "C4");
		dataset.addValue(11.0, "S8", "C1");
		dataset.addValue(13.0, "S8", "C2");
		dataset.addValue(9.0, "S8", "C3");
		dataset.addValue(9.0, "S8", "C4");
		dataset.addValue(-3.0, "S9", "C1");
		dataset.addValue(7.0, "S9", "C2");
		dataset.addValue(11.0, "S9", "C3");
		dataset.addValue(-10.0, "S9", "C4");
		JFreeChart chart = ChartFactory.createBarChart3D("Bar Chart",
				"Category", "Value", dataset, PlotOrientation.VERTICAL, true,
				true, false);
		return chart;
	}

	/**
	 * Creates a sample time series chart.
	 * 
	 * @return a time series chart.
	 */
	private JFreeChart createTimeSeriesChart() {
		// here we just populate a series with random data...
		TimeSeries series = new TimeSeries("Random Data");
		Day current = new Day(1, SerialDate.JANUARY, 2001);
		for (int i = 0; i < 100; i++) {
			series.add(current, Math.random() * 100);
			current = (Day) current.next();
		}
		XYDataset data = new TimeSeriesCollection(series);
		JFreeChart chart = ChartFactory.createTimeSeriesChart(
				"Time Series Chart", "Date", "Rate", data, true, true, false);
		return chart;
	}
}
下一章讲述servlet的支持文件 ，与如何部署它们。
支持文件
Servlet为客户端产生典型的输出。大部分web应用之少包含一个HTML文件，用来进入应用的入口。本章演示的servlet，使用index.html页面，代码如下：
<HTML>
<HEADER>
<TITLE>JFreeChart : Basic Servlet Demo</TITLE>
</HEADER>
<BODY>
<H2>JFreeChart: Basic Servlet Demo</H2>
<P>There are two sample servlets available:
<ul>
	<li>a very basic servlet to generate a <a
		href="servlet/ServletDemo1">bar chart</a>;</li>
	<li>another servlet that allow you to select one of <a
		href="chart.html">three sample charts</a>. The selected chart is
	displayed in an HTML page.</li>
</ul>
</BODY>
</HTML>
该页面上有两个链接，一个是实例1（ServletDemo1），第二个链接是两一个HTML页面，chart.html。代码如下：
<HTML>
<HEADER>
<TITLE>JFreeChart Servlet Demo 2</TITLE>
</HEADER>
<BODY>
<H2>JFreeChart Servlet Demo</H2>
<P>Please choose a chart type:
<FORM ACTION="servlet/ServletDemo2" METHOD=POST><INPUT
	TYPE="radio" NAME="chart" VALUE="pie" CHECKED> Pie Chart <INPUT
	TYPE="radio" NAME="chart" VALUE="bar"> Bar Chart <INPUT
	TYPE="radio" NAME="chart" VALUE="time"> Time Series Chart
<P><INPUT TYPE="submit" VALUE="Generate Chart">
</FORM>
</BODY>
</HTML>
第二个HTML页面包含<FORM>元素用来为第二个serlvet指定一个参数。当servlet运行时，返回自己的HTML，THML包含一个<IMG>元素，该元素引用了ServletDemo2ChartGenerator 的servlet。
部署Servlets
完成上面实例代码的编译厚，需要将它们连同支持文档部署到servlet引擎上，以便于客户端能够正确访问。幸运的是，这些都非常容易做到。
首先是配置web.xml文件，该文件用来描述web应用部署。
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE web-app
PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN"
"http://java.sun.com/j2ee/dtds/web-app_2.2.dtd">
<web-app>
	<servlet>
		<servlet-name>ServletDemo1</servlet-name>
		<servlet-class>demo.ServletDemo1</servlet-class>
	</servlet>
	<servlet>
		<servlet-name>ServletDemo2</servlet-name>
		<servlet-class>demo.ServletDemo2</servlet-class>
	</servlet>
	<servlet>
		<servlet-name>ServletDemo2ChartGenerator</servlet-name>
		<servlet-class>demo.ServletDemo2ChartGenerator</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>ServletDemo1</servlet-name>
		<url-pattern>/servlet/ServletDemo1</url-pattern>
	</servlet-mapping>
	<servlet-mapping>
		<servlet-name>ServletDemo2</servlet-name>
		<url-pattern>/servlet/ServletDemo2</url-pattern>
	</servlet-mapping>
	<servlet-mapping>
		<servlet-name>ServletDemo2ChartGenerator</servlet-name>
		<url-pattern>/servlet/ServletDemo2ChartGenerator</url-pattern>
	</servlet-mapping>
</web-app>
该文件通过名字列出了全部的sevlets，并且指定了具体类。实际的类被放置在servlet引擎的指定目录下面。
最后的步骤是将全部的文档拷贝到响应的servlet引擎的目录下面。我们使用的是servlet引擎是Tomcat。在Tomcat下的webapps目录下面创建一个jfreechart2的目录，将index.html和chart.html文件拷贝到下面的目录：

接下来，在目录jfreechart2下建立一个子目录WEB-INFO，将web.xml文件拷贝到该目录下面。

WEB-INFO目录下面创建子目录classes/demo将编译的类放在该目录下面。

最后，将相关的jar拷贝到下面目录：

现在启动我们的servlet引擎，在我们的浏览器中输入：
http://localhost:8080/jfreechart2/index.html 
如果全部文件放置在适当位置，而不出现特殊意外的话，我们将会看到上面图19.2所示的界面。
二十．JFreeChart相关技术
简介
    本章节主要介绍了JFreeChart涉及的各种信息。
X11/Headless Java
如果我们在Unix/Linux上的服务环境使用JFreeChart，我们会遇到JFreeChart在没有X11的情况下不能运行。这与运行在AWT上的java代码是同一个问题。更多的信息见下面链接：
http://java.sun.com/products/java-media/2D/forDevelopers/java2dfaq.html#xvfb 
同时在JFreeChart的论坛里面也有好多的信息，可以找到一些额外的思路：
http://www.jfree.org/phpBB2/viewtopic.php?t=1012 
JSP
如果开发者在JSP中使用JFreeChart比较感兴趣，那么可以从下面网址找到更多信息：
http://cewolf.sourceforge.net/ 
加载图片
图像在Java中是用Image来描述的。我们可以使用开发包里面的createImage()方法来创建图像，但是我们需要意识到该方法加载图像时不是同步的——换句话说，方法返回的与图像加载是在不同的线程中。这样会产生这样一个问题就是在图像为完全加载完成时，我们就使用了该图像。
我们可以使用MediaTracker类来检查图像加载的进度。但万一在某个地方我们需要在使用方法之前，必须确保图片完全加载完毕。这时该怎么办呢？使用Swing的ImageIcon类可以解决我们这个问题，代码如下：

    构造方法直到图片完全加载完成后才返回，因此在我们调用方法getImage()时，下图已经图像加载完毕。
二十一．包
概述
下面内容讲述了JFreeChart类的参考信息。
包名	说明
org.jfree.chart	主图表类
org.jfree.chart.annotations	注释图表的简单框架
org.jfree.chart.axis	轴类和相关接口
org.jfree.chart.editor	为图表提供的属性编辑器框架（不完善）
org.jfree.chart.encoders	写图象文件类
org.jfree.chart.entity	描述图表实体的类
org.jfree.chart.event	事件类
org.jfree.chart.imagemap	HTML图片映像工具类
org.jfree.chart.labels	图表标签和信息提示类
org.jfree.chart.needle	Needle classes for the compass plot
org.jfree.chart.plot	Plot类和接口
org.jfree.chart.renderer	Renderer的基本类包
org.jfree.chart.renderer.category	Plug-in renderers for use with the CategoryPlot class.
org.jfree.chart.renderer.xy	Plug-in renderers for use with the XYPlot class.
org.jfree.chart.servlet	Servlet utility classes.
org.jfree.chart.title	图表标题类
org.jfree.chart.urls	在图像映像区产生URLs的接口和类
org.jfree.chart.util	实用工具类
org.jfree.data	Dataset接口和类
org.jfree.data.category	CategoryDataset接口和相关类
org.jfree.data.contour	ContourDataset接口和相关类
org.jfree.data.function	Function2D接口和相关类
org.jfree.data.gantt	甘特图的dataset接口和类
org.jfree.data.general	通用的dataset类
org.jfree.data.io	通用的dataset的I/O类
org.jfree.data.jdbc	JDBC相关的dataset类
org.jfree.data.statistics	产生统计的相关类
org.jfree.data.time	基于时间的dataset接口和类
org.jfree.data.time.ohlc	展示高低开发图表dataset的类
org.jfree.data.xml	从xml文件读取dataset的类
org.jfree.data.xy	XYDataset接口和相关类
更多的信息可以查看javadoc产生的HTML文档。

二十二．安装JDK
1.使用FileZilla实现文件上传

2.使用命令ll查看上传的文件

3.如果权限不足时，可以使用chmod修改权限

4.解压bin文件，直接解压就可以

5.使用ll命令查看解压的结果

6.将jdk移动到/user/java/local目录下

7.查看移动后的结果

8.如果移动的是目录下的文件，就可以删除目录

9.再解压，并拷贝内容

10.直接将jdk的bin文件拷到/usr/local/java 目录下

11.发现java目录不存在

12. 删除java文件

13.创建java文件夹

14.将/root/jdk拷贝到usr/local/java下

15.最新版的jdk文件

16.解压新版的JDK文件

17.查看配置文件

18.编辑配置文件

19.直接进入图形界面操作，编辑内容

20.可以使用source命令直接刷新文件
Source /etc/profile
再查看jdk版本

21.上面这种方式，安装太慢了，实际中会使用yum命令
因为它在cdrom中也提供了，

Yum install lrzsz
22.
二十三．安装Tomcat
1.拷贝文件

2.将文件进一步拷贝到user/local/java/目录下

3.查看复制后的结果

4.解压

5.查看解压后的结果


二十四．部署应用
1.进入Tomcat目录

2.打开监控日志

3.启动tomcat

二十五．
Spring4+Quqrtz2.2.1实现定时实例
2015-04-29 15:07
本文示例工程下载 
一、工程创建 
1、新建一个工程，导入相应的包Spring3.2.9+Quqrtz2.2.1+commons-logging


集成起来比较简单,对线程无需任何理解，Spring手册上也有清楚的说明。只需写一个POJO，其余的都是配置，而且若使用CronTriggerBean，可以配置很复杂的任务调度。
编写一个普通的JAVA类
根据业务，写一个简单的JAVA类，和普通的类没有区别。并配置到Spring配置文件上中。例：
package com.mucfc;
import java.text.SimpleDateFormat;
import java.util.Date;
/**  
*事件类
*作者 林炳文（ling20081005@126.com 博客：http://blog.csdn.net/evankaka）  
*时间 2015.4.29
*/
public class MyJob  {
public void run(){
	System.out.println("Hello Spring with Quzrtz  "+
			new SimpleDateFormat("yyyy-MM-dd HH:mm:ss ").format(new Date()));
}

}


二、Spring中配置
1、创建job的bean实例
 <!-- 配置Job的bean -->
 <bean id="myJob" class="com.mucfc.MyJob" />
2.使用MethodInvokingJobDetailFactoryBean建立任务
只需要配置即可，配置信息示例如下：
  <!-- 配置jobDetail -->
 <bean id="myJobDetail"
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
  <!-- 用到的Job实例 -->
  <property name="targetObject">
   <ref bean="myJob"/>
  </property>
  <!-- Job实例中的方法 -->
  <property name="targetMethod">
   <value>run</value>
  </property>
 </bean>
说明：
targetObject	目标对象，即需要定时执行的POJO
targetMethod	目标方法，即需要定时执行的POJO方法
concurrent	默认情况下，Quartz Jobs是无状态的，可能导致jobs之间互相的影响，如果你为相同的JobDetail指定两个Trigger,很可能当第一个job完成之前，第二个job就开始了。如果Jobdetail实现了Stateful接口，就不会发生这样的事情。第二个job将不会在第一个job完成之前开始。为了使得jobs不并发运行，设置concurrent标记为false

3、使用CronTriggerBean建立规则，调度任务
 <!-- 配置触发器Trigger -->
<bean id="myTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
  <property name="name" value="work_default_name"/>
  <property name="group" value="work_default"/>
  <property name="jobDetail">
    <ref bean="myJobDetail"/>
  </property>
  <property name="cronExpression">
  <!-- 每5秒执行一次 -->
    <value>0/5 * * * * ?</value>
  </property>
</bean>

说明：
jobDetail	任务详情，即所需要调度的任务
cronExpression	调用规则，即什么时候调用。详细说明见附录1

4.使用SchedulerFactoryBean包装任务
 <!-- 配置scheduler工厂 -->
<bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
    <property name="triggers">
      <list>
      <ref bean="myTrigger"/>
      </list>
    </property>
</bean>
说明：
triggers	触发器，调用哪些任务
autoStartup	是否自动启动，该Bean被初始化后是否自动启动定时任务。
Set whether to automatically start the scheduler after initialization. 
schedulerName	给这个计划设定一个名称。
Set the name of the Scheduler to fetch from the SchedulerFactory. 
整个配置文件如下：
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
 <!-- 配置Job的bean -->
 <bean id="myJob" class="com.mucfc.MyJob" />
 
  <!-- 配置jobDetail -->
 <bean id="myJobDetail"
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
  <!-- 用到的Job实例 -->
  <property name="targetObject">
   <ref bean="myJob"/>
  </property>
  <!-- Job实例中的方法 -->
  <property name="targetMethod">
   <value>run</value>
  </property>
 </bean>

 <!-- 配置触发器Trigger -->
<bean id="myTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
  <property name="name" value="work_default_name"/>
  <property name="group" value="work_default"/>
  <property name="jobDetail">
    <ref bean="myJobDetail"/>
  </property>
  <property name="cronExpression">
  <!-- 每5秒执行一次 -->
    <value>0/5 * * * * ?</value>
  </property>
</bean>
 
 <!-- 配置scheduler工厂 -->
<bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
    <property name="triggers">
      <list>
      <ref bean="myTrigger"/>
      </list>
    </property>
</bean>
 
</beans>
三、使用
package com.mucfc;

import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
	public static void main(String[] args) {	
		ApplicationContext context=new ClassPathXmlApplicationContext("beans.xml");
	
	}

}
我们在学习Spring中知道，ApplicationContext在加载的时候它会自动生成bean的实例，也就是说这个运行后定时器就会开始执行了，结果如下：

若是不想让它一加载就启动，就可以用beanfactory来加载xml文件，然后再手动打开
package com.mucfc;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
public class MyTest {
	public static void main(String[] args) {
		
		//ApplicationContext context=new ClassPathXmlApplicationContext("beans.xml");
	   
        Resource res = new ClassPathResource("beans.xml");        
        BeanFactory bf = new XmlBeanFactory(res);   
        
		Scheduler scheduler=(Scheduler)bf.getBean("scheduler");
		try {
			scheduler.start();
		} catch (SchedulerException e) {
			e.printStackTrace();
		}
	
	}

}
核心概念
1、scheduler是一个计划调度器容器，容器里面可以盛放众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行。
 
2、JobDetail是一个可执行的工作，它本身可能是有状态的。
 
3、Trigger代表一个调度参数的配置，什么时候去调。
 
4、当JobDetail和Trigger在scheduler容器上注册后，形成了装配好的作业（JobDetail和Trigger所组成的一对儿），就可以伴随容器启动而调度执行了。
 
5、scheduler是个容器，容器中有一个线程池，用来并行调度执行每个作业，这样可以提高容器效率。

四、cron 表达式的格式

Quartz cron 表达式的格式十分类似于 UNIX cron 格式，但还是有少许明显的区别。区别之一就是 Quartz 的格式向下支持到秒级别的计划，而 UNIX cron 计划仅支持至分钟级。许多我们的触发计划要基于秒级递增的(例如，每45秒)，因此这是一个非常好的差异。

在 UNIX cron 里，要执行的作业（或者说命令）是存放在 cron 表达式中的，在第六个域位置上。Quartz 用 cron 表达式存放执行计划。引用了 cron 表达式的 CronTrigger 在计划的时间里会与 job 关联上。

另一个与 UNIX cron 表达式的不同点是在表达式中支持域的数目。UNIX 给出五个域(分、时、日、月和周)，Quartz 提供七个域。表 5.1 列出了 Quartz cron 表达式支持的七个域。
Quartz Cron 表达式支持到七个域 
名称	是否必须	允许值	特殊字符
秒	是	0-59	, - * /
分	是	0-59	, - * /
时	是	0-23	, - * /
日	是	1-31	, - * ? / L W C
月	是	1-12 或 JAN-DEC	, - * /
周	是	1-7 或 SUN-SAT	, - * ? / L C #
年	否	空 或 1970-2099	, - * /

月份和星期的名称是不区分大小写的。FRI 和 fri 是一样的。 

域之间有空格分隔，这和 UNIX cron 一样。无可争辩的，我们能写的最简单的表达式看起来就是这个了： 

* * * ? * * 

这个表达会每秒钟(每分种的、每小时的、每天的)激发一个部署的 job。 

·理解特殊字符 

同 UNIX cron 一样，Quartz cron 表达式支持用特殊字符来创建更为复杂的执行计划。然而，Quartz 在特殊字符的支持上比标准 UNIX cron 表达式更丰富了。 

* 星号 

使用星号(*) 指示着你想在这个域上包含所有合法的值。例如，在月份域上使用星号意味着每个月都会触发这个 trigger。

表达式样例： 

0 * 17 * * ? 

意义：每天从下午5点到下午5:59中的每分钟激发一次 trigger。它停在下午 5:59 是因为值 17 在小时域上，在下午 6 点时，小时变为 18 了，也就不再理会这个 trigger，直到下一天的下午5点。 

在你希望 trigger 在该域的所有有效值上被激发时使用 * 字符。 

? 问号 

? 号只能用在日和周域上，但是不能在这两个域上同时使用。你可以认为 ? 字符是 "我并不关心在该域上是什么值。" 这不同于星号，星号是指示着该域上的每一个值。? 是说不为该域指定值。 

不能同时这两个域上指定值的理由是难以解释甚至是难以理解的。基本上，假定同时指定值的话，意义就会变得含混不清了：考虑一下，如果一个表达式在日域上有值11，同时在周域上指定了 WED。那么是要 trigger 仅在每个月的11号，且正好又是星期三那天被激发？还是在每个星期三的11号被激发呢？要去除这种不明确性的办法就是不能同时在这两个域上指定值。 

只要记住，假如你为这两域的其中一个指定了值，那就必须在另一个字值上放一个 ?。 

表达式样例： 

0 10,44 14 ? 3 WEB 

意义：在三月中的每个星期三的下午 2:10 和 下午 2:44 被触发。 

, 逗号 

逗号 (,) 是用来在给某个域上指定一个值列表的。例如，使用值 0,15,30,45 在秒域上意味着每15秒触发一个 trigger。 

表达式样例： 

0 0,15,30,45 * * * ? 

意义：每刻钟触发一次 trigger。 

/ 斜杠 

斜杠 (/) 是用于时间表的递增的。我们刚刚用了逗号来表示每15分钟的递增，但是我们也能写成这样 0/15。 

表达式样例： 

0/15 0/30 * * * ? 

意义：在整点和半点时每15秒触发 trigger。 

- 中划线 

中划线 (-) 用于指定一个范围。例如，在小时域上的 3-8 意味着 "3,4,5,6,7 和 8 点。"  域的值不允许回卷，所以像 50-10 这样的值是不允许的。 

表达式样例： 

0 45 3-8 ? * * 

意义：在上午的3点至上午的8点的45分时触发 trigger。 

L 字母

L 说明了某域上允许的最后一个值。它仅被日和周域支持。当用在日域上，表示的是在月域上指定的月份的最后一天。例如，当月域上指定了 JAN 时，在日域上的 L 会促使 trigger 在1月31号被触发。假如月域上是 SEP，那么 L 会预示着在9月30号触发。换句话说，就是不管指定了哪个月，都是在相应月份的时最后一天触发 trigger。 

表达式 0 0 8 L * ? 意义是在每个月最后一天的上午 8:00 触发 trigger。在月域上的 * 说明是 "每个月"。 

当 L 字母用于周域上，指示着周的最后一天，就是星期六 (或者数字7)。所以如果你需要在每个月的最后一个星期六下午的 11:59 触发 trigger，你可以用这样的表达式 0 59 23 ? * L。 

当使用于周域上，你可以用一个数字与 L 连起来表示月份的最后一个星期 X。例如，表达式 0 0 12 ? * 2L 说的是在每个月的最后一个星期一触发 trigger。 
不要让范围和列表值与 L 连用

虽然你能用星期数(1-7)与 L 连用，但是不允许你用一个范围值和列表值与 L 连用。这会产生不可预知的结果。

W 字母 

W 字符代表着平日 (Mon-Fri)，并且仅能用于日域中。它用来指定离指定日的最近的一个平日。大部分的商业处理都是基于工作周的，所以 W 字符可能是非常重要的。例如，日域中的 15W 意味着 "离该月15号的最近一个平日。" 假如15号是星期六，那么 trigger 会在14号(星期四)触发，因为距15号最近的是星期一，这个例子中也会是17号（译者Unmi注：不会在17号触发的，如果是15W，可能会是在14号(15号是星期六)或者15号(15号是星期天)触发，也就是只能出现在邻近的一天，如果15号当天为平日直接就会当日执行）。W 只能用在指定的日域为单天，不能是范围或列表值。 

# 井号 

# 字符仅能用于周域中。它用于指定月份中的第几周的哪一天。例如，如果你指定周域的值为 6#3，它意思是某月的第三个周五 (6=星期五，#3意味着月份中的第三周)。另一个例子 2#1 意思是某月的第一个星期一 (2=星期一，#1意味着月份中的第一周)。注意，假如你指定 #5，然而月份中没有第 5 周，那么该月不会触发。
示例：
表达式意义
"0 0 12 * *?" 每天中午12点触发
"0 15 10 ? **" 每天上午10:15触发
"0 15 10 * *?" 每天上午10:15触发
"0 15 10 * * ?*" 每天上午10:15触发
"0 15 10 * * ?2005" 2005年的每天上午10:15触发
"0 * 14 * *?" 在每天下午2点到下午2:59期间的每1分钟触发
"0 0/5 14 * *?" 在每天下午2点到下午2:55期间的每5分钟触发
"0 0/5 14,18 ** ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
"0 0-5 14 * *?" 在每天下午2点到下午2:05期间的每1分钟触发
"0 10,44 14 ? 3WED" 每年三月的星期三的下午2:10和2:44触发
"0 15 10 ? *MON-FRI" 周一至周五的上午10:15触发
"0 15 10 15 *?" 每月15日上午10:15触发
"0 15 10 L *?" 每月最后一日的上午10:15触发
"0 15 10 ? *6L" 每月的最后一个星期五上午10:15触发
"0 15 10 ? * 6L2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发
"0 15 10 ? *6#3" 每月的第三个星期五上午10:15触发

Spring4+Quqrtz2.2.1实现定时实例
2015-04-29 15:07
本文示例工程下载 
一、工程创建 
1、新建一个工程，导入相应的包Spring3.2.9+Quqrtz2.2.1+commons-logging


集成起来比较简单,对线程无需任何理解，Spring手册上也有清楚的说明。只需写一个POJO，其余的都是配置，而且若使用CronTriggerBean，可以配置很复杂的任务调度。
编写一个普通的JAVA类
根据业务，写一个简单的JAVA类，和普通的类没有区别。并配置到Spring配置文件上中。例：
package com.mucfc;
import java.text.SimpleDateFormat;
import java.util.Date;
/**  
*事件类
*作者 林炳文（ling20081005@126.com 博客：http://blog.csdn.net/evankaka）  
*时间 2015.4.29
*/
public class MyJob  {
public void run(){
	System.out.println("Hello Spring with Quzrtz  "+
			new SimpleDateFormat("yyyy-MM-dd HH:mm:ss ").format(new Date()));
}

}


二、Spring中配置
1、创建job的bean实例
 <!-- 配置Job的bean -->
 <bean id="myJob" class="com.mucfc.MyJob" />
2.使用MethodInvokingJobDetailFactoryBean建立任务
只需要配置即可，配置信息示例如下：
  <!-- 配置jobDetail -->
 <bean id="myJobDetail"
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
  <!-- 用到的Job实例 -->
  <property name="targetObject">
   <ref bean="myJob"/>
  </property>
  <!-- Job实例中的方法 -->
  <property name="targetMethod">
   <value>run</value>
  </property>
 </bean>
说明：
targetObject	目标对象，即需要定时执行的POJO
targetMethod	目标方法，即需要定时执行的POJO方法
concurrent	默认情况下，Quartz Jobs是无状态的，可能导致jobs之间互相的影响，如果你为相同的JobDetail指定两个Trigger,很可能当第一个job完成之前，第二个job就开始了。如果Jobdetail实现了Stateful接口，就不会发生这样的事情。第二个job将不会在第一个job完成之前开始。为了使得jobs不并发运行，设置concurrent标记为false

3、使用CronTriggerBean建立规则，调度任务
 <!-- 配置触发器Trigger -->
<bean id="myTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
  <property name="name" value="work_default_name"/>
  <property name="group" value="work_default"/>
  <property name="jobDetail">
    <ref bean="myJobDetail"/>
  </property>
  <property name="cronExpression">
  <!-- 每5秒执行一次 -->
    <value>0/5 * * * * ?</value>
  </property>
</bean>

说明：
jobDetail	任务详情，即所需要调度的任务
cronExpression	调用规则，即什么时候调用。详细说明见附录1

4.使用SchedulerFactoryBean包装任务
 <!-- 配置scheduler工厂 -->
<bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
    <property name="triggers">
      <list>
      <ref bean="myTrigger"/>
      </list>
    </property>
</bean>
说明：
triggers	触发器，调用哪些任务
autoStartup	是否自动启动，该Bean被初始化后是否自动启动定时任务。
Set whether to automatically start the scheduler after initialization. 
schedulerName	给这个计划设定一个名称。
Set the name of the Scheduler to fetch from the SchedulerFactory. 
整个配置文件如下：
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
 <!-- 配置Job的bean -->
 <bean id="myJob" class="com.mucfc.MyJob" />
 
  <!-- 配置jobDetail -->
 <bean id="myJobDetail"
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
  <!-- 用到的Job实例 -->
  <property name="targetObject">
   <ref bean="myJob"/>
  </property>
  <!-- Job实例中的方法 -->
  <property name="targetMethod">
   <value>run</value>
  </property>
 </bean>

 <!-- 配置触发器Trigger -->
<bean id="myTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
  <property name="name" value="work_default_name"/>
  <property name="group" value="work_default"/>
  <property name="jobDetail">
    <ref bean="myJobDetail"/>
  </property>
  <property name="cronExpression">
  <!-- 每5秒执行一次 -->
    <value>0/5 * * * * ?</value>
  </property>
</bean>
 
 <!-- 配置scheduler工厂 -->
<bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
    <property name="triggers">
      <list>
      <ref bean="myTrigger"/>
      </list>
    </property>
</bean>
 
</beans>
三、使用
package com.mucfc;

import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
	public static void main(String[] args) {	
		ApplicationContext context=new ClassPathXmlApplicationContext("beans.xml");
	
	}

}
我们在学习Spring中知道，ApplicationContext在加载的时候它会自动生成bean的实例，也就是说这个运行后定时器就会开始执行了，结果如下：

若是不想让它一加载就启动，就可以用beanfactory来加载xml文件，然后再手动打开
package com.mucfc;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
public class MyTest {
	public static void main(String[] args) {
		
		//ApplicationContext context=new ClassPathXmlApplicationContext("beans.xml");
	   
        Resource res = new ClassPathResource("beans.xml");        
        BeanFactory bf = new XmlBeanFactory(res);   
        
		Scheduler scheduler=(Scheduler)bf.getBean("scheduler");
		try {
			scheduler.start();
		} catch (SchedulerException e) {
			e.printStackTrace();
		}
	
	}

}
核心概念
1、scheduler是一个计划调度器容器，容器里面可以盛放众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行。
 
2、JobDetail是一个可执行的工作，它本身可能是有状态的。
 
3、Trigger代表一个调度参数的配置，什么时候去调。
 
4、当JobDetail和Trigger在scheduler容器上注册后，形成了装配好的作业（JobDetail和Trigger所组成的一对儿），就可以伴随容器启动而调度执行了。
 
5、scheduler是个容器，容器中有一个线程池，用来并行调度执行每个作业，这样可以提高容器效率。

四、cron 表达式的格式

Quartz cron 表达式的格式十分类似于 UNIX cron 格式，但还是有少许明显的区别。区别之一就是 Quartz 的格式向下支持到秒级别的计划，而 UNIX cron 计划仅支持至分钟级。许多我们的触发计划要基于秒级递增的(例如，每45秒)，因此这是一个非常好的差异。

在 UNIX cron 里，要执行的作业（或者说命令）是存放在 cron 表达式中的，在第六个域位置上。Quartz 用 cron 表达式存放执行计划。引用了 cron 表达式的 CronTrigger 在计划的时间里会与 job 关联上。

另一个与 UNIX cron 表达式的不同点是在表达式中支持域的数目。UNIX 给出五个域(分、时、日、月和周)，Quartz 提供七个域。表 5.1 列出了 Quartz cron 表达式支持的七个域。
Quartz Cron 表达式支持到七个域 
名称	是否必须	允许值	特殊字符
秒	是	0-59	, - * /
分	是	0-59	, - * /
时	是	0-23	, - * /
日	是	1-31	, - * ? / L W C
月	是	1-12 或 JAN-DEC	, - * /
周	是	1-7 或 SUN-SAT	, - * ? / L C #
年	否	空 或 1970-2099	, - * /

月份和星期的名称是不区分大小写的。FRI 和 fri 是一样的。 

域之间有空格分隔，这和 UNIX cron 一样。无可争辩的，我们能写的最简单的表达式看起来就是这个了： 

* * * ? * * 

这个表达会每秒钟(每分种的、每小时的、每天的)激发一个部署的 job。 

·理解特殊字符 

同 UNIX cron 一样，Quartz cron 表达式支持用特殊字符来创建更为复杂的执行计划。然而，Quartz 在特殊字符的支持上比标准 UNIX cron 表达式更丰富了。 

* 星号 

使用星号(*) 指示着你想在这个域上包含所有合法的值。例如，在月份域上使用星号意味着每个月都会触发这个 trigger。

表达式样例： 

0 * 17 * * ? 

意义：每天从下午5点到下午5:59中的每分钟激发一次 trigger。它停在下午 5:59 是因为值 17 在小时域上，在下午 6 点时，小时变为 18 了，也就不再理会这个 trigger，直到下一天的下午5点。 

在你希望 trigger 在该域的所有有效值上被激发时使用 * 字符。 

? 问号 

? 号只能用在日和周域上，但是不能在这两个域上同时使用。你可以认为 ? 字符是 "我并不关心在该域上是什么值。" 这不同于星号，星号是指示着该域上的每一个值。? 是说不为该域指定值。 

不能同时这两个域上指定值的理由是难以解释甚至是难以理解的。基本上，假定同时指定值的话，意义就会变得含混不清了：考虑一下，如果一个表达式在日域上有值11，同时在周域上指定了 WED。那么是要 trigger 仅在每个月的11号，且正好又是星期三那天被激发？还是在每个星期三的11号被激发呢？要去除这种不明确性的办法就是不能同时在这两个域上指定值。 

只要记住，假如你为这两域的其中一个指定了值，那就必须在另一个字值上放一个 ?。 

表达式样例： 

0 10,44 14 ? 3 WEB 

意义：在三月中的每个星期三的下午 2:10 和 下午 2:44 被触发。 

, 逗号 

逗号 (,) 是用来在给某个域上指定一个值列表的。例如，使用值 0,15,30,45 在秒域上意味着每15秒触发一个 trigger。 

表达式样例： 

0 0,15,30,45 * * * ? 

意义：每刻钟触发一次 trigger。 

/ 斜杠 

斜杠 (/) 是用于时间表的递增的。我们刚刚用了逗号来表示每15分钟的递增，但是我们也能写成这样 0/15。 

表达式样例： 

0/15 0/30 * * * ? 

意义：在整点和半点时每15秒触发 trigger。 

- 中划线 

中划线 (-) 用于指定一个范围。例如，在小时域上的 3-8 意味着 "3,4,5,6,7 和 8 点。"  域的值不允许回卷，所以像 50-10 这样的值是不允许的。 

表达式样例： 

0 45 3-8 ? * * 

意义：在上午的3点至上午的8点的45分时触发 trigger。 

L 字母

L 说明了某域上允许的最后一个值。它仅被日和周域支持。当用在日域上，表示的是在月域上指定的月份的最后一天。例如，当月域上指定了 JAN 时，在日域上的 L 会促使 trigger 在1月31号被触发。假如月域上是 SEP，那么 L 会预示着在9月30号触发。换句话说，就是不管指定了哪个月，都是在相应月份的时最后一天触发 trigger。 

表达式 0 0 8 L * ? 意义是在每个月最后一天的上午 8:00 触发 trigger。在月域上的 * 说明是 "每个月"。 

当 L 字母用于周域上，指示着周的最后一天，就是星期六 (或者数字7)。所以如果你需要在每个月的最后一个星期六下午的 11:59 触发 trigger，你可以用这样的表达式 0 59 23 ? * L。 

当使用于周域上，你可以用一个数字与 L 连起来表示月份的最后一个星期 X。例如，表达式 0 0 12 ? * 2L 说的是在每个月的最后一个星期一触发 trigger。 
不要让范围和列表值与 L 连用

虽然你能用星期数(1-7)与 L 连用，但是不允许你用一个范围值和列表值与 L 连用。这会产生不可预知的结果。

W 字母 

W 字符代表着平日 (Mon-Fri)，并且仅能用于日域中。它用来指定离指定日的最近的一个平日。大部分的商业处理都是基于工作周的，所以 W 字符可能是非常重要的。例如，日域中的 15W 意味着 "离该月15号的最近一个平日。" 假如15号是星期六，那么 trigger 会在14号(星期四)触发，因为距15号最近的是星期一，这个例子中也会是17号（译者Unmi注：不会在17号触发的，如果是15W，可能会是在14号(15号是星期六)或者15号(15号是星期天)触发，也就是只能出现在邻近的一天，如果15号当天为平日直接就会当日执行）。W 只能用在指定的日域为单天，不能是范围或列表值。 

# 井号 

# 字符仅能用于周域中。它用于指定月份中的第几周的哪一天。例如，如果你指定周域的值为 6#3，它意思是某月的第三个周五 (6=星期五，#3意味着月份中的第三周)。另一个例子 2#1 意思是某月的第一个星期一 (2=星期一，#1意味着月份中的第一周)。注意，假如你指定 #5，然而月份中没有第 5 周，那么该月不会触发。
示例：
表达式意义
"0 0 12 * *?" 每天中午12点触发
"0 15 10 ? **" 每天上午10:15触发
"0 15 10 * *?" 每天上午10:15触发
"0 15 10 * * ?*" 每天上午10:15触发
"0 15 10 * * ?2005" 2005年的每天上午10:15触发
"0 * 14 * *?" 在每天下午2点到下午2:59期间的每1分钟触发
"0 0/5 14 * *?" 在每天下午2点到下午2:55期间的每5分钟触发
"0 0/5 14,18 ** ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
"0 0-5 14 * *?" 在每天下午2点到下午2:05期间的每1分钟触发
"0 10,44 14 ? 3WED" 每年三月的星期三的下午2:10和2:44触发
"0 15 10 ? *MON-FRI" 周一至周五的上午10:15触发
"0 15 10 15 *?" 每月15日上午10:15触发
"0 15 10 L *?" 每月最后一日的上午10:15触发
"0 15 10 ? *6L" 每月的最后一个星期五上午10:15触发
"0 15 10 ? * 6L2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发
"0 15 10 ? *6#3" 每月的第三个星期五上午10:15触发

cron 表达式的格式

Quartz cron 表达式的格式十分类似于 UNIX cron 格式，但还是有少许明显的区别。区别之一就是 Quartz 的格式向下支持到秒级别的计划，而 UNIX cron 计划仅支持至分钟级。许多我们的触发计划要基于秒级递增的(例如，每45秒)，因此这是一个非常好的差异。

在 UNIX cron 里，要执行的作业（或者说命令）是存放在 cron 表达式中的，在第六个域位置上。Quartz 用 cron 表达式存放执行计划。引用了 cron 表达式的 CronTrigger 在计划的时间里会与 job 关联上。

另一个与 UNIX cron 表达式的不同点是在表达式中支持域的数目。UNIX 给出五个域(分、时、日、月和周)，Quartz 提供七个域。表 5.1 列出了 Quartz cron 表达式支持的七个域。
Quartz Cron 表达式支持到七个域 
名称	是否必须	允许值	特殊字符
秒	是	0-59	, - * /
分	是	0-59	, - * /
时	是	0-23	, - * /
日	是	1-31	, - * ? / L W C
月	是	1-12 或 JAN-DEC	, - * /
周	是	1-7 或 SUN-SAT	, - * ? / L C #
年	否	空 或 1970-2099	, - * /

月份和星期的名称是不区分大小写的。FRI 和 fri 是一样的。 

域之间有空格分隔，这和 UNIX cron 一样。无可争辩的，我们能写的最简单的表达式看起来就是这个了： 

* * * ? * * 

这个表达会每秒钟(每分种的、每小时的、每天的)激发一个部署的 job。 

·理解特殊字符 

同 UNIX cron 一样，Quartz cron 表达式支持用特殊字符来创建更为复杂的执行计划。然而，Quartz 在特殊字符的支持上比标准 UNIX cron 表达式更丰富了。 

* 星号 

使用星号(*) 指示着你想在这个域上包含所有合法的值。例如，在月份域上使用星号意味着每个月都会触发这个 trigger。

表达式样例： 

0 * 17 * * ? 

意义：每天从下午5点到下午5:59中的每分钟激发一次 trigger。它停在下午 5:59 是因为值 17 在小时域上，在下午 6 点时，小时变为 18 了，也就不再理会这个 trigger，直到下一天的下午5点。 

在你希望 trigger 在该域的所有有效值上被激发时使用 * 字符。 

? 问号 

? 号只能用在日和周域上，但是不能在这两个域上同时使用。你可以认为 ? 字符是 "我并不关心在该域上是什么值。" 这不同于星号，星号是指示着该域上的每一个值。? 是说不为该域指定值。 

不能同时这两个域上指定值的理由是难以解释甚至是难以理解的。基本上，假定同时指定值的话，意义就会变得含混不清了：考虑一下，如果一个表达式在日域上有值11，同时在周域上指定了 WED。那么是要 trigger 仅在每个月的11号，且正好又是星期三那天被激发？还是在每个星期三的11号被激发呢？要去除这种不明确性的办法就是不能同时在这两个域上指定值。 

只要记住，假如你为这两域的其中一个指定了值，那就必须在另一个字值上放一个 ?。 

表达式样例： 

0 10,44 14 ? 3 WED 

意义：在三月中的每个星期三的下午 2:10 和 下午 2:44 被触发。 

, 逗号 

逗号 (,) 是用来在给某个域上指定一个值列表的。例如，使用值 0,15,30,45 在秒域上意味着每15秒触发一个 trigger。 

表达式样例： 

0 0,15,30,45 * * * ? 

意义：每刻钟触发一次 trigger。 

/ 斜杠 

斜杠 (/) 是用于时间表的递增的。我们刚刚用了逗号来表示每15分钟的递增，但是我们也能写成这样 0/15。 

表达式样例： 

0/15 0/30 * * * ? 

意义：在整点和半点时每15秒触发 trigger。 

- 中划线 

中划线 (-) 用于指定一个范围。例如，在小时域上的 3-8 意味着 "3,4,5,6,7 和 8 点。"  域的值不允许回卷，所以像 50-10 这样的值是不允许的。 

表达式样例： 

0 45 3-8 ? * * 

意义：在上午的3点至上午的8点的45分时触发 trigger。 

L 字母

L 说明了某域上允许的最后一个值。它仅被日和周域支持。当用在日域上，表示的是在月域上指定的月份的最后一天。例如，当月域上指定了 JAN 时，在日域上的 L 会促使 trigger 在1月31号被触发。假如月域上是 SEP，那么 L 会预示着在9月30号触发。换句话说，就是不管指定了哪个月，都是在相应月份的时最后一天触发 trigger。 

表达式 0 0 8 L * ? 意义是在每个月最后一天的上午 8:00 触发 trigger。在月域上的 * 说明是 "每个月"。 

当 L 字母用于周域上，指示着周的最后一天，就是星期六 (或者数字7)。所以如果你需要在每个月的最后一个星期六下午的 11:59 触发 trigger，你可以用这样的表达式 0 59 23 ? * L。 

当使用于周域上，你可以用一个数字与 L 连起来表示月份的最后一个星期 X。例如，表达式 0 0 12 ? * 2L 说的是在每个月的最后一个星期一触发 trigger。 
不要让范围和列表值与 L 连用

虽然你能用星期数(1-7)与 L 连用，但是不允许你用一个范围值和列表值与 L 连用。这会产生不可预知的结果。

W 字母 

W 字符代表着平日 (Mon-Fri)，并且仅能用于日域中。它用来指定离指定日的最近的一个平日。大部分的商业处理都是基于工作周的，所以 W 字符可能是非常重要的。例如，日域中的 15W 意味着 "离该月15号的最近一个平日。" 假如15号是星期六，那么 trigger 会在14号(星期四)触发，因为距15号最近的是星期一，这个例子中也会是17号（译者Unmi注：不会在17号触发的，如果是15W，可能会是在14号(15号是星期六)或者15号(15号是星期天)触发，也就是只能出现在邻近的一天，如果15号当天为平日直接就会当日执行）。W 只能用在指定的日域为单天，不能是范围或列表值。 

# 井号 

# 字符仅能用于周域中。它用于指定月份中的第几周的哪一天。例如，如果你指定周域的值为 6#3，它意思是某月的第三个周五 (6=星期五，#3意味着月份中的第三周)。另一个例子 2#1 意思是某月的第一个星期一 (2=星期一，#1意味着月份中的第一周)。注意，假如你指定 #5，然而月份中没有第 5 周，那么该月不会触发。
示例：
表达式意义
"0 0 12 * *?" 每天中午12点触发
"0 15 10 ? **" 每天上午10:15触发
"0 15 10 * *?" 每天上午10:15触发
"0 15 10 * * ?*" 每天上午10:15触发
"0 15 10 * * ?2005" 2005年的每天上午10:15触发
"0 * 14 * *?" 在每天下午2点到下午2:59期间的每1分钟触发
"0 0/5 14 * *?" 在每天下午2点到下午2:55期间的每5分钟触发
"0 0/5 14,18 ** ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
"0 0-5 14 * *?" 在每天下午2点到下午2:05期间的每1分钟触发
"0 10,44 14 ? 3WED" 每年三月的星期三的下午2:10和2:44触发
"0 15 10 ? *MON-FRI" 周一至周五的上午10:15触发
"0 15 10 15 *?" 每月15日上午10:15触发
"0 15 10 L *?" 每月最后一日的上午10:15触发
"0 15 10 ? *6L" 每月的最后一个星期五上午10:15触发
"0 15 10 ? * 6L2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发
"0 15 10 ? *6#3" 每月的第三个星期五上午10:15触发

cron 表达式的格式

Quartz cron 表达式的格式十分类似于 UNIX cron 格式，但还是有少许明显的区别。区别之一就是 Quartz 的格式向下支持到秒级别的计划，而 UNIX cron 计划仅支持至分钟级。许多我们的触发计划要基于秒级递增的(例如，每45秒)，因此这是一个非常好的差异。

在 UNIX cron 里，要执行的作业（或者说命令）是存放在 cron 表达式中的，在第六个域位置上。Quartz 用 cron 表达式存放执行计划。引用了 cron 表达式的 CronTrigger 在计划的时间里会与 job 关联上。

另一个与 UNIX cron 表达式的不同点是在表达式中支持域的数目。UNIX 给出五个域(分、时、日、月和周)，Quartz 提供七个域。表 5.1 列出了 Quartz cron 表达式支持的七个域。
Quartz Cron 表达式支持到七个域 
名称	是否必须	允许值	特殊字符
秒	是	0-59	, - * /
分	是	0-59	, - * /
时	是	0-23	, - * /
日	是	1-31	, - * ? / L W C
月	是	1-12 或 JAN-DEC	, - * /
周	是	1-7 或 SUN-SAT	, - * ? / L C #
年	否	空 或 1970-2099	, - * /

月份和星期的名称是不区分大小写的。FRI 和 fri 是一样的。 

域之间有空格分隔，这和 UNIX cron 一样。无可争辩的，我们能写的最简单的表达式看起来就是这个了： 

* * * ? * * 

这个表达会每秒钟(每分种的、每小时的、每天的)激发一个部署的 job。 

·理解特殊字符 

同 UNIX cron 一样，Quartz cron 表达式支持用特殊字符来创建更为复杂的执行计划。然而，Quartz 在特殊字符的支持上比标准 UNIX cron 表达式更丰富了。 

* 星号 

使用星号(*) 指示着你想在这个域上包含所有合法的值。例如，在月份域上使用星号意味着每个月都会触发这个 trigger。

表达式样例： 

0 * 17 * * ? 

意义：每天从下午5点到下午5:59中的每分钟激发一次 trigger。它停在下午 5:59 是因为值 17 在小时域上，在下午 6 点时，小时变为 18 了，也就不再理会这个 trigger，直到下一天的下午5点。 

在你希望 trigger 在该域的所有有效值上被激发时使用 * 字符。 

? 问号 

? 号只能用在日和周域上，但是不能在这两个域上同时使用。你可以认为 ? 字符是 "我并不关心在该域上是什么值。" 这不同于星号，星号是指示着该域上的每一个值。? 是说不为该域指定值。 

不能同时这两个域上指定值的理由是难以解释甚至是难以理解的。基本上，假定同时指定值的话，意义就会变得含混不清了：考虑一下，如果一个表达式在日域上有值11，同时在周域上指定了 WED。那么是要 trigger 仅在每个月的11号，且正好又是星期三那天被激发？还是在每个星期三的11号被激发呢？要去除这种不明确性的办法就是不能同时在这两个域上指定值。 

只要记住，假如你为这两域的其中一个指定了值，那就必须在另一个字值上放一个 ?。 

表达式样例： 

0 10,44 14 ? 3 WED 

意义：在三月中的每个星期三的下午 2:10 和 下午 2:44 被触发。 

, 逗号 

逗号 (,) 是用来在给某个域上指定一个值列表的。例如，使用值 0,15,30,45 在秒域上意味着每15秒触发一个 trigger。 

表达式样例： 

0 0,15,30,45 * * * ? 

意义：每刻钟触发一次 trigger。 

/ 斜杠 

斜杠 (/) 是用于时间表的递增的。我们刚刚用了逗号来表示每15分钟的递增，但是我们也能写成这样 0/15。 

表达式样例： 

0/15 0/30 * * * ? 

意义：在整点和半点时每15秒触发 trigger。 

- 中划线 

中划线 (-) 用于指定一个范围。例如，在小时域上的 3-8 意味着 "3,4,5,6,7 和 8 点。"  域的值不允许回卷，所以像 50-10 这样的值是不允许的。 

表达式样例： 

0 45 3-8 ? * * 

意义：在上午的3点至上午的8点的45分时触发 trigger。 

L 字母

L 说明了某域上允许的最后一个值。它仅被日和周域支持。当用在日域上，表示的是在月域上指定的月份的最后一天。例如，当月域上指定了 JAN 时，在日域上的 L 会促使 trigger 在1月31号被触发。假如月域上是 SEP，那么 L 会预示着在9月30号触发。换句话说，就是不管指定了哪个月，都是在相应月份的时最后一天触发 trigger。 

表达式 0 0 8 L * ? 意义是在每个月最后一天的上午 8:00 触发 trigger。在月域上的 * 说明是 "每个月"。 

当 L 字母用于周域上，指示着周的最后一天，就是星期六 (或者数字7)。所以如果你需要在每个月的最后一个星期六下午的 11:59 触发 trigger，你可以用这样的表达式 0 59 23 ? * L。 

当使用于周域上，你可以用一个数字与 L 连起来表示月份的最后一个星期 X。例如，表达式 0 0 12 ? * 2L 说的是在每个月的最后一个星期一触发 trigger。 
不要让范围和列表值与 L 连用

虽然你能用星期数(1-7)与 L 连用，但是不允许你用一个范围值和列表值与 L 连用。这会产生不可预知的结果。

W 字母 

W 字符代表着平日 (Mon-Fri)，并且仅能用于日域中。它用来指定离指定日的最近的一个平日。大部分的商业处理都是基于工作周的，所以 W 字符可能是非常重要的。例如，日域中的 15W 意味着 "离该月15号的最近一个平日。" 假如15号是星期六，那么 trigger 会在14号(星期四)触发，因为距15号最近的是星期一，这个例子中也会是17号（译者Unmi注：不会在17号触发的，如果是15W，可能会是在14号(15号是星期六)或者15号(15号是星期天)触发，也就是只能出现在邻近的一天，如果15号当天为平日直接就会当日执行）。W 只能用在指定的日域为单天，不能是范围或列表值。 

# 井号 

# 字符仅能用于周域中。它用于指定月份中的第几周的哪一天。例如，如果你指定周域的值为 6#3，它意思是某月的第三个周五 (6=星期五，#3意味着月份中的第三周)。另一个例子 2#1 意思是某月的第一个星期一 (2=星期一，#1意味着月份中的第一周)。注意，假如你指定 #5，然而月份中没有第 5 周，那么该月不会触发。
示例：
表达式意义
"0 0 12 * *?" 每天中午12点触发
"0 15 10 ? **" 每天上午10:15触发
"0 15 10 * *?" 每天上午10:15触发
"0 15 10 * * ?*" 每天上午10:15触发
"0 15 10 * * ?2005" 2005年的每天上午10:15触发
"0 * 14 * *?" 在每天下午2点到下午2:59期间的每1分钟触发
"0 0/5 14 * *?" 在每天下午2点到下午2:55期间的每5分钟触发
"0 0/5 14,18 ** ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
"0 0-5 14 * *?" 在每天下午2点到下午2:05期间的每1分钟触发
"0 10,44 14 ? 3WED" 每年三月的星期三的下午2:10和2:44触发
"0 15 10 ? *MON-FRI" 周一至周五的上午10:15触发
"0 15 10 15 *?" 每月15日上午10:15触发
"0 15 10 L *?" 每月最后一日的上午10:15触发
"0 15 10 ? *6L" 每月的最后一个星期五上午10:15触发
"0 15 10 ? * 6L2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发
"0 15 10 ? *6#3" 每月的第三个星期五上午10:15触发

1.打开cmd,查看占用此端口的进程有哪些？


2.调整任务管理器的PID显示


3.到任务管理器结束指定进程

1.打开cmd,查看占用此端口的进程有哪些？


2.调整任务管理器的PID显示


3.到任务管理器结束指定进程

商务综合管理平台
一、项目描述
商务综合管理平台紧跟时代步伐，该软件主要从事的国际物流行业一系列相关过程的管理，公司业务遍及欧美。随着公司不断发展壮大，旧的信息系统已无法满足公司的快速发展需求，妨碍公司成长，在此背景下，公司领导决定研发《商务综合管理平台》。
《商务综合管理平台》分三期完成。一期完成仓储管理（包括：采购单、仓库、货物、条形码、入库、出库、退货、盘点、库存、库存上限报警、统计查询）和展会管理（包括：展会管理、出单管理），形成货物统一数字化管理。二期完成货运全流程管理，包括购销合同、出货表统计、出口报运单、HOME装箱单、装箱单、委托书、发票、财务统计等。三期完成决策分析（包括：成本分析图、销售情况统计、重点客户、经营情况同期比对统计、工作绩效），为公司经营决策提供数据支持。


项目采用了BRAC认证模型，并结合Shiro安全框架进行相应的认证授权工作。利用Shiro更好的实现了项目的认证授权及加密，会话管理工作。该项目采用了细粒度权限控制，不仅可以控制顶部菜单及左侧菜单和按钮，最重要的是还可以控制不同用户所查看的数据，为了实现数据控制，在表设计时就要加入相关字段进行优化，从而做到当事人看到自己的记录，部门经理看到该部门下所有员工添加的记录，副总可以实现跨部门跨人员的数据查看，总经理可以看到所有记录。

购销合同是公司和生产厂家签订的合同。合同是由合同主信息和多个货物信息和多个附件信息组成。两级一对多。公司的货物是玻璃杯，附件是指玻璃杯上的一些装饰物，包括：花纸、PVC、电镀等等）货物由生产厂家，附件由生产厂家。在开发购销合同模块时，我做了一个复杂的表单打印。这个报表非常繁琐，里面包括打印logo图片，包括多个货物的图片，包括线，包括合并单元格。打印时用户可以指定一页纸打印一款货物，还是两款货物。打印时如果是两款货物，如何是同一个生产厂家，可以打印到同一页，如果不是同一个生产厂家，必须另起一页。根据用户的习惯，我们采用poi来输出内容到excel中。

出口报运是公司和生产厂家签订购销合同后，杰信准备报关材料，进行报关。对应我们系统，只打印一个《商品出口报运单》，为报关提供货物信息。一个报运单来自多个合同，包括报运的主信息，包括报运的货物信息。报运单下的货物的信息来自合同，主要包括：货号，数量，包装单位，箱数（件数）等等，还包括：新增的多个字段：毛重、净重、长、宽、高、出口单价、含税等等。在设计时进行了优化，采用“打断设计”方法和“数据搬家”，它实现数据快速查询，后续业务直接使用这里提供的数据。

POI海量数据导出，系统中备份数据和恢复数据。
操作excle主要有jxl和poi两种方式，jxl在处理数据时比早期的poi快。（poi早期对象，处理时都是将加工的数据存放在内存中，如果数据量很多，很容易造成堆溢出，同时它占用CPU和大量内存，导致其他业务也无法正常完成。）poi在新版本中改善这个性能瓶颈。对大数据量的导出做了优化。使用ooxml技术，使用SXSSF对象，当数据创建到指定数量时，自动写缓存，将它内容输出到临时文件中。这个临时文件是一个xml，相比内存中对象的结构非常简单。只保留数据的信息。保存的数据量也非常少。这样就可以形成大数量的导出。例如：该项目中，购销合同业务，它有很多历史信息，积累了很多年，数据量达到近百万。导致系统变慢，我们采用poi导出数据备份到excel文件中。将这部分历史信息从当前表删除。在打印中就可以直接实现。（excel单sheet可以支持1048576）。

自动代码生成工具
原理：应用freeMarker第三方工具类。实现模块开发。自定义一个代码模板，这个模板中自定义一些变量。日常主要类和页面的变量，例如：数据库表，表的字段，类的名称，类的属性。这些可以直接调用。做好每个文件的模板后，在后台从数据库表中读取这个业务相关的字段，类型，备注。调用freeMarks。通过freeMarks配置config。打开我们指定模板，然后将要生成这些文件对应的表名传递进去，通过数据库表名查询数据库，通过数据库提供的直接查询字段的SQL。这里比结果集的元数据多一个备注字段。查询到这些信息，将它们封装到一个map集合中。Key就是我们在模板中定义的变量，value就是数据中的内容。把这个map集合和模板传递给freeMarks。freeMarks进行模板中变量值的替换。freeMarker非常强大，可以有标签，可以有标签嵌套。还可以有自定义的方法，例如：类名全大写，全小写，首字母大写，首字母小写。（可以少定义变量），可以if判断，可以做循环，支持复杂的对象关联。它还支持宏，还支持自定义函数。就可以实现模板的编程。这样模板非常灵活。


系统用例如下：

二、系统功能模结构图

三、项目特色
1.该管理平台采用了当前最流行的S2SH进行总体架构，充分利用框架整合后的各种特性，并加入maven进行项目的分模块开发，有效进行项目管理。
2.采用了BRAC认证模型，有效进行用户权限管理，同时加入当前流行的Shiro安全框架，从而使得系统更加安全可靠。
3.结合Sybase引入数据库设计相关理念，及打断设计理论。
4.使用Apache POI实现海量数据导出。
5.采用跳跃查询相关思想，并结合数据搬家的操作手段，从而有效提高了系统性能。
6.利用CodeMachine实现代码自动生成技术，从而解放程序员的部分编码工作。
7.使用amChart+Flash形成各种统计图形，从而为高层提供决策支撑。
8.引入JavaMail邮件机制，并实现Spring与JavaMail整合开发，实现邮件发送中加入附件。
9.加入了Quartz实现的定时任务调度，并结合Spring整合好的Mail，很好的解决了报表向
  公司高层的定时发送功能。
10.引入WebService的CXF开发方式，并与Spring结合，从而很好的解决了电子报运问题

四、系统功能截图
一、首页面

二、系统主页面

三、货运管理模块


四、权限管理模块

五、统计报表生成


商务综合管理平台
一、项目描述
商务综合管理平台紧跟时代步伐，该软件主要从事的国际物流行业一系列相关过程的管理，公司业务遍及欧美。随着公司不断发展壮大，旧的信息系统已无法满足公司的快速发展需求，妨碍公司成长，在此背景下，公司领导决定研发《商务综合管理平台》。
《商务综合管理平台》分三期完成。一期完成仓储管理（包括：采购单、仓库、货物、条形码、入库、出库、退货、盘点、库存、库存上限报警、统计查询）和展会管理（包括：展会管理、出单管理），形成货物统一数字化管理。二期完成货运全流程管理，包括购销合同、出货表统计、出口报运单、HOME装箱单、装箱单、委托书、发票、财务统计等。三期完成决策分析（包括：成本分析图、销售情况统计、重点客户、经营情况同期比对统计、工作绩效），为公司经营决策提供数据支持。


项目采用了BRAC认证模型，并结合Shiro安全框架进行相应的认证授权工作。利用Shiro更好的实现了项目的认证授权及加密，会话管理工作。该项目采用了细粒度权限控制，不仅可以控制顶部菜单及左侧菜单和按钮，最重要的是还可以控制不同用户所查看的数据，为了实现数据控制，在表设计时就要加入相关字段进行优化，从而做到当事人看到自己的记录，部门经理看到该部门下所有员工添加的记录，副总可以实现跨部门跨人员的数据查看，总经理可以看到所有记录。

购销合同是公司和生产厂家签订的合同。合同是由合同主信息和多个货物信息和多个附件信息组成。两级一对多。公司的货物是玻璃杯，附件是指玻璃杯上的一些装饰物，包括：花纸、PVC、电镀等等）货物由生产厂家，附件由生产厂家。在开发购销合同模块时，我做了一个复杂的表单打印。这个报表非常繁琐，里面包括打印logo图片，包括多个货物的图片，包括线，包括合并单元格。打印时用户可以指定一页纸打印一款货物，还是两款货物。打印时如果是两款货物，如何是同一个生产厂家，可以打印到同一页，如果不是同一个生产厂家，必须另起一页。根据用户的习惯，我们采用poi来输出内容到excel中。

出口报运是公司和生产厂家签订购销合同后，杰信准备报关材料，进行报关。对应我们系统，只打印一个《商品出口报运单》，为报关提供货物信息。一个报运单来自多个合同，包括报运的主信息，包括报运的货物信息。报运单下的货物的信息来自合同，主要包括：货号，数量，包装单位，箱数（件数）等等，还包括：新增的多个字段：毛重、净重、长、宽、高、出口单价、含税等等。在设计时进行了优化，采用“打断设计”方法和“数据搬家”，它实现数据快速查询，后续业务直接使用这里提供的数据。

POI海量数据导出，系统中备份数据和恢复数据。
操作excle主要有jxl和poi两种方式，jxl在处理数据时比早期的poi快。（poi早期对象，处理时都是将加工的数据存放在内存中，如果数据量很多，很容易造成堆溢出，同时它占用CPU和大量内存，导致其他业务也无法正常完成。）poi在新版本中改善这个性能瓶颈。对大数据量的导出做了优化。使用ooxml技术，使用SXSSF对象，当数据创建到指定数量时，自动写缓存，将它内容输出到临时文件中。这个临时文件是一个xml，相比内存中对象的结构非常简单。只保留数据的信息。保存的数据量也非常少。这样就可以形成大数量的导出。例如：该项目中，购销合同业务，它有很多历史信息，积累了很多年，数据量达到近百万。导致系统变慢，我们采用poi导出数据备份到excel文件中。将这部分历史信息从当前表删除。在打印中就可以直接实现。（excel单sheet可以支持1048576）。

自动代码生成工具
原理：应用freeMarker第三方工具类。实现模块开发。自定义一个代码模板，这个模板中自定义一些变量。日常主要类和页面的变量，例如：数据库表，表的字段，类的名称，类的属性。这些可以直接调用。做好每个文件的模板后，在后台从数据库表中读取这个业务相关的字段，类型，备注。调用freeMarks。通过freeMarks配置config。打开我们指定模板，然后将要生成这些文件对应的表名传递进去，通过数据库表名查询数据库，通过数据库提供的直接查询字段的SQL。这里比结果集的元数据多一个备注字段。查询到这些信息，将它们封装到一个map集合中。Key就是我们在模板中定义的变量，value就是数据中的内容。把这个map集合和模板传递给freeMarks。freeMarks进行模板中变量值的替换。freeMarker非常强大，可以有标签，可以有标签嵌套。还可以有自定义的方法，例如：类名全大写，全小写，首字母大写，首字母小写。（可以少定义变量），可以if判断，可以做循环，支持复杂的对象关联。它还支持宏，还支持自定义函数。就可以实现模板的编程。这样模板非常灵活。


系统用例如下：

二、系统功能模结构图

三、项目特色
1.该管理平台采用了当前最流行的S2SH进行总体架构，充分利用框架整合后的各种特性，并加入maven进行项目的分模块开发，有效进行项目管理。
2.采用了BRAC认证模型，有效进行用户权限管理，同时加入当前流行的Shiro安全框架，从而使得系统更加安全可靠。
3.结合Sybase引入数据库设计相关理念，及打断设计理论。
4.使用Apache POI实现海量数据导出。
5.采用跳跃查询相关思想，并结合数据搬家的操作手段，从而有效提高了系统性能。
6.利用CodeMachine实现代码自动生成技术，从而解放程序员的部分编码工作。
7.使用amChart+Flash形成各种统计图形，从而为高层提供决策支撑。
8.引入JavaMail邮件机制，并实现Spring与JavaMail整合开发，实现邮件发送中加入附件。
9.加入了Quartz实现的定时任务调度，并结合Spring整合好的Mail，很好的解决了报表向
  公司高层的定时发送功能。
10.引入WebService的CXF开发方式，并与Spring结合，从而很好的解决了电子报运问题

四、系统功能截图
一、首页面

二、系统主页面

三、货运管理模块


四、权限管理模块

五、统计报表生成


第  组开发问题解决日志
项目组长：                    开发项目：
问题1：





问题2：






日期：        
VMware Workstation 9.0中文版本 （版本不同可能有稍许的不同） 虚拟机上安装红帽6的系统
笔记本上是安装的win7旗舰版
 
一、使用NAT方式联网 
1.1
打开VMware Workstation，找到编辑---虚拟机网络编辑器


2.2
对网络编辑器的NAT进行设置，子网ip可以根据自己的嗜好进行设置，


3.3
选择虚拟机的连接方式，找到虚拟机--设置


4.4
重启linux网卡，验证


END
 
二.使用桥接方式联网 
1.1
打开VMware找到编辑--虚拟机网络编辑器，上面有一样的，所以就简单点。

2.2
接上一条，怎么查看真实机上的使用什么网卡联网的呢？打开网络和共享中心--在左边点击更改适配器设置



3.3
选择虚拟机连接方式


4.4
重启网卡和验证

5.5
查看真实机的物理网卡信息，显示虚拟机和真实机在桥接的方式下面处于同一个局域网中



END
 
三、host-only方式在虚拟几种是不能联网的 
1.1
读者有兴趣可以自行探索，这里我就不多说了
END
 
注意事项 
关于三种连接方式，仅是我个人理解，并简单的描述，如需深入了解请找专业书籍

商务综合管理平台项目实战文档

一、需求摘要
（一）委托管理（10分）
1.委托单的生成(新增)
状态为0：草稿
2.委托单的查询
3.委托单的修改&删除【可以修改状态也可以真实删除】
4.委托单的提交与取消【状态的修改】



（二）发票管理（10分）
1.发票单的生成(新增)【状态0】
2.发票单的查询
3.发票单的修改&删除
4.发票单的提交与取消【提交时状态改为1  】

发票新增时，因为装箱单的发票号，前期是没有值的，所以当发票生成时，发票号就存在值了，就要更新装箱单的发票号





（三）财务报运单管理（10分）
1.财务报运单的生成【新增】
2.财务报运单的查询
3.财务报运单的修改&删除
4.财务报运单的提交与取消


（四）基础信息模块（25分）
1.工厂信息的CRUD
厂家删除时，只要修改状态为2(代表这个厂家与我们公司没有合作了)
2.产品信息的CRUD
产品与工厂之间的关系（多对一）
开发时，可以在产品添加时，提供厂家下拉列表
3.市场价最高的前10名产品（按市场价统计），并使用图形报表进行统计(JSON数据)

（五）登录模块（10分）
1.登录日志的添加

2.登录IP次数的统计图，前10名（使用图形报表方式生成）[可选]


二、表结构文档





三、评分标准
评分项	分数比重	备注
1.功能实现	参考上面的功能点及分值分布，总共功能点为65分	没有实现功能0分，实现功能有BUG,5分，完全实现10分。
2.语言表达	15分	
3.代码规范度（命名及结构）	10分	
4.代码注释	10分	
5.附加分：扩展功能	+ 20分	根据自己的理解扩展需求中未列出的功能，并具有实用性。每功能5分，最多20分.
6.附加分：独立开发能力	+10分	如果开发过程中组内独立解决了开发中的问题，零求助得10分，使用1次求助5分，超过1次不得分



组长：
1.svn仓库中有工程（要将项目的dataSource连接修改为远程服务器的oracle地址）
2.oracle数据库中有表
3.分工（需要填写分工表）
4.开发自己的功能模块
5.测试的工作，现在放在自己的电脑上的Tomcat中进行测试

6.放到远程的服务器(Linux中的Tomcat)进行测试，放在明天再测试

7.抽签决定项目分享



组员：
1.拿到功能模块，分析业务
2.从SVN服务器中将工程下载到本地
3.组员连接oracle数据库进行功能测试
4.开发自己的模块
5.测试的工作，现在放在自己的电脑上的Tomcat中进行测试
6.放到远程的服务器(Linux中的Tomcat)进行测试，放在明天再测试

1.将文件加入到工程中


添加相关的操作sql语句的工具类

因为操作sql语句时，使用的是jdbcTemplate技术，所以就需要配置它，操作sql语句的工具类还要注入jdbcTemplate.
1.配置jdbcTmplate(注入dataSource)
2.配置工具类（注入jdbcTemplate）




为了简化，所以省掉了service.在Action中就直接注入SqlDao来实现相应的统计工作.


运行界面，看菜单是否完整，数据库中可以添加内容 ：



2.添加处理的Action

3.生产饼形



4.配置

5.在jStat页面中访问结果



系统访问压力图
1.准备数据
  online_info_t表   指的是一天的24小时
  login_log_p表  访问日志，当用户登录时就应当向这个表中添加一条记录


数据来源，可以再次修改登录操作
获取相关数据，直接在login_log_p表中添加数据
ServletActionContext.getRequest().getRemoteAddr();//获取客户端ip地址


2.准备统计的sql语句
select a.a1,ifnull(b.lognum,0)
from 
(select a1 from online_info_t ) a 
left join 
(select substring(login_time,12,2) logtime ,count(*) lognum from login_log_p group by logtime) b
on (a.a1=b.logtime)

3.编写及配置Action
一．将项目打成war包
组长按排人员进行打war 包的工作
选择工程右键-Export--WAR Export

Destinition中选择输出war包的位置

解压后，发现如下：

二．文件上传到linux
1.使用上传的工具

2. 需要知道远程Linux系统的IP地址
网络连接方式：桥接方式：整个局域网内都可以访问虚拟机
                       Host-only：便于测试
	                 NAT:可以上外网
IP地址的发布给各位组长
账号：root
密码

3.实现远程连接

测试的结果


实现文件的上传

三．将ws2603.war移动到Tomcat的webapps目录下
1. 打开CRT使用终端连接服务器

2.写入linux命令，实现文件移动
用户上传的文件，在下面的位置


找到移动的目的地
地址：/heima/web/tomcat/webapps


清空之前的所有项目


移动文件


四．启动Tomcat
1.找到启动文件(tomcat/bin)

2.启动

同时还要输出相关的日志信息
tail –f /heima/web/tomcat/logs/catalina.out

3.访问
http://192.168.77.87:8080/ws2803/ws/weather?wsdl

商务综合管理平台项目总结
项目总结，是要求每位同学都要如实去项目所涉及的业务点，技术点，程序设计思想，数据分析思想都要进行好好整理，并分析出各个业务点所使用的技术和设计思想之间的关联，把开发过程的来源去脉都要思考清楚。所以也希望各位都要进行项目的自我总结，这份总结将更有助于面试和就业，请认真对待！

本次项目实战也需要进行总结，主要是对这三天的分组开发的体验和自已编写能力的总结，对项目的实现结果进行总结，对取得的收获进行总结进而继续发扬，当然对自身的不足也应当得到正视，并总结出问题的原因，从而有目标的加强学习。

实战总结，将主要由每个组派出相应的一位和两位代表进行总结，总结的时间限制在20~30分钟内，请各组一定要遵守这个时间观念，因为在企业我们都会在规定的时间里完成计划中制订的工作。那么我们也应当能完成这次所提出的目标，台上一分钟台下十年功，现在也是检验咱们的关键时候了，所以各组一定要认真对待，发挥好本组的优势资源，人尽其才！各位也可以踊跃向组长报名，组长再去认真考虑，最终指定本组的项目分享人
分享的内容主要以下几个方面：
一．项目新增功能模块的演示
功能模块的编写者
二．项目扩展功能模块的演示
功能模块的编写者
三．项目特色技术亮点的总结
四．团队合作的总结和建议
五．SVN+maven分模块开发的总结
六．管理工作的重要性
七．服从管理的重要性
八．与项目管理相关的总结等等





Mybatis第一天

框架课程




























课程计划
第一天：
1、mybatis的介绍
2、Mybatis的入门
a)使用jdbc操作数据库存在的问题
b)Mybatis的架构
c)Mybatis的入门程序
3、Dao的开发方法
a)原始dao的开发方法
b)动态代理方式
4、SqlMapConfig.xml文件说明

第二天：
1、输入映射和输出映射
a)输入参数映射
b)返回值映射
2、动态sql
3、关联查询
a)一对一关联
b)一对多关联
4、Mybatis整合spring
MyBatis介绍
MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。	MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。
Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。
使用jdbc编程问题总结
创建mysql数据库
先导入创建数据库的sql脚本导入到数据库中。




创建工程
开发环境：
eclipse mars
Jdk：1.7

1、创建一个java工程。
2、导入jar包。此时需要mysql 的数据库驱动。

jdbc编程步骤：
1、加载数据库驱动
2、创建并获取数据库链接
3、创建jdbc statement对象
4、设置sql语句
5、设置sql语句中的参数(使用preparedStatement)
6、通过statement执行sql并获取结果
7、对sql执行结果进行解析处理
8、释放资源(resultSet、preparedstatement、connection)

jdbc程序
publicstaticvoid main(String[] args) {
			Connection connection = null;
			PreparedStatement preparedStatement = null;
			ResultSet resultSet = null;
			
			try {
				//加载数据库驱动
				Class.forName("com.mysql.jdbc.Driver");
				
				//通过驱动管理类获取数据库链接
				connection =  DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8", "root", "root");
				//定义sql语句 ?表示占位符
			String sql = "select * from user where username = ?";
				//获取预处理statement
				preparedStatement = connection.prepareStatement(sql);
				//设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值
				preparedStatement.setString(1, "王五");
				//向数据库发出sql执行查询，查询出结果集
				resultSet =  preparedStatement.executeQuery();
				//遍历查询结果集
				while(resultSet.next()){
					System.out.println(resultSet.getString("id")+""+resultSet.getString("username"));
				}
			} catch (Exception e) {
				e.printStackTrace();
			}finally{
				//释放资源
				if(resultSet!=null){
					try {
						resultSet.close();
					} catch (SQLException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				if(preparedStatement!=null){
					try {
						preparedStatement.close();
					} catch (SQLException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				if(connection!=null){
					try {
						connection.close();
					} catch (SQLException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}

			}

		}

上边使用jdbc的原始方法（未经封装）实现了查询数据库表记录的操作。

jdbc问题总结如下：
1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。
2、Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
3、使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。
4、对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。



Mybatis架构



1、mybatis配置
SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。
mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。

2、通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂
3、由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。
4、mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。
5、Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。
6、Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。
7、Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。



Mybatis入门程序
mybatis下载
mybaits的代码由github.com管理，地址：https://github.com/mybatis/mybatis-3/releases


mybatis-3.2.7.jar----mybatis的核心包
lib----mybatis的依赖包
mybatis-3.2.7.pdf----mybatis使用手册


需求
实现以下功能：
根据用户id查询一个用户信息
根据用户名称模糊查询用户信息列表
添加用户
更新用户
删除用户

工程搭建
第一步：创建java工程
使用eclipse创建java工程，jdk使用1.7.0_72。
第二步：加入jar包
加入mybatis核心包、依赖包、数据驱动包。


第三步：log4j.properties
在classpath下创建log4j.properties如下：

# Global logging configuration
log4j.rootLogger=DEBUG, stdout
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n

mybatis默认使用log4j作为输出日志信息。

第四步：SqlMapConfig.xml
在classpath下创建SqlMapConfig.xml，如下：

<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEconfiguration
PUBLIC"-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<!-- 和spring整合后 environments配置将废除-->
	<environmentsdefault="development">
		<environmentid="development">
		<!-- 使用jdbc事务管理-->
			<transactionManagertype="JDBC"/>
		<!-- 数据库连接池-->
			<dataSourcetype="POOLED">
				<propertyname="driver"value="com.mysql.jdbc.Driver"/>
				<propertyname="url"value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8"/>
				<propertyname="username"value="root"/>
				<propertyname="password"value="root"/>
			</dataSource>
		</environment>
	</environments>
	
</configuration>

SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。
第五步：po类

Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下：

Publicclass User {
	privateintid;
	private String username;// 用户姓名
	private String sex;// 性别
	private Date birthday;// 生日
	private String address;// 地址


get/set……

第六步：sql映射文件

在classpath下的sqlmap目录下创建sql映射文件Users.xml：

<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEmapper
PUBLIC"-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mappernamespace="test">
</mapper>

namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。

第七步：加载映射文件
mybatis框架需要加载映射文件，将Users.xml添加在SqlMapConfig.xml，如下：

<mappers>
		<mapperresource="sqlmap/User.xml"/>
</mappers>

根据id查询用户信息
映射文件：
在user.xml中添加：
<!-- 根据id获取用户信息 -->
	<selectid="findUserById"parameterType="int"resultType="cn.itcast.mybatis.po.User">
		select * from user where id = #{id}
	</select>
parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。
resultType：定义结果映射类型。


测试程序：
publicclass Mybatis_first {
	
	//会话工厂
	private SqlSessionFactory sqlSessionFactory;

	@Before
	publicvoid createSqlSessionFactory() throws IOException {
		// 配置文件
		String resource = "SqlMapConfig.xml";
		InputStream inputStream = Resources.getResourceAsStream(resource);

		// 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory
		sqlSessionFactory = new SqlSessionFactoryBuilder()
				.build(inputStream);

	}

	// 根据 id查询用户信息
	@Test
	publicvoid testFindUserById() {
		// 数据库会话实例
		SqlSession sqlSession = null;
		try {
			// 创建数据库会话实例sqlSession
			sqlSession = sqlSessionFactory.openSession();
			// 查询单个记录，根据用户id查询用户信息
			User user = sqlSession.selectOne("test.findUserById", 10);
			// 输出用户信息
			System.out.println(user);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (sqlSession != null) {
				sqlSession.close();
			}
		}

	}
}
根据用户名查询用户信息
映射文件：
在user.xml中添加：
	<!-- 自定义条件查询用户列表 -->
	<selectid="findUserByUsername"parameterType="java.lang.String"
			resultType="cn.itcast.mybatis.po.User">
	   select * from user where username like '%${value}%' 
	</select>

parameterType：定义输入到sql中的映射类型，${value}表示使用参数将${value}替换，做字符串的拼接。
注意：如果是取简单数量类型的参数，括号中的值必须为value
resultType：定义结果映射类型。


测试程序：
	// 根据用户名称模糊查询用户信息
	@Test
	publicvoid testFindUserByUsername() {
		// 数据库会话实例
		SqlSession sqlSession = null;
		try {
			// 创建数据库会话实例sqlSession
			sqlSession = sqlSessionFactory.openSession();
			// 查询单个记录，根据用户id查询用户信息
			List<User> list = sqlSession.selectList("test.findUserByUsername", "张");
			System.out.println(list.size());
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (sqlSession != null) {
				sqlSession.close();
			}
		}

	}

小结
#{}和${}
#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。

${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。


parameterType和resultType
parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。
resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。

selectOne和selectList

selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：
org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)

selectList可以查询一条或多条记录。

添加用户
映射文件：
在SqlMapConfig.xml中添加：
<!-- 添加用户 -->
	<insertid="insertUser"parameterType="cn.itcast.mybatis.po.User">
	  insert into user(username,birthday,sex,address) 
	  values(#{username},#{birthday},#{sex},#{address})
	</insert>

测试程序：
// 添加用户信息
	@Test
	publicvoid testInsert() {
		// 数据库会话实例
		SqlSession sqlSession = null;
		try {
			// 创建数据库会话实例sqlSession
			sqlSession = sqlSessionFactory.openSession();
			// 添加用户信息
			User user = new User();
			user.setUsername("张小明");
			user.setAddress("河南郑州");
			user.setSex("1");
			user.setPrice(1999.9f);
			sqlSession.insert("test.insertUser", user);
			//提交事务
			sqlSession.commit();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (sqlSession != null) {
				sqlSession.close();
			}
		}
	}
mysql自增主键返回
通过修改sql映射文件，可以将mysql自增主键返回：
<insertid="insertUser"parameterType="cn.itcast.mybatis.po.User">
		<!-- selectKey将主键返回，需要再返回 -->
		<selectKeykeyProperty="id"order="AFTER"resultType="java.lang.Integer">
			select LAST_INSERT_ID()
		</selectKey>
	   insert into user(username,birthday,sex,address)
	    values(#{username},#{birthday},#{sex},#{address});
	</insert>
添加selectKey实现将主键返回
keyProperty:返回的主键存储在pojo中的哪个属性
order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after
resultType:返回的主键是什么类型
LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。

Mysql使用 uuid实现主键

需要增加通过select uuid()得到uuid值

<insert id="insertUser" parameterType="cn.itcast.mybatis.po.User">
<selectKey resultType="java.lang.String" order="BEFORE"
keyProperty="id">
select uuid()
</selectKey>
insert into user(id,username,birthday,sex,address) 
		 values(#{id},#{username},#{birthday},#{sex},#{address})
</insert>
注意这里使用的order是“BEFORE”


删除用户
映射文件：

<!-- 删除用户 -->
	<deleteid="deleteUserById"parameterType="int">
		delete from user where id=#{id}
	</delete>


测试程序：

// 根据id删除用户
	@Test
	publicvoidtestDelete() {
		// 数据库会话实例
		SqlSession sqlSession = null;
		try {
			// 创建数据库会话实例sqlSession
			sqlSession = sqlSessionFactory.openSession();
			// 删除用户
			sqlSession.delete("test.deleteUserById",18);
			// 提交事务
			sqlSession.commit();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (sqlSession != null) {
				sqlSession.close();
			}
		}
	}
修改用户
映射文件

<!-- 更新用户 -->
	<updateid="updateUser"parameterType="cn.itcast.mybatis.po.User">
		update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}
		where id=#{id}
	</update>

测试程序

// 更新用户信息
	@Test
	publicvoidtestUpdate() {
		// 数据库会话实例
		SqlSession sqlSession = null;
		try {
			// 创建数据库会话实例sqlSession
			sqlSession = sqlSessionFactory.openSession();
			// 添加用户信息
			User user = new User();
			user.setId(16);
			user.setUsername("张小明");
			user.setAddress("河南郑州");
			user.setSex("1");
			user.setPrice(1999.9f);
			sqlSession.update("test.updateUser", user);
			// 提交事务
			sqlSession.commit();

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (sqlSession != null) {
				sqlSession.close();
			}
		}
	}


Mybatis解决jdbc编程的问题
1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。
解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。
2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。
3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。
4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。
解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。


mybatis与hibernate不同
Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。

Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。

Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 


Dao开发方法
	使用Mybatis开发Dao，通常有两个方法，即原始Dao开发方法和Mapper接口开发方法。

需求
将下边的功能实现Dao：
根据用户id查询一个用户信息
根据用户名称模糊查询用户信息列表
添加用户信息

SqlSession的使用范围
	SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。
通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。

SqlSessionFactoryBuilder
SqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory生产，所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。

SqlSessionFactory
	SqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。

SqlSession
	SqlSession是一个面向用户的接口， sqlSession中定义了数据库操作方法。
	每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。
	打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下：
	SqlSession session = sqlSessionFactory.openSession();
	try {
		 // do work
	} finally {
		session.close();
	}


原始Dao开发方式
	原始Dao开发方法需要程序员编写Dao接口和Dao实现类。
映射文件
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEmapper
PUBLIC"-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mappernamespace="test">
<!-- 根据id获取用户信息 -->
	<selectid="findUserById"parameterType="int"resultType="cn.itcast.mybatis.po.User">
		select * from user where id = #{id}
	</select>
<!-- 添加用户 -->
	<insertid="insertUser"parameterType="cn.itcast.mybatis.po.User">
	<selectKeykeyProperty="id"order="AFTER"resultType="java.lang.Integer">
		select LAST_INSERT_ID() 
	</selectKey>
	  insert into user(username,birthday,sex,address) 
	  values(#{username},#{birthday},#{sex},#{address})
	</insert>
</mapper>


Dao接口
Publicinterface UserDao {
	public User getUserById(int id) throws Exception;
	publicvoid insertUser(User user) throws Exception;
}

Publicclass UserDaoImpl implements UserDao {
	
	//注入SqlSessionFactory
	public UserDaoImpl(SqlSessionFactory sqlSessionFactory){
		this.setSqlSessionFactory(sqlSessionFactory);
	}
	
	private SqlSessionFactory sqlSessionFactory;
	@Override
	public User getUserById(int id) throws Exception {
		SqlSession session = sqlSessionFactory.openSession();
		User user = null;
		try {
			//通过sqlsession调用selectOne方法获取一条结果集
			//参数1：指定定义的statement的id,参数2：指定向statement中传递的参数
			user = session.selectOne("test.findUserById", 1);
			System.out.println(user);
						
		} finally{
			session.close();
		}
		return user;
	}
	
	@Override
	Publicvoid insertUser(User user) throws Exception {
		SqlSession sqlSession= sqlSessionFactory.openSession();
		try {
			sqlSession.insert("insertUser", user);
			sqlSession.commit();
		} finally{
			session.close();
		}
		
	}
}

Dao测试
创建一个JUnit的测试类，对UserDao进行测试。
private SqlSessionFactory sqlSessionFactory;
	
	@Before
	publicvoid init() throws Exception {
		SqlSessionFactoryBuilder sessionFactoryBuilder = new SqlSessionFactoryBuilder();
		InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");
		sqlSessionFactory = sessionFactoryBuilder.build(inputStream);
	}

	@Test
	publicvoidtestGetUserById() {
		UserDao userDao = new UserDaoImpl(sqlSessionFactory);
		User user = userDao.getUserById(22);
		System.out.println(user);
	}
}

问题
原始Dao开发中存在以下问题：
Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法
调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不得于开发维护。

Mapper动态代理方式	
开发规范
	Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。
Mapper接口开发需要遵循以下规范：
1、Mapper.xml文件中的namespace与mapper接口的类路径相同。
2、	Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 
3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同
4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同
Mapper.xml(映射文件)
	定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录 下。

<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEmapper
PUBLIC"-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mappernamespace="cn.itcast.mybatis.mapper.UserMapper">
<!-- 根据id获取用户信息 -->
	<selectid="findUserById"parameterType="int"resultType="cn.itcast.mybatis.po.User">
		select * from user where id = #{id}
	</select>
<!-- 自定义条件查询用户列表 -->
	<selectid="findUserByUsername"parameterType="java.lang.String"
			resultType="cn.itcast.mybatis.po.User">
	   select * from user where username like '%${value}%' 
	</select>
<!-- 添加用户 -->
	<insertid="insertUser"parameterType="cn.itcast.mybatis.po.User">
	<selectKeykeyProperty="id"order="AFTER"resultType="java.lang.Integer">
		select LAST_INSERT_ID() 
	</selectKey>
	  insert into user(username,birthday,sex,address) 
	  values(#{username},#{birthday},#{sex},#{address})
	</insert>

</mapper>

Mapper.java(接口文件)

/**
 * 用户管理mapper
 */
Publicinterface UserMapper {
	//根据用户id查询用户信息
	public User findUserById(int id) throws Exception;
	//查询用户列表
	public List<User> findUserByUsername(String username) throws Exception;
	//添加用户信息
	publicvoid insertUser(User user)throws Exception; 
}

接口定义有如下特点：
1、Mapper接口方法名和Mapper.xml中定义的statement的id相同
2、Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同
3、Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同

加载UserMapper.xml文件
修改SqlMapConfig.xml文件：

<!-- 加载映射文件 -->
<mappers>
<mapperresource="mapper/UserMapper.xml"/>
</mappers>


测试

Publicclass UserMapperTest extends TestCase {

	private SqlSessionFactory sqlSessionFactory;
	
	protectedvoid setUp() throws Exception {
		//mybatis配置文件
		String resource = "sqlMapConfig.xml";
		InputStream inputStream = Resources.getResourceAsStream(resource);
		//使用SqlSessionFactoryBuilder创建sessionFactory
		sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
	}

	
	Publicvoid testFindUserById() throws Exception {
		//获取session
		SqlSession session = sqlSessionFactory.openSession();
		//获取mapper接口的代理对象
		UserMapper userMapper = session.getMapper(UserMapper.class);
		//调用代理对象方法
		User user = userMapper.findUserById(1);
		System.out.println(user);
		//关闭session
		session.close();
		
	}
	@Test
	publicvoid testFindUserByUsername() throws Exception {
		SqlSession sqlSession = sqlSessionFactory.openSession();
		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
		List<User> list = userMapper.findUserByUsername("张");
		System.out.println(list.size());

	}
Publicvoid testInsertUser() throws Exception {
		//获取session
		SqlSession session = sqlSessionFactory.openSession();
		//获取mapper接口的代理对象
		UserMapper userMapper = session.getMapper(UserMapper.class);
		//要添加的数据
		User user = new User();
		user.setUsername("张三");
		user.setBirthday(new Date());
		user.setSex("1");
		user.setAddress("北京市");
		//通过mapper接口添加用户
		userMapper.insertUser(user);
		//提交
		session.commit();
		//关闭session
		session.close();
	}
	

}

小结
selectOne和selectList
动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。

namespace
mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。
SqlMapConfig.xml配置文件
配置内容
SqlMapConfig.xml中配置的内容和顺序如下：

properties（属性）
settings（全局配置参数）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境集合属性对象）
environment（环境子属性对象）
transactionManager（事务管理）
dataSource（数据源）
mappers（映射器）

properties（属性）

SqlMapConfig.xml可以引用java属性文件中的配置信息如下：

在classpath下定义db.properties文件，
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8
jdbc.username=root
jdbc.password=root


SqlMapConfig.xml引用如下：

<propertiesresource="db.properties"/>
	<environmentsdefault="development">
		<environmentid="development">
			<transactionManagertype="JDBC"/>
			<dataSourcetype="POOLED">
				<propertyname="driver"value="${jdbc.driver}"/>
				<propertyname="url"value="${jdbc.url}"/>
				<propertyname="username"value="${jdbc.username}"/>
				<propertyname="password"value="${jdbc.password}"/>
			</dataSource>
		</environment>
	</environments>

注意： MyBatis 将按照下面的顺序来加载属性：
在 properties 元素体内定义的属性首先被读取。 
然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 


typeAliases（类型别名）
mybatis支持别名：
别名	映射的类型
_byte 	byte 
_long 	long 
_short 	short 
_int 	int 
_integer 	int 
_double 	double 
_float 	float 
_boolean 	boolean 
string 	String 
byte 	Byte 
long 	Long 
short 	Short 
int 	Integer 
integer 	Integer 
double 	Double 
float 	Float 
boolean 	Boolean 
date 	Date 
decimal 	BigDecimal 
bigdecimal 	BigDecimal 
map	Map


自定义别名：
在SqlMapConfig.xml中配置：
<typeAliases>
	<!-- 单个别名定义 -->
	<typeAliasalias="user"type="cn.itcast.mybatis.po.User"/>
	<!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） -->
	<packagename="cn.itcast.mybatis.po"/>
	<packagename="其它包"/>
</typeAliases>


mappers（映射器）
Mapper配置的几种方法：
<mapper resource="" />
使用相对于类路径的资源
如：<mapper resource="sqlmap/User.xml" />

<mapper class="" />
使用mapper接口类路径
如：<mapper class="cn.itcast.mybatis.mapper.UserMapper"/>

注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。

<package name=""/>
注册指定包下的所有mapper接口
如：<package name="cn.itcast.mybatis.mapper"/>
注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。









Mybatis第二天

框架课程



课程计划
5、输入映射和输出映射
a)输入参数映射
b)返回值映射
6、动态sql
a)If
b)Where
c)Foreach
d)Sql片段
7、关联查询
a)一对一关联
b)一对多关联
8、Mybatis整合spring

输入映射和输出映射
Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。

parameterType(输入类型)
传递简单类型
参考第一天内容。
传递pojo对象

Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。

传递pojo包装对象

	开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。
Pojo类中包含pojo。

需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。

QueryVo
publicclass QueryVo {

	private User user;

	public User getUser() {
		returnuser;
	}

	publicvoid setUser(User user) {
		this.user = user;
	}
	
	
}

Sql语句
SELECT * FROM user where username like '%刘%'

Mapper文件
<!-- 使用包装类型查询用户 
		使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性
	-->
	<selectid="findUserByQueryVo"parameterType="queryvo"resultType="user">
		SELECT * FROM user where username like '%${user.username}%'
	</select>

接口

测试方法
@Test
	publicvoidtestFindUserByQueryVo() throws Exception {
		SqlSession sqlSession = sessionFactory.openSession();
		//获得mapper的代理对象
		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
		//创建QueryVo对象
		QueryVo queryVo = new QueryVo();
		//创建user对象
		User user = new User();
		user.setUsername("刘");
		queryVo.setUser(user);
		//根据queryvo查询用户
		List<User> list = userMapper.findUserByQueryVo(queryVo);
		System.out.println(list);
		sqlSession.close();
	}

resultType(输出类型)
输出简单类型
参考getnow输出日期类型，看下边的例子输出整型：

Mapper.xml文件
<!-- 获取用户列表总数 -->
	<selectid="findUserCount"parameterType="user"resultType="int">
	   select count(1) from user
	</select>

Mapper接口
public int findUserCount(User user) throws Exception;

调用：

Publicvoid testFindUserCount() throws Exception{
		//获取session
		SqlSession session = sqlSessionFactory.openSession();
		//获取mapper接口实例
		UserMapper userMapper = session.getMapper(UserMapper.class);
	
		User user = new User();
		user.setUsername("管理员");

		//传递Hashmap对象查询用户列表
		intcount = userMapper.findUserCount(user);
		
		//关闭session
		session.close();
	}

输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。
使用session的selectOne可查询单条记录。


输出pojo对象
参考第一天内容
输出pojo列表
参考第一天内容。
resultMap
	resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。
	如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系，resultMap实质上还需要将查询结果映射到pojo对象中。
	resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。
	
Mapper.xml定义


使用resultMap指定上边定义的personmap。

定义resultMap
由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：userListResultMap将sql查询列和Users.java类属性对应起来



<id />：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个<id />。
Property：表示User类的属性。
Column：表示sql查询出来的字段名。
Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。

<result />：普通结果，即pojo的属性。


Mapper接口定义

public List<User>findUserListResultMap() throws Exception;



动态sql
通过mybatis提供的各种标签方法实现动态拼接sql。

If
<!-- 传递pojo综合查询用户信息 -->
	<selectid="findUserList"parameterType="user"resultType="user">
		select * from user 
		where 1=1 
		<iftest="id!=null">
		and id=#{id}
		</if>
		<iftest="username!=null and username!=''">
		and username like '%${username}%'
		</if>
	</select>

注意要做不等于空字符串校验。


Where
上边的sql也可以改为：

<selectid="findUserList"parameterType="user"resultType="user">
		select * from user 
		<where>
		<iftest="id!=null and id!=''">
		and id=#{id}
		</if>
		<iftest="username!=null and username!=''">
		and username like '%${username}%'
		</if>
		</where>
	</select>

<where />可以自动处理第一个and。


foreach

向sql传递数组或List，mybatis使用foreach解析，如下：

需求
传入多个id查询用户信息，用下边两个sql实现：

SELECT * FROM USERS WHERE username LIKE '%张%' AND (id =10 OR id =89 OR id=16)
SELECT * FROM USERS WHERE username LIKE '%张%'  id IN (10,89,16)

在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法


mapper.xml

<iftest="ids!=null and ids.size>0">
		<foreachcollection="ids"open=" and id in("close=")"item="id"separator=",">
			#{id}
		</foreach>
</if>


测试代码：

List<Integer> ids = new ArrayList<Integer>();
		ids.add(1);//查询id为1的用户
		ids.add(10); //查询id为10的用户
		queryVo.setIds(ids);
		List<User> list = userMapper.findUserList(queryVo);




Sql片段

Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：

<!-- 传递pojo综合查询用户信息 -->
	<selectid="findUserList"parameterType="user"resultType="user">
		select * from user 
		<where>
		<iftest="id!=null and id!=''">
		and id=#{id}
		</if>
		<iftest="username!=null and username!=''">
		and username like '%${username}%'
		</if>
		</where>
	</select>

将where条件抽取出来：

<sqlid="query_user_where">
	<iftest="id!=null and id!=''">
		and id=#{id}
	</if>
	<iftest="username!=null and username!=''">
		and username like '%${username}%'
	</if>
</sql>

使用include引用：

<selectid="findUserList"parameterType="user"resultType="user">
		select * from user 
		<where>
		<includerefid="query_user_where"/>
		</where>
	</select>

注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：
<includerefid="namespace.sql片段”/>





关联查询

商品订单数据模型


一对一查询
案例：查询所有订单信息，关联查询下单用户信息。

注意：因为一个订单信息只会是一个人下的订单，所以从查询订单信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的订单信息则为一对多查询，因为一个用户可以下多个订单。

方法一：
使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：

Sql语句：

SELECT 
  orders.*,
  user.username,
  userss.address
FROM
  orders,
user
WHERE orders.user_id = user.id


定义po类
Po类中应该包括上边sql查询出来的所有字段，如下：

publicclass OrdersCustom extends Orders {

	private String username;// 用户名称
	private String address;// 用户地址
get/set。。。。

OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。

Mapper.xml

<!-- 查询所有订单信息 -->
	<selectid="findOrdersList"resultType="cn.itcast.mybatis.po.OrdersCustom">
	SELECT
	orders.*,
	user.username,
	user.address
	FROM
	orders,	user
	WHERE orders.user_id = user.id 
	</select>

Mapper接口：
public List<OrdersCustom> findOrdersList() throws Exception;

测试：

Publicvoid testfindOrdersList()throws Exception{
		//获取session
		SqlSession session = sqlSessionFactory.openSession();
		//获限mapper接口实例
		UserMapper userMapper = session.getMapper(UserMapper.class);
		//查询订单信息
		List<OrdersCustom> list = userMapper.findOrdersList();
		System.out.println(list);
		//关闭session
		session.close();
	}

小结：
	定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。
方法二：
使用resultMap，定义专门的resultMap用于映射一对一查询结果。

Sql语句：

SELECT 
  orders.*,
  user.username,
  user.address
FROM
  orders,
user
WHERE orders.user_id = user.id
定义po类
	在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。

Mapper.xml
<!-- 查询订单关联用户信息使用resultmap -->
	<resultMaptype="Orders"id="orderUserResultMap">
		<idcolumn="id"property="id"/>
		<resultcolumn="user_id"property="userId"/>
		<resultcolumn="number"property="number"/>
		<resultcolumn="createtime"property="createtime"/>
		<resultcolumn="note"property="note"/>
		<!-- 一对一关联映射 -->
		<!-- 
		property:Orders对象的user属性
		javaType：user属性对应 的类型
		 -->
		<association property="user"javaType="cn.itcast.po.User">
			<!-- column:user表的主键对应的列  property：user对象中id属性-->
			<idcolumn="user_id"property="id"/>
			<resultcolumn="username"property="username"/>
			<resultcolumn="address"property="address"/>
		</association>
	</resultMap>
	<selectid="findOrdersWithUserResultMap"resultMap="orderUserResultMap">
		SELECT
			o.id,
			o.user_id,
			o.number,
			o.createtime,
			o.note,
			u.username,
			u.address
		FROM
			orders o
		JOIN `user` u ON u.id = o.user_id
	</select>

这里resultMap指定orderUserResultMap。

association：表示进行关联查询单条记录
property：表示关联查询的结果存储在cn.itcast.mybatis.po.Orders的user属性中
javaType：表示关联查询的结果类型
<idproperty="id"column="user_id"/>：查询结果的user_id列对应关联对象的id属性，这里是<id />表示user_id是关联查询对象的唯一标识。
<resultproperty="username"column="username"/>：查询结果的username列对应关联对象的username属性。

Mapper接口：
public List<Orders> findOrdersListResultMap() throws Exception;

测试：

Publicvoid testfindOrdersListResultMap()throws Exception{
		//获取session
		SqlSession session = sqlSessionFactory.openSession();
		//获限mapper接口实例
		UserMapper userMapper = session.getMapper(UserMapper.class);
		//查询订单信息
		List<Orders> list = userMapper.findOrdersList2();
		System.out.println(list);
		//关闭session
		session.close();
	}

小结：
使用association完成关联查询，将关联查询信息映射到pojo对象中。

一对多查询

案例：查询所有用户信息及用户关联的订单信息。

用户信息和订单信息为一对多关系。

使用resultMap实现如下：

Sql语句：

SELECT
	u.*, o.id oid,
	o.number,
	o.createtime,
	o.note
FROM
	`user` u
LEFT JOIN orders o ON u.id = o.user_id
定义po类
在User类中加入List<Orders> orders属性


Mapper.xml
<resultMaptype="user"id="userOrderResultMap">
		<!-- 用户信息映射 -->
		<idproperty="id"column="id"/>
		<resultproperty="username"column="username"/>
		<resultproperty="birthday"column="birthday"/>
		<resultproperty="sex"column="sex"/>
		<resultproperty="address"column="address"/>
		<!-- 一对多关联映射 -->
		<collectionproperty="orders"ofType="orders">
			<idproperty="id"column="oid"/>	
		<!--用户id已经在user对象中存在，此处可以不设置-->
			<!-- <result property="userId" column="id"/> -->
			<resultproperty="number"column="number"/>
			<resultproperty="createtime"column="createtime"/>
			<resultproperty="note"column="note"/>
		</collection>
	</resultMap>
	<selectid="getUserOrderList"resultMap="userOrderResultMap">
		SELECT
		u.*, o.id oid,
		o.number,
		o.createtime,
		o.note
		FROM
		`user` u
		LEFT JOIN orders o ON u.id = o.user_id
	</select>
	

collection部分定义了用户关联的订单信息。表示关联查询结果集
property="orders"：关联查询的结果集存储在User对象的上哪个属性。
ofType="orders"：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。
<id />及<result/>的意义同一对一查询。
Mapper接口：
List<User> getUserOrderList();
测试
@Test
	publicvoidgetUserOrderList() {
		SqlSession session = sqlSessionFactory.openSession();
		UserMapper userMapper = session.getMapper(UserMapper.class);
		List<User>result = userMapper.getUserOrderList();
		for (User user : result) {
			System.out.println(user);
		}
		session.close();
	}


Mybatis整合spring
整合思路
1、SqlSessionFactory对象应该放到spring容器中作为单例存在。
2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。
3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。
4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。

整合需要的jar包
1、spring的jar包
2、Mybatis的jar包
3、Spring+mybatis的整合包。
4、Mysql的数据库驱动jar包。
5、数据库连接池的jar包。


整合的步骤
第一步：创建一个java工程。
第二步：导入jar包。（上面提到的jar包）
第三步：mybatis的配置文件sqlmapConfig.xml
第四步：编写Spring的配置文件
1、数据库连接及连接池
2、事务管理（暂时可以不配置）
3、sqlsessionFactory对象，配置到spring容器中
4、mapeer代理对象或者是dao实现类配置到spring容器中。
第五步：编写dao或者mapper文件
第六步：测试。
SqlMapConfig.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEconfiguration
PUBLIC"-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<typeAliases>
		<packagename="cn.itcast.mybatis.pojo"/>
	</typeAliases>
	<mappers>
		<mapperresource="sqlmap/User.xml"/>
	</mappers>
</configuration>

applicationContext.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">

	<!-- 加载配置文件 -->
	<context:property-placeholderlocation="classpath:db.properties"/>
	<!-- 数据库连接池 -->
	<beanid="dataSource"class="org.apache.commons.dbcp.BasicDataSource"
		destroy-method="close">
		<propertyname="driverClassName"value="${jdbc.driver}"/>
		<propertyname="url"value="${jdbc.url}"/>
		<propertyname="username"value="${jdbc.username}"/>
		<propertyname="password"value="${jdbc.password}"/>
		<propertyname="maxActive"value="10"/>
		<propertyname="maxIdle"value="5"/>
	</bean>
	<!-- mapper配置 -->
	<!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 -->
	<beanid="sqlSessionFactory"class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 数据库连接池 -->
		<propertyname="dataSource"ref="dataSource"/>
		<!-- 加载mybatis的全局配置文件 -->
		<propertyname="configLocation"value="classpath:mybatis/SqlMapConfig.xml"/>
	</bean>

</beans>

db.properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8
jdbc.username=root
jdbc.password=root



Dao的开发
三种dao的实现方式：
1、传统dao的开发方式
2、使用mapper代理形式开发方式
3、使用扫描包配置mapper代理。

传统dao的开发方式
接口+实现类来完成。需要dao实现类需要继承SqlsessionDaoSupport类

Dao实现类

publicclass UserDaoImpl extends SqlSessionDaoSupport implements UserDao {

	@Override
	public User findUserById(int id) throws Exception {
		SqlSession session = getSqlSession();
		User user = session.selectOne("test.findUserById", id);
		//不能关闭SqlSession，让spring容器来完成
		//session.close();
		return user;
	}

	@Override
	publicvoid insertUser(User user) throws Exception {
		SqlSession session = getSqlSession();
		session.insert("test.insertUser", user);
		session.commit();
		//session.close();
	}

}


配置dao
把dao实现类配置到spring容器中
<!-- 配置UserDao实现类 -->
	<beanid="userDao"class="cn.itcast.dao.UserDaoImpl">
		<propertyname="sqlSessionFactory"ref="sqlSessionFactory"/>
	</bean>
测试方法
@Test
	publicvoid testFindUserById() throws Exception {
		UserDao userDao = (UserDao) applicationContext.getBean("userDao");
		User user = userDao.findUserById(1);
		System.out.println(user);
	}

Mapper代理形式开发dao
开发mapper接口
开发mapper文件


配置mapper代理
<!-- 配置mapper代理对象 -->
	<beanclass="org.mybatis.spring.mapper.MapperFactoryBean">
		<propertyname="mapperInterface"value="cn.itcast.mybatis.mapper.UserMapper"/>
		<propertyname="sqlSessionFactory"ref="sqlSessionFactory"></property>
	</bean>
测试方法
publicclass UserMapperTest {

	private ApplicationContext applicationContext;
	@Before
	publicvoid setUp() throws Exception {
		applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext.xml");
	}

	@Test
	publicvoid testGetUserById() {
		UserMapper userMapper = applicationContext.getBean(UserMapper.class);
		User user = userMapper.getUserById(1);
		System.out.println(user);
	}

}

扫描包形式配置mapper
<!-- 使用扫描包的形式来创建mapper代理对象 -->
	<beanclass="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<propertyname="basePackage"value="cn.itcast.mybatis.mapper"></property>
	</bean>
每个mapper代理对象的id就是类名，首字母小写






Mybatis

逆向工程
































Mybatis逆向工程
使用官方网站的mapper自动生成工具mybatis-generator-core-1.3.2来生成po类和mapper映射文件。

作用:mybatis官方提供逆向工程,可以使用它通过数据库中的表来自动生成Mapper接口和映射文件(单表增删改查)和Po类.

导入的jar包有:


第一步：mapper生成配置文件：
在generatorConfig.xml中配置mapper生成的详细信息，注意改下几点：

1、添加要生成的数据库表
2、po文件所在包路径
3、mapper文件所在包路径

配置文件如下：
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
	<context id="testTables" targetRuntime="MyBatis3">
		<commentGenerator>
			<!-- 是否去除自动生成的注释 true：是 ： false:否 -->
			<property name="suppressAllComments" value="true" />
		</commentGenerator>
		<!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->
		<jdbcConnection driverClass="com.mysql.jdbc.Driver"
			connectionURL="jdbc:mysql://localhost:3306/mybatis" userId="root"
			password="admin">
		</jdbcConnection>
		<!-- <jdbcConnection driverClass="oracle.jdbc.OracleDriver"
			connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg" 
			userId="yycg"
			password="yycg">
		</jdbcConnection> -->

		<!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 
			NUMERIC 类型解析为java.math.BigDecimal -->
		<javaTypeResolver>
			<property name="forceBigDecimals" value="false" />
		</javaTypeResolver>

		<!-- targetProject:生成PO类的位置 -->
		<javaModelGenerator targetPackage="cn.itcast.ssm.po"
			targetProject=".\src">
			<!-- enableSubPackages:是否让schema作为包的后缀 -->
			<property name="enableSubPackages" value="false" />
			<!-- 从数据库返回的值被清理前后的空格 -->
			<property name="trimStrings" value="true" />
		</javaModelGenerator>
        <!-- targetProject:mapper映射文件生成的位置 -->
		<sqlMapGenerator targetPackage="cn.itcast.ssm.mapper" 
			targetProject=".\src">
			<!-- enableSubPackages:是否让schema作为包的后缀 -->
			<property name="enableSubPackages" value="false" />
		</sqlMapGenerator>
		<!-- targetPackage：mapper接口生成的位置 -->
		<javaClientGenerator type="XMLMAPPER"
			targetPackage="cn.itcast.ssm.mapper" 
			targetProject=".\src">
			<!-- enableSubPackages:是否让schema作为包的后缀 -->
			<property name="enableSubPackages" value="false" />
		</javaClientGenerator>
		<!-- 指定数据库表 -->
		<table tableName="items"></table>
		<table tableName="orders"></table>
		<table tableName="orderdetail"></table>
		<table tableName="user"></table>
		<!-- <table schema="" tableName="sys_user"></table>
		<table schema="" tableName="sys_role"></table>
		<table schema="" tableName="sys_permission"></table>
		<table schema="" tableName="sys_user_role"></table>
		<table schema="" tableName="sys_role_permission"></table> -->
		
		<!-- 有些表的字段需要指定java类型
		 <table schema="" tableName="">
			<columnOverride column="" javaType="" />
		</table> -->
	</context>
</generatorConfiguration>


第二步：使用java类生成mapper文件：

Public void generator() throws Exception{
		List<String> warnings = new ArrayList<String>();
		boolean overwrite = true;
		File configFile = new File("generatorConfig.xml"); 
		ConfigurationParser cp = new ConfigurationParser(warnings);
		Configuration config = cp.parseConfiguration(configFile);
		DefaultShellCallback callback = new DefaultShellCallback(overwrite);
		MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
				callback, warnings);
		myBatisGenerator.generate(null);
	}
	Public static void main(String[] args) throws Exception {
		try {
			GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();
			generatorSqlmap.generator();
		} catch (Exception e) {
			e.printStackTrace();
		}
}



第三步：拷贝生成的mapper文件到工程中指定的目录中
Mapper.xml
Mapper.xml的文件拷贝至mapper目录内
Mapper.java
Mapper.java的文件拷贝至mapper 目录内


注意：mapper xml文件和mapper.java文件在一个目录内且文件名相同。


第四步Mapper接口测试

学会使用mapper自动生成的增、删、改、查方法。

//删除符合条件的记录
int deleteByExample(UserExample example);
//根据主键删除
int deleteByPrimaryKey(String id);
//插入对象所有字段
int insert(User record);
//插入对象不为空的字段
int insertSelective(User record);
//自定义查询条件查询结果集
List<User> selectByExample(UserExample example);
//根据主键查询
UserselectByPrimaryKey(String id);
//根据主键将对象中不为空的值更新至数据库
int updateByPrimaryKeySelective(User record);
//根据主键将对象中所有字段的值更新至数据库
int updateByPrimaryKey(User record);


逆向工程注意事项
Mapper文件内容不覆盖而是追加
XXXMapper.xml文件已经存在时，如果进行重新生成则mapper.xml文件内容不被覆盖而是进行内容追加，结果导致mybatis解析失败。
解决方法：删除原来已经生成的mapper xml文件再进行生成。
Mybatis自动生成的po及mapper.java文件不是内容而是直接覆盖没有此问题。

Table schema问题
下边是关于针对oracle数据库表生成代码的schema问题：

Schma即数据库模式，oracle中一个用户对应一个schema，可以理解为用户就是schema。
当Oralce数据库存在多个schema可以访问相同的表名时，使用mybatis生成该表的mapper.xml将会出现mapper.xml内容重复的问题，结果导致mybatis解析错误。
解决方法：在table中填写schema，如下：
<table schema="XXXX" tableName=" " >
XXXX即为一个schema的名称，生成后将mapper.xml的schema前缀批量去掉，如果不去掉当oracle用户变更了sql语句将查询失败。
快捷操作方式：mapper.xml文件中批量替换：“from XXXX.”为空

Oracle查询对象的schema可从dba_objects中查询，如下：
select * from dba_objects






















讲师：传智.黑马























课程安排
1.介绍
2.安装启动及关闭
3.Jedis使用
4.Redis各种数据类型的操作
5.Redis持久化方案
6.主从复制(了解)
课程目标
掌握Redis的安装
掌握redis常用数据结构(string/hash/list/sortedset)的存取数据方法
掌握Jedis的用法

redis介绍
什么是NoSQL
	NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。随着互联网web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。而传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如： 
1、High performance - 对数据库高并发读写的需求 
web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。
2、Huge Storage - 对海量数据的高效率存储和访问的需求 
类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。 
3、High Scalability && High Availability- 对数据库的高可扩展性和高可用性的需求 
在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？ 

	NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。

一些主流的NOSQL产品：



NoSQL数据库的四大分类如下：

键值(Key-Value)存储数据库
相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB
典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 
数据模型： 一系列键值对
优势： 快速查询
劣势： 存储的数据缺少结构化

列存储数据库
相关产品：Cassandra, HBase, Riak
典型应用：分布式的文件系统
数据模型：以列簇式存储，将同一列数据存在一起
优势：查找速度快，可扩展性强，更容易进行分布式扩展
 劣势：功能相对局限
文档型数据库
相关产品：CouchDB、MongoDB
典型应用：Web应用（与Key-Value类似，Value是结构化的）
数据模型： 一系列键值对
 优势：数据结构要求不严格
 劣势： 查询性能不高，而且缺乏统一的查询语法
图形(Graph)数据库
相关数据库：Neo4J、InfoGrid、Infinite Graph
典型应用：社交网络
数据模型：图结构
优势：利用图结构相关算法。
劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。


redis历史发展
	2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人 Salvatore Sanfilippo便 对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。 不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。
	Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁网、知乎网，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。
	VMware公司从2010年开始赞助Redis的开发， Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。

什么是redis
	Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如
下：
字符串类型
散列类型
列表类型
集合类型
有序集合类型。
redis的应用场景
缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）
分布式集群架构中的session分离。
聊天室的在线好友列表。
任务队列。（秒杀、抢购、12306等等）
应用排行榜。
网站访问统计。
数据过期处理（可以精确到毫秒）

测试环境
	redis需要安装在linux服务器上运行测试，本教程使用 linux虚拟机及ssh客户端进行功能测试。
虚拟机
创建Centos6.4虚拟机作为linux服务器。

虚拟机ip：192.168.93.88


ssh客户端
在开发环境(windows)安装ssh客户端，本教程使用SecureCRT作为ssh客户端连接虚拟机。

安装运行redis


redis安装环境
	redis是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。
	安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++
redis安装
版本说明
	本教程使用redis3.0版本。3.0版本主要增加了redis集群功能。
	
源码下载
	从官网下载 
	http://download.redis.io/releases/redis-3.0.0.tar.gz
	将redis-3.0.0.tar.gz拷贝到/usr/local下
	
	
解压源码
   tar -zxvf redis-3.0.0.tar.gz  
进入解压后的目录进行编译
	cd /usr/local/redis-3.0.0
	make
安装到指定目录,如 /usr/local/redis
	cd /usr/local/redis-3.0.0 
	make PREFIX=/usr/local/redis install

redis.conf
redis.conf是redis的配置文件，redis.conf在redis源码目录。
注意修改port作为redis进程的端口,port默认6379。


拷贝配置文件到安装目录下	
	进入源码目录，里面有一份配置文件 redis.conf，然后将其拷贝到安装路径下 
	cd /usr/local/redis
	mkdir conf
	cp /usr/local/redis-3.0.0/redis.conf  /usr/local/redis/bin


安装目录bin下的文件列表





redis3.0新增的redis-sentinel是redis集群管理工具可实现高可用。


配置文件目录：




redis启动
前端模式启动
	直接运行bin/redis-server将以前端模式启动，前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法。如下图：




后端模式启动
修改redis.conf配置文件， daemonize yes 以后端模式启动。

执行如下命令启动redis：
cd /usr/local/redis
./bin/redis-server ./redis.conf

redis默认使用6379端口。

也可更改redis.conf文件，修改端口号：


启动多个redis进程
方法1：
启动时指定端口可在一台服务器启动多个redis进程。
cd /usr/local/redis/bin
./redis-server ./redis.conf --port 6380

方法2(推荐此方法)：
创建多个redis目录，以端口号命名，比如：创建6379、6380两个目录，将redis的安装文件bin和conf拷贝至这两个目录。
修改6379目录下的redis.conf设置端口号为6379
修改6380目录下的redis.conf设置端口号为6380
启动6379和6380目录下的redis-server程序：
cd 6379
./redis-server . /redis.conf
cd 6380
./redis-server . /redis.conf


查询当前redis的进程：


redis停止
强行终止Redis进程可能会导致redis持久化数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为：

cd /usr/local/redis
./bin/redis-cli shutdown

redis客户端
	在redis的安装目录中有redis的客户端，即redis-cli（Redis Command Line Interface），它是Redis自带的基于命令行的Redis客户端。
	
连接redis服务端
执行bin/redis-cli连接redis服务端：
	
从上图得知redis-cli默认连接本机的redis，本机的redis没有启动则报上图中的错误。

指定连接redis服务的ip和端口：



向redis服务端发送命令	
redis-cli连上redis服务后，可以在命令行发送命令。

ping
Redis提供了PING命令来测试客户端与Redis的连接是否正常，如果连接正常会收到回复PONG

set/get

使用set和get可以向redis设置数据、获取数据。



del
删除指定key的内容。
例如：del name

Keys *
查看当前库中所有的key值

redis多数据库
redis实例
	一个redis进程就是一个redis实例，一台服务器可以同时有多个redis实例，不同的redis实例提供不同的服务端口对外提供服务，每个redis实例之间互相影响。每个redis实例都包括自己的数据库，数据库中可以存储自己的数据。 

多数据库测试
	一个Redis实例可以包括多个数据库，客户端可以指定连接某个redis实例的哪个数据库，就好比一个mysql中创建多个数据库，客户端连接时指定连接哪个数据库。
	一个redis实例最多可提供16个数据库，下标从0到15，客户端默认连接第0号数据库，也可以通过select选择连接哪个数据库，如下连接1号库： 


在1号库中查询上节设置的数据，结果查询不到：


重新选择第0号数据库，查询数据：


如果选择一个不存在数据库则会报错：

注意：redis不支持修改数据库的名称，只能通过select 0、select 1...选择数据库。


注意问题
在0号数据库存储数据，在1号数据库执行清空数据命令却把0号数据库的数据给清空了：


建议：不同的应用系统要使用不同的redis实例而不是使用同一个redis实例下的不同数据库。



jedis

jedis介绍
	Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。 
	在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。 
Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis 


通过jedis连接redis单机

jar包
pom坐标：
	<dependency>
	    	<groupId>redis.clients</groupId>
	    	<artifactId>jedis</artifactId>
	    	<version>2.7.0</version>
		</dependency>

jar包如下：

单实例连接
通过创建单实例jedis对象连接redis服务，如下代码：
// 单实例连接redis
	@Test
	public void testJedisSingle() {

		Jedis jedis = new Jedis("192.168.101.3", 6379);
		jedis.set("name", "bar");
		String name = jedis.get("name");
		System.out.println(name);
		jedis.close();

	}
连接超时解决
由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。
关闭防火墙命令：sevice iptables stop
如果是修改防火墙规则，可以修改：/etc/sysconfig/iptables文件
使用连接池连接
	通过单实例连接redis不能对redis连接进行共享，可以使用连接池对redis连接进行共享，提高资源利用率，使用jedisPool连接redis服务，如下代码：

	@Test
	public void pool() {
		JedisPoolConfig config = new JedisPoolConfig();
		//最大连接数
		config.setMaxTotal(30);
		//最大连接空闲数
		config.setMaxIdle(2);
		
		JedisPool pool = new JedisPool(config, "192.168.101.3", 6379);
		Jedis jedis = null;

		try  {
			jedis = pool.getResource();
			
			jedis.set("name", "lisi");
			String name = jedis.get("name");
			System.out.println(name);
		}catch(Exception ex){
			ex.printStackTrace();
		}finally{
			if(jedis != null){
				//关闭连接
				jedis.close();
			}
		}
		
	}

详细的连接池配置参数参考下节jedis和spring整合中applicationContext.xml的配置内容。

jedis与spring整合
配置spring配置文件applicationContext.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-3.2.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd 
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd ">

<!-- 连接池配置 -->
	<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">
		<!-- 最大连接数 -->
		<property name="maxTotal" value="30" />
		<!-- 最大空闲连接数 -->
		<property name="maxIdle" value="10" />
		<!-- 每次释放连接的最大数目 -->
		<property name="numTestsPerEvictionRun" value="1024" />
		<!-- 释放连接的扫描间隔（毫秒） -->
		<property name="timeBetweenEvictionRunsMillis" value="30000" />
		<!-- 连接最小空闲时间 -->
		<property name="minEvictableIdleTimeMillis" value="1800000" />
		<!-- 连接空闲多久后释放, 当空闲时间>该值 且 空闲连接>最大空闲连接数 时直接释放 -->
		<property name="softMinEvictableIdleTimeMillis" value="10000" />
		<!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 -->
		<property name="maxWaitMillis" value="1500" />
		<!-- 在获取连接的时候检查有效性, 默认false -->
		<property name="testOnBorrow" value="true" />
		<!-- 在空闲时检查有效性, 默认false -->
		<property name="testWhileIdle" value="true" />
		<!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true -->
		<property name="blockWhenExhausted" value="false" />
	</bean>
	
	<!-- redis单机 通过连接池 -->
	<bean id="jedisPool" class="redis.clients.jedis.JedisPool" destroy-method="close">
		<constructor-arg name="poolConfig" ref="jedisPoolConfig"/>
		<constructor-arg name="host" value="192.168.25.145"/>
		<constructor-arg name="port" value="6379"/>
	</bean>
</beans>

测试代码：
private ApplicationContext applicationContext;

	@Before
	public void init() {
		applicationContext = new ClassPathXmlApplicationContext(
				"classpath:applicationContext.xml");
	}

	@Test
	public void testJedisPool() {
	JedisPool pool = (JedisPool) applicationContext.getBean("jedisPool");
			try  {
			Jedis jedis = pool.getResource();
			
			jedis.set("name", "lisi");
			String name = jedis.get("name");
			System.out.println(name);
		}catch(Exception ex){
			ex.printStackTrace();
		}finally{
			if(jedis != null){
				//关闭连接
				jedis.close();
			}
		}
	}



数据类型--string
redis string介绍
	redis中没有使用C语言的字符串表示，而是自定义一个数据结构叫SDS（simple dynamic string）即简单动态字符串。
打开下载的redis源码包，找到src下的sds.h文件查看sds源码：

struct sdshdr {
    //字符串长度
	unsigned int len;
	//buf数组中未使用的字节数量
    unsigned int free;
	//用于保存字符串
    char buf[];
};
	
	c语言对字符串的存储是使用字符数组，遇到'\0'字符则认为字符串结束，redis的字符串可以存储任何类型的数据，因为任何类型数据都可以表示成二进制，sds结构中的char buf[]就是存储了二进制数据。
	redis的字符串是二进制安全的，什么是二进制安全？简单理解就是存入什么数据取出的还是什么数据。redis中的sds不像c语言处理字符串那样遇到'\0'字符则认证字符串结束，它不会对存储进去的二进制数据进行处理，存入什么数据取出还是什么数据。


命令

赋值
SET key value
127.0.0.1:6379> set test 123
OK
取值
赋值与取值： 
GET key
127.0.0.1:6379> get test
"123“
当键不存在时返回空结果。
-------------------
GETSET key value
取值时同时对key进行赋值操作。
删除
Del key
127.0.0.1:6379> del test
(integer) 1
数值增减
递增数字 
INCR key
当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。 
127.0.0.1:6379> incr num
(integer) 1
127.0.0.1:6379> incr num
(integer) 2
127.0.0.1:6379> incr num
(integer) 3 

增加指定的整数 
INCRBY key increment
示例： 
127.0.0.1:6379> incrby num 2
(integer) 5
127.0.0.1:6379> incrby num 2
(integer) 7
127.0.0.1:6379> incrby num 2
(integer) 9 

递减数值
DECR key



其它命令(自学)
减少指定的整数 
DECRBY key decrement
示例： 
127.0.0.1:6379> decr num
(integer) 6
127.0.0.1:6379> decr num
(integer) 5
127.0.0.1:6379> decrby num 3
(integer) 2
127.0.0.1:6379> decrby num 3
(integer) -1 


向尾部追加值 
APPEND key value
APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 
127.0.0.1:6379> set str hello
OK
127.0.0.1:6379> append str " world!"
(integer) 12
127.0.0.1:6379> get str 
"hello world!"


获取字符串长度 
STRLEN key
STRLEN命令返回键值的长度，如果键不存在则返回0。 
127.0.0.1:6379> strlen str 
(integer) 0
127.0.0.1:6379> set str hello
OK
127.0.0.1:6379> strlen str 
(integer) 5

同时设置/获取多个键值 
MSET key value [key value …]
MGET key [key …]
127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3
OK
127.0.0.1:6379> get k1
"v1"
127.0.0.1:6379> mget k1 k3
1) "v1"
2) "v3"



应用
自增主键
商品编号、订单号采用string的递增数字特性生成。

定义商品编号key：items:id
192.168.101.3:7003> INCR items:id
(integer) 2
192.168.101.3:7003> INCR items:id
(integer) 3

java代码参考测试工程。


数据类型--hash
使用string的问题
	假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 
保存、更新： 
User对象  json(string)  redis 
如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。

redis hash介绍
	hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下：



思考：redis hash存储比关系数据库的好处？




命令
赋值
HSET key field value	一次只能设置一个字段值
127.0.0.1:6379> hset user username zhangsan 
(integer) 1
-----------------------------
HMSET key field value [field value ...]		一次可以设置多个字段值
127.0.0.1:6379> hmset user age 20 username lisi 
OK


取值 
HGET key field			一次只能获取一个字段值
127.0.0.1:6379> hget user username
"zhangsan“
----------------------------
HMGET key field [field ...]				一次可以获取多个字段值
127.0.0.1:6379> hmget user age username
1) "20"
2) "lisi"
----------------------------
HGETALL key
127.0.0.1:6379> hgetall user
1) "age"
2) "20"
3) "username"
4) "lisi"
HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0.



删除字段
可以删除一个或多个字段，返回值是被删除的字段个数 
HDEL key field [field ...]
127.0.0.1:6379> hdel user age
(integer) 1
127.0.0.1:6379> hdel user age name
(integer) 0
127.0.0.1:6379> hdel user age username
(integer) 1 


增加数字 
HINCRBY key field increment
127.0.0.1:6379> hincrby user age 2	将用户的年龄加2
(integer) 22
127.0.0.1:6379> hget user age		获取用户的年龄
"22“

其它命令(自学)
判断字段是否存在
HEXISTS key field
127.0.0.1:6379> hexists user age		查看user中是否有age字段
(integer) 1
127.0.0.1:6379> hexists user name	查看user中是否有name字段
(integer) 0

HSETNX key field value
当字段不存在时赋值，类似HSET，区别在于如果字段已经存在，该命令不执行任何操作。 
127.0.0.1:6379> hsetnx user age 30	如果user中没有age字段则设置age值为30，否则不做任何操作
(integer) 0

只获取字段名或字段值 
HKEYS key
HVALS key
127.0.0.1:6379> hmset user age 20 name lisi 
OK
127.0.0.1:6379> hkeys user
1) "age"
2) "name"
127.0.0.1:6379> hvals user
1) "20"
2) "lisi"

获取字段数量 
HLEN key
127.0.0.1:6379> hlen user
(integer) 2


应用
商品信息
商品id、商品名称、商品描述、商品库存、商品好评

定义商品信息的key：
商品1001的信息在 redis中的key为：items:1001

存储商品信息
192.168.101.3:7003> HMSET items:1001 id 3 name apple price 999.9
OK

获取商品信息
192.168.101.3:7003> HGET items:1001 id
"3"
192.168.101.3:7003> HGETALL items:1001
1) "id"
2) "3"
3) "name"
4) "apple"
5) "price"
6) "999.9"

java代码参考测试工程。


数据类型--list
ArrayList与LinkedList的区别
	ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。 
	LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。






redis list介绍
	列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。
	列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。


命令
向列表两端增加元素。 
LPUSH key value [value ...]
RPUSH key value [value ...]
向列表左边增加元素 
127.0.0.1:6379> lpush list:1 1 2 3
(integer) 3
向列表右边增加元素 
127.0.0.1:6379> rpush list:1 4 5 6
(integer) 3

查看列表 
LRANGE key start stop
LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 
127.0.0.1:6379> lrange list:1 0 2
1) "2"
2) "1"
3) "4"


从列表两端弹出元素 
LPOP key
RPOP key
LPOP命令从列表左边弹出一个元素，会分两步完成，第一步是将列表左边的元素从列表中移除，第二步是返回被移除的元素值。 
127.0.0.1:6379> lpop list:1
"3“
127.0.0.1:6379> rpop list:1
"6“

获取列表中元素的个数 
LLEN key
127.0.0.1:6379> llen list:1
(integer) 2


其它命令(自学)
删除列表中指定的值 
LREM key count value
LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 
当count>0时， LREM会从列表左边开始删除。 
当count<0时， LREM会从列表后边开始删除。 
当count=0时， LREM删除所有值为value的元素。 

获得/设置指定索引的元素值 
LINDEX key index
LSET key index value
127.0.0.1:6379> lindex l:list 2
"1"
127.0.0.1:6379> lset l:list 2 2
OK
127.0.0.1:6379> lrange l:list 0 -1
1) "6"
2) "5"
3) "2"
4) "2"

只保留列表指定片段，指定范围和LRANGE一致 
LTRIM key start stop
127.0.0.1:6379> lrange l:list 0 -1
1) "6"
2) "5"
3) "0"
4) "2"
127.0.0.1:6379> ltrim l:list 0 2
OK
127.0.0.1:6379> lrange l:list 0 -1
1) "6"
2) "5"
3) "0"

向列表中插入元素 
LINSERT key BEFORE|AFTER pivot value
该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 
127.0.0.1:6379> lrange list 0 -1
1) "3"
2) "2"
3) "1"
127.0.0.1:6379> linsert list after 3 4
(integer) 4
127.0.0.1:6379> lrange list 0 -1
1) "3"
2) "4"
3) "2"
4) "1"


将元素从一个列表转移到另一个列表中 
RPOPLPUSH source destination
127.0.0.1:6379> rpoplpush list newlist 
"1"
127.0.0.1:6379> lrange newlist 0 -1
1) "1"
127.0.0.1:6379> lrange list 0 -1
1) "3"
2) "4"
3) "2" 


应用
商品评论列表
思路：
在redis中创建商品评论列表
用户发布商品评论，将评论信息转成json存储到list中。
用户在页面查询评论列表，从redis中取出json数据展示到页面。

定义商品评论列表key：
商品编号为1001的商品评论key：items: comment:1001
192.168.101.3:7001> LPUSH items:comment:1001 '{"id":1,"name":"商品不错，很好！！","date":1430295077289}'

java代码参考测试工程。


数据类型--set
redis set介绍
在集合中的每个元素都是不同的，且没有顺序。

集合类型和列表类型的对比：

	集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 
Redis还提供了多个集合之间的交集、并集、差集的运算。
命令
增加/删除元素 
SADD key member [member ...]
SREM key member [member ...]
127.0.0.1:6379> sadd set a b c
(integer) 3
127.0.0.1:6379> sadd set a
(integer) 0
127.0.0.1:6379> srem set c d
(integer) 1

获得集合中的所有元素 
SMEMBERS key
127.0.0.1:6379> smembers set
1) "b"
2) "a”
判断元素是否在集合中，无论集合中有多少元素都可以极速的返回结果。 
SISMEMBER key member
127.0.0.1:6379> sismember set a
(integer) 1
127.0.0.1:6379> sismember set h
(integer) 0

其它命令

集合的差集运算 A-B
属于A并且不属于B的元素构成的集合。 

SDIFF key [key ...]
127.0.0.1:6379> sadd setA 1 2 3
(integer) 3
127.0.0.1:6379> sadd setB 2 3 4
(integer) 3
127.0.0.1:6379> sdiff setA setB 
1) "1"
127.0.0.1:6379> sdiff setB setA 
1) "4"

集合的交集运算 A ∩ B
属于A且属于B的元素构成的集合。 

SINTER key [key ...]
127.0.0.1:6379> sinter setA setB 
1) "2"
2) "3"

集合的并集运算 A ∪ B
属于A或者属于B的元素构成的集合


SUNION key [key ...]
127.0.0.1:6379> sunion setA setB
1) "1"
2) "2"
3) "3"
4) "4"

其它命令(自学)
获得集合中元素的个数 
SCARD key
127.0.0.1:6379> smembers setA 
1) "1"
2) "2"
3) "3"
127.0.0.1:6379> scard setA 
(integer) 3
从集合中弹出一个元素 
SPOP key
127.0.0.1:6379> spop setA 
"1“
注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 




数据类型--sorted set
redis sorted set介绍
	在集合类型的基础上有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 
在某些方面有序集合和列表类型有些相似。 
1、二者都是有序的。 
2、二者都可以获得某一范围的元素。 
但是，二者有着很大区别： 
1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 
2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 
3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 
4、有序集合要比列表类型更耗内存。 

命令
增加元素
	向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 
ZADD key score member [score member ...]
127.0.0.1:6379> zadd scoreboard 80 zhangsan 89 lisi 94 wangwu 
(integer) 3
127.0.0.1:6379> zadd scoreboard 97 lisi 
(integer) 0
获取元素的分数 
ZSCORE key member
127.0.0.1:6379> zscore scoreboard lisi 
"97"

删除元素
ZREM key member [member ...]
移除有序集key中的一个或多个成员，不存在的成员将被忽略。
当key存在但不是有序集类型时，返回一个错误。

127.0.0.1:6379> zrem scoreboard lisi
(integer) 1

获得排名在某个范围的元素列表
获得排名在某个范围的元素列表 
ZRANGE key start stop [WITHSCORES]			照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379> zrange scoreboard 0 2
1) "zhangsan"
2) "wangwu"
3) "lisi“

ZREVRANGE key start stop [WITHSCORES]		照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379> zrevrange scoreboard 0 2
1) " lisi "
2) "wangwu"
3) " zhangsan “


如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 
127.0.0.1:6379> zrange scoreboard 0 1 WITHSCORES
1) "zhangsan"
2) "80"
3) "wangwu"
4) "94"



其它命令(自学)
获得指定分数范围的元素 
ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
127.0.0.1:6379> ZRANGEBYSCORE scoreboard 90 97 WITHSCORES
1) "wangwu"
2) "94"
3) "lisi"
4) "97"
127.0.0.1:6379> ZRANGEBYSCORE scoreboard 70 100 limit 1 2
1) "wangwu"
2) "lisi"

增加某个元素的分数，返回值是更改后的分数。 
ZINCRBY  key increment member
给lisi加4分 
127.0.0.1:6379> ZINCRBY scoreboard  4 lisi 
"101“


获得集合中元素的数量 
ZCARD key
127.0.0.1:6379> ZCARD scoreboard
(integer) 3
获得指定分数范围内的元素个数 
ZCOUNT key min max
127.0.0.1:6379> ZCOUNT scoreboard 80 90
(integer) 1

按照排名范围删除元素 
ZREMRANGEBYRANK key start stop
127.0.0.1:6379> ZREMRANGEBYRANK scoreboard 0 1
(integer) 2 
127.0.0.1:6379> ZRANGE scoreboard 0 -1
1) "lisi"
ZREMRANGEBYSCORE key min max
按照分数范围删除元素 
127.0.0.1:6379> zadd scoreboard 84 zhangsan	
(integer) 1
127.0.0.1:6379> ZREMRANGEBYSCORE scoreboard 80 100
(integer) 1

获取元素的排名 
ZRANK key member
ZREVRANK key member
从小到大 
127.0.0.1:6379> ZRANK scoreboard lisi 
(integer) 0
从大到小 
127.0.0.1:6379> ZREVRANK scoreboard zhangsan 
(integer) 1


应用
商品销售排行榜
根据商品销售量对商品进行排行显示，定义sorted set集合，商品销售量为元素的分数。

定义商品销售排行榜key：items:sellsort

写入商品销售量：
商品编号1001的销量是9，商品编号1002的销量是10
192.168.101.3:7007> ZADD items:sellsort 9 1001 10 1002

商品编号1001的销量加1
192.168.101.3:7001> ZINCRBY items:sellsort 1 1001

商品销量前10名：
192.168.101.3:7001> ZRANGE items:sellsort 0 9 withscores

java代码参考测试工程。


keys命令
设置key的生存时间
Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。 

EXPIRE key seconds			设置key的生存时间（单位：秒）key在多少秒后会自动删除
TTL key 					查看key生于的生存时间
PERSIST key				清除生存时间 
PEXPIRE key milliseconds	生存时间设置单位为：毫秒 

例子：
192.168.101.3:7002> set test 1		设置test的值为1
OK
192.168.101.3:7002> get test			获取test的值
"1"
192.168.101.3:7002> EXPIRE test 5	设置test的生存时间为5秒
(integer) 1
192.168.101.3:7002> TTL test			查看test的生于生成时间还有1秒删除
(integer) 1
192.168.101.3:7002> TTL test
(integer) -2
192.168.101.3:7002> get test			获取test的值，已经删除
(nil)

其它命令（自学）

keys
返回满足给定pattern 的所有key
redis 127.0.0.1:6379> keys mylist*
1) "mylist"
2) "mylist5"
3) "mylist6"
4) "mylist7"
5) "mylist8"

exists
确认一个key 是否存在
redis 127.0.0.1:6379> exists HongWan
(integer) 0
redis 127.0.0.1:6379> exists age
(integer) 1
redis 127.0.0.1:6379>
从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的
del
删除一个key
redis 127.0.0.1:6379> del age
(integer) 1
redis 127.0.0.1:6379> exists age
(integer) 0
redis 127.0.0.1:6379>
从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的

rename
重命名key
redis 127.0.0.1:6379[1]> keys *
1) "age"
redis 127.0.0.1:6379[1]> rename age age_new
OK
redis 127.0.0.1:6379[1]> keys *
1) "age_new"
redis 127.0.0.1:6379[1]>
age 成功的被我们改名为age_new 了

type
返回值的类型
redis 127.0.0.1:6379> type addr
string
redis 127.0.0.1:6379> type myzset2
zset
redis 127.0.0.1:6379> type mylist
list
redis 127.0.0.1:6379>
这个方法可以非常简单的判断出值的类型

服务器命令(自学)

ping
测试连接是否存活
redis 127.0.0.1:6379> ping
PONG
//执行下面命令之前，我们停止redis 服务器
redis 127.0.0.1:6379> ping
Could not connect to Redis at 127.0.0.1:6379: Connection refused
//执行下面命令之前，我们启动redis 服务器
not connected> ping
PONG
redis 127.0.0.1:6379>
第一个ping 时，说明此连接正常
第二个ping 之前，我们将redis 服务器停止，那么ping 是失败的
第三个ping 之前，我们将redis 服务器启动，那么ping 是成功的

echo
在命令行打印一些内容
redis 127.0.0.1:6379> echo HongWan
"HongWan"
redis 127.0.0.1:6379>
select
选择数据库。Redis 数据库编号从0~15，我们可以选择任意一个数据库来进行数据的存取。
redis 127.0.0.1:6379> select 1
OK
redis 127.0.0.1:6379[1]> select 16
(error) ERR invalid DB index
redis 127.0.0.1:6379[16]>
当选择16 时，报错，说明没有编号为16 的这个数据库

quit
退出连接。
redis 127.0.0.1:6379> quit

dbsize
返回当前数据库中key 的数目。
redis 127.0.0.1:6379> dbsize
(integer) 18
redis 127.0.0.1:6379>
结果说明此库中有18 个key
info
获取服务器的信息和统计。
redis 127.0.0.1:6379> info
redis_version:2.2.12
redis_git_sha1:00000000
redis_git_dirty:0
arch_bits:32
multiplexing_api:epoll
process_id:28480
uptime_in_seconds:2515
uptime_in_days:0
。。。。
。。。。

flushdb
删除当前选择数据库中的所有key。
redis 127.0.0.1:6379> dbsize
(integer) 18
redis 127.0.0.1:6379> flushdb
OK
redis 127.0.0.1:6379> dbsize
(integer) 0
redis 127.0.0.1:6379>
在本例中我们将0 号数据库中的key 都清除了。

flushall
删除所有数据库中的所有key。
redis 127.0.0.1:6379[1]> dbsize
(integer) 1
redis 127.0.0.1:6379[1]> select 0
OK
redis 127.0.0.1:6379> flushall
OK
redis 127.0.0.1:6379> select 1
OK
redis 127.0.0.1:6379[1]> dbsize
(integer) 0
redis 127.0.0.1:6379[1]>
在本例中我们先查看了一个1 号数据库中有一个key，然后我切换到0 号库执行flushall 命令，结果1 号库中的key 也被清除了，说是此命令工作正常。


持久化(了解)
	Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。
	Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。
RDB持久化
	RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。
	RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：
save 900 1
save 300 10
save 60 10000

	save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。

在redis.conf中：
	配置dir指定rdb快照文件的位置
	配置dbfilenam指定rdb快照文件的名称


	Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。

	问题总结：
	通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。

AOF持久化
	默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：
appendonly yes
开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬
盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof


主从复制（了解）
什么是主从复制

	持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图：



说明：
主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。
主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。
只有一个主redis，可以有多个从redis。
主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求
一个redis可以即是主又是从，如下图：





主从配置
主redis配置
无需特殊配置。

从redis配置
修改从redis服务器上的redis.conf文件，添加slaveof 主redisip  主redis端口


上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379

主从复制过程
完整复制
在redis2.8版本之前主从复制过程如下图：



复制过程说明：

1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。
2、master启动一个后台进程将数据库快照保存到RDB文件中
注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。
3、master 就发送RDB文件给slave
4、slave 将文件保存到磁盘上，然后加载到内存恢复
5、master把缓存的命令转发给slave
注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。
当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。

完整复制的问题：

在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。

部分复制



部分复制说明：
从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。







Spring web mvc
框架课程






课程计划
第一天
1、Springmvc介绍
2、入门程序
3、Springmvc架构讲解
a)框架结构
b)组件说明
4、Springmvc整合mybatis
5、参数绑定
a)Springmvc默认支持的类型
b)简单数据类型
c)Pojo类型
d)Pojo包装类型
e)自定义参数绑定
6、Springmvc和struts2的区别
第二天
1、高级参数绑定
a)数组类型的参数绑定
b)List类型的绑定
2、@RequestMapping注解的使用
3、Controller方法返回值
4、Springmvc中异常处理
5、图片上传处理
6、Json数据交互
7、Springmvc实现Restful
8、拦截器

















Spring web mvc介绍
Springmvc是什么？
Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,我们可以从Spring的整体结构中看得出来：

SpringMVC处理流程













入门程序
开发环境
本教程使用环境：
Jdk：jdk1.7.0_72
Eclipse：mars
Tomcat：apache-tomcat-7.0.53
Springmvc：4.1.3
需求
使用springmvc实现商品列表的展示。
需求分析
请求的url：/itemList.action
参数：无
数据：静态数据
开发步骤
第一步：创建一个javaweb工程
第二步：导入jar包

第三步：创建itemList.jsp

把参考资料中的itemList.jsp复制到工程的/WEB-INF/jsp目录下。
第四步：创建ItemsController
ItemController是一个普通的java类，不需要实现任何接口，只需要在类上添加@Controller注解即可。@RequestMapping注解指定请求的url，其中“.action”可以加也可以不加。在ModelAndView对象中，将视图设置为“/WEB-INF/jsp/itemList.jsp”
@Controller
publicclass ItemController {

	@RequestMapping("/itemList")
	public ModelAndView itemList() throws Exception {
		
		List<Items>itemList = new ArrayList<>();
		
		//商品列表
		Items items_1 = new Items();
		items_1.setName("联想笔记本_3");
		items_1.setPrice(6000f);
		items_1.setDetail("ThinkPad T430 联想笔记本电脑！");
		
		Items items_2 = new Items();
		items_2.setName("苹果手机");
		items_2.setPrice(5000f);
		items_2.setDetail("iphone6苹果手机！");
		
		itemList.add(items_1);
		itemList.add(items_2);
		//创建modelandView对象
		ModelAndView modelAndView = new ModelAndView();
		//添加model
		modelAndView.addObject("itemList", itemList);
		//添加视图
		modelAndView.setViewName("/WEB-INF/jsp/itemList.jsp");
//		modelAndView.setViewName("itemsList");	
		returnmodelAndView;
	}

}

商品数据使用Items类描述，可以使用参考资料中提供的pojo类，

第五步：创建springmvc.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">

	<context:component-scanbase-package="cn.itcast.springmvc.controller"/>
	
</beans>

第六步：配置前端控制器
在web.xml中添加DispatcherServlet的配置。
<!-- 前端控制器 -->
<servlet>
	<servlet-name>springmvc</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:springmvc.xml</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>springmvc</servlet-name>
	<url-pattern>*.action</url-pattern>
</servlet-mapping>



Springmvc架构
框架结构

























架构流程
1、用户发送请求至前端控制器DispatcherServlet
2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器
5、执行处理器(Controller，也叫后端控制器)。
6、Controller执行完成返回ModelAndView
7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet
8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器
9、ViewReslover解析后返回具体View
10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。
11、DispatcherServlet响应用户

组件说明
以下组件通常使用框架提供实现：
DispatcherServlet：前端控制器
用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。
HandlerMapping：处理器映射器
HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。
Handler：处理器
Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。
由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。

HandlAdapter：处理器适配器
通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。



View Resolver：视图解析器
View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 
View：视图
springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。
一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。

说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。
需要用户开放的组件有handler、view

框架默认加载组件





注解映射器和适配器
组件扫描器
	使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用<context:component-scan>自动扫描标记@controller的控制器类，配置如下：

<!-- 扫描controller注解,多个包中间使用半角逗号分隔 -->
	<context:component-scanbase-package="cn.itcast.springmvc.controller.first"/>


RequestMappingHandlerMapping
	注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 

从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。

配置如下：

<!--注解映射器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
	

注解描述：
@RequestMapping：定义请求url到处理器功能方法的映射


RequestMappingHandlerAdapter
注解式处理器适配器，对标记@ResquestMapping的方法进行适配。

从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。

配置如下：
<!--注解适配器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/>

<mvc:annotation-driven>
springmvc使用<mvc:annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<mvc:annotation-driven>替代注解处理器和适配器的配置。
视图解析器
在springmvc.xml文件配置如下：

	<beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<propertyname="viewClass"
			value="org.springframework.web.servlet.view.JstlView"/>
		<propertyname="prefix"value="/WEB-INF/jsp/"/>
		<propertyname="suffix"value=".jsp"/>
	</bean>

InternalResourceViewResolver：支持JSP视图解析
viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。
prefix 和suffix：查找视图页面的前缀和后缀，最终视图的址为：
前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp”
整合mybatis
	为了更好的学习 springmvc和mybatis整合开发的方法，需要将springmvc和mybatis进行整合。

整合目标：控制层采用springmvc、持久层使用mybatis实现。

需求
实现商品查询列表，从mysql数据库查询商品信息。
jar包
包括：spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。
参考：“mybatis与springmvc整合全部jar包”目录 
工程搭建
整合思路
Dao层：
1、SqlMapConfig.xml，空文件即可。需要文件头。
2、applicationContext-dao.xml。
a)数据库连接池
b)SqlSessionFactory对象，需要spring和mybatis整合包下的。
c)配置mapper文件扫描器。
Service层：
1、applicationContext-service.xml包扫描器，扫描@service注解的类。
2、applicationContext-trans.xml配置事务。
表现层：
Springmvc.xml
1、包扫描器，扫描@Controller注解的类。
2、配置注解驱动。
3、视图解析器
Web.xml
配置前端控制器。
sqlMapConfig.xml
在classpath下创建mybatis/sqlMapConfig.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEconfiguration
PUBLIC"-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
</configuration>

applicationContext-dao.xml
配置数据源、配置SqlSessionFactory、mapper扫描器。
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">

	<!-- 加载配置文件 -->
	<context:property-placeholderlocation="classpath:db.properties"/>
	<!-- 数据库连接池 -->
	<beanid="dataSource"class="org.apache.commons.dbcp.BasicDataSource"
		destroy-method="close">
		<propertyname="driverClassName"value="${jdbc.driver}"/>
		<propertyname="url"value="${jdbc.url}"/>
		<propertyname="username"value="${jdbc.username}"/>
		<propertyname="password"value="${jdbc.password}"/>
		<propertyname="maxActive"value="10"/>
		<propertyname="maxIdle"value="5"/>
	</bean>
	<!-- mapper配置 -->
	<!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 -->
	<beanid="sqlSessionFactory"class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 数据库连接池 -->
		<propertyname="dataSource"ref="dataSource"/>
		<!-- 加载mybatis的全局配置文件 -->
		<propertyname="configLocation"value="classpath:mybatis/SqlMapConfig.xml"/>
	</bean>
	<!-- 配置Mapper扫描器 -->
	<beanclass="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<propertyname="basePackage"value="cn.itcast.springmvc.mapper"/>
	</bean>

</beans>

Db.properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/springmvc?characterEncoding=utf-8
jdbc.username=root
jdbc.password=root
applicationContext-service.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">

	<context:component-scanbase-package="cn.itcast.springmvc.service"/>

</beans>
applicationContext-transaction.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">
	<!-- 事务管理器 -->
	<beanid="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<!-- 数据源 -->
		<propertyname="dataSource"ref="dataSource"/>
	</bean>
	<!-- 通知 -->
	<tx:adviceid="txAdvice"transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 传播行为 -->
			<tx:methodname="save*"propagation="REQUIRED"/>
			<tx:methodname="insert*"propagation="REQUIRED"/>
			<tx:methodname="delete*"propagation="REQUIRED"/>
			<tx:methodname="update*"propagation="REQUIRED"/>
			<tx:methodname="find*"propagation="SUPPORTS"read-only="true"/>
			<tx:methodname="get*"propagation="SUPPORTS"read-only="true"/>
		</tx:attributes>
	</tx:advice>
	<!-- 切面 -->
	<aop:config>
		<aop:advisoradvice-ref="txAdvice"
			pointcut="execution(* cn.itcast.springmvc.service.*.*(..))"/>
	</aop:config>
</beans>
springmvc.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">

	<!-- 扫描带Controller注解的类 -->
	<context:component-scanbase-package="cn.itcast.springmvc.controller"/>
	<!-- 加载注解驱动 -->
	<mvc:annotation-driven/>
	<!-- 视图解析器 -->
	<beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<propertyname="viewClass"
			value="org.springframework.web.servlet.view.JstlView"/>
		<!-- jsp前缀 -->
		<propertyname="prefix"value="/WEB-INF/jsp/"/>
		<!-- jsp后缀 -->
		<propertyname="suffix"value=".jsp"/>
	</bean>
</beans>

web.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<web-appxmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	id="WebApp_ID"version="2.5">
	<display-name>springmvc-web</display-name>
	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
		<welcome-file>index.htm</welcome-file>
		<welcome-file>index.jsp</welcome-file>
		<welcome-file>default.html</welcome-file>
		<welcome-file>default.htm</welcome-file>
		<welcome-file>default.jsp</welcome-file>
	</welcome-file-list>
	<!-- 加载spring容器 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:spring/applicationContext-*.xml</param-value>
	</context-param>
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
	
	<servlet>
		<servlet-name>springmvc</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:spring/springmvc.xml</param-value>
		</init-param>
	</servlet>
	<servlet-mapping>
		<servlet-name>springmvc</servlet-name>
		<url-pattern>*.action</url-pattern>
	</servlet-mapping>
</web-app>

Dao
mybatis逆向工程。
Service
1、Service由spring管理
2、spring对Service进行事务控制。
ItemService接口
publicinterface ItemService {

	List<Items> getItemsList();
}


ItemServiceImpl实现类
@Service
publicclass ItemServiceImpl implements ItemService {

	@Autowired
	private ItemMapper itemMapper;
	
	@Override
	public List<Items> getItemsList() {
		List<Items>itemList = itemMapper.getItemList();
		returnitemList;
	}

}

Controller
@Controller
publicclass ItemController {

	@Autowired
	private ItemService itemService;
	
	@RequestMapping("/itemList")
	public ModelAndView getItemList() {
		List<Items>list = itemService.getItemsList();
		ModelAndView modelAndView = new ModelAndView();
		modelAndView.addObject("itemList", list);
		modelAndView.setViewName("itemList");
		returnmodelAndView;
	}
}

测试
访问：http://localhost:8080/springmvc-web/itemList.action


参数绑定
绑定简单数据类型
需求
打开商品编辑页面，展示商品信息。
需求分析
编辑商品信息，需要根据商品id查询商品信息，然后展示到页面。
请求的url：/itemEdit.action
参数：id（商品id）
响应结果：商品编辑页面，展示商品详细信息。

Service
@Override
	public Items getItemById(intid) {
		Items items = itemMapper.getItemById(id);
		returnitems;
	}



Controller参数绑定
要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。
@RequestMapping("/itemEdit")
	publicModelAndView itemEdit(HttpServletRequest request) {
		//从Request中取id
		String strId = request.getParameter("id");
		Integer id = null;
		//如果id有值则转换成int类型
		if (strId != null&& !"".equals(strId)) {
			id = newInteger(strId);
		} else {
			//出错
			returnnull;
		}
		Items items = itemService.getItemById(id);
		//创建ModelAndView
		ModelAndView modelAndView = new ModelAndView();
		//向jsp传递数据
		modelAndView.addObject("item", items);
		//设置跳转的jsp页面
		modelAndView.setViewName("editItem");
		returnmodelAndView;
	}
如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。
默认支持的参数类型
处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。
HttpServletRequest
通过request对象获取请求信息
HttpServletResponse
通过response处理响应信息
HttpSession
通过session对象得到session中存放的对象
Model/ModelMap
ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：

//调用service查询商品信息
Items item = itemService.findItemById(id);
model.addAttribute("item", item);

页面通过${item.XXXX}获取item对象的属性值。
使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。
如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。
如果使用Model则方法可以改造成：
@RequestMapping("/itemEdit")
	publicString itemEdit(HttpServletRequest request, Model model) {
		//从Request中取id
		String strId = request.getParameter("id");
		Integer id = null;
		//如果id有值则转换成int类型
		if (strId != null&& !"".equals(strId)) {
			id = newInteger(strId);
		} else {
			//出错
			returnnull;
		}
		Items items = itemService.getItemById(id);
		//创建ModelAndView
		//ModelAndView modelAndView = new ModelAndView();
		//向jsp传递数据
		//modelAndView.addObject("item", items);
		model.addAttribute("item", items);
		//设置跳转的jsp页面
		//modelAndView.setViewName("editItem");
		//return modelAndView;
		return"editItem";
	}


绑定简单类型
当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。
@RequestMapping("/itemEdit")
	public String itemEdit(Integer id, Model model) {
		Items items = itemService.getItemById(id);
		//向jsp传递数据
		model.addAttribute("item", items);
		//设置跳转的jsp页面
		return"editItem";
	}

支持的数据类型
参数类型推荐使用包装数据类型，因为基础数据类型不可以为null
整形：Integer、int
字符串：String
单精度：Float、float
双精度：Double、double
布尔型：Boolean、boolean
说明：对于布尔类型的参数，请求的参数值为true或false。
处理器方法：
public String editItem(Model model,Integer id,Boolean status) throws Exception
请求url：
http://localhost:8080/xxx.action?id=2&status=false
@RequestParam 
使用@RequestParam常用于处理简单类型的绑定。

value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入；
required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；
TTP Status 400 - Required Integer parameter 'XXXX' is not present

defaultValue：默认值，表示如果请求中没有同名参数时的默认值

定义如下：
public String editItem(@RequestParam(value="item_id",required=true) String id) {
	
}

形参名称为id，但是这里使用value="item_id"限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。
注意：如果请求参数中没有item_id将跑出异常：
HTTP Status 500 - Required Integer parameter 'item_id' is not present

这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值

绑定pojo类型


需求
将页面修改后的商品信息保存到数据库中。
需求分析
请求的url：/updateitem.action
参数：表单中的数据。
响应内容：更新成功页面
使用pojo接收表单数据
如果提交的参数很多，或者提交的表单中的内容很多的时候可以使用pojo接收数据。要求pojo对象中的属性名和表单中input的name属性一致。
页面定义如下;

<input type="text" name="name"/>
<input type="text" name="price"/>

Pojo定义：


请求的参数名称和pojo的属性名称一致，会自动将请求参数赋值给pojo的属性。

@RequestMapping("/updateitem")
	public String updateItem(Items items) {
		itemService.updateItem(items);
		return"success";
	}

注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。

解决post乱码问题
在web.xml中加入：
<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

以上可以解决post请求乱码问题。
对于get请求中文参数出现乱码解决方法有两个：

修改tomcat配置文件添加编码与工程编码一致，如下：

<Connector URIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>

另外一种方法对参数进行重新编码：
String userName new 
String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")

ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码

绑定包装pojo
需求
使用包装的pojo接收商品信息的查询条件。

需求分析
包装对象定义如下：
PublicclassQueryVo {
privateItemsitems;

}

页面定义：

<input type="text" name="items.name" />
<input type="text" name="items.price" />

Controller方法定义如下：

public String useraddsubmit(Model model,QueryVoqueryVo)throws Exception{
System.out.println(queryVo.getItems());

接收查询条件
@RequestMapping("/queryitem")
	public String queryItem(QueryVo queryVo) {
		System.out.println(queryVo.getItems().getName());
		System.out.println(queryVo.getItems().getPrice());
		returnnull;
	}

自定义参数绑定
需求
在商品修改页面可以修改商品的生产日期，并且根据业务需求自定义日期格式。
需求分析
	由于日期数据有很多种格式，所以springmvc没办法把字符串转换成日期类型。所以需要自定义参数绑定。前端控制器接收到请求后，找到注解形式的处理器适配器，对RequestMapping标记的方法进行适配，并对方法中的形参进行参数绑定。在springmvc这可以在处理器适配器上自定义Converter进行参数绑定。如果使用<mvc:annotation-driven/>可以在此标签上进行扩展。

自定义Converter
publicclass DateConverter implements Converter<String, Date> {

	@Override
	public Date convert(String source) {
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try {
			returnsimpleDateFormat.parse(source);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		returnnull;
	}
}

配置Converter


	<!-- 加载注解驱动 -->
	<mvc:annotation-drivenconversion-service="conversionService"/>
	<!-- 转换器配置 -->
	<beanid="conversionService"
		class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
		<propertyname="converters">
			<set>
				<beanclass="cn.itcast.springmvc.convert.DateConverter"/>
			</set>
		</property>
	</bean>

配置方式2（了解）

<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">

	<!-- 扫描带Controller注解的类 -->
	<context:component-scanbase-package="cn.itcast.springmvc.controller"/>
	
	<!-- 转换器配置 -->
	<beanid="conversionService"
		class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
		<propertyname="converters">
			<set>
				<beanclass="cn.itcast.springmvc.convert.DateConverter"/>
			</set>
		</property>
	</bean>
	<!-- 自定义webBinder -->
	<beanid="customBinder"	class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer">
		<propertyname="conversionService"ref="conversionService"/>
	</bean>
	<!--注解适配器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
		<propertyname="webBindingInitializer"ref="customBinder"></property>
	</bean>
	<!-- 注解处理器映射器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
	<!-- 加载注解驱动 -->
	<!-- <mvc:annotation-driven/> -->
	<!-- 视图解析器 -->
	<beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<propertyname="viewClass"
			value="org.springframework.web.servlet.view.JstlView"/>
		<!-- jsp前缀 -->
		<propertyname="prefix"value="/WEB-INF/jsp/"/>
		<!-- jsp后缀 -->
		<propertyname="suffix"value=".jsp"/>
	</bean>
</beans>
注意：此方法需要独立配置处理器映射器、适配器，不再使用<mvc:annotation-driven/>
springmvc与struts2不同
1、springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。
2、springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。
3、Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。







Spring web mvc
框架课程










课程计划
9、高级参数绑定
a)数组类型的参数绑定
b)List类型的绑定
10、@RequestMapping注解的使用
11、Controller方法返回值
12、Springmvc中异常处理
13、图片上传处理
14、Json数据交互
15、Springmvc实现Restful
16、拦截器

高级参数绑定
绑定数组
需求
在商品列表页面选中多个商品，然后删除。
需求分析
此功能要求商品列表页面中的每个商品前有一个checkbook，选中多个商品后点击删除按钮把商品id传递给Controller，根据商品id删除商品信息。
Jsp中实现：
<c:forEach items="${itemList }" var="item">
<tr>
	<td><input name="ids" value="${item.id}" type="checkbox"></td>
	<td>${item.name }</td>
	<td>${item.price }</td>
	<td><fmt:formatDate value="${item.createtime}" pattern="yyyy-MM-dd HH:mm:ss"/></td>
	<td>${item.detail }</td>
	<td><a href="${pageContext.request.contextPath }/itemEdit.action?id=${item.id}">修改</a></td>
</tr>
</c:forEach>
生成html代码如下：
页面选中多个checkbox向controller方法传递
<table width="100%" border=1>
<tr>
	<td>商品名称</td>
	<td>商品价格</td>
	<td>生产日期</td>
	<td>商品描述</td>
	<td>操作</td>
</tr>
<tr>
	<td><input name="ids" value="1" type="checkbox"></td>
	<td>台式机</td>
	<td>3000.0</td>
	<td>2016-02-03 13:22:53</td>
	<td></td>
	<td><a href="/springmvc-web/itemEdit.action?id=1">修改</a></td>
</tr>
<tr>
	<td><input name="ids" value="2" type="checkbox"></td>
	<td>笔记本</td>
	<td>6000.0</td>
	<td>2015-02-09 13:22:57</td>
	<td></td>
	<td><a href="/springmvc-web/itemEdit.action?id=2">修改</a></td>
</tr>
<tr>
	<td><input name="ids" value="3" type="checkbox"></td>
	<td>背包</td>
	<td>200.0</td>
	<td>2015-02-06 13:23:02</td>
	<td></td>
	<td><a href="/springmvc-web/itemEdit.action?id=3">修改</a></td>
</tr>
</table>

Controller
Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。
定义如下：
@RequestMapping("/queryitem")
	public String queryItem(QueryVo queryVo, String[] ids) {
		System.out.println(queryVo.getItems().getName());
		System.out.println(queryVo.getItems().getPrice());
		System.out.println(ids.toString());
		return null;
	}
或者：

查看结果：

将表单的数据绑定到List
需求
实现商品数据的批量修改。
需求分析
要想实现商品数据的批量修改，需要在商品列表中可以对商品信息进行修改，并且可以批量提交修改后的商品数据。

接收商品列表的pojo
List中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。

Jsp改造
页面定义如下：


<tr>
<td>
<input type="text" name=" itemsList[0].id" value="${item.id}"/>
</td>
<td>
<input type="text" name=" itemsList[0].name" value="${item.name }"/>
</td>
<td>
<input type="text" name=" itemsList[0].price" value="${item.price}"/>
</td>
</tr>
<tr>
<td>
<input type="text" name=" itemsList[1].id" value="${item.id}"/>
</td>
<td>
<input type="text" name=" itemsList[1].name" value="${item.name }"/>
</td>
<td>
<input type="text" name=" itemsList[1].price" value="${item.price}"/>
</td>
</tr>

Name属性必须是包装pojo的list属性+下标+元素属性。Jsp做如下改造：
<c:forEach items="${itemList }" var="item">
<tr>
	<td><input name="ids" value="${item.id}" type="checkbox"></td>
	<td>
		<input name="id" value="${item.id}" type="hidden">
		<input name="name" value="${item.name }" type="text">
	</td>
	<td><input name="name" value="${item.price }" type="text"></td>
	<td><input name="name" value="<fmt:formatDate value="${item.createtime}" pattern="yyyy-MM-dd HH:mm:ss"/>" type="text"></td>
	<td><input name="name" value="${item.detail }" type="text"></td>
	<td><a href="${pageContext.request.contextPath }/itemEdit.action?id=${item.id}">修改</a></td>
</tr>
</c:forEach>

varStatus属性常用参数总结下：
${status.index}      输出行号，从0开始。
${status.count}      输出行号，从1开始。
${status.current}   当前这次迭代的（集合中的）项
${status.first}  判断当前项是否为集合中的第一项，返回值为true或false
${status.last}   判断当前项是否为集合中的最后一项，返回值为true或false
begin、end、step分别表示：起始序号，结束序号，跳跃步伐。


Contrller

@RequestMapping("/queryitem")
	public String queryItem(QueryVo queryVo, String[] ids) {
		System.out.println(queryVo.getItems().getName());
		System.out.println(queryVo.getItems().getPrice());
		System.out.println(ids.toString());
		return null;
	}

注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。

@RequestMapping

通过RequestMapping注解可以定义不同的处理器映射规则。
URL路径映射
@RequestMapping(value="/item")或@RequestMapping("/item）
value的值是数组，可以将多个url映射到同一个方法

窄化请求映射
在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。

如下：
@RequestMapping放在类名上边，设置请求前缀 
@Controller
@RequestMapping("/item")

方法名上边设置请求映射url：
@RequestMapping放在方法名上边，如下：
@RequestMapping("/queryItem ")

访问地址为：/item/queryItem


请求方法限定 
限定GET方法
@RequestMapping(method = RequestMethod.GET)

如果通过Post访问则报错：
HTTP Status 405 - Request method 'POST' not supported

例如：
@RequestMapping(value="/editItem",method=RequestMethod.GET)
限定POST方法

@RequestMapping(method = RequestMethod.POST)

如果通过Post访问则报错：
HTTP Status 405 - Request method 'GET' not supported

GET和POST都可以
@RequestMapping(method={RequestMethod.GET,RequestMethod.POST})


controller方法返回值
返回ModelAndView
controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。

返回void
	在controller方法形参上可以定义request和response，使用request或response指定响应结果：
1、使用request转向页面，如下：
request.getRequestDispatcher("页面路径").forward(request, response);

2、也可以通过response页面重定向：
response.sendRedirect("url")

3、也可以通过response指定响应结果，例如响应json数据如下：
response.setCharacterEncoding("utf-8");
response.setContentType("application/json;charset=utf-8");
response.getWriter().write("json串");


返回字符串
逻辑视图名

controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。
//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jsp
return "item/editItem";

Redirect重定向
Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。
//重定向到queryItem.action地址,request无法带过去
return "redirect:queryItem.action";


redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。
由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：
/item/queryItem?...&…..


forward转发
controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。
//结果转发到editItem.action，request可以带过去
return "forward:editItem.action";

forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。

异常处理器

	springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。
	
异常处理思路
	系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。
	系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：



自定义异常类
	为了区别不同的异常通常根据异常类型自定义异常类，这里我们创建一个自定义系统异常，如果controller、service、dao抛出此类异常说明是系统预期处理的异常信息。

	public class CustomException extends Exception {

	/** serialVersionUID*/
	private static final long serialVersionUID = -5212079010855161498L;
	
	public CustomException(String message){
		super(message);
		this.message = message;
	}

	//异常信息
	private String message;

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}
}


自定义异常处理器

public class CustomExceptionResolver implements HandlerExceptionResolver {

	@Override
	public ModelAndView resolveException(HttpServletRequest request,
			HttpServletResponse response, Object handler, Exception ex) {

		ex.printStackTrace();

		CustomException customException = null;
		
		//如果抛出的是系统自定义异常则直接转换
		if(ex instanceof CustomException){
			customException = (CustomException)ex;
		}else{
			//如果抛出的不是系统自定义异常则重新构造一个系统错误异常。
			customException = new CustomException("系统错误，请与系统管理 员联系！");
		}
		
		ModelAndView modelAndView = new ModelAndView();
		modelAndView.addObject("message", customException.getMessage());
		modelAndView.setViewName("error");

		return modelAndView;
	}

}

取异常堆栈：
           try {
			
		} catch (Exception e) {
			StringWriter s = new StringWriter();
			PrintWriter printWriter = new PrintWriter(s);
			e.printStackTrace(printWriter);
			s.toString();
		}

错误页面

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt"  prefix="fmt"%> 
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>错误页面</title>

</head>
<body>
您的操作出现错误如下：<br/>
${message }
</body>

</html>



异常处理器配置
在springmvc.xml中添加：

<!-- 异常处理器 -->
	<bean id="handlerExceptionResolver" class="cn.itcast.ssm.controller.exceptionResolver.CustomExceptionResolver"/>

异常测试
修改商品信息，id输入错误提示商品信息不存在。

修改controller方法“editItem”，调用service查询商品信息，如果商品信息为空则抛出异常：
// 调用service查询商品信息
		Items item = itemService.findItemById(id);
		
		if(item == null){
			throw new CustomException("商品信息不存在!");
		}



在service中抛出异常方法同上。

上传图片
配置虚拟目录 
在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加：
<Context docBase="F:\develop\upload\temp" path="/pic" reloadable="false"/>

访问http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。

也可以通过eclipse配置：



jar包
CommonsMultipartResolver解析器依赖commons-fileupload和commons-io，加入如下jar包：

配置解析器
<!-- 文件上传 -->
	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<!-- 设置上传文件的最大尺寸为5MB -->
		<property name="maxUploadSize">
			<value>5242880</value>
		</property>
	</bean>



图片上传
controller：

//商品修改提交
	@RequestMapping("/editItemSubmit")
	public String editItemSubmit(Items items, MultipartFile pictureFile)throws Exception{
		
		//原始文件名称
		String pictureFile_name =  pictureFile.getOriginalFilename();
		//新文件名称
		String newFileName = UUID.randomUUID().toString()+pictureFile_name.substring(pictureFile_name.lastIndexOf("."));
		
		//上传图片
		File uploadPic = new java.io.File("F:/develop/upload/temp/"+newFileName);
		
		if(!uploadPic.exists()){
			uploadPic.mkdirs();
		}
		//向磁盘写文件
		pictureFile.transferTo(uploadPic);

.....


页面：

form添加enctype="multipart/form-data"：
<form id="itemForm"
action="${pageContext.request.contextPath }/item/editItemSubmit.action"
		method="post" enctype="multipart/form-data">
		<input type="hidden" name="pic" value="${item.pic }" />


file的name与controller形参一致：
<tr>
	<td>商品图片</td>
	<td><c:if test="${item.pic !=null}">
			<img src="/pic/${item.pic}" width=100 height=100 />
			<br />
		</c:if> <input type="file" name="pictureFile" /></td>
</tr>




json数据交互
@RequestBody
作用：
@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。
List.action?id=1&name=zhangsan&age=12

本例子应用：
@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象

@ResponseBody
作用：
该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端

本例子应用：
@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端

请求json，响应json实现：
环境准备
Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，如下：

配置json转换器
在注解适配器中加入messageConverters

<!--注解适配器 -->
	<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
		<property name="messageConverters">
		<list>
		<bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"></bean>
		</list>
		</property>
	</bean>

注意：如果使用<mvc:annotation-driven /> 则不用定义上边的内容。


controller编写
// 商品修改提交json信息，响应json信息
	@RequestMapping("/editItemSubmit_RequestJson")
	public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {
		System.out.println(items);
		//itemService.saveItem(items);
		return items;

	}

页面js方法编写：
引入 js：
<script type="text/javascript" 
src="${pageContext.request.contextPath }/js/jquery-1.4.4.min.js"></script>


//请求json响应json
	function request_json(){
		$.ajax({
			type:"post",
			url:"${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action",
			contentType:"application/json;charset=utf-8",
			data:'{"name":"测试商品","price":99.9}',
			success:function(data){
				alert(data);
			}
		});
	}

测试结果：


从上图可以看出请求的数据是json格式




RESTful支持
什么是restful？
Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格，是对http协议的诠释。
资源定位：互联网所有的事物都是资源，要求url中没有动词，只有名词。没有参数
Url格式：http://blog.csdn.net/beat_the_world/article/details/45621673
资源操作：使用put、delete、post、get，使用不同方法对资源进行操作。分别对应添加、删除、修改、查询。一般使用时还是post和get。Put和Delete几乎不使用。
需求
RESTful方式实现商品信息查询，返回json数据

添加DispatcherServlet的rest配置

<servlet>
		<servlet-name>springmvc-servlet-rest</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:spring/springmvc.xml</param-value>
		</init-param>
	</servlet>
	<servlet-mapping>
		<servlet-name>springmvc-servlet-rest</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
URL 模板模式映射
@RequestMapping(value="/ viewItems/{id}")：{×××}占位符，请求的URL可以是“/viewItems/1”或“/viewItems/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。
@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。

@RequestMapping("/viewItems/{id}") 
	public @ResponseBody viewItems(@PathVariable("id") String id,Model model) throws Exception{
		//方法中使用@PathVariable获取useried的值，使用model传回页面
		//调用 service查询商品信息
		ItemsCustom itemsCustom = itemsService.findItemsById(id);
		return itemsCustom;
}

如果RequestMapping中表示为"/viewItems/{id}"，id和形参名称一致，@PathVariable不用指定名称。

商品查询的controller方法也改为rest实现：

// 查询商品列表
	@RequestMapping("/queryItem")
	public ModelAndView queryItem() throws Exception {
		// 商品列表
		List<Items> itemsList = itemService.findItemsList(null);

		// 创建modelAndView准备填充数据、设置视图
		ModelAndView modelAndView = new ModelAndView();

		// 填充数据
		modelAndView.addObject("itemsList", itemsList);
		// 视图
		modelAndView.setViewName("item/itemsList");

		return modelAndView;
	}

静态资源访问<mvc:resources>
如果在DispatcherServlet中设置url-pattern为 /则必须对静态资源进行访问处理。
spring mvc 的<mvc:resources mapping="" location="">实现对静态资源进行映射访问。
如下是对js文件访问配置：
<mvc:resources location="/js/" mapping="/js/**"/>



拦截器
定义
	Spring Web MVC 的处理器拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。

拦截器定义
实现HandlerInterceptor接口，如下：

Public class HandlerInterceptor1 implements HandlerInterceptor{

	/**
	 * controller执行前调用此方法
	 * 返回true表示继续执行，返回false中止执行
	 * 这里可以加入登录校验、权限拦截等
	 */
	@Override
	Public boolean preHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler) throws Exception {
		// TODO Auto-generated method stub
		Return false;
	}
	/**
	 * controller执行后但未返回视图前调用此方法
	 * 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示
	 */
	@Override
	Public void postHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		// TODO Auto-generated method stub
		
	}
	/**
	 * controller执行后且视图返回后调用此方法
	 * 这里可得到执行controller时的异常信息
	 * 这里可记录操作日志，资源清理等
	 */
	@Override
	Public void afterCompletion(HttpServletRequest request,
			HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
		// TODO Auto-generated method stub
		
	}

}


拦截器配置
针对某种mapping配置拦截器
<bean
	class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
	<property name="interceptors">
		<list>
			<ref bean="handlerInterceptor1"/>
			<ref bean="handlerInterceptor2"/>
		</list>
	</property>
</bean>
	<bean id="handlerInterceptor1" class="springmvc.intercapter.HandlerInterceptor1"/>
	<bean id="handlerInterceptor2" class="springmvc.intercapter.HandlerInterceptor2"/>


针对所有mapping配置全局拦截器

<!--拦截器 -->
<mvc:interceptors>
	<!--多个拦截器,顺序执行 -->
	<mvc:interceptor>
		<mvc:mapping path="/**"/>
		<bean class="cn.itcast.springmvc.filter.HandlerInterceptor1"></bean>
	</mvc:interceptor>
	<mvc:interceptor>
		<mvc:mapping path="/**"/>
		<bean class="cn.itcast.springmvc.filter.HandlerInterceptor2"></bean>
	</mvc:interceptor>
</mvc:interceptors>

正常流程测试

代码：
定义两个拦截器分别为：HandlerInterceptor1和HandlerInteptor2，每个拦截器的preHandler方法都返回true。



运行流程
HandlerInterceptor1..preHandle..
HandlerInterceptor2..preHandle..

HandlerInterceptor2..postHandle..
HandlerInterceptor1..postHandle..

HandlerInterceptor2..afterCompletion..
HandlerInterceptor1..afterCompletion..


中断流程测试
代码：
定义两个拦截器分别为：HandlerInterceptor1和HandlerInteptor2。


运行流程
HandlerInterceptor1的preHandler方法返回false，HandlerInterceptor2返回true，运行流程如下：

HandlerInterceptor1..preHandle..

从日志看出第一个拦截器的preHandler方法返回false后第一个拦截器只执行了preHandler方法，其它两个方法没有执行，第二个拦截器的所有方法不执行，且controller也不执行了。


HandlerInterceptor1的preHandler方法返回true，HandlerInterceptor2返回false，运行流程如下：

HandlerInterceptor1..preHandle..
HandlerInterceptor2..preHandle..
HandlerInterceptor1..afterCompletion..

从日志看出第二个拦截器的preHandler方法返回false后第一个拦截器的postHandler没有执行，第二个拦截器的postHandler和afterCompletion没有执行，且controller也不执行了。

总结：
preHandle按拦截器定义顺序调用
postHandler按拦截器定义逆序调用
afterCompletion按拦截器定义逆序调用

postHandler在拦截器链内所有拦截器返成功调用
afterCompletion只有preHandle返回true才调用
拦截器应用
处理流程
1、有一个登录页面，需要写一个controller访问页面
2、登录页面有一提交表单的动作。需要在controller中处理。
a)判断用户名密码是否正确
b)如果正确 想session中写入用户信息
c)返回登录成功，或者跳转到商品列表
3、拦截器。
a)拦截用户请求，判断用户是否登录
b)如果用户已经登录。放行
c)如果用户未登录，跳转到登录页面。

用户身份认证

Public class LoginInterceptor implements HandlerInterceptor{

	@Override
	Public boolean preHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler) throws Exception {

		//如果是登录页面则放行
		if(request.getRequestURI().indexOf("login.action")>=0){
			return true;
		}
		HttpSession session = request.getSession();
		//如果用户已登录也放行
		if(session.getAttribute("user")!=null){
			return true;
		}
		//用户没有登录挑战到登录页面
		request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response);
		
		return false;
	}
}

用户登陆controller
//登陆页面
	@RequestMapping("/login")
	public String login(Model model)throws Exception{
		
		return "login";
	}
	
	//登陆提交
	//userid：用户账号，pwd：密码
	@RequestMapping("/loginsubmit")
	public String loginsubmit(HttpSession session,String userid,String pwd)throws Exception{
		
		//向session记录用户身份信息
		session.setAttribute("activeUser", userid);
		
		return "redirect:item/queryItem.action";
	}
	
	//退出
	@RequestMapping("/logout")
	public String logout(HttpSession session)throws Exception{
		
		//session过期
		session.invalidate();
		
		return "redirect:item/queryItem.action";
	}






Mybatis、Springmvc练习

CRM系统



数据库
数据库使用mysql 数据库。

1、创建crm数据库
2、将参考资料中的sql脚本导入到数据库中

工程搭建
工程使用Springmvc、spring、mybatis框架整合完成。

SqlMapConfig.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEconfigurationPUBLIC"-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>

</configuration>
applicationContext-dao.xml
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.0.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/task
		http://www.springframework.org/schema/task/spring-task-4.0.xsd
		http://code.alibabatech.com/schema/dubbo        
		http://code.alibabatech.com/schema/dubbo/dubbo.xsd">

	<!-- 配置 读取properties文件 jdbc.properties -->
	<context:property-placeholderlocation="classpath:jdbc.properties"/>

	<!-- 配置 数据源 -->
	<beanid="dataSource"class="com.alibaba.druid.pool.DruidDataSource">
		<!-- 驱动 -->
		<propertyname="driverClassName"value="${jdbc.driver}"/>
		<!-- url -->
		<propertyname="url"value="${jdbc.url}"/>
		<!-- 用户名 -->
		<propertyname="username"value="${jdbc.username}"/>
		<!-- 密码 -->
		<propertyname="password"value="${jdbc.password}"/>
	</bean>

	<!-- 配置 Mybatis的工厂 -->
	<beanclass="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 数据源 -->
		<propertyname="dataSource"ref="dataSource"/>
		<!-- 配置Mybatis的核心 配置文件所在位置 -->
		<propertyname="configLocation"value="classpath:SqlMapConfig.xml"/>
		<!-- 配置pojo别名 -->
		<propertyname="typeAliasesPackage"value="cn.itcast.core.bean"></property>
	</bean>

	<!-- 配置 1：原始Dao开发 接口实现类 Mapper.xml 三个 2：接口开发 接口 不写实现类 Mapper.xml 二个 （UserDao、ProductDao 
		、BrandDao。。。。。。。） 3：接口开发、并支持扫描 cn.itcast.core.dao(UserDao。。。。。） 写在此包下即可被扫描到 -->
	<beanclass="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<propertyname="basePackage"value="cn.itcast.core.dao"/>
	</bean>

</beans>

Jdbc.properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/crm?characterEncoding=utf-8
jdbc.username=root
jdbc.password=root
applicationContext-service.xml
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.0.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd 
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/task
		http://www.springframework.org/schema/task/spring-task-4.0.xsd
		http://code.alibabatech.com/schema/dubbo        
		http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
		
		
		<!-- 配置  扫描   @Service -->
		<context:component-scanbase-package="cn.itcast.core.service"/>
		
		
		
</beans>

applicationContext-trans.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">
	<!-- 事务管理器 -->
	<beanid="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<!-- 数据源 -->
		<propertyname="dataSource"ref="dataSource"/>
	</bean>
	<!-- 通知 -->
	<tx:adviceid="txAdvice"transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 传播行为 -->
			<tx:methodname="save*"propagation="REQUIRED"/>
			<tx:methodname="insert*"propagation="REQUIRED"/>
			<tx:methodname="add*"propagation="REQUIRED"/>
			<tx:methodname="create*"propagation="REQUIRED"/>
			<tx:methodname="delete*"propagation="REQUIRED"/>
			<tx:methodname="update*"propagation="REQUIRED"/>
			<tx:methodname="find*"propagation="SUPPORTS"read-only="true"/>
			<tx:methodname="select*"propagation="SUPPORTS"read-only="true"/>
			<tx:methodname="get*"propagation="SUPPORTS"read-only="true"/>
		</tx:attributes>
	</tx:advice>
	<!-- 切面 -->
	<aop:config>
		<aop:advisoradvice-ref="txAdvice"
			pointcut="execution(* cn.itcast.core.service.*.*(..))"/>
	</aop:config>
</beans>
Springmvc.xml
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.0.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd 
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/task
		http://www.springframework.org/schema/task/spring-task-4.0.xsd
		http://code.alibabatech.com/schema/dubbo        
		http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
		
		<!-- 加载属性文件 -->
		<context:property-placeholderlocation="classpath:resource.properties"/>
		<!-- 配置扫描 器 -->
		<context:component-scanbase-package="cn.itcast.core.web.controller"/>
		<!-- 配置处理器映射器  适配器 -->
		<mvc:annotation-driven/>
		
		<!-- 配置视图解释器 jsp -->
		<beanid="jspViewResolver"class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<propertyname="prefix"value="/WEB-INF/jsp/"/>
			<propertyname="suffix"value=".jsp"/>
		</bean>
		
</beans>

Web.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<web-appversion="2.5"xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
	<welcome-file-list>
		<welcome-file>customer.action</welcome-file>
	</welcome-file-list>
	<!-- 上下文的位置 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext-*.xml</param-value>
	</context-param>
	<!-- Spring的监听器 -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>


	<!-- POST提交过滤器 UTF-8 -->
	<filter>
		<filter-name>encoding</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>

	<filter-mapping>
		<filter-name>encoding</filter-name>
		<url-pattern>*.action</url-pattern>
	</filter-mapping>
	<!-- 前端控制器 -->
	<servlet>
		<servlet-name>crm</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<!-- 此处不配置 默认找 /WEB-INF/[servlet-name]-servlet.xml -->
			<param-value>classpath:springmvc.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>crm</servlet-name>
		<!-- 1:*.do *.action 拦截以.do结尾的请求 (不拦截 jsppngjpg .js .css) 2:/ 拦截所有请求 
			（不拦截.jsp) 建议使用此种 方式 （拦截 .js.css .png) (放行静态资源） 3:/* 拦截所有请求（包括.jsp) 此种方式 不建议使用 -->
		<url-pattern>*.action</url-pattern>
	</servlet-mapping>
</web-app>


加入jsp及分页标签

查询条件初始化
需求

初始化查询条件下拉列表。

客户列表展示
需求

展示商品列表，并且可以根据查询条件过滤查询结果，并且实现分页处理。

修改客户信息
需求

1、点击客户列表中的“修改”按钮弹出客户信息修改对话框，并初始化客户信息
2、点击“保存修改”按钮将修改后的结果保存到数据库中

删除客户
需求

点击客户列表中的删除按钮，提示“警告信息”

点击确定后删除用户信息，并刷新页面。
SSM阶段_异常汇总
待汇总
课程名称: 新巴巴运动网

异常一
异常描述:	Integer类型不能转为 Long
异常信息:	java.lang.ClassCastException:java.lang.Integer cannot be cast to java.lang.Long
异常原因:	在solr仓库中存入的数据为int类型，Pojo类需要参数为Long,所以直接强转了

解决方案:	
解决人:	
备注:	


异常二
异常描述:	页面请求中文乱码
web.xml中配置过滤器过滤路径错误

异常信息:	

异常原因:	过滤器 拦截路径  /* 写成了 / 
解决方案:	
解决人:	
备注:	

异常三
异常描述:	映射Statements 集合中 不包含cn.itcast.dao.UserMapper.findUserByID
异常信息:	org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.itcast.dao.UserMapper.findUserByID
### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.itcast.dao.UserMapper.findUserByID
	…
Caused by: org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.itcast.dao.UserMapper.findUserByID
### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.itcast.dao.UserMapper.findUserByID
	…
Caused by: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.itcast.dao.UserMapper.findUserByID
	…
 
异常原因:	userMapper.xml中namespace填写的是实现类的全类名
<mapper namespace="cn.itcast.dao.impl.UserMapperImpl">

解决方案:	userMapper.xml中namespace应该填写的是对应接口的全类名
<mapper namespace="cn.itcast.dao.UserMapper">
解决人:	
备注:	










Spring web mvc
框架课程






课程计划
第一天
7、Springmvc介绍
8、入门程序
9、Springmvc架构讲解
a)框架结构
b)组件说明
10、Springmvc整合mybatis
11、参数绑定
a)Springmvc默认支持的类型
b)简单数据类型
c)Pojo类型
d)Pojo包装类型
e)自定义参数绑定
12、Springmvc和struts2的区别
第二天
17、高级参数绑定
a)数组类型的参数绑定
b)List类型的绑定
18、@RequestMapping注解的使用
19、Controller方法返回值
20、Springmvc中异常处理
21、图片上传处理
22、Json数据交互
23、Springmvc实现Restful
24、拦截器

















Spring web mvc介绍
Springmvc是什么？
Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,我们可以从Spring的整体结构中看得出来：

SpringMVC处理流程













入门程序
开发环境
本教程使用环境：
Jdk：jdk1.7.0_72
Eclipse：mars
Tomcat：apache-tomcat-7.0.53
Springmvc：4.1.3
需求
使用springmvc实现商品列表的展示。
需求分析
请求的url：/itemList.action
参数：无
数据：静态数据
开发步骤
第一步：创建一个javaweb工程
第二步：导入jar包

第三步：创建itemList.jsp

把参考资料中的itemList.jsp复制到工程的/WEB-INF/jsp目录下。
第四步：创建ItemsController
ItemController是一个普通的java类，不需要实现任何接口，只需要在类上添加@Controller注解即可。@RequestMapping注解指定请求的url，其中“.action”可以加也可以不加。在ModelAndView对象中，将视图设置为“/WEB-INF/jsp/itemList.jsp”
@Controller
publicclass ItemController {

	@RequestMapping("/itemList")
	public ModelAndView itemList() throws Exception {
		
		List<Items>itemList = new ArrayList<>();
		
		//商品列表
		Items items_1 = new Items();
		items_1.setName("联想笔记本_3");
		items_1.setPrice(6000f);
		items_1.setDetail("ThinkPad T430 联想笔记本电脑！");
		
		Items items_2 = new Items();
		items_2.setName("苹果手机");
		items_2.setPrice(5000f);
		items_2.setDetail("iphone6苹果手机！");
		
		itemList.add(items_1);
		itemList.add(items_2);
		//创建modelandView对象
		ModelAndView modelAndView = new ModelAndView();
		//添加model
		modelAndView.addObject("itemList", itemList);
		//添加视图
		modelAndView.setViewName("/WEB-INF/jsp/itemList.jsp");
//		modelAndView.setViewName("itemsList");	
		returnmodelAndView;
	}

}

商品数据使用Items类描述，可以使用参考资料中提供的pojo类，

第五步：创建springmvc.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">

	<context:component-scanbase-package="cn.itcast.springmvc.controller"/>
	
</beans>

第六步：配置前端控制器
在web.xml中添加DispatcherServlet的配置。
<!-- 前端控制器 -->
<servlet>
	<servlet-name>springmvc</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:springmvc.xml</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>springmvc</servlet-name>
	<url-pattern>*.action</url-pattern>
</servlet-mapping>



Springmvc架构
框架结构

























架构流程
12、用户发送请求至前端控制器DispatcherServlet
13、DispatcherServlet收到请求调用HandlerMapping处理器映射器。
14、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
15、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器
16、执行处理器(Controller，也叫后端控制器)。
17、Controller执行完成返回ModelAndView
18、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet
19、DispatcherServlet将ModelAndView传给ViewReslover视图解析器
20、ViewReslover解析后返回具体View
21、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。
22、DispatcherServlet响应用户

组件说明
以下组件通常使用框架提供实现：
DispatcherServlet：前端控制器
用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。
HandlerMapping：处理器映射器
HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。
Handler：处理器
Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。
由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。

HandlAdapter：处理器适配器
通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。



View Resolver：视图解析器
View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 
View：视图
springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。
一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。

说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。
需要用户开放的组件有handler、view

框架默认加载组件





注解映射器和适配器
组件扫描器
	使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用<context:component-scan>自动扫描标记@controller的控制器类，配置如下：

<!-- 扫描controller注解,多个包中间使用半角逗号分隔 -->
	<context:component-scanbase-package="cn.itcast.springmvc.controller.first"/>


RequestMappingHandlerMapping
	注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 

从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。

配置如下：

<!--注解映射器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
	

注解描述：
@RequestMapping：定义请求url到处理器功能方法的映射


RequestMappingHandlerAdapter
注解式处理器适配器，对标记@ResquestMapping的方法进行适配。

从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。

配置如下：
<!--注解适配器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/>

<mvc:annotation-driven>
springmvc使用<mvc:annotation-driven>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<mvc:annotation-driven>替代注解处理器和适配器的配置。
视图解析器
在springmvc.xml文件配置如下：

	<beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<propertyname="viewClass"
			value="org.springframework.web.servlet.view.JstlView"/>
		<propertyname="prefix"value="/WEB-INF/jsp/"/>
		<propertyname="suffix"value=".jsp"/>
	</bean>

InternalResourceViewResolver：支持JSP视图解析
viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。
prefix 和suffix：查找视图页面的前缀和后缀，最终视图的址为：
前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp”
整合mybatis
	为了更好的学习 springmvc和mybatis整合开发的方法，需要将springmvc和mybatis进行整合。

整合目标：控制层采用springmvc、持久层使用mybatis实现。

需求
实现商品查询列表，从mysql数据库查询商品信息。
jar包
包括：spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。
参考：“mybatis与springmvc整合全部jar包”目录 
工程搭建
整合思路
Dao层：
3、SqlMapConfig.xml，空文件即可。需要文件头。
4、applicationContext-dao.xml。
a)数据库连接池
b)SqlSessionFactory对象，需要spring和mybatis整合包下的。
c)配置mapper文件扫描器。
Service层：
3、applicationContext-service.xml包扫描器，扫描@service注解的类。
4、applicationContext-trans.xml配置事务。
表现层：
Springmvc.xml
4、包扫描器，扫描@Controller注解的类。
5、配置注解驱动。
6、视图解析器
Web.xml
配置前端控制器。
sqlMapConfig.xml
在classpath下创建mybatis/sqlMapConfig.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEconfiguration
PUBLIC"-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
</configuration>

applicationContext-dao.xml
配置数据源、配置SqlSessionFactory、mapper扫描器。
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">

	<!-- 加载配置文件 -->
	<context:property-placeholderlocation="classpath:db.properties"/>
	<!-- 数据库连接池 -->
	<beanid="dataSource"class="org.apache.commons.dbcp.BasicDataSource"
		destroy-method="close">
		<propertyname="driverClassName"value="${jdbc.driver}"/>
		<propertyname="url"value="${jdbc.url}"/>
		<propertyname="username"value="${jdbc.username}"/>
		<propertyname="password"value="${jdbc.password}"/>
		<propertyname="maxActive"value="10"/>
		<propertyname="maxIdle"value="5"/>
	</bean>
	<!-- mapper配置 -->
	<!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 -->
	<beanid="sqlSessionFactory"class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 数据库连接池 -->
		<propertyname="dataSource"ref="dataSource"/>
		<!-- 加载mybatis的全局配置文件 -->
		<propertyname="configLocation"value="classpath:mybatis/SqlMapConfig.xml"/>
	</bean>
	<!-- 配置Mapper扫描器 -->
	<beanclass="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<propertyname="basePackage"value="cn.itcast.springmvc.mapper"/>
	</bean>

</beans>

Db.properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/springmvc?characterEncoding=utf-8
jdbc.username=root
jdbc.password=root
applicationContext-service.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">

	<context:component-scanbase-package="cn.itcast.springmvc.service"/>

</beans>
applicationContext-transaction.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">
	<!-- 事务管理器 -->
	<beanid="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<!-- 数据源 -->
		<propertyname="dataSource"ref="dataSource"/>
	</bean>
	<!-- 通知 -->
	<tx:adviceid="txAdvice"transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 传播行为 -->
			<tx:methodname="save*"propagation="REQUIRED"/>
			<tx:methodname="insert*"propagation="REQUIRED"/>
			<tx:methodname="delete*"propagation="REQUIRED"/>
			<tx:methodname="update*"propagation="REQUIRED"/>
			<tx:methodname="find*"propagation="SUPPORTS"read-only="true"/>
			<tx:methodname="get*"propagation="SUPPORTS"read-only="true"/>
		</tx:attributes>
	</tx:advice>
	<!-- 切面 -->
	<aop:config>
		<aop:advisoradvice-ref="txAdvice"
			pointcut="execution(* cn.itcast.springmvc.service.*.*(..))"/>
	</aop:config>
</beans>
springmvc.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">

	<!-- 扫描带Controller注解的类 -->
	<context:component-scanbase-package="cn.itcast.springmvc.controller"/>
	<!-- 加载注解驱动 -->
	<mvc:annotation-driven/>
	<!-- 视图解析器 -->
	<beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<propertyname="viewClass"
			value="org.springframework.web.servlet.view.JstlView"/>
		<!-- jsp前缀 -->
		<propertyname="prefix"value="/WEB-INF/jsp/"/>
		<!-- jsp后缀 -->
		<propertyname="suffix"value=".jsp"/>
	</bean>
</beans>

web.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<web-appxmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
	id="WebApp_ID"version="2.5">
	<display-name>springmvc-web</display-name>
	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
		<welcome-file>index.htm</welcome-file>
		<welcome-file>index.jsp</welcome-file>
		<welcome-file>default.html</welcome-file>
		<welcome-file>default.htm</welcome-file>
		<welcome-file>default.jsp</welcome-file>
	</welcome-file-list>
	<!-- 加载spring容器 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:spring/applicationContext-*.xml</param-value>
	</context-param>
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
	
	<servlet>
		<servlet-name>springmvc</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:spring/springmvc.xml</param-value>
		</init-param>
	</servlet>
	<servlet-mapping>
		<servlet-name>springmvc</servlet-name>
		<url-pattern>*.action</url-pattern>
	</servlet-mapping>
</web-app>

Dao
mybatis逆向工程。
Service
1、Service由spring管理
2、spring对Service进行事务控制。
ItemService接口
publicinterface ItemService {

	List<Items> getItemsList();
}


ItemServiceImpl实现类
@Service
publicclass ItemServiceImpl implements ItemService {

	@Autowired
	private ItemMapper itemMapper;
	
	@Override
	public List<Items> getItemsList() {
		List<Items>itemList = itemMapper.getItemList();
		returnitemList;
	}

}

Controller
@Controller
publicclass ItemController {

	@Autowired
	private ItemService itemService;
	
	@RequestMapping("/itemList")
	public ModelAndView getItemList() {
		List<Items>list = itemService.getItemsList();
		ModelAndView modelAndView = new ModelAndView();
		modelAndView.addObject("itemList", list);
		modelAndView.setViewName("itemList");
		returnmodelAndView;
	}
}

测试
访问：http://localhost:8080/springmvc-web/itemList.action


参数绑定
绑定简单数据类型
需求
打开商品编辑页面，展示商品信息。
需求分析
编辑商品信息，需要根据商品id查询商品信息，然后展示到页面。
请求的url：/itemEdit.action
参数：id（商品id）
响应结果：商品编辑页面，展示商品详细信息。

Service
@Override
	public Items getItemById(intid) {
		Items items = itemMapper.getItemById(id);
		returnitems;
	}



Controller参数绑定
要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。
@RequestMapping("/itemEdit")
	publicModelAndView itemEdit(HttpServletRequest request) {
		//从Request中取id
		String strId = request.getParameter("id");
		Integer id = null;
		//如果id有值则转换成int类型
		if (strId != null&& !"".equals(strId)) {
			id = newInteger(strId);
		} else {
			//出错
			returnnull;
		}
		Items items = itemService.getItemById(id);
		//创建ModelAndView
		ModelAndView modelAndView = new ModelAndView();
		//向jsp传递数据
		modelAndView.addObject("item", items);
		//设置跳转的jsp页面
		modelAndView.setViewName("editItem");
		returnmodelAndView;
	}
如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。
默认支持的参数类型
处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。
HttpServletRequest
通过request对象获取请求信息
HttpServletResponse
通过response处理响应信息
HttpSession
通过session对象得到session中存放的对象
Model/ModelMap
ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：

//调用service查询商品信息
Items item = itemService.findItemById(id);
model.addAttribute("item", item);

页面通过${item.XXXX}获取item对象的属性值。
使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。
如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。
如果使用Model则方法可以改造成：
@RequestMapping("/itemEdit")
	publicString itemEdit(HttpServletRequest request, Model model) {
		//从Request中取id
		String strId = request.getParameter("id");
		Integer id = null;
		//如果id有值则转换成int类型
		if (strId != null&& !"".equals(strId)) {
			id = newInteger(strId);
		} else {
			//出错
			returnnull;
		}
		Items items = itemService.getItemById(id);
		//创建ModelAndView
		//ModelAndView modelAndView = new ModelAndView();
		//向jsp传递数据
		//modelAndView.addObject("item", items);
		model.addAttribute("item", items);
		//设置跳转的jsp页面
		//modelAndView.setViewName("editItem");
		//return modelAndView;
		return"editItem";
	}


绑定简单类型
当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。
@RequestMapping("/itemEdit")
	public String itemEdit(Integer id, Model model) {
		Items items = itemService.getItemById(id);
		//向jsp传递数据
		model.addAttribute("item", items);
		//设置跳转的jsp页面
		return"editItem";
	}

支持的数据类型
参数类型推荐使用包装数据类型，因为基础数据类型不可以为null
整形：Integer、int
字符串：String
单精度：Float、float
双精度：Double、double
布尔型：Boolean、boolean
说明：对于布尔类型的参数，请求的参数值为true或false。
处理器方法：
public String editItem(Model model,Integer id,Boolean status) throws Exception
请求url：
http://localhost:8080/xxx.action?id=2&status=false
@RequestParam 
使用@RequestParam常用于处理简单类型的绑定。

value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入；
required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；
TTP Status 400 - Required Integer parameter 'XXXX' is not present

defaultValue：默认值，表示如果请求中没有同名参数时的默认值

定义如下：
public String editItem(@RequestParam(value="item_id",required=true) String id) {
	
}

形参名称为id，但是这里使用value="item_id"限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。
注意：如果请求参数中没有item_id将跑出异常：
HTTP Status 500 - Required Integer parameter 'item_id' is not present

这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值

绑定pojo类型


需求
将页面修改后的商品信息保存到数据库中。
需求分析
请求的url：/updateitem.action
参数：表单中的数据。
响应内容：更新成功页面
使用pojo接收表单数据
如果提交的参数很多，或者提交的表单中的内容很多的时候可以使用pojo接收数据。要求pojo对象中的属性名和表单中input的name属性一致。
页面定义如下;

<input type="text" name="name"/>
<input type="text" name="price"/>

Pojo定义：


请求的参数名称和pojo的属性名称一致，会自动将请求参数赋值给pojo的属性。

@RequestMapping("/updateitem")
	public String updateItem(Items items) {
		itemService.updateItem(items);
		return"success";
	}

注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。

解决post乱码问题
在web.xml中加入：
<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

以上可以解决post请求乱码问题。
对于get请求中文参数出现乱码解决方法有两个：

修改tomcat配置文件添加编码与工程编码一致，如下：

<Connector URIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>

另外一种方法对参数进行重新编码：
String userName new 
String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")

ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码

绑定包装pojo
需求
使用包装的pojo接收商品信息的查询条件。

需求分析
包装对象定义如下：
PublicclassQueryVo {
privateItemsitems;

}

页面定义：

<input type="text" name="items.name" />
<input type="text" name="items.price" />

Controller方法定义如下：

public String useraddsubmit(Model model,QueryVoqueryVo)throws Exception{
System.out.println(queryVo.getItems());

接收查询条件
@RequestMapping("/queryitem")
	public String queryItem(QueryVo queryVo) {
		System.out.println(queryVo.getItems().getName());
		System.out.println(queryVo.getItems().getPrice());
		returnnull;
	}

自定义参数绑定
需求
在商品修改页面可以修改商品的生产日期，并且根据业务需求自定义日期格式。
需求分析
	由于日期数据有很多种格式，所以springmvc没办法把字符串转换成日期类型。所以需要自定义参数绑定。前端控制器接收到请求后，找到注解形式的处理器适配器，对RequestMapping标记的方法进行适配，并对方法中的形参进行参数绑定。在springmvc这可以在处理器适配器上自定义Converter进行参数绑定。如果使用<mvc:annotation-driven/>可以在此标签上进行扩展。

自定义Converter
publicclass DateConverter implements Converter<String, Date> {

	@Override
	public Date convert(String source) {
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try {
			returnsimpleDateFormat.parse(source);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		returnnull;
	}
}

配置Converter


	<!-- 加载注解驱动 -->
	<mvc:annotation-drivenconversion-service="conversionService"/>
	<!-- 转换器配置 -->
	<beanid="conversionService"
		class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
		<propertyname="converters">
			<set>
				<beanclass="cn.itcast.springmvc.convert.DateConverter"/>
			</set>
		</property>
	</bean>

配置方式2（了解）

<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">

	<!-- 扫描带Controller注解的类 -->
	<context:component-scanbase-package="cn.itcast.springmvc.controller"/>
	
	<!-- 转换器配置 -->
	<beanid="conversionService"
		class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
		<propertyname="converters">
			<set>
				<beanclass="cn.itcast.springmvc.convert.DateConverter"/>
			</set>
		</property>
	</bean>
	<!-- 自定义webBinder -->
	<beanid="customBinder"	class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer">
		<propertyname="conversionService"ref="conversionService"/>
	</bean>
	<!--注解适配器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
		<propertyname="webBindingInitializer"ref="customBinder"></property>
	</bean>
	<!-- 注解处理器映射器 -->
	<beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
	<!-- 加载注解驱动 -->
	<!-- <mvc:annotation-driven/> -->
	<!-- 视图解析器 -->
	<beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<propertyname="viewClass"
			value="org.springframework.web.servlet.view.JstlView"/>
		<!-- jsp前缀 -->
		<propertyname="prefix"value="/WEB-INF/jsp/"/>
		<!-- jsp后缀 -->
		<propertyname="suffix"value=".jsp"/>
	</bean>
</beans>
注意：此方法需要独立配置处理器映射器、适配器，不再使用<mvc:annotation-driven/>
springmvc与struts2不同
4、springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。
5、springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。
6、Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。







Spring web mvc
框架课程










课程计划
25、高级参数绑定
a)数组类型的参数绑定
b)List类型的绑定
26、@RequestMapping注解的使用
27、Controller方法返回值
28、Springmvc中异常处理
29、图片上传处理
30、Json数据交互
31、Springmvc实现Restful
32、拦截器

高级参数绑定
绑定数组
需求
在商品列表页面选中多个商品，然后删除。
需求分析
此功能要求商品列表页面中的每个商品前有一个checkbook，选中多个商品后点击删除按钮把商品id传递给Controller，根据商品id删除商品信息。
Jsp中实现：
<c:forEach items="${itemList }" var="item">
<tr>
	<td><input name="ids" value="${item.id}" type="checkbox"></td>
	<td>${item.name }</td>
	<td>${item.price }</td>
	<td><fmt:formatDate value="${item.createtime}" pattern="yyyy-MM-dd HH:mm:ss"/></td>
	<td>${item.detail }</td>
	<td><a href="${pageContext.request.contextPath }/itemEdit.action?id=${item.id}">修改</a></td>
</tr>
</c:forEach>
生成html代码如下：
页面选中多个checkbox向controller方法传递
<table width="100%" border=1>
<tr>
	<td>商品名称</td>
	<td>商品价格</td>
	<td>生产日期</td>
	<td>商品描述</td>
	<td>操作</td>
</tr>
<tr>
	<td><input name="ids" value="1" type="checkbox"></td>
	<td>台式机</td>
	<td>3000.0</td>
	<td>2016-02-03 13:22:53</td>
	<td></td>
	<td><a href="/springmvc-web/itemEdit.action?id=1">修改</a></td>
</tr>
<tr>
	<td><input name="ids" value="2" type="checkbox"></td>
	<td>笔记本</td>
	<td>6000.0</td>
	<td>2015-02-09 13:22:57</td>
	<td></td>
	<td><a href="/springmvc-web/itemEdit.action?id=2">修改</a></td>
</tr>
<tr>
	<td><input name="ids" value="3" type="checkbox"></td>
	<td>背包</td>
	<td>200.0</td>
	<td>2015-02-06 13:23:02</td>
	<td></td>
	<td><a href="/springmvc-web/itemEdit.action?id=3">修改</a></td>
</tr>
</table>

Controller
Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。
定义如下：
@RequestMapping("/queryitem")
	public String queryItem(QueryVo queryVo, String[] ids) {
		System.out.println(queryVo.getItems().getName());
		System.out.println(queryVo.getItems().getPrice());
		System.out.println(ids.toString());
		return null;
	}
或者：

查看结果：

将表单的数据绑定到List
需求
实现商品数据的批量修改。
需求分析
要想实现商品数据的批量修改，需要在商品列表中可以对商品信息进行修改，并且可以批量提交修改后的商品数据。

接收商品列表的pojo
List中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。

Jsp改造
页面定义如下：


<tr>
<td>
<input type="text" name=" itemsList[0].id" value="${item.id}"/>
</td>
<td>
<input type="text" name=" itemsList[0].name" value="${item.name }"/>
</td>
<td>
<input type="text" name=" itemsList[0].price" value="${item.price}"/>
</td>
</tr>
<tr>
<td>
<input type="text" name=" itemsList[1].id" value="${item.id}"/>
</td>
<td>
<input type="text" name=" itemsList[1].name" value="${item.name }"/>
</td>
<td>
<input type="text" name=" itemsList[1].price" value="${item.price}"/>
</td>
</tr>

Name属性必须是包装pojo的list属性+下标+元素属性。Jsp做如下改造：
<c:forEach items="${itemList }" var="item">
<tr>
	<td><input name="ids" value="${item.id}" type="checkbox"></td>
	<td>
		<input name="id" value="${item.id}" type="hidden">
		<input name="name" value="${item.name }" type="text">
	</td>
	<td><input name="name" value="${item.price }" type="text"></td>
	<td><input name="name" value="<fmt:formatDate value="${item.createtime}" pattern="yyyy-MM-dd HH:mm:ss"/>" type="text"></td>
	<td><input name="name" value="${item.detail }" type="text"></td>
	<td><a href="${pageContext.request.contextPath }/itemEdit.action?id=${item.id}">修改</a></td>
</tr>
</c:forEach>

varStatus属性常用参数总结下：
${status.index}      输出行号，从0开始。
${status.count}      输出行号，从1开始。
${status.current}   当前这次迭代的（集合中的）项
${status.first}  判断当前项是否为集合中的第一项，返回值为true或false
${status.last}   判断当前项是否为集合中的最后一项，返回值为true或false
begin、end、step分别表示：起始序号，结束序号，跳跃步伐。


Contrller

@RequestMapping("/queryitem")
	public String queryItem(QueryVo queryVo, String[] ids) {
		System.out.println(queryVo.getItems().getName());
		System.out.println(queryVo.getItems().getPrice());
		System.out.println(ids.toString());
		return null;
	}

注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。

@RequestMapping

通过RequestMapping注解可以定义不同的处理器映射规则。
URL路径映射
@RequestMapping(value="/item")或@RequestMapping("/item）
value的值是数组，可以将多个url映射到同一个方法

窄化请求映射
在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。

如下：
@RequestMapping放在类名上边，设置请求前缀 
@Controller
@RequestMapping("/item")

方法名上边设置请求映射url：
@RequestMapping放在方法名上边，如下：
@RequestMapping("/queryItem ")

访问地址为：/item/queryItem


请求方法限定 
限定GET方法
@RequestMapping(method = RequestMethod.GET)

如果通过Post访问则报错：
HTTP Status 405 - Request method 'POST' not supported

例如：
@RequestMapping(value="/editItem",method=RequestMethod.GET)
限定POST方法

@RequestMapping(method = RequestMethod.POST)

如果通过Post访问则报错：
HTTP Status 405 - Request method 'GET' not supported

GET和POST都可以
@RequestMapping(method={RequestMethod.GET,RequestMethod.POST})


controller方法返回值
返回ModelAndView
controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。

返回void
	在controller方法形参上可以定义request和response，使用request或response指定响应结果：
1、使用request转向页面，如下：
request.getRequestDispatcher("页面路径").forward(request, response);

2、也可以通过response页面重定向：
response.sendRedirect("url")

3、也可以通过response指定响应结果，例如响应json数据如下：
response.setCharacterEncoding("utf-8");
response.setContentType("application/json;charset=utf-8");
response.getWriter().write("json串");


返回字符串
逻辑视图名

controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。
//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jsp
return "item/editItem";

Redirect重定向
Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。
//重定向到queryItem.action地址,request无法带过去
return "redirect:queryItem.action";


redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。
由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：
/item/queryItem?...&…..


forward转发
controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。
//结果转发到editItem.action，request可以带过去
return "forward:editItem.action";

forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。

异常处理器

	springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。
	
异常处理思路
	系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。
	系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：



自定义异常类
	为了区别不同的异常通常根据异常类型自定义异常类，这里我们创建一个自定义系统异常，如果controller、service、dao抛出此类异常说明是系统预期处理的异常信息。

	public class CustomException extends Exception {

	/** serialVersionUID*/
	private static final long serialVersionUID = -5212079010855161498L;
	
	public CustomException(String message){
		super(message);
		this.message = message;
	}

	//异常信息
	private String message;

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}
}


自定义异常处理器

public class CustomExceptionResolver implements HandlerExceptionResolver {

	@Override
	public ModelAndView resolveException(HttpServletRequest request,
			HttpServletResponse response, Object handler, Exception ex) {

		ex.printStackTrace();

		CustomException customException = null;
		
		//如果抛出的是系统自定义异常则直接转换
		if(ex instanceof CustomException){
			customException = (CustomException)ex;
		}else{
			//如果抛出的不是系统自定义异常则重新构造一个系统错误异常。
			customException = new CustomException("系统错误，请与系统管理 员联系！");
		}
		
		ModelAndView modelAndView = new ModelAndView();
		modelAndView.addObject("message", customException.getMessage());
		modelAndView.setViewName("error");

		return modelAndView;
	}

}

取异常堆栈：
           try {
			
		} catch (Exception e) {
			StringWriter s = new StringWriter();
			PrintWriter printWriter = new PrintWriter(s);
			e.printStackTrace(printWriter);
			s.toString();
		}

错误页面

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt"  prefix="fmt"%> 
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>错误页面</title>

</head>
<body>
您的操作出现错误如下：<br/>
${message }
</body>

</html>



异常处理器配置
在springmvc.xml中添加：

<!-- 异常处理器 -->
	<bean id="handlerExceptionResolver" class="cn.itcast.ssm.controller.exceptionResolver.CustomExceptionResolver"/>

异常测试
修改商品信息，id输入错误提示商品信息不存在。

修改controller方法“editItem”，调用service查询商品信息，如果商品信息为空则抛出异常：
// 调用service查询商品信息
		Items item = itemService.findItemById(id);
		
		if(item == null){
			throw new CustomException("商品信息不存在!");
		}



在service中抛出异常方法同上。

上传图片
配置虚拟目录 
在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加：
<Context docBase="F:\develop\upload\temp" path="/pic" reloadable="false"/>

访问http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。

也可以通过eclipse配置：



jar包
CommonsMultipartResolver解析器依赖commons-fileupload和commons-io，加入如下jar包：

配置解析器
<!-- 文件上传 -->
	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<!-- 设置上传文件的最大尺寸为5MB -->
		<property name="maxUploadSize">
			<value>5242880</value>
		</property>
	</bean>



图片上传
controller：

//商品修改提交
	@RequestMapping("/editItemSubmit")
	public String editItemSubmit(Items items, MultipartFile pictureFile)throws Exception{
		
		//原始文件名称
		String pictureFile_name =  pictureFile.getOriginalFilename();
		//新文件名称
		String newFileName = UUID.randomUUID().toString()+pictureFile_name.substring(pictureFile_name.lastIndexOf("."));
		
		//上传图片
		File uploadPic = new java.io.File("F:/develop/upload/temp/"+newFileName);
		
		if(!uploadPic.exists()){
			uploadPic.mkdirs();
		}
		//向磁盘写文件
		pictureFile.transferTo(uploadPic);

.....


页面：

form添加enctype="multipart/form-data"：
<form id="itemForm"
action="${pageContext.request.contextPath }/item/editItemSubmit.action"
		method="post" enctype="multipart/form-data">
		<input type="hidden" name="pic" value="${item.pic }" />


file的name与controller形参一致：
<tr>
	<td>商品图片</td>
	<td><c:if test="${item.pic !=null}">
			<img src="/pic/${item.pic}" width=100 height=100 />
			<br />
		</c:if> <input type="file" name="pictureFile" /></td>
</tr>




json数据交互
@RequestBody
作用：
@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。
List.action?id=1&name=zhangsan&age=12

本例子应用：
@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象

@ResponseBody
作用：
该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端

本例子应用：
@ResponseBody注解实现将controller方法返回对象转换为json响应给客户端

请求json，响应json实现：
环境准备
Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，如下：

配置json转换器
在注解适配器中加入messageConverters

<!--注解适配器 -->
	<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
		<property name="messageConverters">
		<list>
		<bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"></bean>
		</list>
		</property>
	</bean>

注意：如果使用<mvc:annotation-driven /> 则不用定义上边的内容。


controller编写
// 商品修改提交json信息，响应json信息
	@RequestMapping("/editItemSubmit_RequestJson")
	public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception {
		System.out.println(items);
		//itemService.saveItem(items);
		return items;

	}

页面js方法编写：
引入 js：
<script type="text/javascript" 
src="${pageContext.request.contextPath }/js/jquery-1.4.4.min.js"></script>


//请求json响应json
	function request_json(){
		$.ajax({
			type:"post",
			url:"${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action",
			contentType:"application/json;charset=utf-8",
			data:'{"name":"测试商品","price":99.9}',
			success:function(data){
				alert(data);
			}
		});
	}

测试结果：


从上图可以看出请求的数据是json格式




RESTful支持
什么是restful？
Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格，是对http协议的诠释。
资源定位：互联网所有的事物都是资源，要求url中没有动词，只有名词。没有参数
Url格式：http://blog.csdn.net/beat_the_world/article/details/45621673
资源操作：使用put、delete、post、get，使用不同方法对资源进行操作。分别对应添加、删除、修改、查询。一般使用时还是post和get。Put和Delete几乎不使用。
需求
RESTful方式实现商品信息查询，返回json数据

添加DispatcherServlet的rest配置

<servlet>
		<servlet-name>springmvc-servlet-rest</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:spring/springmvc.xml</param-value>
		</init-param>
	</servlet>
	<servlet-mapping>
		<servlet-name>springmvc-servlet-rest</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
URL 模板模式映射
@RequestMapping(value="/ viewItems/{id}")：{×××}占位符，请求的URL可以是“/viewItems/1”或“/viewItems/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。
@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。

@RequestMapping("/viewItems/{id}") 
	public @ResponseBody viewItems(@PathVariable("id") String id,Model model) throws Exception{
		//方法中使用@PathVariable获取useried的值，使用model传回页面
		//调用 service查询商品信息
		ItemsCustom itemsCustom = itemsService.findItemsById(id);
		return itemsCustom;
}

如果RequestMapping中表示为"/viewItems/{id}"，id和形参名称一致，@PathVariable不用指定名称。

商品查询的controller方法也改为rest实现：

// 查询商品列表
	@RequestMapping("/queryItem")
	public ModelAndView queryItem() throws Exception {
		// 商品列表
		List<Items> itemsList = itemService.findItemsList(null);

		// 创建modelAndView准备填充数据、设置视图
		ModelAndView modelAndView = new ModelAndView();

		// 填充数据
		modelAndView.addObject("itemsList", itemsList);
		// 视图
		modelAndView.setViewName("item/itemsList");

		return modelAndView;
	}

静态资源访问<mvc:resources>
如果在DispatcherServlet中设置url-pattern为 /则必须对静态资源进行访问处理。
spring mvc 的<mvc:resources mapping="" location="">实现对静态资源进行映射访问。
如下是对js文件访问配置：
<mvc:resources location="/js/" mapping="/js/**"/>



拦截器
定义
	Spring Web MVC 的处理器拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。

拦截器定义
实现HandlerInterceptor接口，如下：

Public class HandlerInterceptor1 implements HandlerInterceptor{

	/**
	 * controller执行前调用此方法
	 * 返回true表示继续执行，返回false中止执行
	 * 这里可以加入登录校验、权限拦截等
	 */
	@Override
	Public boolean preHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler) throws Exception {
		// TODO Auto-generated method stub
		Return false;
	}
	/**
	 * controller执行后但未返回视图前调用此方法
	 * 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示
	 */
	@Override
	Public void postHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		// TODO Auto-generated method stub
		
	}
	/**
	 * controller执行后且视图返回后调用此方法
	 * 这里可得到执行controller时的异常信息
	 * 这里可记录操作日志，资源清理等
	 */
	@Override
	Public void afterCompletion(HttpServletRequest request,
			HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
		// TODO Auto-generated method stub
		
	}

}


拦截器配置
针对某种mapping配置拦截器
<bean
	class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
	<property name="interceptors">
		<list>
			<ref bean="handlerInterceptor1"/>
			<ref bean="handlerInterceptor2"/>
		</list>
	</property>
</bean>
	<bean id="handlerInterceptor1" class="springmvc.intercapter.HandlerInterceptor1"/>
	<bean id="handlerInterceptor2" class="springmvc.intercapter.HandlerInterceptor2"/>


针对所有mapping配置全局拦截器

<!--拦截器 -->
<mvc:interceptors>
	<!--多个拦截器,顺序执行 -->
	<mvc:interceptor>
		<mvc:mapping path="/**"/>
		<bean class="cn.itcast.springmvc.filter.HandlerInterceptor1"></bean>
	</mvc:interceptor>
	<mvc:interceptor>
		<mvc:mapping path="/**"/>
		<bean class="cn.itcast.springmvc.filter.HandlerInterceptor2"></bean>
	</mvc:interceptor>
</mvc:interceptors>

正常流程测试

代码：
定义两个拦截器分别为：HandlerInterceptor1和HandlerInteptor2，每个拦截器的preHandler方法都返回true。



运行流程
HandlerInterceptor1..preHandle..
HandlerInterceptor2..preHandle..

HandlerInterceptor2..postHandle..
HandlerInterceptor1..postHandle..

HandlerInterceptor2..afterCompletion..
HandlerInterceptor1..afterCompletion..


中断流程测试
代码：
定义两个拦截器分别为：HandlerInterceptor1和HandlerInteptor2。


运行流程
HandlerInterceptor1的preHandler方法返回false，HandlerInterceptor2返回true，运行流程如下：

HandlerInterceptor1..preHandle..

从日志看出第一个拦截器的preHandler方法返回false后第一个拦截器只执行了preHandler方法，其它两个方法没有执行，第二个拦截器的所有方法不执行，且controller也不执行了。


HandlerInterceptor1的preHandler方法返回true，HandlerInterceptor2返回false，运行流程如下：

HandlerInterceptor1..preHandle..
HandlerInterceptor2..preHandle..
HandlerInterceptor1..afterCompletion..

从日志看出第二个拦截器的preHandler方法返回false后第一个拦截器的postHandler没有执行，第二个拦截器的postHandler和afterCompletion没有执行，且controller也不执行了。

总结：
preHandle按拦截器定义顺序调用
postHandler按拦截器定义逆序调用
afterCompletion按拦截器定义逆序调用

postHandler在拦截器链内所有拦截器返成功调用
afterCompletion只有preHandle返回true才调用
拦截器应用
处理流程
4、有一个登录页面，需要写一个controller访问页面
5、登录页面有一提交表单的动作。需要在controller中处理。
a)判断用户名密码是否正确
b)如果正确 想session中写入用户信息
c)返回登录成功，或者跳转到商品列表
6、拦截器。
a)拦截用户请求，判断用户是否登录
b)如果用户已经登录。放行
c)如果用户未登录，跳转到登录页面。

用户身份认证

Public class LoginInterceptor implements HandlerInterceptor{

	@Override
	Public boolean preHandle(HttpServletRequest request,
			HttpServletResponse response, Object handler) throws Exception {

		//如果是登录页面则放行
		if(request.getRequestURI().indexOf("login.action")>=0){
			return true;
		}
		HttpSession session = request.getSession();
		//如果用户已登录也放行
		if(session.getAttribute("user")!=null){
			return true;
		}
		//用户没有登录挑战到登录页面
		request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response);
		
		return false;
	}
}

用户登陆controller
//登陆页面
	@RequestMapping("/login")
	public String login(Model model)throws Exception{
		
		return "login";
	}
	
	//登陆提交
	//userid：用户账号，pwd：密码
	@RequestMapping("/loginsubmit")
	public String loginsubmit(HttpSession session,String userid,String pwd)throws Exception{
		
		//向session记录用户身份信息
		session.setAttribute("activeUser", userid);
		
		return "redirect:item/queryItem.action";
	}
	
	//退出
	@RequestMapping("/logout")
	public String logout(HttpSession session)throws Exception{
		
		//session过期
		session.invalidate();
		
		return "redirect:item/queryItem.action";
	}






Mybatis、Springmvc练习

CRM系统



数据库
数据库使用mysql 数据库。

3、创建crm数据库
4、将参考资料中的sql脚本导入到数据库中

工程搭建
工程使用Springmvc、spring、mybatis框架整合完成。

SqlMapConfig.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEconfigurationPUBLIC"-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>

</configuration>
applicationContext-dao.xml
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.0.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/task
		http://www.springframework.org/schema/task/spring-task-4.0.xsd
		http://code.alibabatech.com/schema/dubbo        
		http://code.alibabatech.com/schema/dubbo/dubbo.xsd">

	<!-- 配置 读取properties文件 jdbc.properties -->
	<context:property-placeholderlocation="classpath:jdbc.properties"/>

	<!-- 配置 数据源 -->
	<beanid="dataSource"class="com.alibaba.druid.pool.DruidDataSource">
		<!-- 驱动 -->
		<propertyname="driverClassName"value="${jdbc.driver}"/>
		<!-- url -->
		<propertyname="url"value="${jdbc.url}"/>
		<!-- 用户名 -->
		<propertyname="username"value="${jdbc.username}"/>
		<!-- 密码 -->
		<propertyname="password"value="${jdbc.password}"/>
	</bean>

	<!-- 配置 Mybatis的工厂 -->
	<beanclass="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 数据源 -->
		<propertyname="dataSource"ref="dataSource"/>
		<!-- 配置Mybatis的核心 配置文件所在位置 -->
		<propertyname="configLocation"value="classpath:SqlMapConfig.xml"/>
		<!-- 配置pojo别名 -->
		<propertyname="typeAliasesPackage"value="cn.itcast.core.bean"></property>
	</bean>

	<!-- 配置 1：原始Dao开发 接口实现类 Mapper.xml 三个 2：接口开发 接口 不写实现类 Mapper.xml 二个 （UserDao、ProductDao 
		、BrandDao。。。。。。。） 3：接口开发、并支持扫描 cn.itcast.core.dao(UserDao。。。。。） 写在此包下即可被扫描到 -->
	<beanclass="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<propertyname="basePackage"value="cn.itcast.core.dao"/>
	</bean>

</beans>

Jdbc.properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/crm?characterEncoding=utf-8
jdbc.username=root
jdbc.password=root
applicationContext-service.xml
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.0.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd 
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/task
		http://www.springframework.org/schema/task/spring-task-4.0.xsd
		http://code.alibabatech.com/schema/dubbo        
		http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
		
		
		<!-- 配置  扫描   @Service -->
		<context:component-scanbase-package="cn.itcast.core.service"/>
		
		
		
</beans>

applicationContext-trans.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">
	<!-- 事务管理器 -->
	<beanid="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<!-- 数据源 -->
		<propertyname="dataSource"ref="dataSource"/>
	</bean>
	<!-- 通知 -->
	<tx:adviceid="txAdvice"transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 传播行为 -->
			<tx:methodname="save*"propagation="REQUIRED"/>
			<tx:methodname="insert*"propagation="REQUIRED"/>
			<tx:methodname="add*"propagation="REQUIRED"/>
			<tx:methodname="create*"propagation="REQUIRED"/>
			<tx:methodname="delete*"propagation="REQUIRED"/>
			<tx:methodname="update*"propagation="REQUIRED"/>
			<tx:methodname="find*"propagation="SUPPORTS"read-only="true"/>
			<tx:methodname="select*"propagation="SUPPORTS"read-only="true"/>
			<tx:methodname="get*"propagation="SUPPORTS"read-only="true"/>
		</tx:attributes>
	</tx:advice>
	<!-- 切面 -->
	<aop:config>
		<aop:advisoradvice-ref="txAdvice"
			pointcut="execution(* cn.itcast.core.service.*.*(..))"/>
	</aop:config>
</beans>
Springmvc.xml
<beansxmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.0.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-4.0.xsd 
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
		http://www.springframework.org/schema/task
		http://www.springframework.org/schema/task/spring-task-4.0.xsd
		http://code.alibabatech.com/schema/dubbo        
		http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
		
		<!-- 加载属性文件 -->
		<context:property-placeholderlocation="classpath:resource.properties"/>
		<!-- 配置扫描 器 -->
		<context:component-scanbase-package="cn.itcast.core.web.controller"/>
		<!-- 配置处理器映射器  适配器 -->
		<mvc:annotation-driven/>
		
		<!-- 配置视图解释器 jsp -->
		<beanid="jspViewResolver"class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<propertyname="prefix"value="/WEB-INF/jsp/"/>
			<propertyname="suffix"value=".jsp"/>
		</bean>
		
</beans>

Web.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<web-appversion="2.5"xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
	<welcome-file-list>
		<welcome-file>customer.action</welcome-file>
	</welcome-file-list>
	<!-- 上下文的位置 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext-*.xml</param-value>
	</context-param>
	<!-- Spring的监听器 -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>


	<!-- POST提交过滤器 UTF-8 -->
	<filter>
		<filter-name>encoding</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>

	<filter-mapping>
		<filter-name>encoding</filter-name>
		<url-pattern>*.action</url-pattern>
	</filter-mapping>
	<!-- 前端控制器 -->
	<servlet>
		<servlet-name>crm</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<!-- 此处不配置 默认找 /WEB-INF/[servlet-name]-servlet.xml -->
			<param-value>classpath:springmvc.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>crm</servlet-name>
		<!-- 1:*.do *.action 拦截以.do结尾的请求 (不拦截 jsppngjpg .js .css) 2:/ 拦截所有请求 
			（不拦截.jsp) 建议使用此种 方式 （拦截 .js.css .png) (放行静态资源） 3:/* 拦截所有请求（包括.jsp) 此种方式 不建议使用 -->
		<url-pattern>*.action</url-pattern>
	</servlet-mapping>
</web-app>


加入jsp及分页标签

查询条件初始化
需求

初始化查询条件下拉列表。

客户列表展示
需求

展示商品列表，并且可以根据查询条件过滤查询结果，并且实现分页处理。

修改客户信息
需求

3、点击客户列表中的“修改”按钮弹出客户信息修改对话框，并初始化客户信息
4、点击“保存修改”按钮将修改后的结果保存到数据库中

删除客户
需求

点击客户列表中的删除按钮，提示“警告信息”

点击确定后删除用户信息，并刷新页面。



Lucene

全文检索技术






























课程计划
1.什么是全文检索
结构化数据和非结构化数据
对结构化数据的搜索
对非结构化数据的搜索
什么是全文检索
全文检索应用领域

2.什么是lucene
什么是lucene
Lucene与搜索引擎区别
安装lucene
Lucene主要包结构

3.Lucene入门程序： (重点)
1)需求：使用Lucene完成图书信息的全文检索功能开发。
2)互联网搜索引擎架构
3)索引程序
		为什么要采集数据
		如何采集数据
		创建文档Document
		如何创建索引
		分词
		创建索引
4)使用Luke查看索引
5)搜索程序
		输入查询语句
		搜索语法分析
		分词
		搜索索引

4.索引： 
		Field域属性学习(重点)
		索引维护（添加、修改、删除）(重点)
5.搜索：
		使用Query子类对象搜索
		使用QueryParser进行搜索(重点)
6.搜索结果TopDocs(重点)
7.中文分词器(重点)
什么是全文检索
结构化数据和非结构化数据
我们生活中的数据总体分为两种：结构化数据和非结构化数据。

结构化数据：指具有固定格式或有限长度的数据，如数据库中的数据，元数据等。
非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。
对结构化数据的搜索
对数据库的搜索，用SQL语句。再如对元数据的搜索，如利用windows搜索对文件名，类型，修改时间进行搜索等。
对非结构化数据的搜索
（1）顺序扫描法(Serial Scanning)
所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。
（2）全文检索(Full-text Search)
将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。
例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。
这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。
什么是全文检索
	全文检索是一种将文件中所有文本与检索项匹配的文字资料检索方法。全文检索首先将要搜索的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的目的。
	这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。

全文检索就是把文本中的内容拆分成若干个关键词，然后根据关键词创建索引。查询时，根据关键词查询索引，最终找到包含关键词的文章。整个过程类似于查字典的过程。


如下图是对文件搜索的索引：

	上图中，索引栏是从目标数据源中提取出来的词，在进行全文检索时是通过搜索索引（搜索索引中的词）从而找到索引对应的文件即目标数据源。

经过几年的发展，全文检索从最初的字符串匹配程序已经演进到能对超大文本、语音、图像、活动影像等非结构化数据进行综合管理的大型软件。本教程只讨论文本检索。


全文检索的应用领域
	对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。

使用全文检索技术可以实现如下功能：

搜索引擎：




站内搜索：



什么是Lucene
什么是Lucene?
Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。
Lucene与搜索引擎的区别
	

全文检索系统是按照全文检索理论建立起来的用于提供全文检索服务的软件系统。全文检索系统是一个可以运行的系统，包括建立索引、处理查询返回结果集、增加索引、优化索引结构等功能。例如：百度搜索、eclipse帮助搜索、淘宝网商品搜索。
搜索引擎是全文检索技术最主要的一个应用，例如百度。搜索引擎起源于传统的信息全文检索理论，即计算机程序通过扫描每一篇文章中的每一个词，建立以词为单位的倒排文件，检索程序根据检索词在每一篇文章中出现的频率和每一个检索词在一篇文章中出现的概率，对包含这些检索词的文章进行排序，最后输出排序的结果。全文检索技术是搜索引擎的核心支撑技术。
Lucene和搜索引擎不同，Lucene是一套用java或其它语言写的全文检索的工具包，为应用程序提供了很多个api接口去调用，可以简单理解为是一套实现全文检索的类库，搜索引擎是一个全文检索系统，它是一个单独运行的软件。


安装Lucene
Lucene是开发全文检索功能的工具包，从官方网站下载Lucene4.10.3，并解压。

官方网站：http://lucene.apache.org/ 

版本：lucene4.10.3

Jdk要求：1.7以上

Lucene主要包结构

包名	功能
org.apache.lucene.analysis	语言分析器，主要用于的切词
Lucene提供的分析器实现类在：
lucene-analyzers-common-4.10.3.jar
org.apache.lucene.document	索引存储时的文档结构管理，类似于关系型数据库的表结构
org.apache.lucene.index	索引管理，包括索引建立、删除等
org.apache.lucene.queryParser	查询分析器，实现查询关键词间的运算，如与、或、非等, 生成查询表达式，
org.apache.lucene.search	检索管理，根据查询条件，检索得到结果
org.apache.lucene.store	数据存储管理，包括一些I/O操作
org.apache.lucene.util	公用类


Lucene全文检索过程入门
需求
	我们对全文检索的分析以一个电商网站的站内搜索为例进行分析，本例子以搜索图书为例进行讲解。


互联网搜索引擎系统架构


整个全文检索过程分为两个过程，索引和搜索。
1、采集数据
将关系数据库中的数据、互联网的数据、文件系统中文件等原始数据采集到某一个地方。
2、创建索引
对第一步采集到的数据创建索引，将索引文件存储到文件系统（可以将索引文件存储到内存中）中。
创建索引之前需要将原始数据中内容抽取一个一个词，对词创建索引。
3、定义查询语句
要想根据自己的需求去搜索索引库，定义好查询语句（类似sql语言）。
4、搜索索引
拿着上一步定义查询语句去搜索索引。
5、解析搜索的结果
解析出搜索结果按照用户的需求进行展示，将结果进行排序（搜索结果已经按照相关度进行排序），对结果中关键字进行高亮显示。






电商系统中商品搜索的技术架构如下：



准备环境
jdk1.7
lucene-4.10.3
mysql 5.1
eclipse indigo

jar：
mysql5.1驱动包：mysql-connector-java-5.1.7-bin.jar
lucene核心包：lucene-core-4.10.3.jar
lucene分析器通用包：lucene-analyzers-common-4.10.3.jar
lucene查询解析器包：lucene-queryparser-4.10.3.jar
junit包：junit-4.9.jar

创建java工程加入以上jar 包。


【索引过程】
为什么要采集数据？
	全文检索要搜索的数据信息格式多种多样，拿搜索引擎（百度， google）来说，通过搜索引擎网站能搜索互联网站上的网页(html)、互联网上的音乐(mp3..)、视频(avi..)、pdf电子书等。
	全文检索搜索的这些数据称为非结构化数据。


如何采集数据？
采集数据技术有哪些？
	1、对于互联网上网页采用http将网页抓取到本地生成html文件。 
	2、如果数据在数据库中就连接数据库读取表中的数据。
	3、如果数据是文件系统中的某个文件，就通过文件系统读取文件的内容。

以上技术中使用第一种较多，因为目前全文检索主要搜索数据的来源是互联网，搜索引擎使用一种爬虫程序抓取网页（ 通过http抓取html网页信息），以下是一些爬虫项目和一些爬虫所用到的技术框架（了解）：
	Solr（http://lucene.apache.org/solr） ，solr是apache的一个子项目，支持从关系数据库、xml文档中提取原始数据。
	Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。
	jsoup（http://jsoup.org/ ），jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
	heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix 是一个由 java 开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。


针对电商站内搜索功能，全文检索的数据源在数据库中，需要通过jdbc访问数据库中book表的内容。



Book.java
public class Book {
	
	private Integer id;
	private String name;
	private Float price;
	private String pic;
	private String description;

创建Dao负责采集数据库中的数据：
public interface BookDao {
	
	//图书查询
	public List<Book> findBookList()throws Exception;
}

public class BookDaoImpl implements BookDao {

	// 查询sql
	private static String sql = "SELECT * FROM book";

	@Override
	public List<Book> findBookList() throws Exception {

		// 数据库链接
		Connection connection = null;

		// 预编译statement
		PreparedStatement preparedStatement = null;

		// 结果集
		ResultSet resultSet = null;

		// 区域列表
		List<Book> list = new ArrayList<Book>();
		try {
			// 加载数据库驱动
			Class.forName("com.mysql.jdbc.Driver");
			// 连接数据库
			connection = DriverManager.getConnection(
					"jdbc:mysql://localhost:3306/lucene", "root", "mysql");
			// 创建preparedStatement
			preparedStatement = connection.prepareStatement(sql);

			// 获取结果集
			resultSet = preparedStatement.executeQuery();

			// 结果集解析
			while (resultSet.next()) {
				Book book = new Book();
				book.setId(resultSet.getInt("id"));
				book.setName(resultSet.getString("name"));
				book.setPrice(resultSet.getFloat("price"));
				book.setPic(resultSet.getString("pic"));
				book.setDescription(resultSet.getString("description"));
				list.add(book);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			if(resultSet!=null){
				resultSet.close();
			}
			if(preparedStatement!=null){
				preparedStatement.close();
			}
			if(connection!=null){
				connection.close();
			}
		}

		return list;

	}

}





创建文档Document
	Document是Lucene对索引对外表示的逻辑结构，Document采用NOSql的存储理念，每个Document中有很多Field组成，Field中存储key/value对即name:XXX，value：XXX
	创建索引前要将要索引的内容用Document表示，这一步就相当于提取非结构数据的信息然后结构化为Document形式	。
	创建索引就是针对Document中的内容进行索引，确切的说是针对Document中Field域中的内容进行索引。

BookDao bookDao = new BookDaoImpl();
		// 从数据库中查询图书信息
		List<Book> bookList = bookDao.findBookList();
		List<Document> docs = new ArrayList<Document>();
		for (Book book : bookList) {
			//document文档
			Document document = new Document();
			//商品id
			TextField id = new TextField("id", book.getId().toString(),
					Store.YES);
			//商品名称
			TextField name = new TextField("name", book.getName(), Store.YES);
			//商品价格
			FloatField price = new FloatField("price", book.getPrice(),
					Store.YES);
			//商品图片
			TextField pic = new TextField("pic", book.getPic(), Store.YES);
			//商品描述
			TextField description = new TextField("description",
					book.getDescription(), Store.YES);
			//将Field添加到文档中
			document.add(id);
			document.add(name);
			document.add(price);
			document.add(pic);
			document.add(description);

			docs.add(document);

		}



















如何创建索引？(图)
1）索引文件逻辑结构：

 

文档域：
对非结构化的数据统一格式为document文档格式，一个文档有多个field域，不同的文档其field的个数可以不同，建议相同类型的文档包括相同的field。 
本例子一个document对应一 条 book表的记录。
文档域作用：将非结构化数据进行统一结构化，将document中field中的value值进行分词。


索引域：
用于搜索，搜索程序将从索引域中搜索一个一个词，根据词找到对应的文档。
将Document中的Field的内容进行分词，将分好的词创建索引，索引=Field域名:词



倒排索引表

传统方法是已知文件在文件中找内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大就搜索慢。
	倒排索引结构是根据关键字（词语）找文档，倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它是在索引中匹配搜索关键字，由于索引内容量有限并且采用固定优化算法搜索速度很快，找到了索引中的词汇，词汇与文档关联，从而最终找到了文档。


2）创建索引流程：

1、对原始内容信息抽取，并创建Document文档。
2、使用Analyzer分词器对Document文档中的内容进行分词。
3、通过IndexWriter创建索引
	IndexWriter是索引过程的核心组件，通过IndexWriter可以创建新索引、更新索引、删除索引操作。IndexWriter需要通过Directory对索引进行存储操作。
4、通过Directory索引流对象将索引文件写入文件系统
	Directory描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。它的子类常用的包括FSDirectory（在文件系统存储索引）、RAMDirectory（在内存存储索引）。


分词
在对Docuemnt中的内容索引之前需要经过分词、过虑两步。
分词就是将原始文档内容切分成一个一个的词也就是将Document中Field的value值切分成一个一个的词。
过虑包括去除标点符号、去除停用词（的、是、a、an、the等）、大写转小写、词的形态还原（复数形式转成单数形参、过去式转成现在式。。。）等。

Lucene作为了一个工具包提供不同国家的分词器，如下图：


注意由于语言不同分词器的切分规则也不同，本例子使用StandardAnalyzer，标准分词器可以对英文内容进行分词，它先按照空格将内容切分成一个一个词，再去除a/an/the等停用词、大写转小写、词语形态变换（比如将名称复数形式转成单数形式等）：
如下：
原内容：
Lucene is a Java full-text search engine.  Lucene is not a complete
application, but rather a code library and API that can easily be used
to add search capabilities to applications.

分词、过虑后得到的词：
lucene、java、full、search、engine。。。。。




代码如下：
// 创建标准分析器
Analyzer standardAnalyzer = new StandardAnalyzer();


创建索引

// 创建标准分词器
		Analyzer standardAnalyzer = new StandardAnalyzer();
		// 索引操作配置信息
		IndexWriterConfig indexWriterConfig = new IndexWriterConfig(
				Version.LUCENE_4_10_3, standardAnalyzer);
		// 创建索引目录流对象
		Directory directory = FSDirectory.open(new File("F:\\develop\\lucene\\indexdata"));
		// 定义索引操作对象
		IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig);

		// 遍历目录 下的文件生成的文档，调用indexWriter方法创建索引
		for (Document document : docs) {
			indexWriter.addDocument(document);
		}
		//提交 
		indexWriter.commit();
		// 索引操作流关闭
		indexWriter.close();


使用Luke查看索引
	Luke作为Lucene工具包中的一个工具（http://www.getopt.org/luke/），用于查询、修改lucene的索引文件。

打开Luke方法：
cmd运行：java  -jar lukeall-4.10.3.jar







【搜索过程】
搜索过程：


1、创建查询对象query，这里就是指定搜索语句，就相当于查询关系数据要输入sql语句。
2、通过索引搜索对象IndexSearcher搜索索引
3、IndexSearcher通过IndexReader读取索引文件中Document。
4、IndexReader最终通过Directory索引流对象执行I/O操作从索引文件中读取内容。
5、IndexSearcher搜索完成返回搜索结果TopDocs。
6、解析TopDocs的内容展示给用户。

输入查询语句
同数据库的sql一样，lucene全文检索也有固定的语法：
最基本的有比如：AND, OR, NOT 等
举个例子，用户输入语句：description:java AND lucene
说明用户想找一个description中包括java关键字和lucene关键字的文档。
如下是使用luke搜索的例子：



搜索语法分析
	由于查询语句为特殊的语法所以lucene会首先对语法进行分析，判断语法关键字的正确性，比如NOT、AND、OR，分别抽取出语法关键字和搜索关键字。

分词
	和索引过程的分词一样，这里要对用户输入的关键字进行分词，一般情况索引和搜索使用的分词器一致。
	比如：输入搜索关键字“java培训”，分词后为java和培训两个词，与java和培训有关的内容都搜索出来了，如下：


搜索索引
	根据关键字从索引中找到索引信息，索引即词term，term与document相关联，找到了term就找到了关联的document，从document取出Field中的信息即是要搜索的信息。


代码如下：

//搜索索引
	@Test
	public void searchIndex() throws ParseException, IOException{
		
		//分析器
		Analyzer analyzer = new StandardAnalyzer();
		//查询解析器
		//第一个构造参数是默认搜索的域
		QueryParser queryParser = new QueryParser("description", analyzer);
		//搜索语法，由于queryParser中指定的默认搜索的域这里的filed名称可以省略
		Query query = queryParser.parse("description:java AND lucene");
		
		//索引目录流对象
		Directory directory = FSDirectory.open(new File("F:\\develop\\lucene\\indexdata"));
		//索引读取对象
		IndexReader indexReader = IndexReader.open(directory);
		//搜索对象
		IndexSearcher indexSearcher = new IndexSearcher(indexReader);
		//执行搜索，取出符合记录的前100条
		TopDocs topDocs = indexSearcher.search(query, 100);
		
		for(ScoreDoc scoreDoc:topDocs.scoreDocs){
			//文档id
			int docID = scoreDoc.doc;
			//根据id从IndexReader中获取document
			Document doc = indexReader.document(docID);
			//从document中获取Field的信息
			String id = doc.get("id");
			String name = doc.get("name");
			Float price = Float.parseFloat(doc.get("price"));
			String description = doc.get("description");
			System.out.println("==========================");
			System.out.println("文档id："+docID);
			System.out.println("图书id："+id);
			System.out.println("图书名称："+name);
			System.out.println("图书价格："+price);
//			System.out.println("图片描述："+description);
			
		}
		//关闭流
		indexReader.close();
		
		
	}

索引
Field域的属性
索引问题
是否需要分词
分词就是将一句话拆分成一个一个的词，分词的目的是索引
是否需要索引
索引的目的是为了搜索，所以要看是否需要搜索
是否需要存储
存储的目的是为了显示，为了提取要显示的数据。
需求
根据数据库中的图书信息表结构，改造document中filed类型

Field属性
	Field是文档中的域，包括Field名和Field值两部分，一个文档可以包括多个Field，Document只是Field的一个承载体，Field值即为要索引的内容，也是要搜索的内容。

1、是否分词(tokenized)
是：将Field值分词其目的是将词进行索引
比如：图书名称、图书简介等，这些内容用户要输入关键字搜索，由于搜索的内容格式大、内容多需要分析后将语汇单元索引。

否：不作分词处理
比如：图书id、订单号、身份证号等 

2、是否索引(indexed)
是：索引的目的是为了搜索，可以将Field分词后进行索引也可以对整个Field进行索引。
比如：图书名称、图书简介分词后进行索引，订单号、身份证号不用分词但也要索引，这些将来都要作为查询条件，如果将来查询要根据图书表的主键id查询，那图书id也要索引。

否：不索引无法搜索到
比如：图片路径等，不用作为查询条件的不用索引。

3、是否存储(stored)
是：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取
比如：图书名称、订单号，凡是将来要从Document中获取的Field都要存储。

否：不存储Field值，不存储的Field无法通过Document获取
比如：图书简介，内容较大不用存储。如果要向用户展示商品简介可以从系统的关系数据库中获取商品简介，思路是从lucene索引获取图书id，根据图书id查询关系数据库。








Field常用类型
下边列出了开发中常用 的Filed类型，注意Field的属性，根据需求选择：

Field类	数据类型	Tokenized是否分词	Indexed
是否索引	Stored
是否存储	说明
StringField(FieldName, FieldValue,Store.YES))	字符串	N	Y	Y或N	这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)
是否存储在文档中用Store.YES或Store.NO决定
LongField(FieldName, FieldValue,Store.YES)	Long型 	Y	Y	Y或N	这个Field用来构建一个Long数字型Field，进行分析和索引，比如(价格)
是否存储在文档中用Store.YES或Store.NO决定
StoredField(FieldName, FieldValue) 	重载方法，支持多种类型	N	N	Y	这个Field用来构建不同类型Field
不分析，不索引，但要Field存储在文档中
TextField(FieldName, FieldValue, Store.NO)
或
TextField(FieldName, reader)
	字符串
或
流	Y	Y	Y或N	如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略.

创建Field代码如下
修改原来的创建Document代码：

		//商品id，不分词，要索引，要存储
			StringField id = new StringField("id",book.getId().toString(),Store.YES);
			//商品名称，要分词，要索引，要存储
			TextField name = new TextField("name", book.getName(), Store.YES);
			//商品价格，要分词，要索引，要存储
			FloatField price = new FloatField("price", book.getPrice(),
					Store.YES);
			//商品图片，不分词，不索引，要存储
			StoredField pic = new StoredField("pic", book.getPic());
			
			//商品描述，要分词，要索引，不存储
			TextField description = new TextField("description",
					book.getDescription(), Store.NO);

【索引维护】
需求
	管理人员通过电商系统更改图书信息，这时更新的是数据库，如果使用lucene搜索图书信息需要在数据库表book信息变化时及时更新lucene索引库。
添加索引
同入门程序。

删除索引
需要指定条件删除。
最佳实践：删除文档时根据主键唯一标识去匹配删除。
1）删除符合条件的索引

//删除索引
	@Test
	public void deleteIndex() throws IOException, ParseException{
		// 创建标准分析器
		Analyzer standardAnalyzer = new StandardAnalyzer();
		// 索引操作配置信息
		IndexWriterConfig indexWriterConfig = new IndexWriterConfig(
				Version.LUCENE_4_10_3, standardAnalyzer);
		// 创建索引目录流对象
		Directory directory = FSDirectory.open(new File(indexFolder));
		// 定义索引操作对象
		//第一个构造参数是默认搜索的域
		QueryParser queryParser = new QueryParser("description", standardAnalyzer);
		//搜索语法，由于queryParser中指定的默认搜索的域这里的filed名称可以省略
		Query query = queryParser.parse("description:java AND lucene");
		//索引操作对象
		IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig);
		//删除符合搜索语法的索引记录
		indexWriter.deleteDocuments(query);
		//索引删除后无法恢复
		indexWriter.commit();
		// 关闭索引操作流
		indexWriter.close();

		
	}

说明：根据query删除索引，满足条件的将全部删除，建议参照关系数据库基于主键删除方式，所以在创建索引时需要创建一个主键Field比如图书id，它对应数据库表中的主键，删除时根据此主键Field删除。
Lucene3.X版本中索引删除后将放在Lucene的回收站中，可以恢复删除的文档，3.X之后无法恢复。

2）删除全部索引

//删除全部索引
indexWriter.deleteAll();
说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复。

更新索引
流程：先删除后添加文档。
最佳实践：删除文档时根据主键唯一标识去匹配删除。
//创建term第一个参数是field，第二个参数是匹配的值
		Term term =new Term("id", "1");
		//更新document
		Document doc = new Document();
		//商品id，不分词，要索引，要存储
		StringField id = new StringField("id","1",Store.YES);
		//商品名称，要分词，要索引，要存储
		TextField name = new TextField("name","java 编程思想第三版", Store.YES);
		doc.add(id);
		doc.add(name);
		//更新索引
		indexWriter.updateDocument(term, doc);
		//提交
		indexWriter.commit();
		//关闭
		indexWriter.close();

说明：更新索引是先删除再添加，根据term找到匹配field的document，并删除，再添加新的document到索引库。	建议将term设置为主键Field这样根据主键Field只会删除一个文档。



搜索
Query查询
	
	对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。
	可通过两种方法创建查询对象：
	1）使用Lucene提供Query子类
	Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。
	如下代码：
	Query query = new TermQuery(new Term("name", "lucene"));

	2）使用QueryParse解析查询表达式
	QueryParse会将用户输入的查询表达式解析成Query对象实例。
	如下代码：
	QueryParser queryParser = new QueryParser("name", new StandardAnalyzer());
		Query query = queryParser.parse("name:lucene");

TermQuery
	TermQuery通过项查询，匹配某个Field

//创建查询对象
Query query = new TermQuery(new Term("name", "java"));

//搜索索引 目录 
Directory directory = FSDirectory.open(new File(indexFolder));

//定义IndexReader
IndexReader reader = DirectoryReader.open(directory);
//创建indexSearcher
IndexSearcher indexSearcher = new IndexSearcher(reader);
//执行搜索
TopDocs topDocs = indexSearcher.search(query, 100);

NumericRangeQuery
NumericRangeQuery，指定数字范围查询，如下：
//文件大小在0到1024的文件
NumericRangeQuery<Long> numericRangeQuery = NumericRangeQuery
				.newLongRange("price", 0l, 200l, true, true);


BooleanQuery
BooleanQuery，布尔查询，实现组合条件查询，如下：

// 数字范围查询
NumericRangeQuery<Long> numericRangeQuery = NumericRangeQuery
		.newLongRange("price", 0l, 200l, true, true);

//定义Boolean查询
BooleanQuery booleanQuery = new BooleanQuery();
//必须满足price在0到200范围的条件
booleanQuery.add(numericRangeQuery, Occur.MUST);

//根据文件名搜索
Query query = new TermQuery(new Term("name", "java"));
//查询名称“java”
booleanQuery.add(query, Occur. MUST);

IndexReader reader = DirectoryReader.open(directory);

IndexSearcher searcher = new IndexSearcher(reader);

TopDocs topDocs = searcher.search(booleanQuery, 100);

说明：
Occur.MUST 查询条件必须满足，相当于and
Occur.SHOULD 查询条件可选，相当于or
Occur.MUST_NOT 查询条件不能满足，相当于not非

Occur.MUST、Occur.MUST_NOT、Occur.SHOULD通常组合使用，有以下6种组合： 
 
1．MUST和MUST：取得两个查询子句的交集。 
2．MUST和MUST_NOT：表示查询结果中不能包含MUST_NOT所对应得查询子句的检索结果。 
3．SHOULD与MUST_NOT：连用时，功能同MUST和MUST_NOT。
4．SHOULD与MUST连用时，结果为MUST子句的检索结果,但是SHOULD可影响排序。
5．SHOULD与SHOULD：表示“或”关系，最终检索结果为所有检索子句的并集。
6． MUST_NOT和MUST_NOT：无意义，检索无结果。单独使用Occur.MUST_NOT无结果。



QueryParser 
QueryParser使用方法：

//f是默认搜索的域
QueryParser queryParser = new QueryParser("f", analyzer);
// 指定查询语法 ，如果不指定description就搜索默认的域
Query query2 = queryParser.parse("description:java");

或：
Query query2 = queryParser.parse("java");


上边介绍的基于类的查询方法，使用QueryParser可用下边的查询语法 实现，
项查询：
FieldName : value 
范围查询：
FieldName:[min TO max]
注意：QueryParse不支持对数字范围的搜索，它支持字符串范围。数字范围搜索建议使用NumericRangeQuery。
组合查询：
上边BooleanQuery例子的查询表达式如下：
+price:[0 TO 200] +name:java
上边的表达式表示price的值在0和200之间且name为“java”，必须满足的条件使用+（加号）表示。

与BooleanQuery中Occur对应的符号如下：

Occur.MUST 查询条件必须满足，相当于and	+（加号）
Occur.SHOULD 查询条件可选，相当于or
	空（不用符号）
Occur.MUST_NOT 查询条件不能满足，相当于not非	-（减号）

关键字查询

AND：关键字1  AND 关键字2
两个关键字都匹配上条件满足。

OR：关键字1  OR 关键字2
两个关键字匹配一个条件满足

NOT：关键字1  NOT  关键字2
关键字1满足，关键字2不满足


MultiFieldQueryParser 
	通过MuliFieldQueryParse对多个域查询，比如商品信息查询，输入关键字需要从商品名称和商品内容中查询。

代码：
//设置组合查询域
String[] fields = {"name","description"};
//创建查询解析器
QueryParser queryParser =  new MultiFieldQueryParser(fields, new StandardAnalyzer());
//查询名称和内容中包括“java”关键字的文档
Query query = queryParser.parse("java");


TopDocs

Lucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下：

方法或属性	说明
totalHits	匹配搜索条件的总记录数
	
	
	
scoreDocs	顶部匹配记录,相关度前边的记录

注意：
Search方法需要指定匹配前n条记录：indexSearcher.search(query, n)，n表示指定要获取相关度高的记录数。

TopDocs.totalHits：是匹配索引库中所有记录的数量，不受search中n的影响
TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n，scoreDocs的长度小于等于totalHits


中文分词器
Analyzer执行过程
	Analyzer是一个抽象类，在Lucene的lucene-analyzers-common包中提供了很多分析器，比如：org.apache.lucene.analysis.standard.standardAnalyzer标准分词器，它是Lucene的核心分词器，它对分析文本进行分词、大写转成小写、去除停用词、去除标点符号等操作过程。
	

	什么是停用词？停用词是为节省存储空间和提高搜索效率，搜索引擎在索引页面或处理搜索请求时会自动忽略某些字或词，这些字或词即被称为Stop Words(停用词)。比如语气助词、副词、介词、连接词等，通常自身并无明确的意义，只有将其放入一个完整的句子中才有一定作用，如常见的“的”、“在”、“是”、“啊”等。


如下是org.apache.lucene.analysis.standard.standardAnalyzer的部分源码：

final StandardTokenizer src = new StandardTokenizer(getVersion(), reader);//创建分词器
src.setMaxTokenLength(maxTokenLength);
TokenStream tok = new StandardFilter(getVersion(), src);//创建标准分词过滤器
tok = new LowerCaseFilter(getVersion(), tok);//在标准分词过滤器的基础上加大小写转换过滤
tok = new StopFilter(getVersion(), tok, stopwords);//在上边过滤器基础上加停用词过滤

TokenStream是语汇单元流，tokenStream是一个抽象类，它是所有分析器的基类，如下图：


Tokenizer是分词器，负责将reader转换为语汇单元即进行分词，Lucene提供了很多的分词器，也可以使用第三方的分词，比如IKAnalyzer一个中文分词器。

tokenFilter是分词过滤器，负责对语汇单元进行过滤，tokenFilter可以是一个过滤器链儿，Lucene提供了很多的分词器过滤器，比如大小写转换、去除停用词等。


如下图是语汇单元的生成过程：



从一个Reader字符流开始，创建一个基于Reader的Tokenizer分词器，经过三个TokenFilter生成语汇单元Token。

什么是中文分词器
	学过英文的都知道，英文是以单词为单位的，单词与单词之间以空格或者逗号句号隔开。而中文则以字为单位，字又组成词，字和词再组成句子。所以对于英文，我们可以简单以空格判断某个字符串是否为一个单词，比如I love China，love 和 China很容易被程序区分开来；但中文“我爱中国”就不一样了，电脑不知道“中国”是一个词语还是“爱中”是一个词语。把中文的句子切分成有意义的词，就是中文分词，也称切词。我爱中国，分词的结果是：我 爱 中国。

Lucene自带中文分词器
StandardAnalyzer：
单字分词：就是按照中文一个字一个字地进行分词。如：“我爱中国”，
效果：“我”、“爱”、“中”、“国”。
CJKAnalyzer
二分法分词：按两个字进行切分。如：“我是中国人”，效果：“我是”、“是中”、“中国”“国人”。

上边两个分词器无法满足需求。

第三方产品介绍
ik-analyzer：
	IK Analyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。

mmseg4j
用 Chih-Hao Tsai 的 MMSeg 算法(http://technology.chtsai.org/mmseg/)实现的中文分词器，并实现 lucene 的 analyzer 和 solr 的TokenizerFactory 以方便在Lucene和Solr中使用。MMSeg 算法有两种分词方法：Simple和Complex，都是基于正向最大匹配。Complex 加了四个规则过滤。官方说：词语的正确识别率达到了 98.41%。mmseg4j 已经实现了这两种分词算法。
imdict-chinese-analyzer
imdict-chinese-analyzer 是 imdict智能词典 的智能中文分词模块，算法基于隐马尔科夫模型(Hidden Markov Model, HMM)，是中国科学院计算技术研究所的ictclas中文分词程序的重新实现（基于Java），可以直接为lucene搜索引擎提供简体中文分词支持。
ictclas4j
ICTCLAS4j中文分词系统是sinboy在中科院张华平和刘群老师的研制的FreeICTCLAS的基础上完成的一个java开源分词项目，简化了原分词程序的复杂度，旨在为广大的中文分词爱好者一个更好的学习机会。关于ICTCLAS分词系统的讨论，请访问google group关于ictclas分词系统的讨论组http://groups.google.com/group/ictclas
ICTCLAS汉语分词系：http://ictclas.org/
庖丁解牛分词
PaodingAnalzyer，最后版本是2.0.4，更新时间是2008-06-03，不支持Lucene3.0，目前已不再更新。


中文分词器测试
使用Luke测试第三方分词器分词效果，需通过java.ext.dirs加载jar包:
可简单的将第三方分词器和lukeall放在一块儿，cmd下运行：
java -Djava.ext.dirs=. -jar lukeall-4.10.3.jar



使用中文分词器
如果要使用中文分词器则在索引和搜索都要使用中文分词器，并且分词器一致。
//选择中文分词器
Analyzer analyzer = new IKAnalyzer();


自定义词库
在classpath下定义IKAnalyzer.cfg.xml文件，如下：

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">  
<properties>  

    <comment>IK Analyzer 扩展配置</comment>
    <!-- 用户可以在这里配置自己的扩展字典 -->
     <entry key="ext_dict">dicdata/mydict.dic</entry> 
     <!-- 用户可以在这里配置自己的扩展停用词字典    -->
    <entry key="ext_stopwords">dicdata/ext_stopword.dic</entry> 

</properties>

在classpath下的编辑dicdata/mydict.dic文件，此文件中存储扩展词库，在dicdata/ext_stopword.dic文件中存放停用词。
注意：mydict.dic和ext_stopword.dic文件的格式为UTF-8，注意是无BOM 的UTF-8 编码。

使用EditPlus.exe保存为无BOM 的UTF-8 编码格式，如下图：






















全文检索课程
Lucene&Solr（2）



























1.课程计划
1.Solr的安装及配置
a) Solr整合tomcat
b) Solr后台管理功能介绍
c) 配置中文分析器
2.使用Solr的后台管理索引库
a)添加文档
b)删除文档
c)修改文档
d)查询文档
3.使用SolrJ管理索引库
a)添加文档
b)修改文档
c)删除文档
d)查询文档
4.电商搜索案例实现
a)案例分析
b)案例实现
























2.需求分析
2.1.实现方法
在一些大型门户网站、电子商务网站等都需要站内搜索功能，使用传统的数据库查询方式实现搜索无法满足一些高级的搜索需求，比如：搜索速度要快、搜索结果按相关度排序、搜索内容格式不固定等，这里就需要使用全文检索技术实现搜索功能。
2.1.1.使用Lucene实现
单独使用Lucene实现站内搜索需要开发的工作量较大，主要表现在：索引维护、索引性能优化、搜索性能优化等，因此不建议采用。
2.1.2.使用solr实现
基于Solr实现站内搜索扩展性较好并且可以减少程序员的工作量，因为Solr提供了较为完备的搜索引擎解决方案，因此在门户、论坛等系统中常用此方案。

2.2.什么是solr
Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 
Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。

Solr与Lucene的区别：
Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。
 Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。


3.Solr安装及配置
3.1.Solr的下载
从Solr官方网站（http://lucene.apache.org/solr/ ）下载Solr4.10.3，根据Solr的运行环境，Linux下需要下载lucene-4.10.3.tgz，windows下需要下载lucene-4.10.3.zip。
Solr使用指南可参考：https://wiki.apache.org/solr/FrontPage。
3.2.Solr的文件夹结构
将solr-4.10.3.zip解压：


bin：solr的运行脚本
contrib：solr的一些贡献软件/插件，用于增强solr的功能。
dist：该目录包含build过程中产生的war和jar文件，以及相关的依赖文件。
docs：solr的API文档
example：solr工程的例子目录：
example/solr：
	该目录是一个包含了默认配置信息的Solr的Core目录。
example/multicore：
	该目录包含了在Solr的multicore中设置的多个Core目录。 
example/webapps：
    该目录中包括一个solr.war，该war可作为solr的运行实例工程。
licenses：solr相关的一些许可信息
3.3.运行环境
solr 需要运行在一个Servlet容器中，Solr4.10.3要求jdk使用1.7以上，Solr默认提供Jetty（java写的Servlet容器），本教程使用Tocmat作为Servlet容器，环境如下：

Solr：Solr4.10.3
Jdk：jdk1.7.0_72
Tomcat：apache-tomcat-7.0.53
3.4.Solr整合tomcat
3.4.1.Solr Home与SolrCore
创建一个Solr home目录，SolrHome是Solr运行的主目录，目录中包括了运行Solr实例所有的配置文件和数据文件，Solr实例就是SolrCore，一个SolrHome可以包括多个SolrCore（Solr实例），每个SolrCore提供单独的搜索和索引服务。

example\solr是一个solr home目录结构，如下：


上图中“collection1”是一个SolrCore（Solr实例）目录 ，目录内容如下所示：


说明：
collection1：叫做一个Solr运行实例SolrCore，SolrCore名称不固定，一个solr运行实例对外单独提供索引和搜索接口。
solrHome中可以创建多个solr运行实例SolrCore。
一个solr的运行实例对应一个索引目录。
conf是SolrCore的配置文件目录 。
data目录存放索引文件需要创建

3.4.2.整合步骤
第一步：安装tomcat。D:\temp\apache-tomcat-7.0.53
第二步：把solr的war包复制到tomcat 的webapp目录下。
把\solr-4.10.3\dist\solr-4.10.3.war复制到D:\temp\apache-tomcat-7.0.53\webapps下。
改名为solr.war
第三步：solr.war解压。使用压缩工具解压或者启动tomcat自动解压。解压之后删除solr.war
第四步：把\solr-4.10.3\example\lib\ext目录下的所有的jar包添加到solr工程中
第五步：配置solrHome和solrCore。
1）创建一个solrhome（存放solr所有配置文件的一个文件夹）。\solr-4.10.3\example\solr目录就是一个标准的solrhome。
2）把\solr-4.10.3\example\solr文件夹复制到D:\temp\0108路径下，改名为solrhome，改名不是必须的，是为了便于理解。
3）在solrhome下有一个文件夹叫做collection1这就是一个solrcore。就是一个solr的实例。一个solrcore相当于mysql中一个数据库。Solrcore之间是相互隔离。
i.在solrcore中有一个文件夹叫做conf，包含了索引solr实例的配置信息。
ii.在conf文件夹下有一个solrconfig.xml。配置实例的相关信息。如果使用默认配置可以不用做任何修改。
Xml的配置信息：
Lib：solr服务依赖的扩展包，默认的路径是collection1\lib文件夹，如果没有		 就创建一个
dataDir：配置了索引库的存放路径。默认路径是collection1\data文件夹，如			果没有data文件夹，会自动创建。
requestHandler：


第六步：告诉solr服务器配置文件也就是solrHome的位置。修改web.xml使用jndi的方式告诉solr服务器。
Solr/home名称必须是固定的。


第七步：启动tomcat
第八步：访问http://localhost:8080/solr/

3.5.Solr后台管理
3.5.1.管理界面

3.5.2.Dashboard
仪表盘，显示了该Solr实例开始启动运行的时间、版本、系统资源、jvm等信息。
3.5.3.Logging
Solr运行日志信息
3.5.4.Cloud
Cloud即SolrCloud，即Solr云（集群），当使用Solr Cloud模式运行时会显示此菜单，如下图是Solr Cloud的管理界面：

3.5.5.Core Admin
Solr Core的管理界面。Solr Core 是Solr的一个独立运行实例单位，它可以对外提供索引和搜索服务，一个Solr工程可以运行多个SolrCore（Solr实例），一个Core对应一个索引目录。

添加solrcore：
第一步：复制collection1改名为collection2
第二步：修改core.properties。name=collection2
第三步：重启tomcat
3.5.6.java properties
Solr在JVM 运行环境中的属性信息，包括类路径、文件编码、jvm内存设置等信息。

3.5.7.Tread Dump
显示Solr Server中当前活跃线程信息，同时也可以跟踪线程运行栈信息。
3.5.8.Core selector
选择一个SolrCore进行详细操作，如下：

3.5.9.Analysis

通过此界面可以测试索引分析器和搜索分析器的执行情况。
3.5.10.Dataimport
可以定义数据导入处理器，从关系数据库将数据导入 到Solr索引库中。
3.5.11.Document
通过此菜单可以创建索引、更新索引、删除索引等操作，界面如下：


/update表示更新索引，solr默认根据id（唯一约束）域来更新Document的内容，如果根据id值搜索不到id域则会执行添加操作，如果找到则更新。
3.5.12.Query


通过/select执行搜索索引，必须指定“q”查询条件方可搜索。
3.6.配置中文分析器
3.6.1.Schema.xml
schema.xml，在SolrCore的conf目录下，它是Solr数据表配置文件，它定义了加入索引的数据的数据类型的。主要包括FieldTypes、Fields和其他的一些缺省设置。

FieldType域类型定义
下边“text_general”是Solr默认提供的FieldType，通过它说明FieldType定义的内容：


FieldType子结点包括：name,class,positionIncrementGap等一些参数：
name：是这个FieldType的名称
class：是Solr提供的包solr.TextField，solr.TextField 允许用户通过分析器来定制索引和查询，分析器包括一个分词器（tokenizer）和多个过滤器（filter）
positionIncrementGap：可选属性，定义在同一个文档中此类型数据的空白间隔，避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经验设置为100。
例如:搜索big car,如果document中存的是big  red  car,就无法搜索到了, positionIncrementGap就是设置big和car中间最大的间隔距离,只要在距离内就能搜索到.

在FieldType定义的时候最重要的就是定义这个类型的数据在建立索引和进行查询的时候要使用的分析器analyzer,包括分词和过滤

索引分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilterFactory停用词过滤器，solr.LowerCaseFilterFactory小写过滤器。
搜索分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilterFactory停用词过滤器，这里还用到了solr.SynonymFilterFactory同义词过滤器。
Field定义
在fields结点内定义具体的Field，filed定义包括name,type（为之前定义过的各种FieldType）,indexed（是否被索引）,stored（是否被储存），multiValued（是否存储多个值）等属性。
如下：
<field name="name" type="text_general" indexed="true" stored="true"/>
<field name="features" type="text_general" indexed="true" stored="true" multiValued="true"/>

multiValued：该Field如果要存储多个值时设置为true，solr允许一个Field存储多个值，比如存储一个用户的好友id（多个），商品的图片（多个，大图和小图），通过使用solr查询要看出返回给客户端是数组：

uniqueKey
Solr中默认定义唯一主键key为id域，如下：


Solr在删除、更新索引时使用id域进行判断，也可以自定义唯一主键。
注意在创建索引时必须指定唯一约束。
copyField复制域
copyField复制域，可以将多个Field复制到一个Field中，以便进行统一的检索：
比如，输入关键字搜索title标题内容content，
定义title、content、text的域：



根据关键字只搜索text域的内容就相当于搜索title和content，将title和content复制到text中，如下：

dynamicField（动态字段）
动态字段就是不用指定具体的名称，只要定义字段名称的规则，例如定义一个 dynamicField，name 为*_i，定义它的type为text，那么在使用这个字段的时候，任何以_i结尾的字段都被认为是符合这个定义的，例如：name_i，gender_i，school_i等。

自定义Field名为：product_title_t，“product_title_t”和scheam.xml中的dynamicField规则匹配成功，如下：

“product_title_t”是以“_t”结尾。

创建索引：


搜索索引：


3.6.2.安装中文分词器
使用IKAnalyzer中文分析器。

第一步：把IKAnalyzer2012FF_u1.jar添加到solr/WEB-INF/lib目录下。
第二步：复制IKAnalyzer的配置文件和自定义词典和停用词词典到solr的classpath下。
也就是在apache-tomcat-7.0.54\webapps\solr\WEB-INF目录下新建classes目录,将配置文件和词典放进去.

第三步：在schema.xml中添加一个自定义的fieldType，使用中文分析器。
<!-- IKAnalyzer-->
    <fieldType name="text_ik" class="solr.TextField">
      <analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/>
    </fieldType>

第四步：定义field，指定field的type属性为text_ik
<!--IKAnalyzer Field-->
   <field name="title_ik" type="text_ik" indexed="true" stored="true" />
   <field name="content_ik" type="text_ik" indexed="true" stored="false" multiValued="true"/>

第四步：重启tomcat
测试：

3.7.设置业务系统Field
如果不使用Solr提供的Field可以针对具体的业务需要自定义一套Field，如下是商品信息Field：

<!--product-->
   <field name="product_name" type="text_ik" indexed="true" stored="true"/>
   <field name="product_price"  type="float" indexed="true" stored="true"/>
   <field name="product_description" type="text_ik" indexed="true" stored="false" />
   <field name="product_picture" type="string" indexed="false" stored="true" />
   <field name="product_catalog_name" type="string" indexed="true" stored="true" />

   <field name="product_keywords" type="text_ik" indexed="true" stored="false" multiValued="true"/>
   <copyField source="product_name" dest="product_keywords"/>
   <copyField source="product_description" dest="product_keywords"/>


4.Solr管理索引库
4.1.维护索引
4.1.1.添加/更新文档
添加单个文档

批量导入数据
使用dataimport插件批量导入数据。
第一步：把dataimport插件依赖的jar包添加到solrcore（collection1\lib）中

还需要mysql的数据库驱动。
第二步：配置solrconfig.mxl文件，添加一个requestHandler。
 <requestHandler name="/dataimport" 
class="org.apache.solr.handler.dataimport.DataImportHandler">
    <lst name="defaults">
      <str name="config">data-config.xml</str>
     </lst>
  </requestHandler> 

第三步：创建一个data-config.xml，保存到collection1\conf\目录下
<?xml version="1.0" encoding="UTF-8" ?>  
<dataConfig>   
<dataSource type="JdbcDataSource"   
		  driver="com.mysql.jdbc.Driver"   
		  url="jdbc:mysql://localhost:3306/lucene"   
		  user="root"   
		  password="root"/>   
<document>   
	<entity name="product" query="SELECT pid,name,catalog_name,price,description,picture FROM products ">
		 <field column="pid" name="id"/> 
		 <field column="name" name="product_name"/> 
		 <field column="catalog_name" name="product_catalog_name"/> 
		 <field column="price" name="product_price"/> 
		 <field column="description" name="product_description"/> 
		 <field column="picture" name="product_picture"/> 
	</entity>   
</document>   

</dataConfig>

第四步：重启tomcat

第五步：点击“execute”按钮导入数据

到入数据前会先清空索引库，然后再导入。

4.1.2.删除文档
删除索引格式如下：

1） 删除制定ID的索引 
<delete>
	<id>8</id>
</delete>

2） 删除查询到的索引数据 
<delete>
	<query>product_catalog_name:幽默杂货</query>
</delete>
3） 删除所有索引数据
 <delete>
	<query>*:*</query>
</delete>
4.2.查询索引
通过/select搜索索引，Solr制定一些参数完成不同需求的搜索：

1.q - 查询字符串，必须的，如果查询所有使用*:*。



2.fq - （filter query）过虑查询，作用：在q查询符合结果中同时是fq查询符合的，例如：：

过滤查询价格从1到20的记录。
也可以在“q”查询条件中使用product_price:[1 TO 20]，如下：

也可以使用“*”表示无限，例如：
20以上：product_price:[20 TO *]
20以下：product_price:[* TO 20]

3.sort - 排序，格式：sort=<field name>+<desc|asc>[,<field name>+<desc|asc>]… 。示例： 
按价格降序

4.start - 分页显示使用，开始记录下标，从0开始 
5.rows - 指定返回结果最多有多少条记录，配合start来实现分页。

显示前10条。



6.fl - 指定返回那些字段内容，用逗号或空格分隔多个。

显示商品图片、商品名称、商品价格

7.df-指定一个搜索Field

也可以在SolrCore目录 中conf/solrconfig.xml文件中指定默认搜索Field，指定后就可以直接在“q”查询条件中输入关键字。



8.wt - (writer type)指定输出格式，可以有 xml, json, php, phps, 后面 solr 1.3增加的，要用通知我们，因为默认没有打开。

9.hl 是否高亮 ,设置高亮Field，设置格式前缀和后缀。



5.使用SolrJ管理索引库
5.1.什么是solrJ
solrj是访问Solr服务的java客户端，提供索引和搜索的请求方法，SolrJ通常在嵌入在业务系统中，通过SolrJ的API接口操作Solr服务，如下图：


5.2.依赖的jar包


5.3.添加文档
5.3.1.实现步骤
第一步：创建一个java工程
第二步：导入jar包。包括solrJ的jar包。还需要

第三步：和Solr服务器建立连接。HttpSolrServer对象建立连接。
第四步：创建一个SolrInputDocument对象，然后添加域。
第五步：将SolrInputDocument添加到索引库。
第六步：提交。
5.3.2.代码实现
//向索引库中添加索引
	@Test
	public void addDocument() throws Exception {
		//和solr服务器创建连接
		//参数：solr服务器的地址
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//创建一个文档对象
		SolrInputDocument document = new SolrInputDocument();
		//向文档中添加域
		//第一个参数：域的名称，域的名称必须是在schema.xml中定义的
		//第二个参数：域的值
		document.addField("id", "c0001");
		document.addField("title_ik", "使用solrJ添加的文档");
		document.addField("content_ik", "文档的内容");
		document.addField("product_name", "商品名称");
		//把document对象添加到索引库中
		solrServer.add(document);
		//提交修改
		solrServer.commit();
		
	}

5.4.删除文档
5.4.1.根据id删除
//删除文档，根据id删除
	@Test
	public void deleteDocumentByid() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//根据id删除文档
		solrServer.deleteById("c0001");
		//提交修改
		solrServer.commit();
	}

5.4.2.根据查询删除
查询语法完全支持Lucene的查询语法。
//根据查询条件删除文档
	@Test
	public void deleteDocumentByQuery() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//根据查询条件删除文档
		solrServer.deleteByQuery("*:*");
		//提交修改
		solrServer.commit();
	}


5.5.修改文档
在solrJ中修改没有对应的update方法，只有add方法，只需要添加一条新的文档，和被修改的文档id一致就，可以修改了。本质上就是先删除后添加。

5.6.查询文档
5.6.1.简单查询
//查询索引
	@Test
	public void queryIndex() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//创建一个query对象
		SolrQuery query = new SolrQuery();
		//设置查询条件
		query.setQuery("*:*");
		//执行查询
		QueryResponse queryResponse = solrServer.query(query);
		//取查询结果
		SolrDocumentList solrDocumentList = queryResponse.getResults();
		//共查询到商品数量
		System.out.println("共查询到商品数量:" + solrDocumentList.getNumFound());
		//遍历查询的结果
		for (SolrDocument solrDocument : solrDocumentList) {
			System.out.println(solrDocument.get("id"));
			System.out.println(solrDocument.get("product_name"));
			System.out.println(solrDocument.get("product_price"));
			System.out.println(solrDocument.get("product_catalog_name"));
			System.out.println(solrDocument.get("product_picture"));
			
		}
	}

5.6.2.复杂查询
其中包含查询、过滤、分页、排序、高亮显示等处理。
//复杂查询索引
	@Test
	public void queryIndex2() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//创建一个query对象
		SolrQuery query = new SolrQuery();
		//设置查询条件
		query.setQuery("钻石");
		//过滤条件
		query.setFilterQueries("product_catalog_name:幽默杂货");
		//排序条件
		query.setSort("product_price", ORDER.asc);
		//分页处理
		query.setStart(0);
		query.setRows(10);
		//结果中域的列表
		query.setFields("id","product_name","product_price","product_catalog_name","product_picture");
		//设置默认搜索域
		query.set("df", "product_keywords");
		//高亮显示
		query.setHighlight(true);
		//高亮显示的域
		query.addHighlightField("product_name");
		//高亮显示的前缀
		query.setHighlightSimplePre("<em>");
		//高亮显示的后缀
		query.setHighlightSimplePost("</em>");
		//执行查询
		QueryResponse queryResponse = solrServer.query(query);
		//取查询结果
		SolrDocumentList solrDocumentList = queryResponse.getResults();
		//共查询到商品数量
		System.out.println("共查询到商品数量:" + solrDocumentList.getNumFound());
		//遍历查询的结果
		for (SolrDocument solrDocument : solrDocumentList) {
			System.out.println(solrDocument.get("id"));
			//取高亮显示
			String productName = "";
			Map<String, Map<String, List<String>>> highlighting = queryResponse.getHighlighting();
			List<String> list = highlighting.get(solrDocument.get("id")).get("product_name");
			//判断是否有高亮内容
			if (null != list) {
				productName = list.get(0);
			} else {
				productName = (String) solrDocument.get("product_name");
			}
			
			System.out.println(productName);
			System.out.println(solrDocument.get("product_price"));
			System.out.println(solrDocument.get("product_catalog_name"));
			System.out.println(solrDocument.get("product_picture"));
			
		}
	}

6.案例实现
6.1.原型分析

6.2.系统架构

6.3.工程搭建
创建一个web工程导入jar包
1、springmvc的相关jar包
2、solrJ的jar包
3、Example\lib\ext下的jar包

6.3.1.Springmvc.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
        
	<context:component-scan base-package="com.itheima.jd"/>
	<!-- 配置注解驱动，如果配置此标签可以不用配置处理器映射器和适配器 -->
	<mvc:annotation-driven/>
		<!-- 配置视图解析器 -->
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/jsp/"/>
		<property name="suffix" value=".jsp"/>
	</bean>
	<!-- SolrServer的配置 -->
	<bean id="httpSolrServer" class="org.apache.solr.client.solrj.impl.HttpSolrServer">
		<constructor-arg index="0" value="http://localhost:8080/solr"/>
	</bean>
</beans>

6.3.2.Web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5">
  <display-name>solr-jd</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
  <!-- 配置前段控制器 -->
  <servlet>
  	<servlet-name>springmvc</servlet-name>
  	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  	<init-param>
  		<!-- 指定springmvc配置文件的路径 
  			如果不指定默认为：/WEB-INF/${servlet-name}-servlet.xml
  		-->
  		<param-name>contextConfigLocation</param-name>
  		<param-value>classpath:springmvc.xml</param-value>
  	</init-param>
  </servlet>
  <servlet-mapping>
  	<servlet-name>springmvc</servlet-name>
  	<url-pattern>*.action</url-pattern>
  </servlet-mapping>
  <!-- 解决post乱码问题 -->
  <filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
</web-app>



6.4.Dao
功能：接收service层传递过来的参数，根据参数查询索引库，返回查询结果。
参数：SolrQuery对象
返回值：一个商品列表List<ProductModel>，还需要返回查询结果的总数量。
返回：ResultModel
方法定义：ResultModel queryProduct(SolrQuery query) throws Exception;


商品对象模型：
public class ProductModel {
	// 商品编号
	private String pid;
	// 商品名称
	private String name;
	// 商品分类名称
	private String catalog_name;
	// 价格
	private float price;
	// 商品描述
	private String description;
	// 图片名称
	private String picture;
}

返回值对象模型
public class ResultModel {
	// 商品列表
	private List<ProductModel> productList;
	// 商品总数
	private Long recordCount;
	// 总页数
	private Long pageCount;
	// 当前页
	private int curPage;
}

@Repository
public class ProductDaoImpl implements ProductDao {

	@Autowired
	private SolrServer solrServer;
	
	@Override
	public ResultModel queryProduct(SolrQuery query) throws Exception {
		
		ResultModel resultModel  = new ResultModel();
		//根据query对象查询商品列表
		QueryResponse queryResponse = solrServer.query(query);
		SolrDocumentList solrDocumentList = queryResponse.getResults();
		//取查询结果的总数量
		resultModel.setRecordCount(solrDocumentList.getNumFound());
		List<ProductModel> productList = new ArrayList<>();
		//遍历查询结果
		for (SolrDocument solrDocument : solrDocumentList) {
			//取商品信息
			ProductModel productModel = new ProductModel();
			productModel.setPid((String) solrDocument.get("id"));
			//取高亮显示
			String productName = "";
			Map<String, Map<String, List<String>>> highlighting = queryResponse.getHighlighting();
			List<String> list = highlighting.get(solrDocument.get("id")).get("product_name");
			if (null != list) {
				productName = list.get(0);
			} else {
				productName = (String) solrDocument.get("product_name");
			}
			productModel.setName(productName);
			if(null == doc.get("product_price")){
				productModel.setPrice(0f);
			}else{
				productModel.setPrice((float)doc.get("product_price"));
			}
			productModel.setCatalog_name((String) solrDocument.get("product_catalog_name"));
			productModel.setPicture((String) solrDocument.get("product_picture"));
			//添加到商品列表
			productList.add(productModel);
		}
		//商品列表添加到resultmodel中
		resultModel.setProductList(productList);
		return resultModel;
	}

}

6.5.Service
功能：接收action传递过来的参数，根据参数拼装一个查询条件，调用dao层方法，查询商品列表。接收返回的商品列表和商品的总数量，根据每页显示的商品数量计算总页数。
参数：
1、查询条件：字符串
2、商品分类的过滤条件：商品的分类名称，字符串
3、商品价格区间：传递一个字符串，满足格式：“0-100、101-200、201-*”
4、排序条件：页面传递过来一个升序或者降序就可以，默认是价格排序。0：升序1：降序
5、分页信息：每页显示的记录条数创建一个常量60条。传递一个当前页码就可以了。
业务逻辑
1、根据参数创建查询对象
2、调用dao执行查询。
3、根据总记录数计算总页数。
返回值：ResultModel 

方法定义：ResultModel queryProduct(String queryString, String caltalog_name, String price, String sort, Integer page) throws Exception;
@Service
public class ProductServiceImpl implements ProductService {

	@Autowired
	private ProductDao productDao;
	
	@Override
	public ResultModel queryProduct(String queryString, String caltalog_name,
			String price, String sort, Integer page) throws Exception {
		//拼装查询条件
		SolrQuery query = new SolrQuery();
		//查询条件
		if (null != queryString && !"".equals(queryString)) {
			query.setQuery(queryString);
		} else {
			query.setQuery("*:*");
		}
		//商品分类名称过滤
		if (null != caltalog_name && !"".equals(caltalog_name)) {
			query.addFilterQuery("product_catalog_name:" + caltalog_name);
		}
		//价格区间过滤
		if (null != price && !"".equals(price)) {
			String[] strings = price.split("-");
			query.addFilterQuery("product_price:["+strings[0]+" TO "+strings[1]+"]");
		}
		//排序条件
		if ("1".equals(sort)) {
			query.setSort("product_price", ORDER.desc);
		} else {
			query.setSort("product_price", ORDER.asc);
		}
		//分页处理
		if (null == page) {
			page = 1;
		}
		//start
		int start = (page-1) * Commons.PAGE_SIZE;
		query.setStart(start);
		query.setRows(Commons.PAGE_SIZE);
		//设置默认搜索域
		query.set("df", "product_keywords");
		//高亮设置
		query.setHighlight(true);
		query.addHighlightField("product_name");
		query.setHighlightSimplePre("<span style=\"color:red\">");
		query.setHighlightSimplePost("</span>");
		
		//查询商品列表
		ResultModel resultModel = productDao.queryProduct(query);
		//计算总页数
		long recordCount = resultModel.getRecordCount();
		int pages = (int) (recordCount/Commons.PAGE_SIZE);
		if (recordCount % Commons.PAGE_SIZE > 0) {
			pages ++;
		}
		resultModel.setPageCount(pages);
		resultModel.setCurPage(page);
		
		return resultModel;
	}

}

6.6.controller
功能：接收页面传递过来的参数调用service查询商品列表。将查询结果返回给jsp页面，还需要查询参数的回显。

参数：
1、查询条件：字符串
2、商品分类的过滤条件：商品的分类名称，字符串
3、商品价格区间：传递一个字符串，满足格式：“0-100、101-200、201-*”
4、排序条件：页面传递过来一个升序或者降序就可以，默认是价格排序。0：升序1：降序
5、分页信息：每页显示的记录条数创建一个常量60条。传递一个当前页码就可以了。
6、Model：相当于request。

返回结果：String类型，就是一个jsp的名称。

String queryProduct(String queryString, String caltalog_name, String price, String sort, Integer page, Model model) throws Exception;
@Controller
public class ProductAction {
	
	@Autowired
	private ProductService productService;
	
	@RequestMapping("/list")
	public String queryProduct(String queryString, String catalog_name, String price,
			String sort, Integer page, Model model) throws Exception {
		//查询商品列表
		ResultModel resultModel = productService.queryProduct(queryString, catalog_name, price, sort, page);
		//列表传递给jsp
		model.addAttribute("result", resultModel);
		//参数回显
		model.addAttribute("queryString", queryString);
		model.addAttribute("caltalog_name", catalog_name);
		model.addAttribute("price", price);
		model.addAttribute("sort", sort);
		model.addAttribute("page", page);
		
		return "product_list";
	}
}

6.7.Jsp
参考资料。



全文搜索技术——Lucene
7.今天内容安排
实现一个文件的搜索功能，通过关键字搜索文件，凡是文件名或文件内容包括关键字的文件都需要找出来。还可以根据中文词语进程查询，并且支持多种条件查询。
本案例中的原始内容就是磁盘上的文件，如下图：


8.需求分析
8.1.数据分类

我们生活中的数据总体分为两种：结构化数据和非结构化数据。

结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。
非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件

8.2.非结构化数据查询方法
（3）顺序扫描法(Serial Scanning)
所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。
（4）全文检索(Full-text Search)
将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。
例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。
这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。
8.3.如何实现全文检索
可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。

8.4.全文检索的应用场景
对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。

9.Lucene实现全文检索的流程
9.1.索引和搜索流程图

1、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：
确定原始内容即要搜索的内容采集文档创建文档分析文档索引文档
	
2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括：
用户通过搜索界面创建查询执行搜索，从索引库搜索渲染搜索结果

9.2.创建索引
对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。
这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。

9.2.1.获得原始文档
原始文档是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。 
本案例中的原始内容就是磁盘上的文件，如下图：


从互联网上、数据库、文件系统中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。
在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。
	Lucene不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，如下：
	Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。
	jsoup（http://jsoup.org/ ），jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
	heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix 是一个由 java 开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。
本案例我们要获取磁盘上文件的内容，可以通过文件流来读取文本文件的内容，对于pdf、doc、xls等文件可通过第三方提供的解析工具读取文件内容，比如Apache POI读取doc和xls的文件内容。

9.2.2.创建文档对象
获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。
这里我们可以将磁盘上的一个文件当成一个document，Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容），如下图：



注意：每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同）

每个文档都有一个唯一的编号，就是文档id。

9.2.3.分析文档
将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。

比如下边的文档经过分析如下：
原文档内容：
Lucene is a Java full-text search engine.  Lucene is not a complete
application, but rather a code library and API that can easily be used
to add search capabilities to applications.

分析后得到的语汇单元：
lucene、java、full、search、engine。。。。

每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。term中包含两部分一部分是文档的域名，另一部分是单词的内容。
例如：文件名中包含apache和文件内容中包含的apache是不同的term。
9.2.4.创建索引
对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。
注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。
传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。
倒排索引结构是根据内容（词语）找文档，如下图： 



倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。

9.3.查询索引
查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。 

9.3.1.用户查询接口
全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。

比如：


Lucene不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。
9.3.2.创建查询
用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的Field文档域、查询关键字等，查询对象会生成具体的查询语法，比如：
语法 “fileName:spring.txt”表示要搜索Field域的内容为“spring.txt”的文档
语法 “lucene AND java” 表示要搜索即包括关键字“lucene”也包括“java”的文档。

9.3.3.执行查询
搜索索引过程：
1.根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。
比如搜索语法为“lucene AND java”表示搜索出的文档中即要包括lucene也要包括java。


2、由于是AND，所以要对包含lucene或java词语的链表进行交集，得到文档链表应该包括每一个搜索词语
3、获取文档中的Field域数据。

9.3.4.渲染结果
以一个友好的界面将查询结果展示给用户，用户根据搜索结果找自己想要的信息，为了帮助用户很快找到自己的结果，提供了很多展示的效果，比如搜索结果中将关键字高亮显示，百度提供的快照等。



10.配置开发环境
10.1.Lucene下载
Lucene是开发全文检索功能的工具包，从官方网站下载Lucene4.10.3，并解压。
官方网站：http://lucene.apache.org/ 
版本：lucene4.10.3
Jdk要求：1.7以上
IDE：Eclipse

10.2.使用的jar包


Lucene包：
lucene-core-4.10.3.jar
lucene-analyzers-common-4.10.3.jar
lucene-queryparser-4.10.3.jar

其它：
commons-io-2.4.jar
junit-4.9.jar

11.功能一：创建索引库
使用indexwriter对象创建索引
11.1.实现步骤
第一步：创建一个java工程，并导入jar包。
第二步：创建一个indexwriter对象。
1）指定索引库的存放位置Directory对象
2）指定一个分析器，对文档内容进行分析。
第二步：创建document对象。
第三步：创建field对象，将field添加到document对象中。
第四步：使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。
第五步：关闭IndexWriter对象。
11.2.Field域的属性
是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。
是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。
比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。
是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取
比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。

是否存储的标准：是否要将内容展示给用户

Field类	数据类型	Analyzed
是否分析	Indexed
是否索引	Stored
是否存储	说明
StringField(FieldName, FieldValue,Store.YES))	字符串	N	Y	Y或N	这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)
是否存储在文档中用Store.YES或Store.NO决定
LongField(FieldName, FieldValue,Store.YES)	Long型 	Y	Y	Y或N	这个Field用来构建一个Long数字型Field，进行分析和索引，比如(价格)
是否存储在文档中用Store.YES或Store.NO决定
StoredField(FieldName, FieldValue) 	重载方法，支持多种类型	N	N	Y	这个Field用来构建不同类型Field
不分析，不索引，但要Field存储在文档中(如图片,因为要存放图片地址)
TextField(FieldName, FieldValue, Store.NO)
或
TextField(FieldName, reader)
	字符串
或
流	Y	Y	Y或N	如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略.

11.3.代码实现
//创建索引
	@Test
	public void createIndex() throws Exception {
		
		//指定索引库存放的路径
		//D:\temp\0108\index
		Directory directory = FSDirectory.open(new File("D:\\temp\\0108\\index"));
		//索引库还可以存放到内存中
		//Directory directory = new RAMDirectory();
		//创建一个标准分析器
		Analyzer analyzer = new StandardAnalyzer();
		//创建indexwriterCofig对象
		//第一个参数： Lucene的版本信息，可以选择对应的lucene版本也可以使用LATEST
		//第二根参数：分析器对象
		IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer);
		//创建indexwriter对象
		IndexWriter indexWriter = new IndexWriter(directory, config);
		//原始文档的路径D:\传智播客\01.课程\04.lucene\01.参考资料\searchsource
		File dir = new File("D:\\传智播客\\01.课程\\04.lucene\\01.参考资料\\searchsource");
		for (File f : dir.listFiles()) {
			//文件名
			String fileName = f.getName();
			//文件内容
			String fileContent = FileUtils.readFileToString(f);
			//文件路径
			String filePath = f.getPath();
			//文件的大小
			long fileSize  = FileUtils.sizeOf(f);
			//创建文件名域
			//第一个参数：域的名称
			//第二个参数：域的内容
			//第三个参数：是否存储
			Field fileNameField = new TextField("filename", fileName, Store.YES);
			//文件内容域
			Field fileContentField = new TextField("content", fileContent, Store.YES);
			//文件路径域（不分析、不索引、只存储）
			Field filePathField = new StoredField("path", filePath);
			//文件大小域
			Field fileSizeField = new LongField("size", fileSize, Store.YES);
			
			//创建document对象
			Document document = new Document();
			document.add(fileNameField);
			document.add(fileContentField);
			document.add(filePathField);
			document.add(fileSizeField);
			//创建索引，并写入索引库
			indexWriter.addDocument(document);
		}
		//关闭indexwriter
		indexWriter.close();
	}

11.4.使用Luke工具查看索引文件


12.功能二：查询索引
12.1.实现步骤
第一步：创建一个Directory对象，也就是索引库存放的位置。
第二步：创建一个indexReader对象，需要指定Directory对象。
第三步：创建一个indexsearcher对象，需要指定IndexReader对象
第四步：创建一个TermQuery对象，指定查询的域和查询的关键词。
第五步：执行查询。
第六步：返回查询结果。遍历查询结果并输出。
第七步：关闭IndexReader对象
12.2.IndexSearcher搜索方法

方法	说明
indexSearcher.search(query, n)	根据Query搜索，返回评分最高的n条记录
indexSearcher.search(query, filter, n)	根据Query搜索，添加过滤策略，返回评分最高的n条记录
indexSearcher.search(query, n, sort)	根据Query搜索，添加排序策略，返回评分最高的n条记录
indexSearcher.search(booleanQuery, filter, n, sort)	根据Query搜索，添加过滤策略，添加排序策略，返回评分最高的n条记录

12.3.代码实现
//查询索引库
	@Test
	public void searchIndex() throws Exception {
		//指定索引库存放的路径
		//D:\temp\0108\index
		Directory directory = FSDirectory.open(new File("D:\\temp\\0108\\index"));
		//创建indexReader对象
		IndexReader indexReader = DirectoryReader.open(directory);
		//创建indexsearcher对象
		IndexSearcher indexSearcher = new IndexSearcher(indexReader);
		//创建查询
		Query query = new TermQuery(new Term("filename", "apache"));
		//执行查询
		//第一个参数是查询对象，第二个参数是查询结果返回的最大值
		TopDocs topDocs = indexSearcher.search(query, 10);
		//查询结果的总条数
		System.out.println("查询结果的总条数："+ topDocs.totalHits);
		//遍历查询结果
		//topDocs.scoreDocs存储了document对象的id
		for (ScoreDoc scoreDoc : topDocs.scoreDocs) {
			//scoreDoc.doc属性就是document对象的id
			//根据document的id找到document对象
			Document document = indexSearcher.doc(scoreDoc.doc);
			System.out.println(document.get("filename"));
			//System.out.println(document.get("content"));
			System.out.println(document.get("path"));
			System.out.println(document.get("size"));
		}
		//关闭indexreader对象
		indexReader.close();
	}
12.4.TopDocs

Lucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下：

方法或属性	说明
totalHits	匹配搜索条件的总记录数
scoreDocs	顶部匹配记录

注意：
Search方法需要指定匹配记录数量n：indexSearcher.search(query, n)
TopDocs.totalHits：是匹配索引库中所有记录的数量
TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n

13.功能三：支持中文分词
13.1.分析器（Analyzer）的执行过程
如下图是语汇单元的生成过程：



从一个Reader字符流开始，创建一个基于Reader的Tokenizer分词器，经过三个TokenFilter生成语汇单元Token。
要看分析器的分析效果，只需要看Tokenstream中的内容就可以了。每个分析器都有一个方法tokenStream，返回一个tokenStream对象。

13.2.分析器的分词效果
//查看标准分析器的分词效果
	public void testTokenStream() throws Exception {
		//创建一个标准分析器对象
		Analyzer analyzer = new StandardAnalyzer();
		//获得tokenStream对象
		//第一个参数：域名，可以随便给一个
		//第二个参数：要分析的文本内容
		TokenStream tokenStream = analyzer.tokenStream("test", "The Spring Framework provides a comprehensive programming and configuration model.");
		//添加一个引用，可以获得每个关键词
		CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class);
		//添加一个偏移量的引用，记录了关键词的开始位置以及结束位置
		OffsetAttribute offsetAttribute = tokenStream.addAttribute(OffsetAttribute.class);
		//将指针调整到列表的头部
		tokenStream.reset();
		//遍历关键词列表，通过incrementToken方法判断列表是否结束
		while(tokenStream.incrementToken()) {
			//关键词的起始位置
			System.out.println("start->" + offsetAttribute.startOffset());
			//取关键词
			System.out.println(charTermAttribute);
			//结束位置
			System.out.println("end->" + offsetAttribute.endOffset());
		}
		tokenStream.close();
	}

13.3.中文分析器
13.3.1.Lucene自带中文分词器
StandardAnalyzer：
单字分词：就是按照中文一个字一个字地进行分词。如：“我爱中国”，
效果：“我”、“爱”、“中”、“国”。
CJKAnalyzer
二分法分词：按两个字进行切分。如：“我是中国人”，效果：“我是”、“是中”、“中国”“国人”。

上边两个分词器无法满足需求。
SmartChineseAnalyzer
对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理
13.3.2.第三方中文分析器
  paoding： 庖丁解牛最新版在 https://code.google.com/p/paoding/ 中最多支持Lucene 3.0，且最新提交的代码在 2008-06-03，在svn中最新也是2010年提交，已经过时，不予考虑。
  mmseg4j：最新版已从 https://code.google.com/p/mmseg4j/ 移至 https://github.com/chenlb/mmseg4j-solr，支持Lucene 4.10，且在github中最新提交代码是2014年6月，从09年～14年一共有：18个版本，也就是一年几乎有3个大小版本，有较大的活跃度，用了mmseg算法。
  IK-analyzer： 最新版在https://code.google.com/p/ik-analyzer/上，支持Lucene 4.10从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开 始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词 歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有在更新。
  ansj_seg：最新版本在 https://github.com/NLPchina/ansj_seg tags仅有1.1版本，从2012年到2014年更新了大小6次，但是作者本人在2014年10月10日说明：“可能我以后没有精力来维护ansj_seg了”，现在由”nlp_china”管理。2014年11月有更新。并未说明是否支持Lucene，是一个由CRF（条件随机场）算法所做的分词算法。
  imdict-chinese-analyzer：最新版在 https://code.google.com/p/imdict-chinese-analyzer/ ， 最新更新也在2009年5月，下载源码，不支持Lucene 4.10 。是利用HMM（隐马尔科夫链）算法。
  Jcseg：最新版本在git.oschina.net/lionsoul/jcseg，支持Lucene 4.10，作者有较高的活跃度。利用mmseg算法。
13.3.3.IKAnalyzer

使用方法：
第一步：把jar包添加到工程中
第二步：把配置文件和扩展词典和停用词词典添加到classpath下

注意：mydict.dic和ext_stopword.dic文件的格式为UTF-8，注意是无BOM 的UTF-8 编码。

使用EditPlus.exe保存为无BOM 的UTF-8 编码格式，如下图：

13.4.Analyzer使用时机
13.4.1.索引时使用Analyzer
	输入关键字进行搜索，当需要让该关键字与文档域内容所包含的词进行匹配时需要对文档域内容进行分析，需要经过Analyzer分析器处理生成语汇单元（Token）。分析器分析的对象是文档中的Field域。当Field的属性tokenized（是否分词）为true时会对Field值进行分析，如下图： 


对于一些Field可以不用分析：
1、不作为查询条件的内容，比如文件路径
2、不是匹配内容中的词而匹配Field的整体内容，比如订单号、身份证号等。

13.4.2.搜索时使用Analyzer
	对搜索关键字进行分析和索引分析一样，使用Analyzer对搜索关键字进行分析、分词处理，使用分析后每个词语进行搜索。比如：搜索关键字：spring web ，经过分析器进行分词，得出：spring  web拿词去索引词典表查找 ，找到索引链接到Document，解析Document内容。
	对于匹配整体Field域的查询可以在搜索时不分析，比如根据订单号、身份证号查询等。

	注意：搜索使用的分析器要和索引使用的分析器一致。

14.功能四：索引库的维护
14.1.索引库的添加
14.1.1.步骤
向索引库中添加document对象。
第一步：先创建一个indexwriter对象
第二步：创建一个document对象
第三步：把document对象写入索引库
第四步：关闭indexwriter。

14.1.2.代码实现
//添加索引
	@Test
	public void addDocument() throws Exception {
		//索引库存放路径
		Directory directory = FSDirectory.open(new File("D:\\temp\\0108\\index"));
		
		IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, new IKAnalyzer());
		//创建一个indexwriter对象
		IndexWriter indexWriter = new IndexWriter(directory, config);
		//创建一个Document对象
		Document document = new Document();
		//向document对象中添加域。
		//不同的document可以有不同的域，同一个document可以有相同的域。
		document.add(new TextField("filename", "新添加的文档", Store.YES));
		document.add(new TextField("content", "新添加的文档的内容", Store.NO));
		document.add(new TextField("content", "新添加的文档的内容第二个content", Store.YES));
		document.add(new TextField("content1", "新添加的文档的内容要能看到", Store.YES));
		//添加文档到索引库
		indexWriter.addDocument(document);
		//关闭indexwriter
		indexWriter.close();
		
	}

14.2.索引库删除
14.2.1.删除全部
//删除全部索引
	@Test
	public void deleteAllIndex() throws Exception {
		IndexWriter indexWriter = getIndexWriter();
		//删除全部索引
		indexWriter.deleteAll();
		//关闭indexwriter
		indexWriter.close();
	}

说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复。

此方法慎用！！

14.2.2.指定查询条件删除
//根据查询条件删除索引
	@Test
	public void deleteIndexByQuery() throws Exception {
		IndexWriter indexWriter = getIndexWriter();
		//创建一个查询条件
		Query query = new TermQuery(new Term("filename", "apache"));
		//根据查询条件删除
		indexWriter.deleteDocuments(query);
		//关闭indexwriter
		indexWriter.close();
	}

14.3.索引库的修改
原理就是先删除后添加。
//修改索引库
	@Test
	public void updateIndex() throws Exception {
		IndexWriter indexWriter = getIndexWriter();
		//创建一个Document对象
		Document document = new Document();
		//向document对象中添加域。
		//不同的document可以有不同的域，同一个document可以有相同的域。
		document.add(new TextField("filename", "要更新的文档", Store.YES));
		document.add(new TextField("content", "2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。", Store.YES));
		indexWriter.updateDocument(new Term("content", "java"), document);
		//关闭indexWriter
		indexWriter.close();
	}

15.功能五：索引库的查询（重点）
	对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。
	可通过两种方法创建查询对象：
	1）使用Lucene提供Query子类
	Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。
	如下代码：
	Query query = new TermQuery(new Term("name", "lucene"));

	2）使用QueryParse解析查询表达式
	QueryParse会将用户输入的查询表达式解析成Query对象实例。
	如下代码：
	QueryParser queryParser = new QueryParser("name", new IKAnalyzer());
		Query query = queryParser.parse("name:lucene");


15.1.使用query的子类查询
15.1.1.TermQuery
TermQuery，通过项查询，TermQuery不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。
指定要查询的域和要查询的关键词。
//使用Termquery查询
	@Test
	public void testTermQuery() throws Exception {
		IndexSearcher indexSearcher = getIndexSearcher();
		//创建查询对象
		Query query = new TermQuery(new Term("content", "lucene"));
		//执行查询
		TopDocs topDocs = indexSearcher.search(query, 10);
		//共查询到的document个数
		System.out.println("查询结果总数量：" + topDocs.totalHits);
		//遍历查询结果
		for (ScoreDoc scoreDoc : topDocs.scoreDocs) {
			Document document = indexSearcher.doc(scoreDoc.doc);
			System.out.println(document.get("filename"));
			//System.out.println(document.get("content"));
			System.out.println(document.get("path"));
			System.out.println(document.get("size"));
		}
		//关闭indexreader
		indexSearcher.getIndexReader().close();
	}

15.1.2.NumericRangeQuery
可以根据数值范围查询。
//数值范围查询
	@Test
	public void testNumericRangeQuery() throws Exception {
		IndexSearcher indexSearcher = getIndexSearcher();
		//创建查询
		//参数：
		//1.域名
		//2.最小值
		//3.最大值
		//4.是否包含最小值
		//5.是否包含最大值
		Query query = NumericRangeQuery.newLongRange("size", 1l, 1000l, true, true);
		//执行查询
		printResult(query, indexSearcher);
	}

15.1.3.BooleanQuery
可以组合查询条件。
//组合条件查询
	@Test
	public void testBooleanQuery() throws Exception {
		IndexSearcher indexSearcher = getIndexSearcher();
		//创建一个布尔查询对象
		BooleanQuery query = new BooleanQuery();
		//创建第一个查询条件
		Query query1 = new TermQuery(new Term("filename", "apache"));
		Query query2 = new TermQuery(new Term("content", "apache"));
		//组合查询条件
		query.add(query1, Occur.MUST);
		query.add(query2, Occur.MUST);
		//执行查询
		printResult(query, indexSearcher);
	}

Occur.MUST：必须满足此条件，相当于and
Occur.SHOULD：应该满足，但是不满足也可以，相当于or
Occur.MUST_NOT：必须不满足。相当于not

15.1.4.MatchAllDocsQuery
使用MatchAllDocsQuery查询索引目录中的所有文档
@Test
	public void testMatchAllDocsQuery() throws Exception {
		IndexSearcher indexSearcher = getIndexSearcher();
		//创建查询条件
		Query query = new MatchAllDocsQuery();
		//执行查询
		printResult(query, indexSearcher);
	}

15.2.使用queryparser查询
通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。
需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。

15.2.1.QueryParser
需要加入queryParser依赖的jar包。

程序实现
@Test
	public void testQueryParser() throws Exception {
		IndexSearcher indexSearcher = getIndexSearcher();
		//创建queryparser对象
		//第一个参数默认搜索的域
		//第二个参数就是分析器对象
		QueryParser queryParser = new QueryParser("content", new IKAnalyzer());
		Query query = queryParser.parse("Lucene是java开发的");
		//执行查询
		printResult(query, indexSearcher);
	}

查询语法
1、基础的查询语法，关键词查询：
域名+“：”+搜索的关键字
例如：content:java
2、范围查询
域名+“:”+[最小值 TO 最大值]
例如：size:[1 TO 1000]
范围查询在lucene中不支持数值类型，支持字符串类型。在solr中支持数值类型。
3、组合条件查询
1）+条件1 +条件2：两个条件之间是并且的关系and
例如：+filename:apache +content:apache
2）+条件1 条件2：必须满足第一个条件，应该满足第二个条件
例如：+filename:apache content:apache
3）条件1 条件2：两个条件满足其一即可。
例如：filename:apache content:apache
4）-条件1 条件2：必须不满足条件1，要满足条件2
例如：-filename:apache content:apache
Occur.MUST 查询条件必须满足，相当于and	+（加号）
Occur.SHOULD 查询条件可选，相当于or
	空（不用符号）
Occur.MUST_NOT 查询条件不能满足，相当于not非	-（减号）

第二种写法：
条件1 AND 条件2
条件1 OR 条件2
条件1 NOT 条件2

15.2.2.MulitFieldQueryParser
可以指定多个默认搜索域
@Test
	public void testMultiFiledQueryParser() throws Exception {
		IndexSearcher indexSearcher = getIndexSearcher();
		//可以指定默认搜索的域是多个
		String[] fields = {"filename", "content"};
		//创建一个MulitFiledQueryParser对象
		MultiFieldQueryParser queryParser = new MultiFieldQueryParser(fields, new IKAnalyzer());
		Query query = queryParser.parse("java and apache");
		System.out.println(query);
		//执行查询
		printResult(query, indexSearcher);
		
	}



全文搜索技术——Solr

16.今天内容安排
使用Solr实现电商网站中商品信息搜索功能，可以根据关键字、分类、价格搜索商品信息，也可以根据价格进行排序。

17.需求分析
17.1.实现方法
在一些大型门户网站、电子商务网站等都需要站内搜索功能，使用传统的数据库查询方式实现搜索无法满足一些高级的搜索需求，比如：搜索速度要快、搜索结果按相关度排序、搜索内容格式不固定等，这里就需要使用全文检索技术实现搜索功能。
17.1.1.使用Lucene实现
单独使用Lucene实现站内搜索需要开发的工作量较大，主要表现在：索引维护、索引性能优化、搜索性能优化等，因此不建议采用。
17.1.2.使用solr实现
基于Solr实现站内搜索扩展性较好并且可以减少程序员的工作量，因为Solr提供了较为完备的搜索引擎解决方案，因此在门户、论坛等系统中常用此方案。

17.2.什么是solr
Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 
Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。

Solr与Lucene的区别：
Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。
 Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。


18.Solr安装及配置
18.1.Solr的下载
从Solr官方网站（http://lucene.apache.org/solr/ ）下载Solr4.10.3，根据Solr的运行环境，Linux下需要下载lucene-4.10.3.tgz，windows下需要下载lucene-4.10.3.zip。
Solr使用指南可参考：https://wiki.apache.org/solr/FrontPage。
18.2.Solr的文件夹结构
将solr-4.10.3.zip解压：


bin：solr的运行脚本
contrib：solr的一些软件/插件，用于增强solr的功能。
dist：该目录包含build过程中产生的war和jar文件，以及相关的依赖文件。
docs：solr的API文档
example：solr工程的例子目录：
example/solr：
	该目录是一个包含了默认配置信息的Solr的Core目录。
example/multicore：
	该目录包含了在Solr的multicore中设置的多个Core目录。 
example/webapps：
    该目录中包括一个solr.war，该war可作为solr的运行实例工程。
licenses：solr相关的一些许可信息
18.3.运行环境
solr 需要运行在一个Servlet容器中，Solr4.10.3要求jdk使用1.7以上，Solr默认提供Jetty（java写的Servlet容器），本教程使用Tocmat作为Servlet容器，环境如下：

Solr：Solr4.10.3
Jdk：jdk1.7.0_72
Tomcat：apache-tomcat-7.0.53
18.4.Solr整合tomcat
18.4.1.Solr Home与SolrCore
创建一个Solr home目录，SolrHome是Solr运行的主目录，目录中包括了运行Solr实例所有的配置文件和数据文件，Solr实例就是SolrCore，一个SolrHome可以包括多个SolrCore（Solr实例），每个SolrCore提供单独的搜索和索引服务。

example\solr是一个solr home目录结构，如下：


上图中“collection1”是一个SolrCore（Solr实例）目录 ，目录内容如下所示：


说明：
collection1：叫做一个Solr运行实例SolrCore，SolrCore名称不固定，一个solr运行实例对外单独提供索引和搜索接口。
solrHome中可以创建多个solr运行实例SolrCore。
一个solr的运行实例对应一个索引目录。
conf是SolrCore的配置文件目录 。
data目录存放索引文件需要创建

18.4.2.整合步骤
第一步：安装tomcat。D:\temp\apache-tomcat-7.0.53
第二步：把solr的war包复制到tomcat 的webapp目录下。
把\solr-4.10.3\dist\solr-4.10.3.war复制到D:\temp\apache-tomcat-7.0.53\webapps下。
改名为solr.war
第三步：solr.war解压。使用压缩工具解压或者启动tomcat自动解压。解压之后删除solr.war
第四步：把\solr-4.10.3\example\lib\ext目录下的所有的jar包添加到solr工程中
第五步：配置solrHome和solrCore。
4）创建一个solrhome（存放solr所有配置文件的一个文件夹）。\solr-4.10.3\example\solr目录就是一个标准的solrhome。
5）把\solr-4.10.3\example\solr文件夹复制到D:\temp\0108路径下，改名为solrhome，改名不是必须的，是为了便于理解。
6）在solrhome下有一个文件夹叫做collection1这就是一个solrcore。就是一个solr的实例。一个solrcore相当于mysql中一个数据库。Solrcore之间是相互隔离。
i.在solrcore中有一个文件夹叫做conf，包含了索引solr实例的配置信息。
ii.在conf文件夹下有一个solrconfig.xml。配置实例的相关信息。如果使用默认配置可以不用做任何修改。
Xml的配置信息：
Lib：solr服务依赖的扩展包，默认的路径是collection1\lib文件夹，如果没有		 就创建一个
dataDir：配置了索引库的存放路径。默认路径是collection1\data文件夹，如			果data文件夹，会自动创建。
requestHandler：


第六步：告诉solr服务器配置文件也就是solrHome的位置。修改web.xml使用jndi的方式告诉solr服务器。
Solr/home名称必须是固定的。


第七步：启动tomcat
第八步：访问http://localhost:8080/solr/

18.5.Solr后台管理
18.5.1.管理界面

18.5.2.Dashboard
仪表盘，显示了该Solr实例开始启动运行的时间、版本、系统资源、jvm等信息。
18.5.3.Logging
Solr运行日志信息
18.5.4.Cloud
Cloud即SolrCloud，即Solr云（集群），当使用Solr Cloud模式运行时会显示此菜单，如下图是Solr Cloud的管理界面：

18.5.5.Core Admin
Solr Core的管理界面。Solr Core 是Solr的一个独立运行实例单位，它可以对外提供索引和搜索服务，一个Solr工程可以运行多个SolrCore（Solr实例），一个Core对应一个索引目录。

添加solrcore：
第一步：复制collection1改名为collection2
第二步：修改core.properties。name=collection2
第三步：重启tomcat
18.5.6.java properties
Solr在JVM 运行环境中的属性信息，包括类路径、文件编码、jvm内存设置等信息。

18.5.7.Tread Dump
显示Solr Server中当前活跃线程信息，同时也可以跟踪线程运行栈信息。
18.5.8.Core selector
选择一个SolrCore进行详细操作，如下：

18.5.9.Analysis

通过此界面可以测试索引分析器和搜索分析器的执行情况。
18.5.10.Dataimport
可以定义数据导入处理器，从关系数据库将数据导入 到Solr索引库中。
18.5.11.Document
通过此菜单可以创建索引、更新索引、删除索引等操作，界面如下：


/update表示更新索引，solr默认根据id（唯一约束）域来更新Document的内容，如果根据id值搜索不到id域则会执行添加操作，如果找到则更新。
18.5.12.Query


通过/select执行搜索索引，必须指定“q”查询条件方可搜索。
18.6.配置中文分析器
18.6.1.Schema.xml
schema.xml，在SolrCore的conf目录下，它是Solr数据表配置文件，它定义了加入索引的数据的数据类型的。主要包括FieldTypes、Fields和其他的一些缺省设置。

FieldType域类型定义
下边“text_general”是Solr默认提供的FieldType，通过它说明FieldType定义的内容：


FieldType子结点包括：name,class,positionIncrementGap等一些参数：
name：是这个FieldType的名称
class：是Solr提供的包solr.TextField，solr.TextField 允许用户通过分析器来定制索引和查询，分析器包括一个分词器（tokenizer）和多个过滤器（filter）
positionIncrementGap：可选属性，定义在同一个文档中此类型数据的空白间隔，避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经验设置为100。

在FieldType定义的时候最重要的就是定义这个类型的数据在建立索引和进行查询的时候要使用的分析器analyzer,包括分词和过滤

索引分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilterFactory停用词过滤器，solr.LowerCaseFilterFactory小写过滤器。
搜索分析器中：使用solr.StandardTokenizerFactory标准分词器，solr.StopFilterFactory停用词过滤器，这里还用到了solr.SynonymFilterFactory同义词过滤器。
Field定义
	solr索引字段在solrhome\collection1\conf\schema.xml配置文件中，类似下面这些，包含在<fields>与</fields>之间的。
在fields结点内定义具体的Field，filed定义包括name,type（为之前定义过的各种FieldType）,indexed（是否被索引）,stored（是否被储存），multiValued（是否存储多个值）等属性。
如下：
<field name="name" type="text_general" indexed="true" stored="true"/>
<field name="features" type="text_general" indexed="true" stored="true" multiValued="true"/>

multiValued：该Field如果要存储多个值时设置为true，solr允许一个Field存储多个值，比如存储一个用户的好友id（多个），商品的图片（多个，大图和小图），通过使用solr查询要看出返回给客户端是数组：

uniqueKey
Solr中默认定义唯一主键key为id域，如下：


Solr在删除、更新索引时使用id域进行判断，也可以自定义唯一主键。
注意在创建索引时必须指定唯一约束。
copyField复制域
copyField复制域，可以将多个Field复制到一个Field中，以便进行统一的检索：
比如，输入关键字搜索title标题内容content，
定义title、content、text的域：



根据关键字只搜索text域的内容就相当于搜索title和content，将title和content复制到text中，如下：

dynamicField（动态字段）
动态字段就是不用指定具体的名称，只要定义字段名称的规则，例如定义一个 dynamicField，name 为*_i，定义它的type为text，那么在使用这个字段的时候，任何以_i结尾的字段都被认为是符合这个定义的，例如：name_i，gender_i，school_i等。

自定义Field名为：product_title_t，“product_title_t”和scheam.xml中的dynamicField规则匹配成功，如下：

“product_title_t”是以“_t”结尾。

创建索引：


搜索索引：


18.6.2.安装中文分词器
使用IKAnalyzer中文分析器。

第一步：把IKAnalyzer2012FF_u1.jar添加到solr/WEB-INF/lib目录下。
第二步：复制IKAnalyzer的配置文件和自定义词典和停用词词典到solr的classpath下。
第三步：在schema.xml中添加一个自定义的fieldType，使用中文分析器。
<!-- IKAnalyzer-->
    <fieldType name="text_ik" class="solr.TextField">
      <analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/>
    </fieldType>

第四步：定义field，指定field的type属性为text_ik
<!--IKAnalyzer Field-->
   <field name="title_ik" type="text_ik" indexed="true" stored="true" />
   <field name="content_ik" type="text_ik" indexed="true" stored="false" multiValued="true"/>

第四步：重启tomcat
测试：

18.7.设置业务系统Field
如果不使用Solr提供的Field可以针对具体的业务需要自定义一套Field，如下是商品信息Field：

<!--product-->
   <field name="product_name" type="text_ik" indexed="true" stored="true"/>
   <field name="product_price"  type="float" indexed="true" stored="true"/>
   <field name="product_description" type="text_ik" indexed="true" stored="false" />
   <field name="product_picture" type="string" indexed="false" stored="true" />
   <field name="product_catalog_name" type="string" indexed="true" stored="true" />

   <field name="product_keywords" type="text_ik" indexed="true" stored="false" multiValued="true"/>
   <copyField source="product_name" dest="product_keywords"/>
   <copyField source="product_description" dest="product_keywords"/>

18.8.维护索引
18.8.1.添加/更新文档
添加单个文档

18.8.2.批量导入数据
使用dataimport插件批量导入数据。
第一步：把dataimport插件依赖的jar包添加到solrcore（collection1\lib）中

还需要mysql的数据库驱动。
第二步：配置solrconfig.mxl文件，添加一个requestHandler。
 <requestHandler name="/dataimport" 
class="org.apache.solr.handler.dataimport.DataImportHandler">
    <lst name="defaults">
      <str name="config">data-config.xml</str>
     </lst>
  </requestHandler> 

第三步：创建一个data-config.xml，保存到collection1\conf\目录下
<?xml version="1.0" encoding="UTF-8" ?>  
<dataConfig>   
<dataSource type="JdbcDataSource"   
		  driver="com.mysql.jdbc.Driver"   
		  url="jdbc:mysql://localhost:3306/lucene"   
		  user="root"   
		  password="root"/>   
<document>   
	<entity name="product" query="SELECT pid,name,catalog_name,price,description,picture FROM products ">
		 <field column="pid" name="id"/> 
		 <field column="name" name="product_name"/> 
		 <field column="catalog_name" name="product_catalog_name"/> 
		 <field column="price" name="product_price"/> 
		 <field column="description" name="product_description"/> 
		 <field column="picture" name="product_picture"/> 
	</entity>   
</document>   

</dataConfig>

第四步：重启tomcat

第五步：点击“execute”按钮导入数据

到入数据前会先清空索引库，然后再导入。

18.8.3.删除文档
删除索引格式如下：

1） 删除制定ID的索引 
<delete>
	<id>8</id>
</delete>

2） 删除查询到的索引数据 
<delete>
	<query>product_catalog_name:幽默杂货</query>
</delete>
3） 删除所有索引数据
 <delete>
	<query>*:*</query>
</delete>
18.9.查询索引
通过/select搜索索引，Solr制定一些参数完成不同需求的搜索：

10.q - 查询字符串，必须的，如果查询所有使用*:*。



11.fq - （filter query）过虑查询，作用：在q查询符合结果中同时是fq查询符合的，例如：：

过滤查询价格从1到20的记录。
也可以在“q”查询条件中使用product_price:[1 TO 20]，如下：

也可以使用“*”表示无限，例如：
20以上：product_price:[20 TO *]
20以下：product_price:[* TO 20]

12.sort - 排序，格式：sort=<field name>+<desc|asc>[,<field name>+<desc|asc>]… 。示例： 
按价格降序

13.start - 分页显示使用，开始记录下标，从0开始 
14.rows - 指定返回结果最多有多少条记录，配合start来实现分页。

显示前10条。



15.fl - 指定返回那些字段内容，用逗号或空格分隔多个。

显示商品图片、商品名称、商品价格

16.df-指定一个搜索Field

也可以在SolrCore目录 中conf/solrconfig.xml文件中指定默认搜索Field，指定后就可以直接在“q”查询条件中输入关键字。



17.wt - (writer type)指定输出格式，可以有 xml, json, php, phps, 后面 solr 1.3增加的，要用通知我们，因为默认没有打开。

18.hl 是否高亮 ,设置高亮Field，设置格式前缀和后缀。



19.使用SolrJ管理索引库
19.1.什么是solrJ
solrj是访问Solr服务的java客户端，提供索引和搜索的请求方法，SolrJ通常在嵌入在业务系统中，通过SolrJ的API接口操作Solr服务，如下图：


19.2.依赖的jar包


19.3.添加文档
19.3.1.实现步骤
第一步：创建一个java工程
第二步：导入jar包。包括solrJ的jar包。还需要

第三步：和Solr服务器建立连接。HttpSolrServer对象建立连接。
第四步：创建一个SolrInputDocument对象，然后添加域。
第五步：将SolrInputDocument添加到索引库。
第六步：提交。
19.3.2.代码实现
//向索引库中添加索引
	@Test
	public void addDocument() throws Exception {
		//和solr服务器创建连接
		//参数：solr服务器的地址
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//创建一个文档对象
		SolrInputDocument document = new SolrInputDocument();
		//向文档中添加域
		//第一个参数：域的名称，域的名称必须是在schema.xml中定义的
		//第二个参数：域的值
		document.addField("id", "c0001");
		document.addField("title_ik", "使用solrJ添加的文档");
		document.addField("content_ik", "文档的内容");
		document.addField("product_name", "商品名称");
		//把document对象添加到索引库中
		solrServer.add(document);
		//提交修改
		solrServer.commit();
		
	}

19.4.删除文档
19.4.1.根据id删除
//删除文档，根据id删除
	@Test
	public void deleteDocumentByid() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//根据id删除文档
		solrServer.deleteById("c0001");
		//提交修改
		solrServer.commit();
	}

19.4.2.根据查询删除
查询语法完全支持Lucene的查询语法。
//根据查询条件删除文档
	@Test
	public void deleteDocumentByQuery() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//根据查询条件删除文档
		solrServer.deleteByQuery("*:*");
		//提交修改
		solrServer.commit();
	}


19.5.修改文档
在solrJ中修改没有对应的update方法，只有add方法，只需要添加一条新的文档，和被修改的文档id一致就，可以修改了。本质上就是先删除后添加。

19.6.查询文档
19.6.1.简单查询
//查询索引
	@Test
	public void queryIndex() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//创建一个query对象
		SolrQuery query = new SolrQuery();
		//设置查询条件
		query.setQuery("*:*");
		//执行查询
		QueryResponse queryResponse = solrServer.query(query);
		//取查询结果
		SolrDocumentList solrDocumentList = queryResponse.getResults();
		//共查询到商品数量
		System.out.println("共查询到商品数量:" + solrDocumentList.getNumFound());
		//遍历查询的结果
		for (SolrDocument solrDocument : solrDocumentList) {
			System.out.println(solrDocument.get("id"));
			System.out.println(solrDocument.get("product_name"));
			System.out.println(solrDocument.get("product_price"));
			System.out.println(solrDocument.get("product_catalog_name"));
			System.out.println(solrDocument.get("product_picture"));
			
		}
	}

19.6.2.复杂查询
其中包含查询、过滤、分页、排序、高亮显示等处理。
//复杂查询索引
	@Test
	public void queryIndex2() throws Exception {
		//创建连接
		SolrServer solrServer = new HttpSolrServer("http://localhost:8080/solr");
		//创建一个query对象
		SolrQuery query = new SolrQuery();
		//设置查询条件
		query.setQuery("钻石");
		//过滤条件
		query.setFilterQueries("product_catalog_name:幽默杂货");
		//排序条件
		query.setSort("product_price", ORDER.asc);
		//分页处理
		query.setStart(0);
		query.setRows(10);
		//结果中域的列表
		query.setFields("id","product_name","product_price","product_catalog_name","product_picture");
		//设置默认搜索域
		query.set("df", "product_keywords");
		//高亮显示
		query.setHighlight(true);
		//高亮显示的域
		query.addHighlightField("product_name");
		//高亮显示的前缀
		query.setHighlightSimplePre("<em>");
		//高亮显示的后缀
		query.setHighlightSimplePost("</em>");
		//执行查询
		QueryResponse queryResponse = solrServer.query(query);
		//取查询结果
		SolrDocumentList solrDocumentList = queryResponse.getResults();
		//共查询到商品数量
		System.out.println("共查询到商品数量:" + solrDocumentList.getNumFound());
		//遍历查询的结果
		for (SolrDocument solrDocument : solrDocumentList) {
			System.out.println(solrDocument.get("id"));
			//取高亮显示
			String productName = "";
			Map<String, Map<String, List<String>>> highlighting = queryResponse.getHighlighting();
			List<String> list = highlighting.get(solrDocument.get("id")).get("product_name");
			//判断是否有高亮内容
			if (null != list) {
				productName = list.get(0);
			} else {
				productName = (String) solrDocument.get("product_name");
			}
			
			System.out.println(productName);
			System.out.println(solrDocument.get("product_price"));
			System.out.println(solrDocument.get("product_catalog_name"));
			System.out.println(solrDocument.get("product_picture"));
			
		}
	}

20.案例实现
20.1.原型分析

20.2.系统架构

20.3.工程搭建
创建一个web工程导入jar包
4、springmvc的相关jar包
5、solrJ的jar包
6、Example\lib\ext下的jar包



20.4.Dao
功能：接收service层传递过来的参数，根据参数查询索引库，返回查询结果。
参数：SolrQuery对象
返回值：一个商品列表List<ProductModel>，还需要返回查询结果的总数量。
返回：ResultModel
方法定义：ResultModel queryProduct(SolrQuery query) throws Exception;


商品对象模型：
public class ProductModel {
	// 商品编号
	private String pid;
	// 商品名称
	private String name;
	// 商品分类名称
	private String catalog_name;
	// 价格
	private float price;
	// 商品描述
	private String description;
	// 图片名称
	private String picture;
}

返回值对象模型
public class ResultModel {
	// 商品列表
	private List<ProductModel> productList;
	// 商品总数
	private Long recordCount;
	// 总页数
	private int pageCount;
	// 当前页
	private int curPage;
}

@Repository
public class ProductDaoImpl implements ProductDao {

	@Autowired
	private SolrServer solrServer;
	
	@Override
	public ResultModel queryProduct(SolrQuery query) throws Exception {
		
		ResultModel resultModel  = new ResultModel();
		//根据query对象查询商品列表
		QueryResponse queryResponse = solrServer.query(query);
		SolrDocumentList solrDocumentList = queryResponse.getResults();
		//取查询结果的总数量
		resultModel.setRecordCount(solrDocumentList.getNumFound());
		List<ProductModel> productList = new ArrayList<>();
		//遍历查询结果
		for (SolrDocument solrDocument : solrDocumentList) {
			//取商品信息
			ProductModel productModel = new ProductModel();
			productModel.setPid((String) solrDocument.get("id"));
			//取高亮显示
			String productName = "";
			Map<String, Map<String, List<String>>> highlighting = queryResponse.getHighlighting();
			List<String> list = highlighting.get(solrDocument.get("id")).get("product_name");
			if (null != list) {
				productName = list.get(0);
			} else {
				productName = (String) solrDocument.get("product_name");
			}
			productModel.setName(productName);
			productModel.setPrice((float) solrDocument.get("product_price"));
			productModel.setCatalog_name((String) solrDocument.get("product_catalog_name"));
			productModel.setPicture((String) solrDocument.get("product_picture"));
			//添加到商品列表
			productList.add(productModel);
		}
		//商品列表添加到resultmodel中
		resultModel.setProductList(productList);
		return resultModel;
	}

}

20.5.Service
功能：接收action传递过来的参数，根据参数拼装一个查询条件，调用dao层方法，查询商品列表。接收返回的商品列表和商品的总数量，根据每页显示的商品数量计算总页数。
参数：
1、查询条件：字符串
2、商品分类的过滤条件：商品的分类名称，字符串
3、商品价格区间：传递一个字符串，满足格式：“0-100、101-200、201-*”
4、排序条件：页面传递过来一个升序或者降序就可以，默认是价格排序。0：升序1：降序
5、分页信息：每页显示的记录条数创建一个常量60条。传递一个当前页码就可以了。
返回值：ResultModel 

方法定义：ResultModel queryProduct(String queryString, String caltalog_name, String price, String sort, Integer page) throws Exception;
@Service
public class ProductServiceImpl implements ProductService {

	@Autowired
	private ProductDao productDao;
	
	@Override
	public ResultModel queryProduct(String queryString, String caltalog_name,
			String price, String sort, Integer page) throws Exception {
		//拼装查询条件
		SolrQuery query = new SolrQuery();
		//查询条件
		if (null != queryString && !"".equals(queryString)) {
			query.setQuery(queryString);
		} else {
			query.setQuery("*:*");
		}
		//商品分类名称过滤
		if (null != caltalog_name && !"".equals(caltalog_name)) {
			query.addFilterQuery("product_catalog_name:" + caltalog_name);
		}
		//价格区间过滤
		if (null != price && !"".equals(price)) {
			String[] strings = price.split("-");
			query.addFilterQuery("product_price:["+strings[0]+" TO "+strings[1]+"]");
		}
		//排序条件
		if ("1".equals(sort)) {
			query.setSort("product_price", ORDER.desc);
		} else {
			query.setSort("product_price", ORDER.asc);
		}
		//分页处理
		if (null == page) {
			page = 1;
		}
		//start
		int start = (page-1) * Commons.PAGE_SIZE;
		query.setStart(start);
		query.setRows(Commons.PAGE_SIZE);
		//设置默认搜索域
		query.set("df", "product_keywords");
		//高亮设置
		query.setHighlight(true);
		query.addHighlightField("product_name");
		query.setHighlightSimplePre("<span style=\"color:red\">");
		query.setHighlightSimplePost("</span>");
		
		//查询商品列表
		ResultModel resultModel = productDao.queryProduct(query);
		//计算总页数
		long recordCount = resultModel.getRecordCount();
		int pages = (int) (recordCount/Commons.PAGE_SIZE);
		if (recordCount % Commons.PAGE_SIZE > 0) {
			pages ++;
		}
		resultModel.setPageCount(pages);
		resultModel.setCurPage(page);
		
		return resultModel;
	}

}

20.6.controller
功能：接收页面传递过来的参数调用service查询商品列表。将查询结果返回给jsp页面，还需要查询参数的回显。

参数：
1、查询条件：字符串
2、商品分类的过滤条件：商品的分类名称，字符串
3、商品价格区间：传递一个字符串，满足格式：“0-100、101-200、201-*”
4、排序条件：页面传递过来一个升序或者降序就可以，默认是价格排序。0：升序1：降序
5、分页信息：每页显示的记录条数创建一个常量60条。传递一个当前页码就可以了。
6、Model：相当于request。

返回结果：String类型，就是一个jsp的名称。

String queryProduct(String queryString, String caltalog_name, String price, String sort, Integer page, Model model) throws Exception;
@Controller
public class ProductAction {
	
	@Autowired
	private ProductService productService;
	
	@RequestMapping("/list")
	public String queryProduct(String queryString, String catalog_name, String price,
			String sort, Integer page, Model model) throws Exception {
		//查询商品列表
		ResultModel resultModel = productService.queryProduct(queryString, catalog_name, price, sort, page);
		//列表传递给jsp
		model.addAttribute("result", resultModel);
		//参数回显
		model.addAttribute("queryString", queryString);
		model.addAttribute("caltalog_name", catalog_name);
		model.addAttribute("price", price);
		model.addAttribute("sort", sort);
		model.addAttribute("page", page);
		
		return "product_list";
	}
}

20.7.Jsp
参考资料。




Lucene
课程计划
什么是lucene
应用领域
创建索引
使用luke查看索引
搜索索引
Field域的详细介绍
各种类型的搜索
使用中文分词器


数据的分类
结构化数据:有固定类型或者有固定长度的数据
	例如:数据库中的数据(mysql,oracle等), 元数据(就是windows中的数据)
结构化数据搜索方法:
	数据库中数据通过sql语句可以搜索
	元数据(windows中的)通过windows提供的搜索栏进行搜索

非结构化数据:没有固定类型和固定长度的数据
	例如: world文档中的数据, 邮件中的数据
非结构化数据搜索方法:
	Word文档使用ctrl+F来搜索
	顺序扫描法: 
Ctrl+F中是使用的顺序扫描法,拿到搜索的关键字,去文档中,逐字匹配,直到找到和关键字一致的内容为止.
		优点: 如果文档中存在要找的关键字就一定能找到想要的内容
		缺点: 慢, 效率低
	全文检索算法(倒排索引算法):
		将文件中的内容提取出来, 将文字拆封成一个一个的词(分词), 将这些词组成索引(字典中的目录), 搜索的时候先搜索索引,通过索引找文档,这个过程就叫做全文检索.
		
分词: 去掉停用词(a, an, the ,的, 地, 得, 啊, 嗯 ,呵呵),因为搜索的时候搜索这些词没有意义,将句子拆分成词,去掉标点符号和空格
	优点: 搜索速度快
	缺点: 因为创建的索引需要占用磁盘空间,所以这个算法会使用掉更多的磁盘空间,这是用空间换时间

原理:
相当于字典,分为目录和正文两部分,查询的时候通过先查目录,然后通过目录上标注的页数去正文页查找需要的内容

Lucene
什么是lucene
Lucene是apache旗下的顶级项目,是一个全文检索工具包
Lucene就是一个可以创建全文检索引擎系统的一堆jar包.可以使用它来构建全文检索引擎系统,但是它不能独立运

全文检索引擎系统
	放在tomcat下可以独立运行,对外提供全文检索服务.



Lucene应用领域
1.互联网全文检索引擎(比如百度,  谷歌,  必应)
2.站内全文检索引擎(淘宝, 京东搜索功能)
3.优化数据库查询(因为数据库中使用like关键字是全表扫描也就是顺序扫描算法,查询慢)


Lucene下载
官方网站：http://lucene.apache.org/ 
版本：lucene4.10.3
Jdk要求：1.7以上
IDE：Eclipse

Lucene结构

索引:
域名:词  这样的形式,
它里面有指针执行这个词来源的文档

索引库: 放索引的文件夹(这个文件夹可以自己随意创建,在里面放索引就是索引库)
Term词元: 就是一个词, 是lucene中词的最小单位
文档:
Document对象,一个Document中可以有多个Field域对象,Field域对象中是key   value键值对的形式:有域名和域值,
一个document就是数据库表中的一条记录, 一个Filed域对象就是数据库表中的一行一列
这是一个通用的存储结构.

创建索引和所有时所用的分词器必须一致

域的详细介绍
是否分词:
	分词的作用是为了索引
	需要分词: 文件名称, 文件内容
	不需要分词: 不需要索引的域不需要分词,还有就是分词后无意义的域不需要分词
	 		比如: id, 身份证号

是否索引:
	索引的的目的是为了搜索.
	需要搜索的域就一定要创建索引,只有创建了索引才能被搜索出来
	不需要搜索的域可以不创建索引
	需要索引: 文件名称, 文件内容, id, 身份证号等
	不需要索引: 比如图片地址不需要创建索引, e:\\xxx.jpg
		因为根据图片地址搜索无意义

是否存储:
	存储的目的是为了显示.
	是否存储看个人需要,存储就是将内容放入Document文档对象中保存出来,会额外占用磁盘空间, 如果搜索的时候需要马上显示出来可以放入document中也就是要存储,这样查询显示速度快, 如果不是马上立刻需要显示出来,则不需要存储,因为额外占用磁盘空间不划算.





域的各种类型

Field类	数据类型	Analyzed
是否分析	Indexed
是否索引	Stored
是否存储	说明
StringField(FieldName, FieldValue,Store.YES))	字符串	N	Y	Y或N	这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)
是否存储在文档中用Store.YES或Store.NO决定
LongField(FieldName, FieldValue,Store.YES)	Long型 	Y	Y	Y或N	这个Field用来构建一个Long数字型Field，进行分析和索引，比如(价格)
是否存储在文档中用Store.YES或Store.NO决定
StoredField(FieldName, FieldValue) 	重载方法，支持多种类型	N	N	Y	这个Field用来构建不同类型Field
不分析，不索引，但要Field存储在文档中
TextField(FieldName, FieldValue, Store.NO)
或
TextField(FieldName, reader)
	字符串
或
流	Y	Y	Y或N	如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略.



注意:lucene底层的算法,钱数是要分词的,因为要根据价钱进行对比
例如: 大于12.5元的小于100元的商品搜索出来


	
文档的更新
更新就是按照传入的Term进行搜索,如果找到结果那么删除,将更新的内容重新生成一个Document对象
如果没有搜索到结果,那么将更新的内容直接添加一个新的Document对象

文档的删除
可以根据某个域的内容进行删除
还可以一次删除所有

搜索
TermQuery:
	根据词进行搜索(只能从文本中进行搜索)
QueryParser:
	根据域名进行搜索,可以设置默认搜索域,推荐使用. (只能从文本中进行搜索)
NumericRangeQuery:
	从数值范围进行搜索
BooleanQuery:
	组合查询,可以设置组合条件,not and or.从多个域中进行查询
	must相当于and关键字,是并且的意思
	should,相当于or关键字或者的意思
	must_not相当于not关键字, 非的意思
	注意:单独使用must_not  或者 独自使用must_not没有任何意义
MatchAllDocsQuery:
	查询出所有文档
MultiFieldQueryParser:
	可以从多个域中进行查询,只有这些域中有关键词的存在就查询出来.













